#!/usr/bin/env bun
// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = import.meta.require;

// node_modules/commander/lib/error.js
var require_error = __commonJS((exports) => {
  class CommanderError extends Error {
    constructor(exitCode, code, message) {
      super(message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
      this.code = code;
      this.exitCode = exitCode;
      this.nestedError = undefined;
    }
  }

  class InvalidArgumentError extends CommanderError {
    constructor(message) {
      super(1, "commander.invalidArgument", message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
    }
  }
  exports.CommanderError = CommanderError;
  exports.InvalidArgumentError = InvalidArgumentError;
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS((exports) => {
  var { InvalidArgumentError } = require_error();

  class Argument {
    constructor(name, description) {
      this.description = description || "";
      this.variadic = false;
      this.parseArg = undefined;
      this.defaultValue = undefined;
      this.defaultValueDescription = undefined;
      this.argChoices = undefined;
      switch (name[0]) {
        case "<":
          this.required = true;
          this._name = name.slice(1, -1);
          break;
        case "[":
          this.required = false;
          this._name = name.slice(1, -1);
          break;
        default:
          this.required = true;
          this._name = name;
          break;
      }
      if (this._name.length > 3 && this._name.slice(-3) === "...") {
        this.variadic = true;
        this._name = this._name.slice(0, -3);
      }
    }
    name() {
      return this._name;
    }
    _concatValue(value, previous) {
      if (previous === this.defaultValue || !Array.isArray(previous)) {
        return [value];
      }
      return previous.concat(value);
    }
    default(value, description) {
      this.defaultValue = value;
      this.defaultValueDescription = description;
      return this;
    }
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    choices(values) {
      this.argChoices = values.slice();
      this.parseArg = (arg, previous) => {
        if (!this.argChoices.includes(arg)) {
          throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
        }
        if (this.variadic) {
          return this._concatValue(arg, previous);
        }
        return arg;
      };
      return this;
    }
    argRequired() {
      this.required = true;
      return this;
    }
    argOptional() {
      this.required = false;
      return this;
    }
  }
  function humanReadableArgName(arg) {
    const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
    return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
  }
  exports.Argument = Argument;
  exports.humanReadableArgName = humanReadableArgName;
});

// node_modules/commander/lib/help.js
var require_help = __commonJS((exports) => {
  var { humanReadableArgName } = require_argument();

  class Help {
    constructor() {
      this.helpWidth = undefined;
      this.sortSubcommands = false;
      this.sortOptions = false;
      this.showGlobalOptions = false;
    }
    visibleCommands(cmd) {
      const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
      const helpCommand = cmd._getHelpCommand();
      if (helpCommand && !helpCommand._hidden) {
        visibleCommands.push(helpCommand);
      }
      if (this.sortSubcommands) {
        visibleCommands.sort((a, b) => {
          return a.name().localeCompare(b.name());
        });
      }
      return visibleCommands;
    }
    compareOptions(a, b) {
      const getSortKey = (option) => {
        return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
      };
      return getSortKey(a).localeCompare(getSortKey(b));
    }
    visibleOptions(cmd) {
      const visibleOptions = cmd.options.filter((option) => !option.hidden);
      const helpOption = cmd._getHelpOption();
      if (helpOption && !helpOption.hidden) {
        const removeShort = helpOption.short && cmd._findOption(helpOption.short);
        const removeLong = helpOption.long && cmd._findOption(helpOption.long);
        if (!removeShort && !removeLong) {
          visibleOptions.push(helpOption);
        } else if (helpOption.long && !removeLong) {
          visibleOptions.push(cmd.createOption(helpOption.long, helpOption.description));
        } else if (helpOption.short && !removeShort) {
          visibleOptions.push(cmd.createOption(helpOption.short, helpOption.description));
        }
      }
      if (this.sortOptions) {
        visibleOptions.sort(this.compareOptions);
      }
      return visibleOptions;
    }
    visibleGlobalOptions(cmd) {
      if (!this.showGlobalOptions)
        return [];
      const globalOptions = [];
      for (let ancestorCmd = cmd.parent;ancestorCmd; ancestorCmd = ancestorCmd.parent) {
        const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
        globalOptions.push(...visibleOptions);
      }
      if (this.sortOptions) {
        globalOptions.sort(this.compareOptions);
      }
      return globalOptions;
    }
    visibleArguments(cmd) {
      if (cmd._argsDescription) {
        cmd.registeredArguments.forEach((argument) => {
          argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
        });
      }
      if (cmd.registeredArguments.find((argument) => argument.description)) {
        return cmd.registeredArguments;
      }
      return [];
    }
    subcommandTerm(cmd) {
      const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(" ");
      return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
    }
    optionTerm(option) {
      return option.flags;
    }
    argumentTerm(argument) {
      return argument.name();
    }
    longestSubcommandTermLength(cmd, helper) {
      return helper.visibleCommands(cmd).reduce((max, command) => {
        return Math.max(max, helper.subcommandTerm(command).length);
      }, 0);
    }
    longestOptionTermLength(cmd, helper) {
      return helper.visibleOptions(cmd).reduce((max, option) => {
        return Math.max(max, helper.optionTerm(option).length);
      }, 0);
    }
    longestGlobalOptionTermLength(cmd, helper) {
      return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
        return Math.max(max, helper.optionTerm(option).length);
      }, 0);
    }
    longestArgumentTermLength(cmd, helper) {
      return helper.visibleArguments(cmd).reduce((max, argument) => {
        return Math.max(max, helper.argumentTerm(argument).length);
      }, 0);
    }
    commandUsage(cmd) {
      let cmdName = cmd._name;
      if (cmd._aliases[0]) {
        cmdName = cmdName + "|" + cmd._aliases[0];
      }
      let ancestorCmdNames = "";
      for (let ancestorCmd = cmd.parent;ancestorCmd; ancestorCmd = ancestorCmd.parent) {
        ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
      }
      return ancestorCmdNames + cmdName + " " + cmd.usage();
    }
    commandDescription(cmd) {
      return cmd.description();
    }
    subcommandDescription(cmd) {
      return cmd.summary() || cmd.description();
    }
    optionDescription(option) {
      const extraInfo = [];
      if (option.argChoices) {
        extraInfo.push(`choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
      }
      if (option.defaultValue !== undefined) {
        const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
        if (showDefault) {
          extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
        }
      }
      if (option.presetArg !== undefined && option.optional) {
        extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
      }
      if (option.envVar !== undefined) {
        extraInfo.push(`env: ${option.envVar}`);
      }
      if (extraInfo.length > 0) {
        return `${option.description} (${extraInfo.join(", ")})`;
      }
      return option.description;
    }
    argumentDescription(argument) {
      const extraInfo = [];
      if (argument.argChoices) {
        extraInfo.push(`choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
      }
      if (argument.defaultValue !== undefined) {
        extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
      }
      if (extraInfo.length > 0) {
        const extraDescripton = `(${extraInfo.join(", ")})`;
        if (argument.description) {
          return `${argument.description} ${extraDescripton}`;
        }
        return extraDescripton;
      }
      return argument.description;
    }
    formatHelp(cmd, helper) {
      const termWidth = helper.padWidth(cmd, helper);
      const helpWidth = helper.helpWidth || 80;
      const itemIndentWidth = 2;
      const itemSeparatorWidth = 2;
      function formatItem(term, description) {
        if (description) {
          const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
          return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
        }
        return term;
      }
      function formatList(textArray) {
        return textArray.join(`
`).replace(/^/gm, " ".repeat(itemIndentWidth));
      }
      let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
      const commandDescription = helper.commandDescription(cmd);
      if (commandDescription.length > 0) {
        output = output.concat([
          helper.wrap(commandDescription, helpWidth, 0),
          ""
        ]);
      }
      const argumentList = helper.visibleArguments(cmd).map((argument) => {
        return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
      });
      if (argumentList.length > 0) {
        output = output.concat(["Arguments:", formatList(argumentList), ""]);
      }
      const optionList = helper.visibleOptions(cmd).map((option) => {
        return formatItem(helper.optionTerm(option), helper.optionDescription(option));
      });
      if (optionList.length > 0) {
        output = output.concat(["Options:", formatList(optionList), ""]);
      }
      if (this.showGlobalOptions) {
        const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
          return formatItem(helper.optionTerm(option), helper.optionDescription(option));
        });
        if (globalOptionList.length > 0) {
          output = output.concat([
            "Global Options:",
            formatList(globalOptionList),
            ""
          ]);
        }
      }
      const commandList = helper.visibleCommands(cmd).map((cmd2) => {
        return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
      });
      if (commandList.length > 0) {
        output = output.concat(["Commands:", formatList(commandList), ""]);
      }
      return output.join(`
`);
    }
    padWidth(cmd, helper) {
      return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestGlobalOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
    }
    wrap(str, width, indent, minColumnWidth = 40) {
      const indents = " \\f\\t\\v\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF";
      const manualIndent = new RegExp(`[\\n][${indents}]+`);
      if (str.match(manualIndent))
        return str;
      const columnWidth = width - indent;
      if (columnWidth < minColumnWidth)
        return str;
      const leadingStr = str.slice(0, indent);
      const columnText = str.slice(indent).replace(`\r
`, `
`);
      const indentString = " ".repeat(indent);
      const zeroWidthSpace = "\u200B";
      const breaks = `\\s${zeroWidthSpace}`;
      const regex = new RegExp(`
|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`, "g");
      const lines = columnText.match(regex) || [];
      return leadingStr + lines.map((line, i) => {
        if (line === `
`)
          return "";
        return (i > 0 ? indentString : "") + line.trimEnd();
      }).join(`
`);
    }
  }
  exports.Help = Help;
});

// node_modules/commander/lib/option.js
var require_option = __commonJS((exports) => {
  var { InvalidArgumentError } = require_error();

  class Option {
    constructor(flags, description) {
      this.flags = flags;
      this.description = description || "";
      this.required = flags.includes("<");
      this.optional = flags.includes("[");
      this.variadic = /\w\.\.\.[>\]]$/.test(flags);
      this.mandatory = false;
      const optionFlags = splitOptionFlags(flags);
      this.short = optionFlags.shortFlag;
      this.long = optionFlags.longFlag;
      this.negate = false;
      if (this.long) {
        this.negate = this.long.startsWith("--no-");
      }
      this.defaultValue = undefined;
      this.defaultValueDescription = undefined;
      this.presetArg = undefined;
      this.envVar = undefined;
      this.parseArg = undefined;
      this.hidden = false;
      this.argChoices = undefined;
      this.conflictsWith = [];
      this.implied = undefined;
    }
    default(value, description) {
      this.defaultValue = value;
      this.defaultValueDescription = description;
      return this;
    }
    preset(arg) {
      this.presetArg = arg;
      return this;
    }
    conflicts(names) {
      this.conflictsWith = this.conflictsWith.concat(names);
      return this;
    }
    implies(impliedOptionValues) {
      let newImplied = impliedOptionValues;
      if (typeof impliedOptionValues === "string") {
        newImplied = { [impliedOptionValues]: true };
      }
      this.implied = Object.assign(this.implied || {}, newImplied);
      return this;
    }
    env(name) {
      this.envVar = name;
      return this;
    }
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    makeOptionMandatory(mandatory = true) {
      this.mandatory = !!mandatory;
      return this;
    }
    hideHelp(hide = true) {
      this.hidden = !!hide;
      return this;
    }
    _concatValue(value, previous) {
      if (previous === this.defaultValue || !Array.isArray(previous)) {
        return [value];
      }
      return previous.concat(value);
    }
    choices(values) {
      this.argChoices = values.slice();
      this.parseArg = (arg, previous) => {
        if (!this.argChoices.includes(arg)) {
          throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
        }
        if (this.variadic) {
          return this._concatValue(arg, previous);
        }
        return arg;
      };
      return this;
    }
    name() {
      if (this.long) {
        return this.long.replace(/^--/, "");
      }
      return this.short.replace(/^-/, "");
    }
    attributeName() {
      return camelcase(this.name().replace(/^no-/, ""));
    }
    is(arg) {
      return this.short === arg || this.long === arg;
    }
    isBoolean() {
      return !this.required && !this.optional && !this.negate;
    }
  }

  class DualOptions {
    constructor(options) {
      this.positiveOptions = new Map;
      this.negativeOptions = new Map;
      this.dualOptions = new Set;
      options.forEach((option) => {
        if (option.negate) {
          this.negativeOptions.set(option.attributeName(), option);
        } else {
          this.positiveOptions.set(option.attributeName(), option);
        }
      });
      this.negativeOptions.forEach((value, key) => {
        if (this.positiveOptions.has(key)) {
          this.dualOptions.add(key);
        }
      });
    }
    valueFromOption(value, option) {
      const optionKey = option.attributeName();
      if (!this.dualOptions.has(optionKey))
        return true;
      const preset = this.negativeOptions.get(optionKey).presetArg;
      const negativeValue = preset !== undefined ? preset : false;
      return option.negate === (negativeValue === value);
    }
  }
  function camelcase(str) {
    return str.split("-").reduce((str2, word) => {
      return str2 + word[0].toUpperCase() + word.slice(1);
    });
  }
  function splitOptionFlags(flags) {
    let shortFlag;
    let longFlag;
    const flagParts = flags.split(/[ |,]+/);
    if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
      shortFlag = flagParts.shift();
    longFlag = flagParts.shift();
    if (!shortFlag && /^-[^-]$/.test(longFlag)) {
      shortFlag = longFlag;
      longFlag = undefined;
    }
    return { shortFlag, longFlag };
  }
  exports.Option = Option;
  exports.DualOptions = DualOptions;
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS((exports) => {
  var maxDistance = 3;
  function editDistance(a, b) {
    if (Math.abs(a.length - b.length) > maxDistance)
      return Math.max(a.length, b.length);
    const d = [];
    for (let i = 0;i <= a.length; i++) {
      d[i] = [i];
    }
    for (let j = 0;j <= b.length; j++) {
      d[0][j] = j;
    }
    for (let j = 1;j <= b.length; j++) {
      for (let i = 1;i <= a.length; i++) {
        let cost = 1;
        if (a[i - 1] === b[j - 1]) {
          cost = 0;
        } else {
          cost = 1;
        }
        d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
          d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
        }
      }
    }
    return d[a.length][b.length];
  }
  function suggestSimilar(word, candidates) {
    if (!candidates || candidates.length === 0)
      return "";
    candidates = Array.from(new Set(candidates));
    const searchingOptions = word.startsWith("--");
    if (searchingOptions) {
      word = word.slice(2);
      candidates = candidates.map((candidate) => candidate.slice(2));
    }
    let similar = [];
    let bestDistance = maxDistance;
    const minSimilarity = 0.4;
    candidates.forEach((candidate) => {
      if (candidate.length <= 1)
        return;
      const distance = editDistance(word, candidate);
      const length = Math.max(word.length, candidate.length);
      const similarity = (length - distance) / length;
      if (similarity > minSimilarity) {
        if (distance < bestDistance) {
          bestDistance = distance;
          similar = [candidate];
        } else if (distance === bestDistance) {
          similar.push(candidate);
        }
      }
    });
    similar.sort((a, b) => a.localeCompare(b));
    if (searchingOptions) {
      similar = similar.map((candidate) => `--${candidate}`);
    }
    if (similar.length > 1) {
      return `
(Did you mean one of ${similar.join(", ")}?)`;
    }
    if (similar.length === 1) {
      return `
(Did you mean ${similar[0]}?)`;
    }
    return "";
  }
  exports.suggestSimilar = suggestSimilar;
});

// node_modules/commander/lib/command.js
var require_command = __commonJS((exports) => {
  var EventEmitter = __require("events").EventEmitter;
  var childProcess = __require("child_process");
  var path = __require("path");
  var fs = __require("fs");
  var process2 = __require("process");
  var { Argument, humanReadableArgName } = require_argument();
  var { CommanderError } = require_error();
  var { Help } = require_help();
  var { Option, DualOptions } = require_option();
  var { suggestSimilar } = require_suggestSimilar();

  class Command extends EventEmitter {
    constructor(name) {
      super();
      this.commands = [];
      this.options = [];
      this.parent = null;
      this._allowUnknownOption = false;
      this._allowExcessArguments = true;
      this.registeredArguments = [];
      this._args = this.registeredArguments;
      this.args = [];
      this.rawArgs = [];
      this.processedArgs = [];
      this._scriptPath = null;
      this._name = name || "";
      this._optionValues = {};
      this._optionValueSources = {};
      this._storeOptionsAsProperties = false;
      this._actionHandler = null;
      this._executableHandler = false;
      this._executableFile = null;
      this._executableDir = null;
      this._defaultCommandName = null;
      this._exitCallback = null;
      this._aliases = [];
      this._combineFlagAndOptionalValue = true;
      this._description = "";
      this._summary = "";
      this._argsDescription = undefined;
      this._enablePositionalOptions = false;
      this._passThroughOptions = false;
      this._lifeCycleHooks = {};
      this._showHelpAfterError = false;
      this._showSuggestionAfterError = true;
      this._outputConfiguration = {
        writeOut: (str) => process2.stdout.write(str),
        writeErr: (str) => process2.stderr.write(str),
        getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : undefined,
        getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : undefined,
        outputError: (str, write) => write(str)
      };
      this._hidden = false;
      this._helpOption = undefined;
      this._addImplicitHelpCommand = undefined;
      this._helpCommand = undefined;
      this._helpConfiguration = {};
    }
    copyInheritedSettings(sourceCommand) {
      this._outputConfiguration = sourceCommand._outputConfiguration;
      this._helpOption = sourceCommand._helpOption;
      this._helpCommand = sourceCommand._helpCommand;
      this._helpConfiguration = sourceCommand._helpConfiguration;
      this._exitCallback = sourceCommand._exitCallback;
      this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
      this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
      this._allowExcessArguments = sourceCommand._allowExcessArguments;
      this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
      this._showHelpAfterError = sourceCommand._showHelpAfterError;
      this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
      return this;
    }
    _getCommandAndAncestors() {
      const result = [];
      for (let command = this;command; command = command.parent) {
        result.push(command);
      }
      return result;
    }
    command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
      let desc = actionOptsOrExecDesc;
      let opts = execOpts;
      if (typeof desc === "object" && desc !== null) {
        opts = desc;
        desc = null;
      }
      opts = opts || {};
      const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
      const cmd = this.createCommand(name);
      if (desc) {
        cmd.description(desc);
        cmd._executableHandler = true;
      }
      if (opts.isDefault)
        this._defaultCommandName = cmd._name;
      cmd._hidden = !!(opts.noHelp || opts.hidden);
      cmd._executableFile = opts.executableFile || null;
      if (args)
        cmd.arguments(args);
      this._registerCommand(cmd);
      cmd.parent = this;
      cmd.copyInheritedSettings(this);
      if (desc)
        return this;
      return cmd;
    }
    createCommand(name) {
      return new Command(name);
    }
    createHelp() {
      return Object.assign(new Help, this.configureHelp());
    }
    configureHelp(configuration) {
      if (configuration === undefined)
        return this._helpConfiguration;
      this._helpConfiguration = configuration;
      return this;
    }
    configureOutput(configuration) {
      if (configuration === undefined)
        return this._outputConfiguration;
      Object.assign(this._outputConfiguration, configuration);
      return this;
    }
    showHelpAfterError(displayHelp = true) {
      if (typeof displayHelp !== "string")
        displayHelp = !!displayHelp;
      this._showHelpAfterError = displayHelp;
      return this;
    }
    showSuggestionAfterError(displaySuggestion = true) {
      this._showSuggestionAfterError = !!displaySuggestion;
      return this;
    }
    addCommand(cmd, opts) {
      if (!cmd._name) {
        throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
      }
      opts = opts || {};
      if (opts.isDefault)
        this._defaultCommandName = cmd._name;
      if (opts.noHelp || opts.hidden)
        cmd._hidden = true;
      this._registerCommand(cmd);
      cmd.parent = this;
      cmd._checkForBrokenPassThrough();
      return this;
    }
    createArgument(name, description) {
      return new Argument(name, description);
    }
    argument(name, description, fn, defaultValue) {
      const argument = this.createArgument(name, description);
      if (typeof fn === "function") {
        argument.default(defaultValue).argParser(fn);
      } else {
        argument.default(fn);
      }
      this.addArgument(argument);
      return this;
    }
    arguments(names) {
      names.trim().split(/ +/).forEach((detail) => {
        this.argument(detail);
      });
      return this;
    }
    addArgument(argument) {
      const previousArgument = this.registeredArguments.slice(-1)[0];
      if (previousArgument && previousArgument.variadic) {
        throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
      }
      if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
        throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
      }
      this.registeredArguments.push(argument);
      return this;
    }
    helpCommand(enableOrNameAndArgs, description) {
      if (typeof enableOrNameAndArgs === "boolean") {
        this._addImplicitHelpCommand = enableOrNameAndArgs;
        return this;
      }
      enableOrNameAndArgs = enableOrNameAndArgs ?? "help [command]";
      const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
      const helpDescription = description ?? "display help for command";
      const helpCommand = this.createCommand(helpName);
      helpCommand.helpOption(false);
      if (helpArgs)
        helpCommand.arguments(helpArgs);
      if (helpDescription)
        helpCommand.description(helpDescription);
      this._addImplicitHelpCommand = true;
      this._helpCommand = helpCommand;
      return this;
    }
    addHelpCommand(helpCommand, deprecatedDescription) {
      if (typeof helpCommand !== "object") {
        this.helpCommand(helpCommand, deprecatedDescription);
        return this;
      }
      this._addImplicitHelpCommand = true;
      this._helpCommand = helpCommand;
      return this;
    }
    _getHelpCommand() {
      const hasImplicitHelpCommand = this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help"));
      if (hasImplicitHelpCommand) {
        if (this._helpCommand === undefined) {
          this.helpCommand(undefined, undefined);
        }
        return this._helpCommand;
      }
      return null;
    }
    hook(event, listener) {
      const allowedValues = ["preSubcommand", "preAction", "postAction"];
      if (!allowedValues.includes(event)) {
        throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      if (this._lifeCycleHooks[event]) {
        this._lifeCycleHooks[event].push(listener);
      } else {
        this._lifeCycleHooks[event] = [listener];
      }
      return this;
    }
    exitOverride(fn) {
      if (fn) {
        this._exitCallback = fn;
      } else {
        this._exitCallback = (err) => {
          if (err.code !== "commander.executeSubCommandAsync") {
            throw err;
          } else {}
        };
      }
      return this;
    }
    _exit(exitCode, code, message) {
      if (this._exitCallback) {
        this._exitCallback(new CommanderError(exitCode, code, message));
      }
      process2.exit(exitCode);
    }
    action(fn) {
      const listener = (args) => {
        const expectedArgsCount = this.registeredArguments.length;
        const actionArgs = args.slice(0, expectedArgsCount);
        if (this._storeOptionsAsProperties) {
          actionArgs[expectedArgsCount] = this;
        } else {
          actionArgs[expectedArgsCount] = this.opts();
        }
        actionArgs.push(this);
        return fn.apply(this, actionArgs);
      };
      this._actionHandler = listener;
      return this;
    }
    createOption(flags, description) {
      return new Option(flags, description);
    }
    _callParseArg(target, value, previous, invalidArgumentMessage) {
      try {
        return target.parseArg(value, previous);
      } catch (err) {
        if (err.code === "commander.invalidArgument") {
          const message = `${invalidArgumentMessage} ${err.message}`;
          this.error(message, { exitCode: err.exitCode, code: err.code });
        }
        throw err;
      }
    }
    _registerOption(option) {
      const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
      if (matchingOption) {
        const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
        throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
      }
      this.options.push(option);
    }
    _registerCommand(command) {
      const knownBy = (cmd) => {
        return [cmd.name()].concat(cmd.aliases());
      };
      const alreadyUsed = knownBy(command).find((name) => this._findCommand(name));
      if (alreadyUsed) {
        const existingCmd = knownBy(this._findCommand(alreadyUsed)).join("|");
        const newCmd = knownBy(command).join("|");
        throw new Error(`cannot add command '${newCmd}' as already have command '${existingCmd}'`);
      }
      this.commands.push(command);
    }
    addOption(option) {
      this._registerOption(option);
      const oname = option.name();
      const name = option.attributeName();
      if (option.negate) {
        const positiveLongFlag = option.long.replace(/^--no-/, "--");
        if (!this._findOption(positiveLongFlag)) {
          this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, "default");
        }
      } else if (option.defaultValue !== undefined) {
        this.setOptionValueWithSource(name, option.defaultValue, "default");
      }
      const handleOptionValue = (val, invalidValueMessage, valueSource) => {
        if (val == null && option.presetArg !== undefined) {
          val = option.presetArg;
        }
        const oldValue = this.getOptionValue(name);
        if (val !== null && option.parseArg) {
          val = this._callParseArg(option, val, oldValue, invalidValueMessage);
        } else if (val !== null && option.variadic) {
          val = option._concatValue(val, oldValue);
        }
        if (val == null) {
          if (option.negate) {
            val = false;
          } else if (option.isBoolean() || option.optional) {
            val = true;
          } else {
            val = "";
          }
        }
        this.setOptionValueWithSource(name, val, valueSource);
      };
      this.on("option:" + oname, (val) => {
        const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, "cli");
      });
      if (option.envVar) {
        this.on("optionEnv:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "env");
        });
      }
      return this;
    }
    _optionEx(config, flags, description, fn, defaultValue) {
      if (typeof flags === "object" && flags instanceof Option) {
        throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
      }
      const option = this.createOption(flags, description);
      option.makeOptionMandatory(!!config.mandatory);
      if (typeof fn === "function") {
        option.default(defaultValue).argParser(fn);
      } else if (fn instanceof RegExp) {
        const regex = fn;
        fn = (val, def) => {
          const m = regex.exec(val);
          return m ? m[0] : def;
        };
        option.default(defaultValue).argParser(fn);
      } else {
        option.default(fn);
      }
      return this.addOption(option);
    }
    option(flags, description, parseArg, defaultValue) {
      return this._optionEx({}, flags, description, parseArg, defaultValue);
    }
    requiredOption(flags, description, parseArg, defaultValue) {
      return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
    }
    combineFlagAndOptionalValue(combine = true) {
      this._combineFlagAndOptionalValue = !!combine;
      return this;
    }
    allowUnknownOption(allowUnknown = true) {
      this._allowUnknownOption = !!allowUnknown;
      return this;
    }
    allowExcessArguments(allowExcess = true) {
      this._allowExcessArguments = !!allowExcess;
      return this;
    }
    enablePositionalOptions(positional = true) {
      this._enablePositionalOptions = !!positional;
      return this;
    }
    passThroughOptions(passThrough = true) {
      this._passThroughOptions = !!passThrough;
      this._checkForBrokenPassThrough();
      return this;
    }
    _checkForBrokenPassThrough() {
      if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {
        throw new Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`);
      }
    }
    storeOptionsAsProperties(storeAsProperties = true) {
      if (this.options.length) {
        throw new Error("call .storeOptionsAsProperties() before adding options");
      }
      if (Object.keys(this._optionValues).length) {
        throw new Error("call .storeOptionsAsProperties() before setting option values");
      }
      this._storeOptionsAsProperties = !!storeAsProperties;
      return this;
    }
    getOptionValue(key) {
      if (this._storeOptionsAsProperties) {
        return this[key];
      }
      return this._optionValues[key];
    }
    setOptionValue(key, value) {
      return this.setOptionValueWithSource(key, value, undefined);
    }
    setOptionValueWithSource(key, value, source) {
      if (this._storeOptionsAsProperties) {
        this[key] = value;
      } else {
        this._optionValues[key] = value;
      }
      this._optionValueSources[key] = source;
      return this;
    }
    getOptionValueSource(key) {
      return this._optionValueSources[key];
    }
    getOptionValueSourceWithGlobals(key) {
      let source;
      this._getCommandAndAncestors().forEach((cmd) => {
        if (cmd.getOptionValueSource(key) !== undefined) {
          source = cmd.getOptionValueSource(key);
        }
      });
      return source;
    }
    _prepareUserArgs(argv, parseOptions) {
      if (argv !== undefined && !Array.isArray(argv)) {
        throw new Error("first parameter to parse must be array or undefined");
      }
      parseOptions = parseOptions || {};
      if (argv === undefined && parseOptions.from === undefined) {
        if (process2.versions?.electron) {
          parseOptions.from = "electron";
        }
        const execArgv = process2.execArgv ?? [];
        if (execArgv.includes("-e") || execArgv.includes("--eval") || execArgv.includes("-p") || execArgv.includes("--print")) {
          parseOptions.from = "eval";
        }
      }
      if (argv === undefined) {
        argv = process2.argv;
      }
      this.rawArgs = argv.slice();
      let userArgs;
      switch (parseOptions.from) {
        case undefined:
        case "node":
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
          break;
        case "electron":
          if (process2.defaultApp) {
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
          } else {
            userArgs = argv.slice(1);
          }
          break;
        case "user":
          userArgs = argv.slice(0);
          break;
        case "eval":
          userArgs = argv.slice(1);
          break;
        default:
          throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
      }
      if (!this._name && this._scriptPath)
        this.nameFromFilename(this._scriptPath);
      this._name = this._name || "program";
      return userArgs;
    }
    parse(argv, parseOptions) {
      const userArgs = this._prepareUserArgs(argv, parseOptions);
      this._parseCommand([], userArgs);
      return this;
    }
    async parseAsync(argv, parseOptions) {
      const userArgs = this._prepareUserArgs(argv, parseOptions);
      await this._parseCommand([], userArgs);
      return this;
    }
    _executeSubCommand(subcommand, args) {
      args = args.slice();
      let launchWithNode = false;
      const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
      function findFile(baseDir, baseName) {
        const localBin = path.resolve(baseDir, baseName);
        if (fs.existsSync(localBin))
          return localBin;
        if (sourceExt.includes(path.extname(baseName)))
          return;
        const foundExt = sourceExt.find((ext) => fs.existsSync(`${localBin}${ext}`));
        if (foundExt)
          return `${localBin}${foundExt}`;
        return;
      }
      this._checkForMissingMandatoryOptions();
      this._checkForConflictingOptions();
      let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
      let executableDir = this._executableDir || "";
      if (this._scriptPath) {
        let resolvedScriptPath;
        try {
          resolvedScriptPath = fs.realpathSync(this._scriptPath);
        } catch (err) {
          resolvedScriptPath = this._scriptPath;
        }
        executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);
      }
      if (executableDir) {
        let localFile = findFile(executableDir, executableFile);
        if (!localFile && !subcommand._executableFile && this._scriptPath) {
          const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));
          if (legacyName !== this._name) {
            localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
          }
        }
        executableFile = localFile || executableFile;
      }
      launchWithNode = sourceExt.includes(path.extname(executableFile));
      let proc;
      if (process2.platform !== "win32") {
        if (launchWithNode) {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process2.execArgv).concat(args);
          proc = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
        } else {
          proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
        }
      } else {
        args.unshift(executableFile);
        args = incrementNodeInspectorPort(process2.execArgv).concat(args);
        proc = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
      }
      if (!proc.killed) {
        const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
        signals.forEach((signal) => {
          process2.on(signal, () => {
            if (proc.killed === false && proc.exitCode === null) {
              proc.kill(signal);
            }
          });
        });
      }
      const exitCallback = this._exitCallback;
      proc.on("close", (code) => {
        code = code ?? 1;
        if (!exitCallback) {
          process2.exit(code);
        } else {
          exitCallback(new CommanderError(code, "commander.executeSubCommandAsync", "(close)"));
        }
      });
      proc.on("error", (err) => {
        if (err.code === "ENOENT") {
          const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
          const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
          throw new Error(executableMissing);
        } else if (err.code === "EACCES") {
          throw new Error(`'${executableFile}' not executable`);
        }
        if (!exitCallback) {
          process2.exit(1);
        } else {
          const wrappedError = new CommanderError(1, "commander.executeSubCommandAsync", "(error)");
          wrappedError.nestedError = err;
          exitCallback(wrappedError);
        }
      });
      this.runningCommand = proc;
    }
    _dispatchSubcommand(commandName, operands, unknown) {
      const subCommand = this._findCommand(commandName);
      if (!subCommand)
        this.help({ error: true });
      let promiseChain;
      promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, "preSubcommand");
      promiseChain = this._chainOrCall(promiseChain, () => {
        if (subCommand._executableHandler) {
          this._executeSubCommand(subCommand, operands.concat(unknown));
        } else {
          return subCommand._parseCommand(operands, unknown);
        }
      });
      return promiseChain;
    }
    _dispatchHelpCommand(subcommandName) {
      if (!subcommandName) {
        this.help();
      }
      const subCommand = this._findCommand(subcommandName);
      if (subCommand && !subCommand._executableHandler) {
        subCommand.help();
      }
      return this._dispatchSubcommand(subcommandName, [], [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"]);
    }
    _checkNumberOfArguments() {
      this.registeredArguments.forEach((arg, i) => {
        if (arg.required && this.args[i] == null) {
          this.missingArgument(arg.name());
        }
      });
      if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
        return;
      }
      if (this.args.length > this.registeredArguments.length) {
        this._excessArguments(this.args);
      }
    }
    _processArguments() {
      const myParseArg = (argument, value, previous) => {
        let parsedValue = value;
        if (value !== null && argument.parseArg) {
          const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
          parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
        }
        return parsedValue;
      };
      this._checkNumberOfArguments();
      const processedArgs = [];
      this.registeredArguments.forEach((declaredArg, index) => {
        let value = declaredArg.defaultValue;
        if (declaredArg.variadic) {
          if (index < this.args.length) {
            value = this.args.slice(index);
            if (declaredArg.parseArg) {
              value = value.reduce((processed, v) => {
                return myParseArg(declaredArg, v, processed);
              }, declaredArg.defaultValue);
            }
          } else if (value === undefined) {
            value = [];
          }
        } else if (index < this.args.length) {
          value = this.args[index];
          if (declaredArg.parseArg) {
            value = myParseArg(declaredArg, value, declaredArg.defaultValue);
          }
        }
        processedArgs[index] = value;
      });
      this.processedArgs = processedArgs;
    }
    _chainOrCall(promise, fn) {
      if (promise && promise.then && typeof promise.then === "function") {
        return promise.then(() => fn());
      }
      return fn();
    }
    _chainOrCallHooks(promise, event) {
      let result = promise;
      const hooks = [];
      this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== undefined).forEach((hookedCommand) => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        });
      });
      if (event === "postAction") {
        hooks.reverse();
      }
      hooks.forEach((hookDetail) => {
        result = this._chainOrCall(result, () => {
          return hookDetail.callback(hookDetail.hookedCommand, this);
        });
      });
      return result;
    }
    _chainOrCallSubCommandHook(promise, subCommand, event) {
      let result = promise;
      if (this._lifeCycleHooks[event] !== undefined) {
        this._lifeCycleHooks[event].forEach((hook) => {
          result = this._chainOrCall(result, () => {
            return hook(this, subCommand);
          });
        });
      }
      return result;
    }
    _parseCommand(operands, unknown) {
      const parsed = this.parseOptions(unknown);
      this._parseOptionsEnv();
      this._parseOptionsImplied();
      operands = operands.concat(parsed.operands);
      unknown = parsed.unknown;
      this.args = operands.concat(unknown);
      if (operands && this._findCommand(operands[0])) {
        return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
      }
      if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {
        return this._dispatchHelpCommand(operands[1]);
      }
      if (this._defaultCommandName) {
        this._outputHelpIfRequested(unknown);
        return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
      }
      if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
        this.help({ error: true });
      }
      this._outputHelpIfRequested(parsed.unknown);
      this._checkForMissingMandatoryOptions();
      this._checkForConflictingOptions();
      const checkForUnknownOptions = () => {
        if (parsed.unknown.length > 0) {
          this.unknownOption(parsed.unknown[0]);
        }
      };
      const commandEvent = `command:${this.name()}`;
      if (this._actionHandler) {
        checkForUnknownOptions();
        this._processArguments();
        let promiseChain;
        promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
        promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
        if (this.parent) {
          promiseChain = this._chainOrCall(promiseChain, () => {
            this.parent.emit(commandEvent, operands, unknown);
          });
        }
        promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
        return promiseChain;
      }
      if (this.parent && this.parent.listenerCount(commandEvent)) {
        checkForUnknownOptions();
        this._processArguments();
        this.parent.emit(commandEvent, operands, unknown);
      } else if (operands.length) {
        if (this._findCommand("*")) {
          return this._dispatchSubcommand("*", operands, unknown);
        }
        if (this.listenerCount("command:*")) {
          this.emit("command:*", operands, unknown);
        } else if (this.commands.length) {
          this.unknownCommand();
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      } else if (this.commands.length) {
        checkForUnknownOptions();
        this.help({ error: true });
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    }
    _findCommand(name) {
      if (!name)
        return;
      return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
    }
    _findOption(arg) {
      return this.options.find((option) => option.is(arg));
    }
    _checkForMissingMandatoryOptions() {
      this._getCommandAndAncestors().forEach((cmd) => {
        cmd.options.forEach((anOption) => {
          if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) {
            cmd.missingMandatoryOptionValue(anOption);
          }
        });
      });
    }
    _checkForConflictingLocalOptions() {
      const definedNonDefaultOptions = this.options.filter((option) => {
        const optionKey = option.attributeName();
        if (this.getOptionValue(optionKey) === undefined) {
          return false;
        }
        return this.getOptionValueSource(optionKey) !== "default";
      });
      const optionsWithConflicting = definedNonDefaultOptions.filter((option) => option.conflictsWith.length > 0);
      optionsWithConflicting.forEach((option) => {
        const conflictingAndDefined = definedNonDefaultOptions.find((defined) => option.conflictsWith.includes(defined.attributeName()));
        if (conflictingAndDefined) {
          this._conflictingOption(option, conflictingAndDefined);
        }
      });
    }
    _checkForConflictingOptions() {
      this._getCommandAndAncestors().forEach((cmd) => {
        cmd._checkForConflictingLocalOptions();
      });
    }
    parseOptions(argv) {
      const operands = [];
      const unknown = [];
      let dest = operands;
      const args = argv.slice();
      function maybeOption(arg) {
        return arg.length > 1 && arg[0] === "-";
      }
      let activeVariadicOption = null;
      while (args.length) {
        const arg = args.shift();
        if (arg === "--") {
          if (dest === unknown)
            dest.push(arg);
          dest.push(...args);
          break;
        }
        if (activeVariadicOption && !maybeOption(arg)) {
          this.emit(`option:${activeVariadicOption.name()}`, arg);
          continue;
        }
        activeVariadicOption = null;
        if (maybeOption(arg)) {
          const option = this._findOption(arg);
          if (option) {
            if (option.required) {
              const value = args.shift();
              if (value === undefined)
                this.optionMissingArgument(option);
              this.emit(`option:${option.name()}`, value);
            } else if (option.optional) {
              let value = null;
              if (args.length > 0 && !maybeOption(args[0])) {
                value = args.shift();
              }
              this.emit(`option:${option.name()}`, value);
            } else {
              this.emit(`option:${option.name()}`);
            }
            activeVariadicOption = option.variadic ? option : null;
            continue;
          }
        }
        if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
          const option = this._findOption(`-${arg[1]}`);
          if (option) {
            if (option.required || option.optional && this._combineFlagAndOptionalValue) {
              this.emit(`option:${option.name()}`, arg.slice(2));
            } else {
              this.emit(`option:${option.name()}`);
              args.unshift(`-${arg.slice(2)}`);
            }
            continue;
          }
        }
        if (/^--[^=]+=/.test(arg)) {
          const index = arg.indexOf("=");
          const option = this._findOption(arg.slice(0, index));
          if (option && (option.required || option.optional)) {
            this.emit(`option:${option.name()}`, arg.slice(index + 1));
            continue;
          }
        }
        if (maybeOption(arg)) {
          dest = unknown;
        }
        if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
          if (this._findCommand(arg)) {
            operands.push(arg);
            if (args.length > 0)
              unknown.push(...args);
            break;
          } else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
            operands.push(arg);
            if (args.length > 0)
              operands.push(...args);
            break;
          } else if (this._defaultCommandName) {
            unknown.push(arg);
            if (args.length > 0)
              unknown.push(...args);
            break;
          }
        }
        if (this._passThroughOptions) {
          dest.push(arg);
          if (args.length > 0)
            dest.push(...args);
          break;
        }
        dest.push(arg);
      }
      return { operands, unknown };
    }
    opts() {
      if (this._storeOptionsAsProperties) {
        const result = {};
        const len = this.options.length;
        for (let i = 0;i < len; i++) {
          const key = this.options[i].attributeName();
          result[key] = key === this._versionOptionName ? this._version : this[key];
        }
        return result;
      }
      return this._optionValues;
    }
    optsWithGlobals() {
      return this._getCommandAndAncestors().reduce((combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()), {});
    }
    error(message, errorOptions) {
      this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
      if (typeof this._showHelpAfterError === "string") {
        this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
      } else if (this._showHelpAfterError) {
        this._outputConfiguration.writeErr(`
`);
        this.outputHelp({ error: true });
      }
      const config = errorOptions || {};
      const exitCode = config.exitCode || 1;
      const code = config.code || "commander.error";
      this._exit(exitCode, code, message);
    }
    _parseOptionsEnv() {
      this.options.forEach((option) => {
        if (option.envVar && option.envVar in process2.env) {
          const optionKey = option.attributeName();
          if (this.getOptionValue(optionKey) === undefined || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
            if (option.required || option.optional) {
              this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
            } else {
              this.emit(`optionEnv:${option.name()}`);
            }
          }
        }
      });
    }
    _parseOptionsImplied() {
      const dualHelper = new DualOptions(this.options);
      const hasCustomOptionValue = (optionKey) => {
        return this.getOptionValue(optionKey) !== undefined && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
      };
      this.options.filter((option) => option.implied !== undefined && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
        Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
          this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
        });
      });
    }
    missingArgument(name) {
      const message = `error: missing required argument '${name}'`;
      this.error(message, { code: "commander.missingArgument" });
    }
    optionMissingArgument(option) {
      const message = `error: option '${option.flags}' argument missing`;
      this.error(message, { code: "commander.optionMissingArgument" });
    }
    missingMandatoryOptionValue(option) {
      const message = `error: required option '${option.flags}' not specified`;
      this.error(message, { code: "commander.missingMandatoryOptionValue" });
    }
    _conflictingOption(option, conflictingOption) {
      const findBestOptionFromValue = (option2) => {
        const optionKey = option2.attributeName();
        const optionValue = this.getOptionValue(optionKey);
        const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
        const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
        if (negativeOption && (negativeOption.presetArg === undefined && optionValue === false || negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)) {
          return negativeOption;
        }
        return positiveOption || option2;
      };
      const getErrorMessage = (option2) => {
        const bestOption = findBestOptionFromValue(option2);
        const optionKey = bestOption.attributeName();
        const source = this.getOptionValueSource(optionKey);
        if (source === "env") {
          return `environment variable '${bestOption.envVar}'`;
        }
        return `option '${bestOption.flags}'`;
      };
      const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
      this.error(message, { code: "commander.conflictingOption" });
    }
    unknownOption(flag) {
      if (this._allowUnknownOption)
        return;
      let suggestion = "";
      if (flag.startsWith("--") && this._showSuggestionAfterError) {
        let candidateFlags = [];
        let command = this;
        do {
          const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
          candidateFlags = candidateFlags.concat(moreFlags);
          command = command.parent;
        } while (command && !command._enablePositionalOptions);
        suggestion = suggestSimilar(flag, candidateFlags);
      }
      const message = `error: unknown option '${flag}'${suggestion}`;
      this.error(message, { code: "commander.unknownOption" });
    }
    _excessArguments(receivedArgs) {
      if (this._allowExcessArguments)
        return;
      const expected = this.registeredArguments.length;
      const s = expected === 1 ? "" : "s";
      const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
      const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
      this.error(message, { code: "commander.excessArguments" });
    }
    unknownCommand() {
      const unknownName = this.args[0];
      let suggestion = "";
      if (this._showSuggestionAfterError) {
        const candidateNames = [];
        this.createHelp().visibleCommands(this).forEach((command) => {
          candidateNames.push(command.name());
          if (command.alias())
            candidateNames.push(command.alias());
        });
        suggestion = suggestSimilar(unknownName, candidateNames);
      }
      const message = `error: unknown command '${unknownName}'${suggestion}`;
      this.error(message, { code: "commander.unknownCommand" });
    }
    version(str, flags, description) {
      if (str === undefined)
        return this._version;
      this._version = str;
      flags = flags || "-V, --version";
      description = description || "output the version number";
      const versionOption = this.createOption(flags, description);
      this._versionOptionName = versionOption.attributeName();
      this._registerOption(versionOption);
      this.on("option:" + versionOption.name(), () => {
        this._outputConfiguration.writeOut(`${str}
`);
        this._exit(0, "commander.version", str);
      });
      return this;
    }
    description(str, argsDescription) {
      if (str === undefined && argsDescription === undefined)
        return this._description;
      this._description = str;
      if (argsDescription) {
        this._argsDescription = argsDescription;
      }
      return this;
    }
    summary(str) {
      if (str === undefined)
        return this._summary;
      this._summary = str;
      return this;
    }
    alias(alias) {
      if (alias === undefined)
        return this._aliases[0];
      let command = this;
      if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
        command = this.commands[this.commands.length - 1];
      }
      if (alias === command._name)
        throw new Error("Command alias can't be the same as its name");
      const matchingCommand = this.parent?._findCommand(alias);
      if (matchingCommand) {
        const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join("|");
        throw new Error(`cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`);
      }
      command._aliases.push(alias);
      return this;
    }
    aliases(aliases) {
      if (aliases === undefined)
        return this._aliases;
      aliases.forEach((alias) => this.alias(alias));
      return this;
    }
    usage(str) {
      if (str === undefined) {
        if (this._usage)
          return this._usage;
        const args = this.registeredArguments.map((arg) => {
          return humanReadableArgName(arg);
        });
        return [].concat(this.options.length || this._helpOption !== null ? "[options]" : [], this.commands.length ? "[command]" : [], this.registeredArguments.length ? args : []).join(" ");
      }
      this._usage = str;
      return this;
    }
    name(str) {
      if (str === undefined)
        return this._name;
      this._name = str;
      return this;
    }
    nameFromFilename(filename) {
      this._name = path.basename(filename, path.extname(filename));
      return this;
    }
    executableDir(path2) {
      if (path2 === undefined)
        return this._executableDir;
      this._executableDir = path2;
      return this;
    }
    helpInformation(contextOptions) {
      const helper = this.createHelp();
      if (helper.helpWidth === undefined) {
        helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
      }
      return helper.formatHelp(this, helper);
    }
    _getHelpContext(contextOptions) {
      contextOptions = contextOptions || {};
      const context = { error: !!contextOptions.error };
      let write;
      if (context.error) {
        write = (arg) => this._outputConfiguration.writeErr(arg);
      } else {
        write = (arg) => this._outputConfiguration.writeOut(arg);
      }
      context.write = contextOptions.write || write;
      context.command = this;
      return context;
    }
    outputHelp(contextOptions) {
      let deprecatedCallback;
      if (typeof contextOptions === "function") {
        deprecatedCallback = contextOptions;
        contextOptions = undefined;
      }
      const context = this._getHelpContext(contextOptions);
      this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", context));
      this.emit("beforeHelp", context);
      let helpInformation = this.helpInformation(context);
      if (deprecatedCallback) {
        helpInformation = deprecatedCallback(helpInformation);
        if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
          throw new Error("outputHelp callback must return a string or a Buffer");
        }
      }
      context.write(helpInformation);
      if (this._getHelpOption()?.long) {
        this.emit(this._getHelpOption().long);
      }
      this.emit("afterHelp", context);
      this._getCommandAndAncestors().forEach((command) => command.emit("afterAllHelp", context));
    }
    helpOption(flags, description) {
      if (typeof flags === "boolean") {
        if (flags) {
          this._helpOption = this._helpOption ?? undefined;
        } else {
          this._helpOption = null;
        }
        return this;
      }
      flags = flags ?? "-h, --help";
      description = description ?? "display help for command";
      this._helpOption = this.createOption(flags, description);
      return this;
    }
    _getHelpOption() {
      if (this._helpOption === undefined) {
        this.helpOption(undefined, undefined);
      }
      return this._helpOption;
    }
    addHelpOption(option) {
      this._helpOption = option;
      return this;
    }
    help(contextOptions) {
      this.outputHelp(contextOptions);
      let exitCode = process2.exitCode || 0;
      if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
        exitCode = 1;
      }
      this._exit(exitCode, "commander.help", "(outputHelp)");
    }
    addHelpText(position, text) {
      const allowedValues = ["beforeAll", "before", "after", "afterAll"];
      if (!allowedValues.includes(position)) {
        throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      const helpEvent = `${position}Help`;
      this.on(helpEvent, (context) => {
        let helpStr;
        if (typeof text === "function") {
          helpStr = text({ error: context.error, command: context.command });
        } else {
          helpStr = text;
        }
        if (helpStr) {
          context.write(`${helpStr}
`);
        }
      });
      return this;
    }
    _outputHelpIfRequested(args) {
      const helpOption = this._getHelpOption();
      const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
      if (helpRequested) {
        this.outputHelp();
        this._exit(0, "commander.helpDisplayed", "(outputHelp)");
      }
    }
  }
  function incrementNodeInspectorPort(args) {
    return args.map((arg) => {
      if (!arg.startsWith("--inspect")) {
        return arg;
      }
      let debugOption;
      let debugHost = "127.0.0.1";
      let debugPort = "9229";
      let match;
      if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
        debugOption = match[1];
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
        debugOption = match[1];
        if (/^\d+$/.test(match[3])) {
          debugPort = match[3];
        } else {
          debugHost = match[3];
        }
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
        debugOption = match[1];
        debugHost = match[3];
        debugPort = match[4];
      }
      if (debugOption && debugPort !== "0") {
        return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
      }
      return arg;
    });
  }
  exports.Command = Command;
});

// node_modules/commander/index.js
var require_commander = __commonJS((exports) => {
  var { Argument } = require_argument();
  var { Command } = require_command();
  var { CommanderError, InvalidArgumentError } = require_error();
  var { Help } = require_help();
  var { Option } = require_option();
  exports.program = new Command;
  exports.createCommand = (name) => new Command(name);
  exports.createOption = (flags, description) => new Option(flags, description);
  exports.createArgument = (name, description) => new Argument(name, description);
  exports.Command = Command;
  exports.Option = Option;
  exports.Argument = Argument;
  exports.Help = Help;
  exports.CommanderError = CommanderError;
  exports.InvalidArgumentError = InvalidArgumentError;
  exports.InvalidOptionArgumentError = InvalidArgumentError;
});

// node_modules/commander/esm.mjs
var import__ = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  Command,
  Argument,
  Option,
  Help
} = import__.default;

// packages/@oxen-cli/pptx-cli/src/commands/loader.ts
import * as fs from "fs/promises";
import { extname } from "path";

// node_modules/fflate/esm/index.mjs
import { createRequire } from "module";
var require2 = createRequire("/");
var Worker;
try {
  Worker = require2("worker_threads").Worker;
} catch (e) {}
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0;i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1;i < 30; ++i) {
    for (var j = b[i];j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i = 0;i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i2 = 0;
  var l = new u16(mb);
  for (;i2 < s; ++i2) {
    if (cd[i2])
      ++l[cd[i2] - 1];
  }
  var le = new u16(mb);
  for (i2 = 1;i2 < mb; ++i2) {
    le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0;i2 < s; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v = le[cd[i2] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1;v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i2 = 0;i2 < s; ++i2) {
      if (cd[i2]) {
        co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i = 0;i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144;i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256;i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280;i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0;i < 32; ++i)
  fdt[i] = 5;
var i;
var flm = /* @__PURE__ */ hMap(flt, 9, 0);
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function(a) {
  var m = a[0];
  for (var i2 = 1;i2 < a.length; ++i2) {
    if (a[i2] > m)
      m = a[i2];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0;i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0;i2 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i2++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i2++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (;; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b = fleb[i2];
          add = bits(dat, pos, (1 << b) - 1) + fl[i2];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (;bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (;bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var wbits = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
};
var wbits16 = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
  d[o + 2] |= v >> 16;
};
var hTree = function(d, mb) {
  var t = [];
  for (var i2 = 0;i2 < d.length; ++i2) {
    if (d[i2])
      t.push({ s: i2, f: d[i2] });
  }
  var s = t.length;
  var t2 = t.slice();
  if (!s)
    return { t: et, l: 0 };
  if (s == 1) {
    var v = new u8(t[0].s + 1);
    v[t[0].s] = 1;
    return { t: v, l: 1 };
  }
  t.sort(function(a, b) {
    return a.f - b.f;
  });
  t.push({ s: -1, f: 25001 });
  var l = t[0], r = t[1], i0 = 0, i1 = 1, i22 = 2;
  t[0] = { s: -1, f: l.f + r.f, l, r };
  while (i1 != s - 1) {
    l = t[t[i0].f < t[i22].f ? i0++ : i22++];
    r = t[i0 != i1 && t[i0].f < t[i22].f ? i0++ : i22++];
    t[i1++] = { s: -1, f: l.f + r.f, l, r };
  }
  var maxSym = t2[0].s;
  for (var i2 = 1;i2 < s; ++i2) {
    if (t2[i2].s > maxSym)
      maxSym = t2[i2].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i2 = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t2.sort(function(a, b) {
      return tr[b.s] - tr[a.s] || a.f - b.f;
    });
    for (;i2 < s; ++i2) {
      var i2_1 = t2[i2].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>= lft;
    while (dt > 0) {
      var i2_2 = t2[i2].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i2;
    }
    for (;i2 >= 0 && dt; --i2) {
      var i2_3 = t2[i2].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return { t: new u8(tr), l: mbt };
};
var ln = function(n, l, d) {
  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
};
var lc = function(c) {
  var s = c.length;
  while (s && !c[--s])
    ;
  var cl = new u16(++s);
  var cli = 0, cln = c[0], cls = 1;
  var w = function(v) {
    cl[cli++] = v;
  };
  for (var i2 = 1;i2 <= s; ++i2) {
    if (c[i2] == cln && i2 != s)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (;cls > 138; cls -= 138)
          w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (;cls > 6; cls -= 6)
          w(8304);
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w(cln);
      cls = 1;
      cln = c[i2];
    }
  }
  return { c: cl.subarray(0, cli), n: s };
};
var clen = function(cf, cl) {
  var l = 0;
  for (var i2 = 0;i2 < cl.length; ++i2)
    l += cf[i2] * cl[i2];
  return l;
};
var wfblk = function(out, pos, dat) {
  var s = dat.length;
  var o = shft(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i2 = 0;i2 < s; ++i2)
    out[o + i2 + 4] = dat[i2];
  return (o + 4 + s) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i2 = 0;i2 < lclt.length; ++i2)
    ++lcfreq[lclt[i2] & 31];
  for (var i2 = 0;i2 < lcdt.length; ++i2)
    ++lcfreq[lcdt[i2] & 31];
  var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
  var nlcc = 19;
  for (;nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;
    for (var i2 = 0;i2 < nlcc; ++i2)
      wbits(out, p + 3 * i2, lct[clim[i2]]);
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0;it < 2; ++it) {
      var clct = lcts[it];
      for (var i2 = 0;i2 < clct.length; ++i2) {
        var len = clct[i2] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15)
          wbits(out, p, clct[i2] >> 5 & 127), p += clct[i2] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i2 = 0;i2 < li; ++i2) {
    var sym = syms[i2];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7)
        wbits(out, p, sym >> 23 & 31), p += fleb[len];
      var dst = sym & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3)
        wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[sym]), p += ll[sym];
    }
  }
  wbits16(out, p, lm[256]);
  return p + ll[256];
};
var deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = /* @__PURE__ */ new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, st) {
  var s = st.z || dat.length;
  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
  var w = o.subarray(pre, o.length - post);
  var lst = st.l;
  var pos = (st.r || 0) & 7;
  if (lvl) {
    if (pos)
      w[0] = st.r >> 3;
    var opt = deo[lvl - 1];
    var n = opt >> 13, c = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i3) {
      return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25000);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i2 = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
    for (;i2 + 2 < s; ++i2) {
      var hv = hsh(i2);
      var imod = i2 & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i2) {
        var rem = s - i2;
        if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
          li = lc_1 = eb = 0, bs = i2;
          for (var j = 0;j < 286; ++j)
            lf[j] = 0;
          for (var j = 0;j < 30; ++j)
            df[j] = 0;
        }
        var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i2 - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i2);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i2 + l] == dat[i2 + l - dif]) {
              var nl = 0;
              for (;nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                ;
              if (nl > l) {
                l = nl, d = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j = 0;j < mmd; ++j) {
                  var ti = i2 - dif + j & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31, din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i2 + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
      }
    }
    for (i2 = Math.max(i2, wi);i2 < s; ++i2) {
      syms[li++] = dat[i2];
      ++lf[dat[i2]];
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
    if (!lst) {
      st.r = pos & 7 | w[pos / 8 | 0] << 3;
      pos -= 7;
      st.h = head, st.p = prev, st.i = i2, st.w = wi;
    }
  } else {
    for (var i2 = st.w || 0;i2 < s + lst; i2 += 65535) {
      var e = i2 + 65535;
      if (e >= s) {
        w[pos / 8 | 0] = lst;
        e = s;
      }
      pos = wfblk(w, pos + 1, dat.subarray(i2, e));
    }
    st.i = s;
  }
  return slc(o, 0, pre + shft(pos) + post);
};
var crct = /* @__PURE__ */ function() {
  var t = new Int32Array(256);
  for (var i2 = 0;i2 < 256; ++i2) {
    var c = i2, k = 9;
    while (--k)
      c = (c & 1 && -306674912) ^ c >>> 1;
    t[i2] = c;
  }
  return t;
}();
var crc = function() {
  var c = -1;
  return {
    p: function(d) {
      var cr = c;
      for (var i2 = 0;i2 < d.length; ++i2)
        cr = crct[cr & 255 ^ d[i2]] ^ cr >>> 8;
      c = cr;
    },
    d: function() {
      return ~c;
    }
  };
};
var dopt = function(dat, opt, pre, post, st) {
  if (!st) {
    st = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
};
var mrg = function(a, b) {
  var o = {};
  for (var k in a)
    o[k] = a[k];
  for (var k in b)
    o[k] = b[k];
  return o;
};
var b2 = function(d, b) {
  return d[b] | d[b + 1] << 8;
};
var b4 = function(d, b) {
  return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};
var b8 = function(d, b) {
  return b4(d, b) + b4(d, b + 4) * 4294967296;
};
var wbytes = function(d, b, v) {
  for (;v; ++b)
    d[b] = v, v >>>= 8;
};
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var fltn = function(d, p, t, o) {
  for (var k in d) {
    var val = d[k], n = p + k, op = o;
    if (Array.isArray(val))
      op = mrg(o, val[1]), val = val[0];
    if (val instanceof u8)
      t[n] = [val, op];
    else {
      t[n += "/"] = [new u8(0), op];
      fltn(val, n, t, o);
    }
  }
};
var te = typeof TextEncoder != "undefined" && /* @__PURE__ */ new TextEncoder;
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder;
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {}
var dutf8 = function(d) {
  for (var r = "", i2 = 0;; ) {
    var c = d[i2++];
    var eb = (c > 127) + (c > 223) + (c > 239);
    if (i2 + eb > d.length)
      return { s: r, r: slc(d, i2 - 1) };
    if (!eb)
      r += String.fromCharCode(c);
    else if (eb == 3) {
      c = ((c & 15) << 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
    } else if (eb & 1)
      r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);
    else
      r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63);
  }
};
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i2 = 0;i2 < str.length; ++i2)
      ar_1[i2] = str.charCodeAt(i2);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w = function(v) {
    ar[ai++] = v;
  };
  for (var i2 = 0;i2 < l; ++i2) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i2 << 1));
      n.set(ar);
      ar = n;
    }
    var c = str.charCodeAt(i2);
    if (c < 128 || latin1)
      w(c);
    else if (c < 2048)
      w(192 | c >> 6), w(128 | c & 63);
    else if (c > 55295 && c < 57344)
      c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i2) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
    else
      w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
  }
  return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i2 = 0;i2 < dat.length; i2 += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));
    return r;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
    if (r.length)
      err(8);
    return s;
  }
}
var slzh = function(d, b) {
  return b + 30 + b2(d, b + 26) + b2(d, b + 28);
};
var zh = function(d, b, z) {
  var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
  var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];
  return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
};
var z64e = function(d, b) {
  for (;b2(d, b) != 1; b += 4 + b2(d, b + 2))
    ;
  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
};
var exfl = function(ex) {
  var le = 0;
  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535)
        err(9);
      le += l + 4;
    }
  }
  return le;
};
var wzh = function(d, b, f, fn, u, c, ce, co) {
  var fl2 = fn.length, ex = f.extra, col = co && co.length;
  var exl = exfl(ex);
  wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
  if (ce != null)
    d[b++] = 20, d[b++] = f.os;
  d[b] = 20, b += 2;
  d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;
  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
  var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
  if (y < 0 || y > 119)
    err(10);
  wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
  if (c != -1) {
    wbytes(d, b, f.crc);
    wbytes(d, b + 4, c < 0 ? -c - 2 : c);
    wbytes(d, b + 8, f.size);
  }
  wbytes(d, b + 12, fl2);
  wbytes(d, b + 14, exl), b += 16;
  if (ce != null) {
    wbytes(d, b, col);
    wbytes(d, b + 6, f.attrs);
    wbytes(d, b + 10, ce), b += 14;
  }
  d.set(fn, b);
  b += fl2;
  if (exl) {
    for (var k in ex) {
      var exf = ex[k], l = exf.length;
      wbytes(d, b, +k);
      wbytes(d, b + 2, l);
      d.set(exf, b + 4), b += 4 + l;
    }
  }
  if (col)
    d.set(co, b), b += col;
  return b;
};
var wzf = function(o, b, c, d, e) {
  wbytes(o, b, 101010256);
  wbytes(o, b + 8, c);
  wbytes(o, b + 10, c);
  wbytes(o, b + 12, d);
  wbytes(o, b + 16, e);
};
function zipSync(data, opts) {
  if (!opts)
    opts = {};
  var r = {};
  var files = [];
  fltn(data, "", r, opts);
  var o = 0;
  var tot = 0;
  for (var fn in r) {
    var _a2 = r[fn], file = _a2[0], p = _a2[1];
    var compression = p.level == 0 ? 0 : 8;
    var f = strToU8(fn), s = f.length;
    var com = p.comment, m = com && strToU8(com), ms = m && m.length;
    var exl = exfl(p.extra);
    if (s > 65535)
      err(11);
    var d = compression ? deflateSync(file, p) : file, l = d.length;
    var c = crc();
    c.p(file);
    files.push(mrg(p, {
      size: file.length,
      crc: c.d(),
      c: d,
      f,
      m,
      u: s != fn.length || m && com.length != ms,
      o,
      compression
    }));
    o += 30 + s + exl + l;
    tot += 76 + 2 * (s + exl) + (ms || 0) + l;
  }
  var out = new u8(tot + 22), oe = o, cdl = tot - o;
  for (var i2 = 0;i2 < files.length; ++i2) {
    var f = files[i2];
    wzh(out, f.o, f, f.f, f.u, f.c.length);
    var badd = 30 + f.f.length + exfl(f.extra);
    out.set(f.c, f.o + badd);
    wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
  }
  wzf(out, o, files.length, cdl, oe);
  return out;
}
function unzipSync(data, opts) {
  var files = {};
  var e = data.length - 22;
  for (;b4(data, e) != 101010256; --e) {
    if (!e || data.length - e > 65558)
      err(13);
  }
  var c = b2(data, e + 8);
  if (!c)
    return {};
  var o = b4(data, e + 16);
  var z = o == 4294967295 || c == 65535;
  if (z) {
    var ze = b4(data, e - 12);
    z = b4(data, ze) == 101075792;
    if (z) {
      c = b4(data, ze + 32);
      o = b4(data, ze + 48);
    }
  }
  var fltr = opts && opts.filter;
  for (var i2 = 0;i2 < c; ++i2) {
    var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
    o = no;
    if (!fltr || fltr({
      name: fn,
      size: sc,
      originalSize: su,
      compression: c_2
    })) {
      if (!c_2)
        files[fn] = slc(data, b, b + sc);
      else if (c_2 == 8)
        files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });
      else
        err(14, "unknown compression type " + c_2);
    }
  }
  return files;
}

// packages/@oxen/zip/src/zip-reader.ts
function toUint8Array(buffer) {
  return buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
}
function readZipEntries(buffer) {
  const files = unzipSync(toUint8Array(buffer));
  const entries = new Map;
  for (const [path, bytes] of Object.entries(files)) {
    if (!path) {
      continue;
    }
    entries.set(path, bytes);
  }
  return entries;
}

// packages/@oxen/zip/src/zip-writer.ts
function normalizeCompressionLevel(level) {
  if (!Number.isInteger(level) || level < 0 || level > 9) {
    throw new Error(`compressionLevel must be an integer 0-9 (got: ${level})`);
  }
  return level;
}
function writeZipEntries(entries, options = {}) {
  const compressionLevel = normalizeCompressionLevel(options.compressionLevel ?? 6);
  const files = {};
  for (const [path, bytes] of entries) {
    files[path] = bytes;
  }
  return zipSync(files, { level: compressionLevel });
}

// packages/@oxen/zip/src/zip-package.ts
var PPTX_MIME_TYPE = "application/vnd.openxmlformats-officedocument.presentationml.presentation";
var BINARY_EXTENSIONS = new Set([
  ".png",
  ".jpg",
  ".jpeg",
  ".gif",
  ".bmp",
  ".tiff",
  ".tif",
  ".wmf",
  ".emf",
  ".svg",
  ".bin",
  ".ole",
  ".vml",
  ".wav",
  ".mp3",
  ".mp4",
  ".m4a",
  ".wma",
  ".wmv",
  ".avi"
]);
var textDecoder = new TextDecoder;
var textEncoder = new TextEncoder;
function u8ToArrayBuffer(bytes) {
  return bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
}
function toUint8Array2(content) {
  if (content instanceof Uint8Array) {
    const isWholeBuffer = content.byteOffset === 0 && content.byteLength === content.buffer.byteLength;
    if (isWholeBuffer) {
      return content;
    }
    return content.slice();
  }
  return new Uint8Array(content);
}
async function loadZipPackage(buffer) {
  const entries = readZipEntries(buffer);
  return Promise.resolve(createZipPackageFromEntries(entries));
}
function createEmptyZipPackage() {
  return createZipPackageFromEntries(new Map);
}
function createZipPackageFromEntries(initialEntries) {
  const entries = new Map(initialEntries);
  const textCache = new Map;
  const pkg = {
    readText(path) {
      const cached = textCache.get(path);
      if (cached !== undefined) {
        return cached;
      }
      const bytes = entries.get(path);
      if (!bytes) {
        return null;
      }
      const text = textDecoder.decode(bytes);
      textCache.set(path, text);
      return text;
    },
    readBinary(path) {
      const bytes = entries.get(path);
      if (!bytes) {
        return null;
      }
      return u8ToArrayBuffer(bytes);
    },
    exists(path) {
      return entries.has(path);
    },
    listFiles() {
      return Array.from(entries.keys());
    },
    writeText(path, content) {
      const bytes = textEncoder.encode(content);
      entries.set(path, bytes);
      textCache.set(path, content);
    },
    writeBinary(path, content) {
      entries.set(path, toUint8Array2(content));
      textCache.delete(path);
    },
    remove(path) {
      entries.delete(path);
      textCache.delete(path);
    },
    async toBlob(options = {}) {
      const compressionLevel = options.compressionLevel ?? 6;
      const mimeType = options.mimeType ?? PPTX_MIME_TYPE;
      const bytes = writeZipEntries(entries, { compressionLevel });
      return new Blob([bytes], { type: mimeType });
    },
    async toArrayBuffer(options = {}) {
      const compressionLevel = options.compressionLevel ?? 6;
      const bytes = writeZipEntries(entries, { compressionLevel });
      return u8ToArrayBuffer(bytes);
    },
    asPresentationFile() {
      return {
        readText: (path) => pkg.readText(path),
        readBinary: (path) => pkg.readBinary(path),
        exists: (path) => pkg.exists(path),
        listFiles: () => pkg.listFiles()
      };
    }
  };
  return pkg;
}
// packages/@oxen/xml/src/ast.ts
function isXmlElement(node) {
  if (typeof node !== "object") {
    return false;
  }
  if (node === null) {
    return false;
  }
  if (!("type" in node)) {
    return false;
  }
  return node.type === "element";
}
function isXmlDocument(value) {
  if (typeof value !== "object") {
    return false;
  }
  if (value === null) {
    return false;
  }
  if (!("children" in value)) {
    return false;
  }
  return Array.isArray(value.children);
}
function isXmlText(node) {
  if (typeof node !== "object") {
    return false;
  }
  if (node === null) {
    return false;
  }
  if (!("type" in node)) {
    return false;
  }
  return node.type === "text";
}
function getChild(parent, name) {
  const match = createElementNameMatcher(name);
  for (const child of parent.children) {
    if (isXmlElement(child) && match(child.name)) {
      return child;
    }
  }
  return;
}
function getChildren(parent, name) {
  const match = createElementNameMatcher(name);
  const result = [];
  for (const child of parent.children) {
    if (isXmlElement(child) && match(child.name)) {
      result.push(child);
    }
  }
  return result;
}
function createElementNameMatcher(name) {
  if (name.includes(":")) {
    return (childName) => childName === name;
  }
  return (childName) => childName === name || childName.endsWith(`:${name}`);
}
function getTextContent(element) {
  return element.children.filter(isXmlText).map((child) => child.value).join("");
}
function getAttr(element, name) {
  return element.attrs[name];
}
function getByPath(element, path) {
  if (element === null || element === undefined) {
    return;
  }
  if ("children" in element && !("type" in element)) {
    const doc = element;
    if (path.length === 0) {
      return;
    }
    const firstChild = doc.children.find((c) => {
      if (!isXmlElement(c)) {
        return false;
      }
      return c.name === path[0];
    });
    if (!firstChild) {
      return;
    }
    return getByPath(firstChild, path.slice(1));
  }
  if (!isXmlElement(element)) {
    return;
  }
  return path.reduce((current, name) => current ? getChild(current, name) : undefined, element);
}
function getTextByPath(element, path) {
  const target = getByPath(element, path);
  if (!target) {
    return;
  }
  return getTextContent(target);
}
function findChild(element, predicate) {
  if (!element) {
    return;
  }
  for (const child of element.children) {
    if (isXmlElement(child) && predicate(child)) {
      return child;
    }
  }
  return;
}
function createElement(name, attrs = {}, children = []) {
  return {
    type: "element",
    name,
    attrs,
    children
  };
}
function createText(value) {
  return {
    type: "text",
    value
  };
}
// packages/@oxen/xml/src/lexer.ts
var TokenType = {
  TAG_OPEN: "TAG_OPEN",
  TAG_OPEN_END: "TAG_OPEN_END",
  TAG_CLOSE: "TAG_CLOSE",
  TAG_SELF_CLOSE: "TAG_SELF_CLOSE",
  TAG_NAME: "TAG_NAME",
  ATTR_NAME: "ATTR_NAME",
  ATTR_EQ: "ATTR_EQ",
  ATTR_VALUE: "ATTR_VALUE",
  TEXT: "TEXT",
  COMMENT: "COMMENT",
  DECLARATION: "DECLARATION",
  DOCTYPE: "DOCTYPE",
  CDATA: "CDATA",
  EOF: "EOF"
};
function decodeEntities(text) {
  return text.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&apos;/g, "'").replace(/&quot;/g, '"').replace(/&#(\d+);/g, (_, code) => String.fromCharCode(parseInt(code, 10))).replace(/&#x([0-9a-fA-F]+);/g, (_, code) => String.fromCharCode(parseInt(code, 16)));
}
function isNameChar(char) {
  const code = char.charCodeAt(0);
  return code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 48 && code <= 57 || code === 45 || code === 95 || code === 58 || code === 46;
}
function isWhitespace(char) {
  return char === " " || char === "\t" || char === `
` || char === "\r";
}
class XmlLexer {
  input;
  pos = 0;
  state = 0 /* Content */;
  constructor(input) {
    this.input = input;
  }
  nextToken() {
    if (this.pos >= this.input.length) {
      return { type: TokenType.EOF, value: "", pos: this.pos };
    }
    if (this.state === 1 /* InsideTag */) {
      return this.readInsideTag();
    }
    return this.readContent();
  }
  readContent() {
    const char = this.input[this.pos];
    if (char === "<") {
      return this.readTagStart();
    }
    return this.readText();
  }
  readTagStart() {
    const startPos = this.pos;
    if (this.input[this.pos + 1] === "/") {
      this.pos += 2;
      this.state = 1 /* InsideTag */;
      return { type: TokenType.TAG_OPEN_END, value: "</", pos: startPos };
    }
    if (this.input[this.pos + 1] === "!" && this.input[this.pos + 2] === "-" && this.input[this.pos + 3] === "-") {
      return this.readComment();
    }
    if (this.input.slice(this.pos + 1, this.pos + 9) === "![CDATA[") {
      return this.readCData();
    }
    if (this.input[this.pos + 1] === "!") {
      return this.readDocType();
    }
    if (this.input[this.pos + 1] === "?") {
      return this.readDeclaration();
    }
    this.pos++;
    this.state = 1 /* InsideTag */;
    return { type: TokenType.TAG_OPEN, value: "<", pos: startPos };
  }
  readText() {
    const startPos = this.pos;
    const endPos = this.input.indexOf("<", this.pos);
    const text = endPos === -1 ? this.input.slice(this.pos) : this.input.slice(this.pos, endPos);
    this.pos = endPos === -1 ? this.input.length : endPos;
    return { type: TokenType.TEXT, value: decodeEntities(text), pos: startPos };
  }
  readComment() {
    const startPos = this.pos;
    this.pos += 4;
    const endIndex = this.input.indexOf("-->", this.pos);
    if (endIndex === -1) {
      const content2 = this.input.slice(this.pos);
      this.pos = this.input.length;
      return { type: TokenType.COMMENT, value: content2, pos: startPos };
    }
    const content = this.input.slice(this.pos, endIndex);
    this.pos = endIndex + 3;
    return { type: TokenType.COMMENT, value: content, pos: startPos };
  }
  readCData() {
    const startPos = this.pos;
    this.pos += 9;
    const endIndex = this.input.indexOf("]]>", this.pos);
    if (endIndex === -1) {
      const content2 = this.input.slice(this.pos);
      this.pos = this.input.length;
      return { type: TokenType.CDATA, value: content2, pos: startPos };
    }
    const content = this.input.slice(this.pos, endIndex);
    this.pos = endIndex + 3;
    return { type: TokenType.CDATA, value: content, pos: startPos };
  }
  readDocType() {
    const startPos = this.pos;
    this.pos += 2;
    const endIndex = this.input.indexOf(">", this.pos);
    if (endIndex === -1) {
      const content2 = this.input.slice(this.pos);
      this.pos = this.input.length;
      return { type: TokenType.DOCTYPE, value: content2, pos: startPos };
    }
    const content = this.input.slice(this.pos, endIndex);
    this.pos = endIndex + 1;
    return { type: TokenType.DOCTYPE, value: content, pos: startPos };
  }
  readDeclaration() {
    const startPos = this.pos;
    this.pos += 2;
    const endIndex = this.input.indexOf("?>", this.pos);
    if (endIndex === -1) {
      const content2 = this.input.slice(this.pos);
      this.pos = this.input.length;
      return { type: TokenType.DECLARATION, value: content2.trim(), pos: startPos };
    }
    const content = this.input.slice(this.pos, endIndex);
    this.pos = endIndex + 2;
    return { type: TokenType.DECLARATION, value: content.trim(), pos: startPos };
  }
  readInsideTag() {
    this.skipWhitespace();
    if (this.pos >= this.input.length) {
      return { type: TokenType.EOF, value: "", pos: this.pos };
    }
    const char = this.input[this.pos];
    if (char === "/" && this.input[this.pos + 1] === ">") {
      const startPos = this.pos;
      this.pos += 2;
      this.state = 0 /* Content */;
      return { type: TokenType.TAG_SELF_CLOSE, value: "/>", pos: startPos };
    }
    if (char === ">") {
      const startPos = this.pos;
      this.pos++;
      this.state = 0 /* Content */;
      return { type: TokenType.TAG_CLOSE, value: ">", pos: startPos };
    }
    if (char === "=") {
      const startPos = this.pos;
      this.pos++;
      return { type: TokenType.ATTR_EQ, value: "=", pos: startPos };
    }
    if (char === '"' || char === "'") {
      return this.readAttributeValue(char);
    }
    if (isNameChar(char)) {
      return this.readName();
    }
    this.pos++;
    return this.readInsideTag();
  }
  skipWhitespace() {
    while (this.pos < this.input.length && isWhitespace(this.input[this.pos])) {
      this.pos++;
    }
  }
  readName() {
    const startPos = this.pos;
    while (this.pos < this.input.length && isNameChar(this.input[this.pos])) {
      this.pos++;
    }
    const name = this.input.slice(startPos, this.pos);
    const nextNonWhitespace = this.peekNextNonWhitespace();
    if (nextNonWhitespace === "=") {
      return { type: TokenType.ATTR_NAME, value: name, pos: startPos };
    }
    return { type: TokenType.TAG_NAME, value: name, pos: startPos };
  }
  peekNextNonWhitespace() {
    const remaining = this.input.slice(this.pos);
    const match = remaining.match(/^\s*/);
    const skipCount = match?.[0].length ?? 0;
    return this.input[this.pos + skipCount] ?? "";
  }
  readAttributeValue(quote) {
    const startPos = this.pos;
    this.pos++;
    const endPos = this.input.indexOf(quote, this.pos);
    const value = endPos === -1 ? this.input.slice(this.pos) : this.input.slice(this.pos, endPos);
    this.pos = endPos === -1 ? this.input.length : endPos + 1;
    return { type: TokenType.ATTR_VALUE, value: decodeEntities(value), pos: startPos };
  }
}

// packages/@oxen/xml/src/parser.ts
function parseXml(input) {
  const parser = new XmlParser(input);
  return parser.parse();
}

class XmlParser {
  lexer;
  currentToken;
  constructor(input) {
    this.lexer = new XmlLexer(input);
    this.currentToken = this.lexer.nextToken();
  }
  parse() {
    const children = this.parseChildren(null);
    return { children };
  }
  advance() {
    this.currentToken = this.lexer.nextToken();
    return this.currentToken;
  }
  isAtElementEnd() {
    return this.currentToken.type === TokenType.TAG_CLOSE || this.currentToken.type === TokenType.TAG_SELF_CLOSE || this.currentToken.type === TokenType.EOF;
  }
  parseChildren(parentTagName) {
    const children = [];
    while (this.currentToken.type !== TokenType.EOF) {
      if (this.currentToken.type === TokenType.TAG_OPEN_END) {
        const nextToken = this.advance();
        if (nextToken.type === TokenType.TAG_NAME) {
          const tagName = nextToken.value;
          const afterName = this.advance();
          if (afterName.type === TokenType.TAG_CLOSE) {
            this.advance();
          }
          if (tagName === parentTagName) {
            return children;
          }
          continue;
        }
        continue;
      }
      if (this.currentToken.type === TokenType.DECLARATION || this.currentToken.type === TokenType.COMMENT || this.currentToken.type === TokenType.DOCTYPE) {
        this.advance();
        continue;
      }
      if (this.currentToken.type === TokenType.TAG_OPEN) {
        const element = this.parseElement();
        if (element) {
          children.push(element);
        }
        continue;
      }
      if (this.currentToken.type === TokenType.TEXT) {
        const textNode = this.parseText();
        if (textNode) {
          children.push(textNode);
        }
        continue;
      }
      if (this.currentToken.type === TokenType.CDATA) {
        const textNode = {
          type: "text",
          value: this.currentToken.value
        };
        children.push(textNode);
        this.advance();
        continue;
      }
      this.advance();
    }
    return children;
  }
  parseElement() {
    const tagNameToken = this.advance();
    if (tagNameToken.type !== TokenType.TAG_NAME) {
      return null;
    }
    const name = tagNameToken.value;
    this.advance();
    const attrs = {};
    while (!this.isAtElementEnd()) {
      if (this.currentToken.type === TokenType.ATTR_NAME) {
        const attrName = this.currentToken.value;
        const tokenAfterName = this.advance();
        const valueToken = tokenAfterName.type === TokenType.ATTR_EQ ? this.advance() : tokenAfterName;
        if (valueToken.type === TokenType.ATTR_VALUE) {
          attrs[attrName] = valueToken.value;
          this.advance();
        } else {
          attrs[attrName] = "";
        }
      } else {
        this.advance();
      }
    }
    if (this.currentToken.type === TokenType.TAG_SELF_CLOSE) {
      this.advance();
      return {
        type: "element",
        name,
        attrs,
        children: []
      };
    }
    if (this.currentToken.type === TokenType.TAG_CLOSE) {
      this.advance();
    }
    const children = this.parseChildren(name);
    return {
      type: "element",
      name,
      attrs,
      children
    };
  }
  parseText() {
    const value = this.currentToken.value;
    this.advance();
    if (value.trim().length === 0) {
      return null;
    }
    return {
      type: "text",
      value
    };
  }
}
// packages/@oxen/xml/src/escape.ts
var ENCODE_MAP = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&apos;"
};
function escapeXml(text) {
  return text.replace(/[&<>"']/g, (char) => ENCODE_MAP[char]);
}

// packages/@oxen/xml/src/serializer.ts
var DEFAULT_OPTIONS = {
  declaration: false,
  encoding: "UTF-8",
  standalone: true,
  indent: false,
  indentString: "  ",
  selfClosing: true
};
function serializeDocument(document, options = {}) {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const parts = [];
  if (opts.declaration) {
    parts.push(buildDeclaration(opts));
    if (opts.indent) {
      parts.push(`
`);
    }
  }
  for (const child of document.children) {
    parts.push(serializeNode(child, opts, 0));
  }
  return parts.join("");
}
function serializeNode(node, options = {}, depth = 0) {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  if (isXmlText(node)) {
    return serializeText(node);
  }
  if (isXmlElement(node)) {
    return serializeElementInternal(node, opts, depth);
  }
  return "";
}
function serializeElementInternal(element, opts, depth) {
  const indent = opts.indent ? opts.indentString.repeat(depth) : "";
  const newline = opts.indent ? `
` : "";
  const attrs = serializeAttributes(element.attrs);
  const attrStr = attrs.length > 0 ? " " + attrs : "";
  if (element.children.length === 0) {
    if (opts.selfClosing) {
      return `${indent}<${element.name}${attrStr}/>`;
    }
    return `${indent}<${element.name}${attrStr}></${element.name}>`;
  }
  const hasOnlyText = element.children.every((child) => isXmlText(child));
  if (hasOnlyText) {
    const textContent = element.children.filter(isXmlText).map((t) => escapeXml(t.value)).join("");
    return `${indent}<${element.name}${attrStr}>${textContent}</${element.name}>`;
  }
  const parts = [];
  parts.push(`${indent}<${element.name}${attrStr}>`);
  for (const child of element.children) {
    if (isXmlText(child)) {
      parts.push(escapeXml(child.value));
    } else if (isXmlElement(child)) {
      if (opts.indent) {
        parts.push(newline);
      }
      parts.push(serializeElementInternal(child, opts, depth + 1));
    }
  }
  if (opts.indent) {
    parts.push(newline);
    parts.push(indent);
  }
  parts.push(`</${element.name}>`);
  return parts.join("");
}
function serializeText(text) {
  return escapeXml(text.value);
}
function serializeAttributes(attrs) {
  const parts = [];
  for (const [key, value] of Object.entries(attrs)) {
    parts.push(`${key}="${escapeXml(value)}"`);
  }
  return parts.join(" ");
}
function buildDeclaration(opts) {
  const parts = ['<?xml version="1.0"'];
  if (opts.encoding) {
    parts.push(` encoding="${opts.encoding}"`);
  }
  if (opts.standalone !== undefined) {
    parts.push(` standalone="${opts.standalone ? "yes" : "no"}"`);
  }
  parts.push("?>");
  return parts.join("");
}
// packages/@oxen/xml/src/markup-compatibility.ts
var EMPTY_SCOPE = {
  ignorablePrefixes: new Set,
  processContentElements: new Set
};
function parseSpaceSeparatedList(value) {
  if (!value) {
    return [];
  }
  return value.split(/\s+/).filter((item) => item.length > 0);
}
function parseElementPrefix(name) {
  const idx = name.indexOf(":");
  if (idx === -1) {
    return;
  }
  return name.slice(0, idx);
}
function extendScope(element, scope) {
  const ignorable = new Set(scope.ignorablePrefixes);
  const processContent = new Set(scope.processContentElements);
  for (const prefix of parseSpaceSeparatedList(getAttr(element, "mc:Ignorable"))) {
    ignorable.add(prefix);
  }
  for (const name of parseSpaceSeparatedList(getAttr(element, "mc:ProcessContent"))) {
    processContent.add(name);
  }
  return { ignorablePrefixes: ignorable, processContentElements: processContent };
}
function assertMustUnderstand(element, supportedPrefixes) {
  const requiredPrefixes = parseSpaceSeparatedList(getAttr(element, "mc:MustUnderstand"));
  if (requiredPrefixes.length === 0) {
    return;
  }
  const unsupported = requiredPrefixes.filter((prefix) => !supportedPrefixes.has(prefix));
  if (unsupported.length === 0) {
    return;
  }
  throw new Error(`Unsupported mc:MustUnderstand prefixes: ${unsupported.join(", ")} (element: ${element.name})`);
}
function processNodes(nodes, scope, supportedPrefixes) {
  const result = [];
  for (const node of nodes) {
    if (!isXmlElement(node)) {
      result.push(node);
      continue;
    }
    const processed = processElement(node, scope, supportedPrefixes);
    result.push(...processed);
  }
  return result;
}
function processElement(element, scope, supportedPrefixes) {
  const nextScope = extendScope(element, scope);
  assertMustUnderstand(element, supportedPrefixes);
  const prefix = parseElementPrefix(element.name);
  const isIgnorable = prefix === undefined ? false : nextScope.ignorablePrefixes.has(prefix);
  const shouldProcessContent = nextScope.processContentElements.has(element.name);
  const children = processNodes(element.children, nextScope, supportedPrefixes);
  if (isIgnorable) {
    return shouldProcessContent ? children : [];
  }
  return [
    {
      ...element,
      children
    }
  ];
}
function applyMarkupCompatibility(document, options) {
  if (!options?.supportedPrefixes) {
    throw new Error("MarkupCompatibilityOptions.supportedPrefixes is required.");
  }
  const supportedPrefixes = new Set(options.supportedPrefixes);
  const children = processNodes(document.children, EMPTY_SCOPE, supportedPrefixes);
  return { children };
}
// packages/@oxen/xml/src/string-utils.ts
var CDATA_REGEX = /<!\[CDATA\[(.*?)\]\]>/g;
function stripCdata(content) {
  return content.replace(CDATA_REGEX, "$1");
}
function getBasename(path) {
  const filename = path.split("/").pop() ?? "";
  const dotIndex = filename.lastIndexOf(".");
  return dotIndex > 0 ? filename.substring(0, dotIndex) : filename;
}
function replaceDspNamespace(content) {
  return content.replace(/dsp:/g, "p:");
}

// packages/@oxen/xml/src/index.ts
function getXmlText(value) {
  if (value === undefined || value === null) {
    return;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isXmlText(value)) {
    return value.value;
  }
  if (isXmlElement(value)) {
    const text = getTextContent(value);
    if (text.length > 0) {
      return text;
    }
    return;
  }
  return;
}

// packages/@oxen-office/drawing-ml/src/domain/units.ts
var px = (value) => value;
var deg = (value) => value;
var pct = (value) => value;
var pt = (value) => value;
var emu = (value) => value;

// packages/@oxen-office/pptx/src/domain/defaults.ts
var DEFAULT_FONT_SIZE_PT = 18;
var FONT_SIZE_CENTIPOINTS_TO_PT = 100;
var EMU_PER_INCH = 914400;
var STANDARD_DPI = 96;
var EMU_PER_PIXEL = EMU_PER_INCH / STANDARD_DPI;
var POINTS_PER_INCH = 72;
var OOXML_PERCENT_FACTOR = 1e5;

// packages/@oxen-office/pptx/src/domain/unit-conversion.ts
var SLIDE_FACTOR = STANDARD_DPI / EMU_PER_INCH;
var FONT_SIZE_FACTOR = 4 / 3.2;
var PT_TO_PX = STANDARD_DPI / POINTS_PER_INCH;
function angleToDegrees(angle) {
  if (angle === undefined || angle === null) {
    return 0;
  }
  const numAngle = typeof angle === "string" ? parseInt(angle, 10) : angle;
  if (isNaN(numAngle)) {
    return 0;
  }
  return numAngle / 60000;
}

// packages/@oxen-office/pptx/src/app/presentation-info.ts
var DEFAULT_SLIDE_SIZE = { width: px(960), height: px(540) };
function parseSlideSizeFromXml(presentationXml) {
  if (presentationXml === null) {
    return DEFAULT_SLIDE_SIZE;
  }
  const sldSz = getByPath(presentationXml, ["p:presentation", "p:sldSz"]);
  if (sldSz === undefined) {
    return DEFAULT_SLIDE_SIZE;
  }
  const cx = parseInt(sldSz.attrs["cx"] ?? "0", 10);
  const cy = parseInt(sldSz.attrs["cy"] ?? "0", 10);
  return {
    width: px(cx * SLIDE_FACTOR | 0),
    height: px(cy * SLIDE_FACTOR | 0)
  };
}
function parseDefaultTextStyle(presentationXml) {
  if (presentationXml === null) {
    return null;
  }
  const node = getByPath(presentationXml, ["p:presentation", "p:defaultTextStyle"]);
  if (node === undefined) {
    return null;
  }
  return node;
}
function parseAppVersion(appXml) {
  if (appXml === null) {
    return null;
  }
  const versionStr = getTextByPath(appXml, ["Properties", "AppVersion"]);
  if (versionStr === undefined) {
    return null;
  }
  return parseInt(versionStr, 10);
}

// packages/@oxen-office/drawing-ml/src/parser/primitive.ts
var EMU_PER_INCH2 = 914400;
var STANDARD_DPI2 = 96;
var EMU_TO_PX = STANDARD_DPI2 / EMU_PER_INCH2;
var ANGLE_UNITS_PER_DEGREE = 60000;
var PERCENT_1000 = 1000;
var PERCENT_100000 = 1e5;
function parseInt32(value) {
  if (value === undefined) {
    return;
  }
  const num = parseInt(value, 10);
  return Number.isNaN(num) ? undefined : num;
}
function parseInt64(value) {
  if (value === undefined) {
    return;
  }
  const num = parseInt(value, 10);
  if (Number.isNaN(num)) {
    return;
  }
  if (!Number.isSafeInteger(num)) {
    return;
  }
  return num;
}
function parseUnsignedInt(value) {
  const num = parseInt64(value);
  if (num === undefined) {
    return;
  }
  if (num < 0 || num > 4294967295) {
    return;
  }
  return num;
}
function parseIndex(value) {
  return parseUnsignedInt(value);
}
function parseInt32Or(value, defaultValue) {
  return parseInt32(value) ?? defaultValue;
}
function parseFloat64(value) {
  if (value === undefined) {
    return;
  }
  const num = parseFloat(value);
  return Number.isNaN(num) ? undefined : num;
}
function parseBoolean(value) {
  if (value === undefined) {
    return;
  }
  const lower = value.toLowerCase();
  if (lower === "1" || lower === "true" || lower === "on" || lower === "") {
    return true;
  }
  if (lower === "0" || lower === "false" || lower === "off") {
    return false;
  }
  return;
}
function parseBooleanOr(value, defaultValue) {
  return parseBoolean(value) ?? defaultValue;
}
function parseEmu(value) {
  const num = parseInt32(value);
  if (num === undefined) {
    return;
  }
  return px(num * EMU_TO_PX);
}
function parseLineWidth(value) {
  const num = parseInt32(value);
  if (num === undefined) {
    return;
  }
  if (num < 0 || num > 20116800) {
    return;
  }
  return px(num * EMU_TO_PX);
}
function parseAngle(value) {
  const num = parseInt32(value);
  if (num === undefined) {
    return;
  }
  return deg(num / ANGLE_UNITS_PER_DEGREE);
}
function parsePercentage(value) {
  const num = parseInt32(value);
  if (num === undefined) {
    return;
  }
  return pct(num / PERCENT_1000);
}
function parsePercentage100k(value) {
  const num = parseInt32(value);
  if (num === undefined) {
    return;
  }
  return pct(num / PERCENT_100000 * 100);
}
function parsePositivePercentage(value) {
  const p = parsePercentage(value);
  if (p === undefined || p < 0) {
    return;
  }
  return p;
}
function parseFixedPercentage(value) {
  const p = parsePercentage100k(value);
  if (p === undefined || p < 0 || p > 100) {
    return;
  }
  return p;
}
function parseSchemeColorValue(value) {
  switch (value) {
    case "dk1":
    case "lt1":
    case "dk2":
    case "lt2":
    case "accent1":
    case "accent2":
    case "accent3":
    case "accent4":
    case "accent5":
    case "accent6":
    case "hlink":
    case "folHlink":
    case "bg1":
    case "bg2":
    case "tx1":
    case "tx2":
    case "phClr":
      return value;
    default:
      return;
  }
}
function getEmuAttr(element, name) {
  return parseEmu(getAttr(element, name));
}
function getAngleAttr(element, name) {
  return parseAngle(getAttr(element, name));
}
function getBoolAttr(element, name) {
  if (!element) {
    return;
  }
  return parseBoolean(getAttr(element, name));
}
function getBoolAttrOr(element, name, defaultValue) {
  return parseBooleanOr(getAttr(element, name), defaultValue);
}
function getIntAttr(element, name) {
  if (!element) {
    return;
  }
  return parseInt32(getAttr(element, name));
}
function getFloatAttr(element, name) {
  if (!element) {
    return;
  }
  return parseFloat64(getAttr(element, name));
}
function getPercent100kAttr(element, name) {
  return parsePercentage100k(getAttr(element, name));
}

// packages/@oxen-office/drawing-ml/src/parser/color.ts
var COLOR_ELEMENT_NAMES = [
  "a:srgbClr",
  "a:schemeClr",
  "a:sysClr",
  "a:prstClr",
  "a:hslClr",
  "a:scrgbClr"
];
function findColorElement(parent) {
  return findChild(parent, (child) => COLOR_ELEMENT_NAMES.includes(child.name));
}
function parseSrgbColor(element) {
  const val = getAttr(element, "val");
  if (!val) {
    return;
  }
  return { type: "srgb", value: val.toUpperCase() };
}
function parseSchemeColor(element) {
  const val = parseSchemeColorValue(getAttr(element, "val"));
  if (!val) {
    return;
  }
  return { type: "scheme", value: val };
}
function parseSystemColor(element) {
  const val = getAttr(element, "val");
  if (!val) {
    return;
  }
  const lastClr = getAttr(element, "lastClr");
  return {
    type: "system",
    value: val,
    lastColor: lastClr
  };
}
function parsePresetColor(element) {
  const val = getAttr(element, "val");
  if (!val) {
    return;
  }
  return { type: "preset", value: val };
}
function parseHslColor(element) {
  const hue = getAngleAttr(element, "hue");
  const sat = getPercent100kAttr(element, "sat");
  const lum = getPercent100kAttr(element, "lum");
  if (hue === undefined || sat === undefined || lum === undefined) {
    return;
  }
  return { type: "hsl", hue, saturation: sat, luminance: lum };
}
function parseScrgbColor(element) {
  const r = getPercent100kAttr(element, "r");
  const g = getPercent100kAttr(element, "g");
  const b = getPercent100kAttr(element, "b");
  if (r === undefined || g === undefined || b === undefined) {
    return;
  }
  return { type: "scrgb", red: r, green: g, blue: b };
}
function parseColorSpec(element) {
  switch (element.name) {
    case "a:srgbClr":
      return parseSrgbColor(element);
    case "a:schemeClr":
      return parseSchemeColor(element);
    case "a:sysClr":
      return parseSystemColor(element);
    case "a:prstClr":
      return parsePresetColor(element);
    case "a:hslClr":
      return parseHslColor(element);
    case "a:scrgbClr":
      return parseScrgbColor(element);
    default:
      return;
  }
}
function parseColorTransforms(element) {
  const state = {
    transform: {},
    hasTransform: false
  };
  for (const child of element.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    switch (child.name) {
      case "a:alpha":
        state.transform.alpha = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:alphaMod":
        state.transform.alphaMod = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:alphaOff":
        state.transform.alphaOff = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:hue":
        state.transform.hue = getAngleAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:hueMod":
        state.transform.hueMod = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:hueOff":
        state.transform.hueOff = getAngleAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:sat":
        state.transform.sat = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:satMod":
        state.transform.satMod = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:satOff":
        state.transform.satOff = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:lum":
        state.transform.lum = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:lumMod":
        state.transform.lumMod = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:lumOff":
        state.transform.lumOff = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:red":
        state.transform.red = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:redMod":
        state.transform.redMod = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:redOff":
        state.transform.redOff = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:green":
        state.transform.green = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:greenMod":
        state.transform.greenMod = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:greenOff":
        state.transform.greenOff = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:blue":
        state.transform.blue = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:blueMod":
        state.transform.blueMod = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:blueOff":
        state.transform.blueOff = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:gamma":
        state.transform.gamma = true;
        state.hasTransform = true;
        break;
      case "a:inv":
        state.transform.inv = true;
        state.hasTransform = true;
        break;
      case "a:invGamma":
        state.transform.invGamma = true;
        state.hasTransform = true;
        break;
      case "a:shade":
        state.transform.shade = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:tint":
        state.transform.tint = getPercent100kAttr(child, "val");
        state.hasTransform = true;
        break;
      case "a:comp":
        state.transform.comp = true;
        state.hasTransform = true;
        break;
      case "a:gray":
        state.transform.gray = true;
        state.hasTransform = true;
        break;
    }
  }
  return state.hasTransform ? state.transform : undefined;
}
function parseColor(element) {
  if (!element) {
    return;
  }
  const spec = parseColorSpec(element);
  if (!spec) {
    return;
  }
  const transform = parseColorTransforms(element);
  return { spec, transform };
}
function parseColorFromParent(parent) {
  if (!parent) {
    return;
  }
  const colorEl = findColorElement(parent);
  return parseColor(colorEl);
}

// packages/@oxen-office/drawing-ml/src/parser/fill.ts
var FILL_ELEMENT_NAMES = [
  "a:noFill",
  "a:solidFill",
  "a:gradFill",
  "a:blipFill",
  "a:pattFill",
  "a:grpFill"
];
function findFillElement(parent) {
  return findChild(parent, (child) => FILL_ELEMENT_NAMES.includes(child.name));
}
function parseNoFill() {
  return { type: "noFill" };
}
function parseSolidFill(element) {
  const color = parseColorFromParent(element);
  if (!color) {
    return;
  }
  return { type: "solidFill", color };
}
function parseGradientStop(element) {
  const pos = getPercent100kAttr(element, "pos");
  if (pos === undefined) {
    return;
  }
  const color = parseColorFromParent(element);
  if (!color) {
    return;
  }
  return { position: pos, color };
}
function parseLinearGradient(element) {
  const lin = getChild(element, "a:lin");
  if (!lin) {
    return;
  }
  return {
    angle: getAngleAttr(lin, "ang") ?? deg(0),
    scaled: getBoolAttrOr(lin, "scaled", true)
  };
}
function parseFillToRect(fillToRect) {
  return {
    left: getPercent100kAttr(fillToRect, "l") ?? pct(0),
    top: getPercent100kAttr(fillToRect, "t") ?? pct(0),
    right: getPercent100kAttr(fillToRect, "r") ?? pct(0),
    bottom: getPercent100kAttr(fillToRect, "b") ?? pct(0)
  };
}
function parsePathGradient(element) {
  const path = getChild(element, "a:path");
  if (!path) {
    return;
  }
  const pathType = getAttr(path, "path");
  if (!pathType) {
    return;
  }
  const fillToRect = getChild(path, "a:fillToRect");
  const fillRect = fillToRect ? parseFillToRect(fillToRect) : undefined;
  return { path: pathType, fillToRect: fillRect };
}
function parseTileRect(element) {
  const tileRect = getChild(element, "a:tileRect");
  if (!tileRect) {
    return;
  }
  return {
    left: getPercent100kAttr(tileRect, "l") ?? pct(0),
    top: getPercent100kAttr(tileRect, "t") ?? pct(0),
    right: getPercent100kAttr(tileRect, "r") ?? pct(0),
    bottom: getPercent100kAttr(tileRect, "b") ?? pct(0)
  };
}
function parseGradientFill(element) {
  const gsLst = getChild(element, "a:gsLst");
  if (!gsLst) {
    return;
  }
  const stops = [];
  for (const gs of getChildren(gsLst, "a:gs")) {
    const stop = parseGradientStop(gs);
    if (stop) {
      stops.push(stop);
    }
  }
  if (stops.length === 0) {
    return;
  }
  stops.sort((a, b) => a.position - b.position);
  return {
    type: "gradientFill",
    stops,
    linear: parseLinearGradient(element),
    path: parsePathGradient(element),
    tileRect: parseTileRect(element),
    rotWithShape: getBoolAttrOr(element, "rotWithShape", true)
  };
}
function parsePatternFill(element) {
  const preset = getAttr(element, "prst");
  if (!preset) {
    return;
  }
  const fgClr = getChild(element, "a:fgClr");
  const bgClr = getChild(element, "a:bgClr");
  const foregroundColor = parseColorFromParent(fgClr);
  const backgroundColor = parseColorFromParent(bgClr);
  if (!foregroundColor || !backgroundColor) {
    return;
  }
  return {
    type: "patternFill",
    preset,
    foregroundColor,
    backgroundColor
  };
}
function parseGroupFill() {
  return { type: "groupFill" };
}
function parseBaseFill(element) {
  if (!element) {
    return;
  }
  switch (element.name) {
    case "a:noFill":
      return parseNoFill();
    case "a:solidFill":
      return parseSolidFill(element);
    case "a:gradFill":
      return parseGradientFill(element);
    case "a:pattFill":
      return parsePatternFill(element);
    case "a:grpFill":
      return parseGroupFill();
    case "a:blipFill":
      return;
    default:
      return;
  }
}
function parseBaseFillFromParent(parent) {
  if (!parent) {
    return;
  }
  const fillEl = findFillElement(parent);
  return parseBaseFill(fillEl);
}

// packages/@oxen-office/drawing-ml/src/parser/line.ts
function parseLineEnd(element) {
  if (!element) {
    return;
  }
  const type = mapLineEndType(getAttr(element, "type"));
  if (!type || type === "none") {
    return;
  }
  return {
    type,
    width: mapLineEndWidth(getAttr(element, "w")),
    length: mapLineEndLength(getAttr(element, "len"))
  };
}
function parseCustomDash(element) {
  const custDash = getChild(element, "a:custDash");
  if (!custDash) {
    return;
  }
  const dashes = [];
  for (const ds of getChildren(custDash, "a:ds")) {
    const dashLength = getPercent100kAttr(ds, "d");
    const spaceLength = getPercent100kAttr(ds, "sp");
    if (dashLength !== undefined && spaceLength !== undefined) {
      dashes.push({ dashLength, spaceLength });
    }
  }
  if (dashes.length === 0) {
    return;
  }
  return { dashes };
}
function getDashStyle(element) {
  const prstDash = getChild(element, "a:prstDash");
  if (prstDash) {
    return getAttr(prstDash, "val") ?? "solid";
  }
  const customDash = parseCustomDash(element);
  if (customDash) {
    return customDash;
  }
  return "solid";
}
function mapLineEndType(type) {
  switch (type) {
    case "none":
      return "none";
    case "triangle":
      return "triangle";
    case "stealth":
      return "stealth";
    case "diamond":
      return "diamond";
    case "oval":
      return "oval";
    case "arrow":
      return "arrow";
    default:
      return;
  }
}
function mapLineEndWidth(w) {
  switch (w) {
    case "sm":
      return "sm";
    case "med":
      return "med";
    case "lg":
      return "lg";
    default:
      return "med";
  }
}
function mapLineEndLength(len) {
  switch (len) {
    case "sm":
      return "sm";
    case "med":
      return "med";
    case "lg":
      return "lg";
    default:
      return "med";
  }
}
function mapLineCap(cap) {
  switch (cap) {
    case "flat":
      return "flat";
    case "rnd":
      return "round";
    case "sq":
      return "square";
    default:
      return "flat";
  }
}
function mapCompound(cmpd) {
  switch (cmpd) {
    case "sng":
      return "sng";
    case "dbl":
      return "dbl";
    case "thickThin":
      return "thickThin";
    case "thinThick":
      return "thinThick";
    case "tri":
      return "tri";
    default:
      return "sng";
  }
}
function mapPenAlignment(algn) {
  switch (algn) {
    case "ctr":
      return "ctr";
    case "in":
      return "in";
    default:
      return "ctr";
  }
}
function resolveLineJoin(element) {
  if (getChild(element, "a:bevel")) {
    return "bevel";
  }
  if (getChild(element, "a:miter")) {
    return "miter";
  }
  return "round";
}
function parseLine(element) {
  if (!element) {
    return;
  }
  const fill = parseBaseFillFromParent(element);
  const width = parseLineWidth(getAttr(element, "w"));
  if (!fill && width === undefined) {
    return;
  }
  const join = resolveLineJoin(element);
  const miterEl = getChild(element, "a:miter");
  const miterLimit = miterEl ? getPercent100kAttr(miterEl, "lim") : undefined;
  return {
    width: width ?? px(1),
    cap: mapLineCap(getAttr(element, "cap")),
    compound: mapCompound(getAttr(element, "cmpd")),
    alignment: mapPenAlignment(getAttr(element, "algn")),
    fill: fill ?? { type: "noFill" },
    dash: getDashStyle(element),
    headEnd: parseLineEnd(getChild(element, "a:headEnd")),
    tailEnd: parseLineEnd(getChild(element, "a:tailEnd")),
    join,
    miterLimit
  };
}
function getLineFromProperties(spPr) {
  if (!spPr) {
    return;
  }
  return parseLine(getChild(spPr, "a:ln"));
}

// packages/@oxen-office/drawing-ml/src/parser/effects.ts
function getEffectColor(element, overrideColor) {
  const color = parseColorFromParent(element);
  if (!color) {
    return overrideColor;
  }
  if (color.spec.type === "scheme" && color.spec.value === "phClr" && overrideColor) {
    return overrideColor;
  }
  return color;
}
function parseOuterShadowEffect(element, overrideColor) {
  const color = getEffectColor(element, overrideColor);
  if (!color) {
    return;
  }
  return {
    type: "outer",
    color,
    blurRadius: getEmuAttr(element, "blurRad") ?? px(0),
    distance: getEmuAttr(element, "dist") ?? px(0),
    direction: getAngleAttr(element, "dir") ?? deg(0),
    scaleX: getPercent100kAttr(element, "sx"),
    scaleY: getPercent100kAttr(element, "sy"),
    skewX: getAngleAttr(element, "kx"),
    skewY: getAngleAttr(element, "ky"),
    alignment: getAttr(element, "algn"),
    rotateWithShape: getBoolAttrOr(element, "rotWithShape", true)
  };
}
function parseInnerShadowEffect(element, overrideColor) {
  const color = getEffectColor(element, overrideColor);
  if (!color) {
    return;
  }
  return {
    type: "inner",
    color,
    blurRadius: getEmuAttr(element, "blurRad") ?? px(0),
    distance: getEmuAttr(element, "dist") ?? px(0),
    direction: getAngleAttr(element, "dir") ?? deg(0)
  };
}
function parseGlowEffect(element, overrideColor) {
  const color = getEffectColor(element, overrideColor);
  if (!color) {
    return;
  }
  return {
    color,
    radius: getEmuAttr(element, "rad") ?? px(0)
  };
}
function parseReflectionEffect(element) {
  return {
    blurRadius: getEmuAttr(element, "blurRad") ?? px(0),
    startOpacity: getPercent100kAttr(element, "stA") ?? pct(100),
    startPosition: getPercent100kAttr(element, "stPos") ?? pct(0),
    endOpacity: getPercent100kAttr(element, "endA") ?? pct(0),
    endPosition: getPercent100kAttr(element, "endPos") ?? pct(100),
    distance: getEmuAttr(element, "dist") ?? px(0),
    direction: getAngleAttr(element, "dir") ?? deg(0),
    fadeDirection: getAngleAttr(element, "fadeDir") ?? deg(90),
    scaleX: getPercent100kAttr(element, "sx") ?? pct(100),
    scaleY: getPercent100kAttr(element, "sy") ?? pct(100),
    skewX: getAngleAttr(element, "kx"),
    skewY: getAngleAttr(element, "ky"),
    alignment: getAttr(element, "algn"),
    rotateWithShape: getBoolAttrOr(element, "rotWithShape", true)
  };
}
function parseSoftEdgeEffect(element) {
  const radius = getEmuAttr(element, "rad");
  if (radius === undefined) {
    return;
  }
  return { radius };
}

// packages/@oxen-office/pptx/src/parser/graphics/color-parser.ts
function parseColor2(...args) {
  return parseColor(...args);
}
function parseColorFromParent2(...args) {
  return parseColorFromParent(...args);
}

// packages/@oxen-office/pptx/src/parser/primitive.ts
var EMU_PER_INCH3 = 914400;
var STANDARD_DPI3 = 96;
var POINTS_PER_INCH2 = 72;
var EMU_TO_PX2 = STANDARD_DPI3 / EMU_PER_INCH3;
var PT_TO_PX2 = STANDARD_DPI3 / POINTS_PER_INCH2;
var PERCENT_10002 = 1000;
function parseInt322(value) {
  return parseInt32(value);
}
function parseUnsignedInt2(value) {
  return parseUnsignedInt(value);
}
function parseIndex2(value) {
  return parseIndex(value);
}
function parseInt32Or2(value, defaultValue) {
  return parseInt32Or(value, defaultValue);
}
function parseBoolean2(value) {
  if (value === undefined) {
    return;
  }
  const lower = value.toLowerCase();
  if (lower === "1" || lower === "true" || lower === "on") {
    return true;
  }
  if (lower === "0" || lower === "false" || lower === "off") {
    return false;
  }
  return;
}
function parseBooleanOr2(value, defaultValue) {
  const bool = parseBoolean2(value);
  return bool ?? defaultValue;
}
function parseEmu2(value) {
  return parseEmu(value);
}
function parseEmuOr(value, defaultValue) {
  return parseEmu2(value) ?? defaultValue;
}
function parseAngle2(value) {
  return parseAngle(value);
}
function parsePercentage2(value) {
  return parsePercentage(value);
}
function parsePercentage100k2(value) {
  return parsePercentage100k(value);
}
function parsePositivePercentage2(value) {
  return parsePositivePercentage(value);
}
function parseFixedPercentage2(value) {
  return parseFixedPercentage(value);
}
function parsePositiveFixedPercentage(value) {
  if (!value) {
    return;
  }
  if (!value.endsWith("%")) {
    return;
  }
  const numeric = value.slice(0, -1);
  if (!numeric) {
    return;
  }
  const num = parseFloat(numeric);
  if (Number.isNaN(num)) {
    return;
  }
  if (num < 0 || num > 100) {
    return;
  }
  return pct(num);
}
function parseBlackWhiteMode(value) {
  switch (value) {
    case "auto":
    case "black":
    case "blackGray":
    case "blackWhite":
    case "clr":
    case "gray":
    case "grayWhite":
    case "hidden":
    case "invGray":
    case "ltGray":
    case "white":
      return value;
    default:
      return;
  }
}
function parseBlipCompression(value) {
  switch (value) {
    case "email":
    case "hqprint":
    case "none":
    case "print":
    case "screen":
      return value;
    default:
      return;
  }
}
function parseFontCollectionIndex(value) {
  switch (value) {
    case "major":
    case "minor":
    case "none":
      return value;
    default:
      return;
  }
}
function parseRectAlignment(value) {
  switch (value) {
    case "b":
    case "bl":
    case "br":
    case "ctr":
    case "l":
    case "r":
    case "t":
    case "tl":
    case "tr":
      return value;
    default:
      return;
  }
}
function parseShapeId(value) {
  if (value === undefined) {
    return;
  }
  const normalized = value.trim().replace(/\s+/g, " ");
  if (!normalized) {
    return;
  }
  return normalized;
}
function parseStyleMatrixColumnIndex(value) {
  return parseUnsignedInt2(value);
}
function parseTextBulletSizePercent(value) {
  if (value === undefined) {
    return;
  }
  if (value.endsWith("%")) {
    const numeric = value.slice(0, -1);
    if (!numeric) {
      return;
    }
    const num2 = parseFloat(numeric);
    if (Number.isNaN(num2)) {
      return;
    }
    if (num2 < 25 || num2 > 400) {
      return;
    }
    return pct(num2);
  }
  const num = parseInt322(value);
  if (num === undefined) {
    return;
  }
  const percentValue = num / PERCENT_10002;
  if (percentValue < 25 || percentValue > 400) {
    return;
  }
  return pct(percentValue);
}
function parseTextBulletSize(value) {
  return parseTextBulletSizePercent(value);
}
function parseTextBulletStartAt(value) {
  const num = parseInt322(value);
  if (num === undefined) {
    return;
  }
  if (num < 1 || num > 32767) {
    return;
  }
  return num;
}
function parseTextColumnCount(value) {
  const num = parseInt322(value);
  if (num === undefined) {
    return;
  }
  if (num < 1 || num > 16) {
    return;
  }
  return num;
}
function parseTextFontScalePercent(value) {
  return value?.endsWith("%") ? parsePositiveFixedPercentage(value) : parsePercentage2(value);
}
function parseTextIndent(value) {
  const num = parseInt322(value);
  if (num === undefined) {
    return;
  }
  if (num < -51206400 || num > 51206400) {
    return;
  }
  return px(num * EMU_TO_PX2);
}
function parseTextIndentLevel(value) {
  const num = parseInt322(value);
  if (num === undefined) {
    return;
  }
  if (num < 0 || num > 8) {
    return;
  }
  return num;
}
function parseTextMargin(value) {
  const num = parseInt322(value);
  if (num === undefined) {
    return;
  }
  if (num < 0 || num > 51206400) {
    return;
  }
  return px(num * EMU_TO_PX2);
}
function parseTextNonNegativePoint(value) {
  const num = parseInt322(value);
  if (num === undefined) {
    return;
  }
  if (num < 0 || num > 400000) {
    return;
  }
  return pt(num / 100);
}
function parseUniversalMeasureToPixels(value) {
  if (value === undefined) {
    return;
  }
  const match = /^(-?\d+(?:\.\d+)?)(mm|cm|in|pt|pc|pi)$/.exec(value);
  if (!match) {
    return;
  }
  const raw = parseFloat(match[1]);
  if (Number.isNaN(raw)) {
    return;
  }
  const unit = match[2];
  switch (unit) {
    case "in":
      return px(raw * STANDARD_DPI3);
    case "cm":
      return px(raw / 2.54 * STANDARD_DPI3);
    case "mm":
      return px(raw / 25.4 * STANDARD_DPI3);
    case "pt":
      return px(raw * PT_TO_PX2);
    case "pc":
    case "pi":
      return px(raw * 12 * PT_TO_PX2);
    default:
      return;
  }
}
function parseTextPointUnqualified(value) {
  const num = parseInt322(value);
  if (num === undefined) {
    return;
  }
  if (num < -400000 || num > 400000) {
    return;
  }
  return px(num / 100 * PT_TO_PX2);
}
function parseTextPoint(value) {
  if (value === undefined) {
    return;
  }
  if (/^-?\d+$/.test(value)) {
    return parseTextPointUnqualified(value);
  }
  return parseUniversalMeasureToPixels(value);
}
function parseTextShapeType(value) {
  switch (value) {
    case "textNoShape":
    case "textPlain":
    case "textStop":
    case "textTriangle":
    case "textTriangleInverted":
    case "textChevron":
    case "textChevronInverted":
    case "textRingInside":
    case "textRingOutside":
    case "textArchUp":
    case "textArchDown":
    case "textCircle":
    case "textButton":
    case "textArchUpPour":
    case "textArchDownPour":
    case "textCirclePour":
    case "textButtonPour":
    case "textCurveUp":
    case "textCurveDown":
    case "textCanUp":
    case "textCanDown":
    case "textWave1":
    case "textWave2":
    case "textDoubleWave1":
    case "textWave4":
    case "textInflate":
    case "textDeflate":
    case "textInflateBottom":
    case "textDeflateBottom":
    case "textInflateTop":
    case "textDeflateTop":
    case "textDeflateInflate":
    case "textDeflateInflateDeflate":
    case "textFadeRight":
    case "textFadeLeft":
    case "textFadeUp":
    case "textFadeDown":
    case "textSlantUp":
    case "textSlantDown":
    case "textCascadeUp":
    case "textCascadeDown":
      return value;
    default:
      return;
  }
}
function parseTextSpacingPoint(value) {
  const num = parseInt322(value);
  if (num === undefined) {
    return;
  }
  if (num < 0 || num > 158400) {
    return;
  }
  return pt(num / 100);
}
function parseFontSize(value) {
  const num = parseInt322(value);
  if (num === undefined) {
    return;
  }
  return pt(num / 100);
}
function parseCharacterSpacing(value) {
  return parseTextPoint(value);
}
function getEmuAttr2(element, name) {
  return parseEmu2(getAttr(element, name));
}
function getEmuAttrOr(element, name, defaultValue) {
  return parseEmuOr(getAttr(element, name), defaultValue);
}
function getAngleAttr2(element, name) {
  return parseAngle2(getAttr(element, name));
}
function getBoolAttr2(element, name) {
  if (!element) {
    return;
  }
  return parseBoolean2(getAttr(element, name));
}
function getBoolAttrOr2(element, name, defaultValue) {
  return parseBooleanOr2(getAttr(element, name), defaultValue);
}
function getIntAttr2(element, name) {
  if (!element) {
    return;
  }
  return parseInt322(getAttr(element, name));
}
function getIndexAttr(element, name) {
  if (!element) {
    return;
  }
  return parseIndex2(getAttr(element, name));
}
function getIntAttrOr(element, name, defaultValue) {
  return parseInt32Or2(getAttr(element, name), defaultValue);
}
function getFontSizeAttr(element, name) {
  return parseFontSize(getAttr(element, name));
}
function getCharacterSpacingAttr(element, name) {
  return parseCharacterSpacing(getAttr(element, name));
}
function getPercentAttr(element, name) {
  return parsePercentage2(getAttr(element, name));
}
function getPercent100kAttr2(element, name) {
  return parsePercentage100k2(getAttr(element, name));
}

// packages/@oxen-office/pptx/src/parser/graphics/fill-parser.ts
function findFillElement2(parent) {
  return findFillElement(parent);
}
function parseStretchFill(element) {
  const stretch = getChild(element, "a:stretch");
  if (!stretch) {
    return;
  }
  const fillRect = getChild(stretch, "a:fillRect");
  if (!fillRect) {
    return {};
  }
  return {
    fillRect: {
      left: getPercent100kAttr(fillRect, "l") ?? pct(0),
      top: getPercent100kAttr(fillRect, "t") ?? pct(0),
      right: getPercent100kAttr(fillRect, "r") ?? pct(0),
      bottom: getPercent100kAttr(fillRect, "b") ?? pct(0)
    }
  };
}
function parseTileFillMode(element) {
  const tile = getChild(element, "a:tile");
  if (!tile) {
    return;
  }
  const flip = getAttr(tile, "flip");
  return {
    tx: getEmuAttr(tile, "tx") ?? px(0),
    ty: getEmuAttr(tile, "ty") ?? px(0),
    sx: getPercent100kAttr(tile, "sx") ?? pct(100),
    sy: getPercent100kAttr(tile, "sy") ?? pct(100),
    flip: flip ?? "none",
    alignment: parseRectAlignment(getAttr(tile, "algn")) ?? "tl"
  };
}
function parseSourceRect(element) {
  const srcRect = getChild(element, "a:srcRect");
  if (!srcRect) {
    return;
  }
  return {
    left: getPercent100kAttr(srcRect, "l") ?? pct(0),
    top: getPercent100kAttr(srcRect, "t") ?? pct(0),
    right: getPercent100kAttr(srcRect, "r") ?? pct(0),
    bottom: getPercent100kAttr(srcRect, "b") ?? pct(0)
  };
}
function parseBlipEffects(blip) {
  const effects = {};
  let hasEffect = false;
  for (const child of blip.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    switch (child.name) {
      case "a:alphaBiLevel": {
        const threshold = parseFixedPercentage(getAttr(child, "thresh"));
        if (threshold !== undefined) {
          effects.alphaBiLevel = { threshold };
          hasEffect = true;
        }
        break;
      }
      case "a:alphaCeiling":
        effects.alphaCeiling = true;
        hasEffect = true;
        break;
      case "a:alphaFloor":
        effects.alphaFloor = true;
        hasEffect = true;
        break;
      case "a:alphaInv":
        effects.alphaInv = true;
        hasEffect = true;
        break;
      case "a:alphaMod":
        effects.alphaMod = true;
        hasEffect = true;
        break;
      case "a:alphaModFix": {
        const amount = parsePositivePercentage(getAttr(child, "amt")) ?? pct(100);
        effects.alphaModFix = { amount };
        hasEffect = true;
        break;
      }
      case "a:alphaRepl": {
        const alpha = parseFixedPercentage(getAttr(child, "a"));
        if (alpha !== undefined) {
          effects.alphaRepl = { alpha };
          hasEffect = true;
        }
        break;
      }
      case "a:biLevel": {
        const threshold = parseFixedPercentage(getAttr(child, "thresh"));
        if (threshold !== undefined) {
          effects.biLevel = { threshold };
          hasEffect = true;
        }
        break;
      }
      case "a:blur": {
        const radius = getEmuAttr(child, "rad") ?? px(0);
        const grow = getBoolAttrOr(child, "grow", true);
        effects.blur = { radius, grow };
        hasEffect = true;
        break;
      }
      case "a:clrChange": {
        const clrFrom = getChild(child, "a:clrFrom");
        const clrTo = getChild(child, "a:clrTo");
        if (clrFrom && clrTo) {
          const from = parseColorFromParent2(clrFrom);
          const to = parseColorFromParent2(clrTo);
          if (from && to) {
            effects.colorChange = {
              from,
              to,
              useAlpha: getBoolAttrOr(child, "useA", true)
            };
            hasEffect = true;
          }
        }
        break;
      }
      case "a:clrRepl": {
        const color = parseColorFromParent2(child);
        if (color) {
          effects.colorReplace = { color };
          hasEffect = true;
        }
        break;
      }
      case "a:duotone": {
        const colors = [];
        for (const colorChild of child.children) {
          if (isXmlElement(colorChild)) {
            const parsed = parseColor2(colorChild);
            if (parsed) {
              colors.push(parsed);
            }
          }
        }
        if (colors.length === 2) {
          effects.duotone = { colors: [colors[0], colors[1]] };
          hasEffect = true;
        }
        break;
      }
      case "a:grayscl":
        effects.grayscale = true;
        hasEffect = true;
        break;
      case "a:hsl": {
        const hue = getAngleAttr(child, "hue") ?? deg(0);
        const sat = getPercent100kAttr(child, "sat") ?? pct(0);
        const lum = getPercent100kAttr(child, "lum") ?? pct(0);
        effects.hsl = { hue, saturation: sat, luminance: lum };
        hasEffect = true;
        break;
      }
      case "a:lum": {
        const bright = getPercent100kAttr(child, "bright") ?? pct(0);
        const contrast = getPercent100kAttr(child, "contrast") ?? pct(0);
        effects.luminance = { brightness: bright, contrast };
        hasEffect = true;
        break;
      }
      case "a:tint": {
        const hue = getAngleAttr(child, "hue") ?? deg(0);
        const amt = parseFixedPercentage(getAttr(child, "amt")) ?? pct(0);
        effects.tint = { hue, amount: amt };
        hasEffect = true;
        break;
      }
    }
  }
  return hasEffect ? effects : undefined;
}
function parseBlipFill(element) {
  const blip = getChild(element, "a:blip");
  if (!blip) {
    return;
  }
  const embedId = getAttr(blip, "r:embed");
  const linkId = getAttr(blip, "r:link");
  const resourceId = embedId ?? linkId;
  if (!resourceId) {
    return;
  }
  const dpiAttr = getAttr(element, "dpi");
  const dpi = dpiAttr ? parseInt(dpiAttr, 10) : undefined;
  const blipEffects = parseBlipEffects(blip);
  return {
    type: "blipFill",
    resourceId,
    relationshipType: embedId ? "embed" : "link",
    compressionState: parseBlipCompression(getAttr(blip, "cstate")),
    dpi: dpi !== undefined && !Number.isNaN(dpi) ? dpi : undefined,
    blipEffects,
    stretch: parseStretchFill(element),
    tile: parseTileFillMode(element),
    sourceRect: parseSourceRect(element),
    rotWithShape: getBoolAttrOr(element, "rotWithShape", true)
  };
}
function parseFill(element) {
  if (!element) {
    return;
  }
  if (element.name === "a:blipFill") {
    return parseBlipFill(element);
  }
  return parseBaseFill(element) ?? undefined;
}
function parseFillFromParent(parent) {
  if (!parent) {
    return;
  }
  const fillEl = findFillElement2(parent);
  return parseFill(fillEl);
}
function resolveFillFromStyleReference(fillRef, fillStyles) {
  if (!fillRef || fillRef.index === 0) {
    return;
  }
  const styleIndex = resolveFillStyleIndex(fillRef.index);
  if (styleIndex < 0 || styleIndex >= fillStyles.length) {
    return;
  }
  const styleElement = fillStyles[styleIndex];
  const parsedFill = parseFill(styleElement);
  if (!parsedFill) {
    return;
  }
  if (fillRef.color) {
    return applyColorOverride(parsedFill, fillRef.color);
  }
  return parsedFill;
}
function resolveFillStyleIndex(index) {
  if (index >= 1001) {
    return index - 1001;
  }
  return index - 1;
}
function applyColorOverride(fill, overrideColor) {
  if (fill.type === "solidFill" && overrideColor.type === "solidFill") {
    return {
      type: "solidFill",
      color: overrideColor.color
    };
  }
  if (fill.type === "gradientFill" && overrideColor.type === "solidFill") {
    return {
      ...fill,
      stops: fill.stops.map((stop) => {
        if (stop.color.spec.type === "scheme" && stop.color.spec.value === "phClr") {
          return {
            ...stop,
            color: overrideColor.color
          };
        }
        return stop;
      })
    };
  }
  return fill;
}

// packages/@oxen-office/pptx/src/parser/graphics/line-parser.ts
function convertBaseLineToPptxLine(line) {
  return {
    width: line.width,
    cap: line.cap,
    compound: line.compound,
    alignment: line.alignment,
    fill: line.fill,
    dash: line.dash,
    headEnd: line.headEnd,
    tailEnd: line.tailEnd,
    join: line.join,
    miterLimit: line.miterLimit
  };
}
function parseLine2(element) {
  const parsed = parseLine(element);
  if (!parsed) {
    return;
  }
  return convertBaseLineToPptxLine(parsed);
}
function getLineFromProperties2(spPr) {
  const parsed = getLineFromProperties(spPr);
  if (!parsed) {
    return;
  }
  return convertBaseLineToPptxLine(parsed);
}

// packages/@oxen-office/pptx/src/parser/shape-parser/style.ts
function parseStyleReference(element) {
  if (!element) {
    return;
  }
  const idx = parseStyleMatrixColumnIndex(getAttr(element, "idx"));
  if (idx === undefined) {
    return;
  }
  const parsedColor = parseColorFromParent2(element);
  const color = parsedColor ? { type: "solidFill", color: parsedColor } : undefined;
  return { index: idx, color };
}
function parseFontReference(element) {
  if (!element) {
    return;
  }
  const idx = parseFontCollectionIndex(getAttr(element, "idx"));
  if (!idx || idx === "none") {
    return;
  }
  const parsedColor = parseColorFromParent2(element);
  const color = parsedColor ? { type: "solidFill", color: parsedColor } : undefined;
  return { index: idx, color };
}
function parseShapeStyle(style) {
  if (!style) {
    return;
  }
  return {
    lineReference: parseStyleReference(getChild(style, "a:lnRef")),
    fillReference: parseStyleReference(getChild(style, "a:fillRef")),
    effectReference: parseStyleReference(getChild(style, "a:effectRef")),
    fontReference: parseFontReference(getChild(style, "a:fontRef"))
  };
}

// packages/@oxen-office/pptx/src/parser/cell3d-parser.ts
function isBevelPresetType(value) {
  switch (value) {
    case "angle":
    case "artDeco":
    case "circle":
    case "convex":
    case "coolSlant":
    case "cross":
    case "divot":
    case "hardEdge":
    case "relaxedInset":
    case "riblet":
    case "slope":
    case "softRound":
      return true;
    default:
      return false;
  }
}
function parseBevel(element) {
  if (!element) {
    return;
  }
  const width = getEmuAttr2(element, "w");
  const height = getEmuAttr2(element, "h");
  const preset = getAttr(element, "prst");
  if (width === undefined || height === undefined) {
    return;
  }
  if (!isBevelPresetType(preset)) {
    return;
  }
  return { width, height, preset };
}
function isPresetMaterialType(value) {
  switch (value) {
    case "clear":
    case "dkEdge":
    case "flat":
    case "legacyMatte":
    case "legacyMetal":
    case "legacyPlastic":
    case "legacyWireframe":
    case "matte":
    case "metal":
    case "plastic":
    case "powder":
    case "softEdge":
    case "softmetal":
    case "translucentPowder":
    case "warmMatte":
      return true;
    default:
      return false;
  }
}
function parsePresetMaterialType(value) {
  return isPresetMaterialType(value) ? value : undefined;
}
function isLightRigType(value) {
  switch (value) {
    case "legacyFlat1":
    case "legacyFlat2":
    case "legacyFlat3":
    case "legacyFlat4":
    case "legacyNormal1":
    case "legacyNormal2":
    case "legacyNormal3":
    case "legacyNormal4":
    case "legacyHarsh1":
    case "legacyHarsh2":
    case "legacyHarsh3":
    case "legacyHarsh4":
    case "threePt":
    case "balanced":
    case "soft":
    case "harsh":
    case "flood":
    case "contrasting":
    case "morning":
    case "sunrise":
    case "sunset":
    case "chilly":
    case "freezing":
    case "flat":
    case "twoPt":
    case "glow":
    case "brightRoom":
      return true;
    default:
      return false;
  }
}
function isLightRigDirection(value) {
  switch (value) {
    case "tl":
    case "t":
    case "tr":
    case "l":
    case "r":
    case "bl":
    case "b":
    case "br":
      return true;
    default:
      return false;
  }
}
function parseLightRig(element) {
  if (!element) {
    return;
  }
  const rig = getAttr(element, "rig");
  const direction = getAttr(element, "dir");
  if (!isLightRigType(rig) || !isLightRigDirection(direction)) {
    return;
  }
  return { rig, direction };
}
function parseCell3d(element) {
  if (!element) {
    return;
  }
  const bevel = parseBevel(getChild(element, "a:bevel"));
  const lightRig = parseLightRig(getChild(element, "a:lightRig"));
  const preset = parsePresetMaterialType(getAttr(element, "prstMaterial"));
  if (!bevel && !lightRig && !preset) {
    return;
  }
  return {
    bevel,
    lightRig,
    preset
  };
}

// packages/@oxen-office/pptx/src/parser/table/style-parser.ts
function parseTableCellBorders(tcBdr) {
  if (!tcBdr) {
    return;
  }
  const left = parseLine2(getChild(tcBdr, "a:left"));
  const right = parseLine2(getChild(tcBdr, "a:right"));
  const top = parseLine2(getChild(tcBdr, "a:top"));
  const bottom = parseLine2(getChild(tcBdr, "a:bottom"));
  const insideH = parseLine2(getChild(tcBdr, "a:insideH"));
  const insideV = parseLine2(getChild(tcBdr, "a:insideV"));
  const tlToBr = parseLine2(getChild(tcBdr, "a:tl2br"));
  const blToTr = parseLine2(getChild(tcBdr, "a:tr2bl"));
  if (!left && !right && !top && !bottom && !insideH && !insideV && !tlToBr && !blToTr) {
    return;
  }
  return {
    left: left ?? undefined,
    right: right ?? undefined,
    top: top ?? undefined,
    bottom: bottom ?? undefined,
    insideH: insideH ?? undefined,
    insideV: insideV ?? undefined,
    tlToBr: tlToBr ?? undefined,
    blToTr: blToTr ?? undefined
  };
}
function parseTableCellStyle(tcStyle) {
  if (!tcStyle) {
    return;
  }
  const fillContainer = getChild(tcStyle, "a:fill");
  const fill = fillContainer ? parseFillFromParent(fillContainer) : undefined;
  const fillRef = parseStyleReference(getChild(tcStyle, "a:fillRef"));
  const borders = parseTableCellBorders(getChild(tcStyle, "a:tcBdr"));
  const cell3d = parseCell3d(getChild(tcStyle, "a:cell3D"));
  if (!fill && !fillRef && !borders && !cell3d) {
    return;
  }
  return {
    fill,
    fillReference: fillRef ? { index: fillRef.index, color: fillRef.color } : undefined,
    borders,
    cell3d
  };
}
function parseTableCellTextStyle(tcTxStyle) {
  if (!tcTxStyle) {
    return;
  }
  const fontReference = parseFontReference(getChild(tcTxStyle, "a:fontRef"));
  if (!fontReference) {
    return;
  }
  return { fontReference };
}
function parseTablePartStyle(part) {
  if (!part) {
    return;
  }
  const tcStyle = parseTableCellStyle(getChild(part, "a:tcStyle"));
  const textProperties = parseTableCellTextStyle(getChild(part, "a:tcTxStyle"));
  if (!tcStyle && !textProperties) {
    return;
  }
  return {
    ...tcStyle,
    textProperties
  };
}
function parseTableStyle(element) {
  const styleId = getAttr(element, "styleId");
  if (!styleId) {
    return;
  }
  return {
    id: styleId,
    name: getAttr(element, "styleName"),
    tblBg: parseFillFromParent(getChild(element, "a:tblBg")),
    wholeTbl: parseTablePartStyle(getChild(element, "a:wholeTbl")),
    band1H: parseTablePartStyle(getChild(element, "a:band1H")),
    band2H: parseTablePartStyle(getChild(element, "a:band2H")),
    band1V: parseTablePartStyle(getChild(element, "a:band1V")),
    band2V: parseTablePartStyle(getChild(element, "a:band2V")),
    firstCol: parseTablePartStyle(getChild(element, "a:firstCol")),
    lastCol: parseTablePartStyle(getChild(element, "a:lastCol")),
    firstRow: parseTablePartStyle(getChild(element, "a:firstRow")),
    lastRow: parseTablePartStyle(getChild(element, "a:lastRow")),
    seCell: parseTablePartStyle(getChild(element, "a:seCell")),
    swCell: parseTablePartStyle(getChild(element, "a:swCell")),
    neCell: parseTablePartStyle(getChild(element, "a:neCell")),
    nwCell: parseTablePartStyle(getChild(element, "a:nwCell"))
  };
}
function parseTableStyleList(tblStyleLst) {
  if (!tblStyleLst) {
    return;
  }
  const styles = [];
  for (const tblStyle of getChildren(tblStyleLst, "a:tblStyle")) {
    const parsed = parseTableStyle(tblStyle);
    if (parsed) {
      styles.push(parsed);
    }
  }
  return {
    defaultStyleId: getAttr(tblStyleLst, "def"),
    styles
  };
}

// packages/@oxen-office/pptx/src/domain/zip-adapter.ts
function createZipAdapter(file) {
  return {
    file(filePath) {
      if (!file.exists(filePath)) {
        return null;
      }
      return {
        asText() {
          const text = file.readText(filePath);
          if (text === null) {
            return "";
          }
          return text;
        },
        asArrayBuffer() {
          const binary = file.readBinary(filePath);
          if (binary === null) {
            return new ArrayBuffer(0);
          }
          return binary;
        }
      };
    },
    load() {
      throw new Error("ZipFile.load() is not supported in PresentationFile adapter");
    }
  };
}

// packages/@oxen-office/pptx/src/domain/relationships.ts
var RELATIONSHIP_TYPES = {
  SLIDE: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide",
  SLIDE_LAYOUT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout",
  SLIDE_MASTER: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster",
  THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  THEME_OVERRIDE: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/themeOverride",
  IMAGE: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
  HYPERLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  NOTES: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide",
  DIAGRAM_DRAWING: "http://schemas.microsoft.com/office/2007/relationships/diagramDrawing",
  VML_DRAWING: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  OLE_OBJECT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject",
  VIDEO: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/video",
  AUDIO: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/audio"
};
function createEmptyResourceMap() {
  return {
    getTarget: () => {
      return;
    },
    getType: () => {
      return;
    },
    getTargetByType: () => {
      return;
    },
    getAllTargetsByType: () => []
  };
}

// packages/@oxen-office/opc/src/relationships.ts
function listRelationships(relsXml) {
  const root = relsXml.children.find(isXmlElement);
  if (!root || root.name !== "Relationships") {
    return [];
  }
  const relationships = [];
  for (const child of root.children) {
    if (!isXmlElement(child) || child.name !== "Relationship") {
      continue;
    }
    const id = child.attrs.Id;
    const target = child.attrs.Target;
    if (!id || !target) {
      continue;
    }
    relationships.push({
      id,
      type: child.attrs.Type ?? "",
      target,
      targetMode: child.attrs.TargetMode
    });
  }
  return relationships;
}
function createEmptyResourceMap2() {
  return {
    getTarget: () => {
      return;
    },
    getType: () => {
      return;
    },
    getTargetByType: () => {
      return;
    },
    getAllTargetsByType: () => []
  };
}
function createResourceMap(entries) {
  return {
    getTarget(rId) {
      return entries[rId]?.target;
    },
    getType(rId) {
      return entries[rId]?.type;
    },
    getTargetByType(relType) {
      for (const entry of Object.values(entries)) {
        if (entry.type === relType) {
          return entry.target;
        }
      }
      return;
    },
    getAllTargetsByType(relType) {
      const targets = [];
      for (const entry of Object.values(entries)) {
        if (entry.type === relType) {
          targets.push(entry.target);
        }
      }
      return targets;
    }
  };
}
// packages/@oxen-office/opc/src/path.ts
function joinPosixPath(...parts) {
  const normalizedParts = parts.filter((part) => part.length > 0);
  if (normalizedParts.length === 0) {
    return "";
  }
  return normalizedParts.join("/").replace(/\/{2,}/gu, "/");
}
function dirnamePosixPath(p) {
  const trimmed = p.replace(/\/+$/gu, "");
  const index = trimmed.lastIndexOf("/");
  if (index === -1) {
    return ".";
  }
  if (index === 0) {
    return "/";
  }
  return trimmed.slice(0, index);
}
function basenamePosixPath(p) {
  const trimmed = p.replace(/\/+$/gu, "");
  const index = trimmed.lastIndexOf("/");
  return index === -1 ? trimmed : trimmed.slice(index + 1);
}
function normalizePosixPath(p) {
  const absolute = p.startsWith("/");
  const parts = p.split("/").filter((part) => part.length > 0);
  const stack = parts.reduce((acc, part) => {
    if (part === ".") {
      return acc;
    }
    if (part === "..") {
      if (acc.length > 0 && acc[acc.length - 1] !== "..") {
        acc.pop();
        return acc;
      }
      if (!absolute) {
        acc.push("..");
      }
      return acc;
    }
    acc.push(part);
    return acc;
  }, []);
  const joined = stack.join("/");
  if (absolute) {
    return `/${joined}`;
  }
  return joined.length === 0 ? "." : joined;
}
// packages/@oxen-office/opc/src/relationship-target.ts
function getParentDirectory(path) {
  if (path.endsWith("/")) {
    return path;
  }
  const lastSlash = path.lastIndexOf("/");
  if (lastSlash === -1) {
    return "";
  }
  return path.substring(0, lastSlash + 1);
}
function removeDotSegments(path) {
  const segments = path.split("/");
  const result = [];
  for (const segment of segments) {
    if (segment === "..") {
      if (result.length > 0) {
        result.pop();
      }
      continue;
    }
    if (segment === "." || segment === "") {
      continue;
    }
    result.push(segment);
  }
  return result.join("/");
}
function isAbsoluteIri(value) {
  return /^[A-Za-z][A-Za-z0-9+.-]*:/.test(value);
}
function resolveRelationshipTargetPath(sourcePartPath, target) {
  if (!sourcePartPath) {
    throw new Error("sourcePartPath is required");
  }
  if (!target) {
    throw new Error("target is required");
  }
  if (isAbsoluteIri(target)) {
    throw new Error(`External/absolute target is not supported here: ${target}`);
  }
  if (target.startsWith("/")) {
    return removeDotSegments(target.substring(1));
  }
  const baseDir = getParentDirectory(sourcePartPath);
  return removeDotSegments(baseDir + target);
}
// packages/@oxen-office/ooxml/src/parser/relationships.ts
function isAbsoluteIri2(value) {
  return /^[A-Za-z][A-Za-z0-9+.-]*:/.test(value);
}
function resolvePartPath(basePath, reference) {
  if (isAbsoluteIri2(reference)) {
    return reference;
  }
  return resolveRelationshipTargetPath(basePath, reference);
}
function getRelationshipPath(partPath) {
  const lastSlash = partPath.lastIndexOf("/");
  if (lastSlash === -1) {
    return `_rels/${partPath}.rels`;
  }
  const dir = partPath.substring(0, lastSlash);
  const filename = partPath.substring(lastSlash + 1);
  return `${dir}/_rels/${filename}.rels`;
}
function parseRelationships(relsXml, sourcePath) {
  if (relsXml === null) {
    return createEmptyResourceMap2();
  }
  const relationshipsElement = getByPath(relsXml, ["Relationships"]);
  if (!relationshipsElement) {
    return createEmptyResourceMap2();
  }
  const relationships = getChildren(relationshipsElement, "Relationship");
  const entries = {};
  for (const rel of relationships) {
    const id = rel.attrs["Id"];
    const type = rel.attrs["Type"];
    const target = rel.attrs["Target"];
    const targetMode = rel.attrs["TargetMode"];
    if (id !== undefined && target !== undefined) {
      const resolvedTarget = targetMode === "External" ? target : resolvePartPath(sourcePath, target);
      entries[id] = { type: type ?? "", target: resolvedTarget };
    }
  }
  return createResourceMap(entries);
}
function parseRelationshipsFromText(relsText, sourcePath) {
  if (relsText === null || relsText === undefined) {
    return createEmptyResourceMap2();
  }
  return parseRelationships(parseXml(relsText), sourcePath);
}
// packages/@oxen-office/ooxml/src/parser/drawing-primitive.ts
function parseAlignH(value) {
  switch (value) {
    case "left":
    case "right":
    case "center":
    case "inside":
    case "outside":
      return value;
    default:
      return;
  }
}
function parseAlignV(value) {
  switch (value) {
    case "top":
    case "bottom":
    case "center":
    case "inside":
    case "outside":
      return value;
    default:
      return;
  }
}
function parseRelFromH(value) {
  switch (value) {
    case "character":
    case "column":
    case "insideMargin":
    case "leftMargin":
    case "margin":
    case "outsideMargin":
    case "page":
    case "rightMargin":
      return value;
    default:
      return;
  }
}
function parseRelFromV(value) {
  switch (value) {
    case "bottomMargin":
    case "insideMargin":
    case "line":
    case "margin":
    case "outsideMargin":
    case "page":
    case "paragraph":
    case "topMargin":
      return value;
    default:
      return;
  }
}
function parseWrapText(value) {
  switch (value) {
    case "bothSides":
    case "left":
    case "right":
    case "largest":
      return value;
    default:
      return;
  }
}
function parseEditAs(value) {
  switch (value) {
    case "twoCell":
    case "oneCell":
    case "absolute":
      return value;
    default:
      return;
  }
}
// packages/@oxen-office/pptx/src/parser/relationships.ts
function resolvePartPath2(basePath, reference) {
  return resolvePartPath(basePath, reference);
}
function getRelationshipPath2(partPath) {
  return getRelationshipPath(partPath);
}
function parseRelationships2(relsXml, sourcePath) {
  return parseRelationships(relsXml, sourcePath);
}
function loadRelationships2(file, partPath) {
  const relsPath = getRelationshipPath(partPath);
  const relsText = file.readText(relsPath);
  if (relsText === null) {
    return createEmptyResourceMap();
  }
  return parseRelationshipsFromText(relsText, partPath);
}
function findLayoutPath(resources) {
  return resources.getTargetByType(RELATIONSHIP_TYPES.SLIDE_LAYOUT);
}
function findMasterPath(resources) {
  return resources.getTargetByType(RELATIONSHIP_TYPES.SLIDE_MASTER);
}
function findThemePath(resources) {
  return resources.getTargetByType(RELATIONSHIP_TYPES.THEME);
}
function findDiagramDrawingPath(resources) {
  return resources.getTargetByType(RELATIONSHIP_TYPES.DIAGRAM_DRAWING);
}

// packages/@oxen-office/pptx/src/parser/slide/xml-reader.ts
var DEFAULT_MARKUP_COMPATIBILITY_OPTIONS = {
  supportedPrefixes: [
    "a",
    "c",
    "dgm",
    "dsp",
    "mc",
    "o",
    "p",
    "r",
    "v",
    "wp",
    "wpc",
    "wpg",
    "wsp",
    "wgp",
    "xdr"
  ]
};
function processContent(text, appVersion, isSlideContent) {
  if (isSlideContent && appVersion <= 12) {
    return stripCdata(text);
  }
  return text;
}
function readXml(file, path, ...rest) {
  const [appVersion = 16, isSlideContent = false, markupCompatibility] = rest;
  if (!markupCompatibility) {
    throw new Error("Markup compatibility options are required.");
  }
  const text = file.readText(path);
  if (text === null) {
    return null;
  }
  const content = processContent(text, appVersion, isSlideContent);
  const document = parseXml(content);
  return applyMarkupCompatibility(document, markupCompatibility);
}
function getRelationships(file, path, _markupCompatibility) {
  return loadRelationships2(file, path);
}

// packages/@oxen-renderer/pptx/src/render-options.ts
var DEFAULT_RENDER_OPTIONS = {
  dialect: "ecma376",
  lineSpacingMode: "fontSizeMultiplier",
  baselineMode: "svgBaseline",
  libreofficeLineSpacingFactor: 0.75,
  tableScalingMode: "natural"
};

// packages/@oxen-office/ooxml/src/domain/border.ts
var eighthPt = (value) => value;

// packages/@oxen-office/ooxml/src/domain/table.ts
var gridSpan = (value) => value;
// packages/@oxen-office/ooxml/src/domain/warnings.ts
function createWarningCollector() {
  const warnings = [];
  return {
    add: (warning) => warnings.push(warning),
    getAll: () => warnings,
    hasErrors: () => warnings.some((w) => w.type === "error")
  };
}
// packages/@oxen-renderer/pptx/src/background-fill.ts
function calculateRadialCenter(gradientData) {
  if (gradientData.type !== "path" || gradientData.fillToRect === undefined) {
    return;
  }
  const { l, r, t, b } = gradientData.fillToRect;
  return {
    cx: (l + r) / 2000,
    cy: (t + b) / 2000
  };
}
function toResolvedBackgroundFill(bgFillData) {
  if (bgFillData.image !== undefined) {
    return {
      type: "image",
      dataUrl: bgFillData.image,
      mode: bgFillData.imageFillMode === "stretch" ? "stretch" : "tile"
    };
  }
  if (bgFillData.gradientData !== undefined) {
    const isRadial = bgFillData.gradientData.type === "path";
    const radialCenter = calculateRadialCenter(bgFillData.gradientData);
    return {
      type: "gradient",
      angle: bgFillData.gradientData.angle,
      stops: bgFillData.gradientData.stops.map((stop) => ({
        position: stop.position,
        color: stop.color.startsWith("#") ? stop.color : `#${stop.color}`
      })),
      isRadial,
      radialCenter
    };
  }
  if (bgFillData.color !== undefined) {
    return {
      type: "solid",
      color: bgFillData.color.startsWith("#") ? bgFillData.color : `#${bgFillData.color}`
    };
  }
  return;
}

// packages/@oxen/color/src/convert.ts
function hexToRgb(hex) {
  const cleanHex = hex.replace(/^#/, "");
  const bigint = parseInt(cleanHex, 16);
  if (cleanHex.length === 3) {
    return {
      r: (bigint >> 8 & 15) * 17,
      g: (bigint >> 4 & 15) * 17,
      b: (bigint & 15) * 17
    };
  }
  return {
    r: bigint >> 16 & 255,
    g: bigint >> 8 & 255,
    b: bigint & 255
  };
}
function toHex(n) {
  const hex = Math.max(0, Math.min(255, Math.round(n))).toString(16);
  return hex.length < 2 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
  return toHex(Math.round(r)) + toHex(Math.round(g)) + toHex(Math.round(b));
}
function rgbToHsl(r, g, b) {
  const rNorm = r / 255;
  const gNorm = g / 255;
  const bNorm = b / 255;
  const max2 = Math.max(rNorm, gNorm, bNorm);
  const min = Math.min(rNorm, gNorm, bNorm);
  const l = (max2 + min) / 2;
  if (max2 === min) {
    return { h: 0, s: 0, l };
  }
  const d = max2 - min;
  const s = l > 0.5 ? d / (2 - max2 - min) : d / (max2 + min);
  const hueMap = {
    [rNorm]: () => ((gNorm - bNorm) / d + (gNorm < bNorm ? 6 : 0)) / 6,
    [gNorm]: () => ((bNorm - rNorm) / d + 2) / 6,
    [bNorm]: () => ((rNorm - gNorm) / d + 4) / 6
  };
  const h = (hueMap[max2]?.() ?? 0) * 360;
  return { h, s, l };
}
function hueToRgb(t1, t2, hue) {
  const h = hue < 0 ? hue + 6 : hue >= 6 ? hue - 6 : hue;
  if (h < 1) {
    return (t2 - t1) * h + t1;
  }
  if (h < 3) {
    return t2;
  }
  if (h < 4) {
    return (t2 - t1) * (4 - h) + t1;
  }
  return t1;
}
function hslToRgb(hue, sat, light) {
  const h = hue / 60;
  const t2 = light <= 0.5 ? light * (sat + 1) : light + sat - light * sat;
  const t1 = light * 2 - t2;
  return {
    r: hueToRgb(t1, t2, h + 2) * 255,
    g: hueToRgb(t1, t2, h) * 255,
    b: hueToRgb(t1, t2, h - 2) * 255
  };
}
function parseColorToHsl(colorStr) {
  const cleanColor = colorStr.replace(/^#/, "");
  const rgb = hexToRgb(cleanColor);
  return rgbToHsl(rgb.r, rgb.g, rgb.b);
}
function hslToHexString(hsl, includeAlpha = false) {
  const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
  const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
  if (includeAlpha && hsl.a !== undefined) {
    return hex + toHex(Math.round(hsl.a * 255));
  }
  return hex;
}
// packages/@oxen/color/src/transform.ts
function applyShade(rgbStr, shadeValue, isAlpha = false) {
  const hex = rgbStr.replace("#", "");
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);
  const clampedShade = Math.min(Math.max(shadeValue, 0), 1);
  const newR = Math.round(r * clampedShade);
  const newG = Math.round(g * clampedShade);
  const newB = Math.round(b * clampedShade);
  const toHex2 = (n) => n.toString(16).padStart(2, "0");
  if (isAlpha && hex.length === 8) {
    const a = hex.substring(6, 8);
    return toHex2(newR) + toHex2(newG) + toHex2(newB) + a;
  }
  return toHex2(newR) + toHex2(newG) + toHex2(newB);
}
function applyTint(rgbStr, tintValue, isAlpha = false) {
  const hex = rgbStr.replace("#", "");
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);
  const clampedTint = Math.min(Math.max(tintValue, 0), 1);
  const newR = Math.round(r + (255 - r) * (1 - clampedTint));
  const newG = Math.round(g + (255 - g) * (1 - clampedTint));
  const newB = Math.round(b + (255 - b) * (1 - clampedTint));
  const toHex2 = (n) => n.toString(16).padStart(2, "0");
  if (isAlpha && hex.length === 8) {
    const a = hex.substring(6, 8);
    return toHex2(newR) + toHex2(newG) + toHex2(newB) + a;
  }
  return toHex2(newR) + toHex2(newG) + toHex2(newB);
}
function applyLumOff(rgbStr, offset, isAlpha = false) {
  const color = parseColorToHsl(rgbStr);
  const newL = Math.min(Math.max(offset + color.l, 0), 1);
  return hslToHexString({ h: color.h, s: color.s, l: newL, a: color.a }, isAlpha);
}
function applyLumMod(rgbStr, multiplier, isAlpha = false) {
  const color = parseColorToHsl(rgbStr);
  const newL = Math.min(color.l * multiplier, 1);
  return hslToHexString({ h: color.h, s: color.s, l: newL, a: color.a }, isAlpha);
}
function applyHueMod(rgbStr, multiplier, isAlpha = false) {
  const color = parseColorToHsl(rgbStr);
  const newH = color.h * multiplier >= 360 ? color.h * multiplier - 360 : color.h * multiplier;
  return hslToHexString({ h: newH, s: color.s, l: color.l, a: color.a }, isAlpha);
}
function applySatMod(rgbStr, multiplier, isAlpha = false) {
  const color = parseColorToHsl(rgbStr);
  const newS = Math.min(color.s * multiplier, 1);
  return hslToHexString({ h: color.h, s: newS, l: color.l, a: color.a }, isAlpha);
}
// packages/@oxen/color/src/named-colors.ts
var COLOR_NAMES = {
  white: "ffffff",
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgrey: "a9a9a9",
  darkgreen: "006400",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  grey: "808080",
  green: "008000",
  greenyellow: "adff2f",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgrey: "d3d3d3",
  lightgreen: "90ee90",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "778899",
  lightslategrey: "778899",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "00ff00",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "ff00ff",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "ff0000",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  whitesmoke: "f5f5f5",
  yellow: "ffff00",
  yellowgreen: "9acd32"
};
function getColorName2Hex(name) {
  return COLOR_NAMES[name.toLowerCase()];
}
// packages/@oxen/files/src/mime.ts
var MIME_TYPES = {
  jpg: "image/jpeg",
  jpeg: "image/jpeg",
  png: "image/png",
  gif: "image/gif",
  bmp: "image/bmp",
  tiff: "image/tiff",
  tif: "image/tiff",
  svg: "image/svg+xml",
  emf: "image/x-emf",
  wmf: "image/x-wmf",
  ico: "image/x-icon",
  webp: "image/webp",
  mp4: "video/mp4",
  webm: "video/webm",
  ogg: "video/ogg",
  avi: "video/x-msvideo",
  mov: "video/quicktime",
  wmv: "video/x-ms-wmv",
  mp3: "audio/mpeg",
  wav: "audio/wav",
  m4a: "audio/mp4",
  wma: "audio/x-ms-wma",
  aac: "audio/aac",
  pdf: "application/pdf"
};
var DEFAULT_MIME_TYPE = "application/octet-stream";
function getMimeType(extension) {
  return MIME_TYPES[extension.toLowerCase()] ?? DEFAULT_MIME_TYPE;
}
function getMimeTypeFromPath(path) {
  const ext = path.split(".").pop()?.toLowerCase();
  if (ext === undefined) {
    return;
  }
  return MIME_TYPES[ext];
}
// packages/@oxen-office/pptx/src/parser/slide/context.ts
var TYPE_TO_MASTER_STYLE = {
  ctrTitle: "titleStyle",
  title: "titleStyle",
  subTitle: "bodyStyle",
  body: "bodyStyle",
  obj: "bodyStyle",
  chart: "bodyStyle",
  tbl: "bodyStyle",
  clipArt: "bodyStyle",
  dgm: "bodyStyle",
  media: "bodyStyle",
  pic: "bodyStyle",
  sldImg: "bodyStyle",
  dt: "otherStyle",
  ftr: "otherStyle",
  sldNum: "otherStyle",
  hdr: "otherStyle"
};
function createParagraphContext(shape, lvl) {
  const lvlpPr = `a:lvl${lvl}pPr`;
  return {
    lvl,
    type: shape.type,
    idx: shape.idx,
    shape,
    getDefRPr(lstStyle) {
      if (lstStyle !== undefined) {
        const defRPr = getByPath(lstStyle, [lvlpPr, "a:defRPr"]);
        if (defRPr !== undefined) {
          return defRPr;
        }
      }
      const layoutPh = shape.slide.layout.placeholders.byType[shape.type];
      if (layoutPh !== undefined) {
        const defRPr = getByPath(layoutPh, ["p:txBody", "a:lstStyle", lvlpPr, "a:defRPr"]);
        if (defRPr !== undefined) {
          return defRPr;
        }
      }
      const masterPh = shape.slide.master.placeholders.byType[shape.type];
      if (masterPh !== undefined) {
        const defRPr = getByPath(masterPh, ["p:txBody", "a:lstStyle", lvlpPr, "a:defRPr"]);
        if (defRPr !== undefined) {
          return defRPr;
        }
      }
      const masterStyleKey = TYPE_TO_MASTER_STYLE[shape.type];
      if (masterStyleKey !== undefined) {
        const masterStyle = shape.slide.master.textStyles[masterStyleKey];
        if (masterStyle !== undefined) {
          const defRPr = getByPath(masterStyle, [lvlpPr, "a:defRPr"]);
          if (defRPr !== undefined) {
            return defRPr;
          }
        }
      }
      const defaultTextStyle = shape.slide.presentation.defaultTextStyle;
      if (defaultTextStyle !== null) {
        return getByPath(defaultTextStyle, [lvlpPr, "a:defRPr"]);
      }
      return;
    },
    getDefPPr(lstStyle) {
      if (lstStyle !== undefined) {
        const pPr = getChild(lstStyle, lvlpPr);
        if (pPr !== undefined) {
          return pPr;
        }
      }
      const layoutPh = shape.slide.layout.placeholders.byType[shape.type];
      if (layoutPh !== undefined) {
        const pPr = getByPath(layoutPh, ["p:txBody", "a:lstStyle", lvlpPr]);
        if (pPr !== undefined) {
          return pPr;
        }
      }
      const masterPh = shape.slide.master.placeholders.byType[shape.type];
      if (masterPh !== undefined) {
        const pPr = getByPath(masterPh, ["p:txBody", "a:lstStyle", lvlpPr]);
        if (pPr !== undefined) {
          return pPr;
        }
      }
      const masterStyleKey = TYPE_TO_MASTER_STYLE[shape.type];
      if (masterStyleKey !== undefined) {
        const masterStyle = shape.slide.master.textStyles[masterStyleKey];
        if (masterStyle !== undefined) {
          const pPr = getChild(masterStyle, lvlpPr);
          if (pPr !== undefined) {
            return pPr;
          }
        }
      }
      const defaultTextStyle = shape.slide.presentation.defaultTextStyle;
      if (defaultTextStyle !== null) {
        return getChild(defaultTextStyle, lvlpPr);
      }
      return;
    },
    resolveThemeFont(typeface) {
      const fontScheme = shape.slide.presentation.theme.fontScheme;
      if (typeface === "+mj-lt" || typeface === "+mj-ea") {
        return fontScheme.majorFont.latin ?? fontScheme.majorFont.eastAsian;
      }
      if (typeface === "+mn-lt" || typeface === "+mn-ea") {
        return fontScheme.minorFont.latin ?? fontScheme.minorFont.eastAsian;
      }
      return typeface;
    },
    resolveSchemeColor(schemeColor) {
      const slideCtx = shape.slide;
      const slideOverride = slideCtx.slide.colorMapOverride;
      if (slideOverride !== undefined) {
        const mapped2 = slideOverride[schemeColor];
        if (mapped2 !== undefined) {
          return slideCtx.presentation.theme.colorScheme[mapped2];
        }
      }
      const mapped = slideCtx.master.colorMap[schemeColor];
      if (mapped !== undefined) {
        return slideCtx.presentation.theme.colorScheme[mapped];
      }
      return slideCtx.presentation.theme.colorScheme[schemeColor];
    }
  };
}
function createShapeContext(slide, type, idx) {
  const self = {
    slide,
    type,
    idx,
    forParagraph(lvl) {
      return createParagraphContext(self, lvl);
    },
    getLayoutPlaceholder() {
      if (idx !== undefined) {
        const byIdx = slide.layout.placeholders.byIdx.get(idx);
        if (byIdx !== undefined) {
          return byIdx;
        }
      }
      return slide.layout.placeholders.byType[type];
    },
    getMasterPlaceholder() {
      if (idx !== undefined) {
        const byIdx = slide.master.placeholders.byIdx.get(idx);
        if (byIdx !== undefined) {
          return byIdx;
        }
      }
      return slide.master.placeholders.byType[type];
    }
  };
  return self;
}
function createSlideContext({
  slide,
  layout,
  master,
  presentation
}) {
  const self = {
    slide,
    layout,
    master,
    presentation,
    forShape(type, idx) {
      return createShapeContext(self, type, idx);
    },
    readFile(path) {
      const entry = presentation.zip.file(path);
      if (entry === null) {
        return null;
      }
      return entry.asArrayBuffer();
    },
    resolveResource(rId) {
      const slideTarget = slide.resources.getTarget(rId);
      if (slideTarget !== undefined) {
        return slideTarget;
      }
      const layoutTarget = layout.resources.getTarget(rId);
      if (layoutTarget !== undefined) {
        return layoutTarget;
      }
      return master.resources.getTarget(rId);
    },
    toColorContext() {
      return {
        colorMap: master.colorMap,
        colorMapOverride: slide.colorMapOverride,
        colorScheme: presentation.theme.colorScheme
      };
    },
    toPlaceholderContext() {
      return {
        layoutPlaceholders: layout.placeholders,
        masterPlaceholders: master.placeholders
      };
    },
    toResourceContext() {
      return createResourceContextImpl(self.resolveResource.bind(self), self.readFile.bind(self));
    },
    toTextStyleContext() {
      return {
        masterTextStyles: master.textStyles,
        defaultTextStyle: presentation.defaultTextStyle,
        placeholders: self.toPlaceholderContext()
      };
    },
    toThemeResourceContext() {
      return createResourceContextImpl((rId) => presentation.themeResources?.getTarget(rId), self.readFile.bind(self));
    }
  };
  return self;
}
function createResourceContextImpl(resolveResource, readFile) {
  return {
    resolveResource,
    readFile,
    resolveBlipFill(rId) {
      const path = resolveResource(rId);
      if (path === undefined) {
        return;
      }
      const ext = path.split(".").pop()?.toLowerCase() ?? "";
      if (ext === "xml" || ext === "rels") {
        return;
      }
      const data = readFile(path);
      if (data === null) {
        return;
      }
      return {
        data,
        mimeType: getMimeType(ext),
        path
      };
    }
  };
}

// packages/@oxen-office/pptx/src/parser/context.ts
function createParseContext(ctx) {
  const masterTextStyles = ctx.master.textStyles;
  const formatScheme = ctx.presentation.theme.formatScheme;
  const fontScheme = ctx.presentation.theme.fontScheme;
  const colorContext = buildColorContext(ctx);
  return {
    colorContext,
    placeholderContext: {
      layout: toPlaceholderTables(ctx.layout.placeholders),
      master: toPlaceholderTables(ctx.master.placeholders)
    },
    masterStylesInfo: {
      masterTextStyles: {
        titleStyle: masterTextStyles.titleStyle,
        bodyStyle: masterTextStyles.bodyStyle,
        otherStyle: masterTextStyles.otherStyle
      },
      defaultTextStyle: ctx.presentation.defaultTextStyle ?? undefined
    },
    slideResources: {
      getTarget: (id) => ctx.slide.resources.getTarget(id),
      getType: (id) => ctx.slide.resources.getType(id)
    },
    layoutResources: {
      getTarget: (id) => ctx.layout.resources.getTarget(id),
      getType: (id) => ctx.layout.resources.getType(id)
    },
    masterResources: {
      getTarget: (id) => ctx.master.resources.getTarget(id),
      getType: (id) => ctx.master.resources.getType(id)
    },
    themeContent: undefined,
    formatScheme: {
      fillStyles: formatScheme.fillStyles,
      lineStyles: formatScheme.lineStyles,
      effectStyles: formatScheme.effectStyles
    },
    fontScheme: {
      majorFont: {
        latin: fontScheme.majorFont.latin,
        eastAsian: fontScheme.majorFont.eastAsian,
        complexScript: fontScheme.majorFont.complexScript
      },
      minorFont: {
        latin: fontScheme.minorFont.latin,
        eastAsian: fontScheme.minorFont.eastAsian,
        complexScript: fontScheme.minorFont.complexScript
      }
    }
  };
}
function toPlaceholderTables(table) {
  return {
    byIdx: table.byIdx,
    byType: table.byType
  };
}
function buildColorContext(ctx) {
  const scheme = ctx.presentation.theme.colorScheme;
  const masterMap = ctx.master.colorMap;
  const overrideMap = ctx.slide.colorMapOverride;
  const colorScheme = {};
  const schemeColors = [
    "dk1",
    "lt1",
    "dk2",
    "lt2",
    "accent1",
    "accent2",
    "accent3",
    "accent4",
    "accent5",
    "accent6",
    "hlink",
    "folHlink"
  ];
  for (const name of schemeColors) {
    const value = scheme[name];
    if (value !== undefined) {
      colorScheme[name] = value;
    }
  }
  const colorMap = {};
  const mappedColors = [
    "tx1",
    "tx2",
    "bg1",
    "bg2",
    "accent1",
    "accent2",
    "accent3",
    "accent4",
    "accent5",
    "accent6",
    "hlink",
    "folHlink"
  ];
  for (const name of mappedColors) {
    if (overrideMap !== undefined) {
      const value2 = overrideMap[name];
      if (value2 !== undefined) {
        colorMap[name] = value2;
        continue;
      }
    }
    const value = masterMap[name];
    if (value !== undefined) {
      colorMap[name] = value;
    }
  }
  return { colorScheme, colorMap };
}

// packages/@oxen-office/pptx/src/parser/graphics/transform-parser.ts
function parseTransform(xfrm) {
  if (!xfrm) {
    return;
  }
  const off = getChild(xfrm, "a:off");
  const ext = getChild(xfrm, "a:ext");
  if (!off || !ext) {
    return;
  }
  return {
    x: getEmuAttrOr(off, "x", px(0)),
    y: getEmuAttrOr(off, "y", px(0)),
    width: getEmuAttrOr(ext, "cx", px(0)),
    height: getEmuAttrOr(ext, "cy", px(0)),
    rotation: getAngleAttr2(xfrm, "rot") ?? deg(0),
    flipH: getBoolAttrOr2(xfrm, "flipH", false),
    flipV: getBoolAttrOr2(xfrm, "flipV", false)
  };
}
function parseGroupTransform(xfrm) {
  if (!xfrm) {
    return;
  }
  const off = getChild(xfrm, "a:off");
  const ext = getChild(xfrm, "a:ext");
  const chOff = getChild(xfrm, "a:chOff");
  const chExt = getChild(xfrm, "a:chExt");
  if (!off || !ext || !chOff || !chExt) {
    return;
  }
  return {
    x: getEmuAttrOr(off, "x", px(0)),
    y: getEmuAttrOr(off, "y", px(0)),
    width: getEmuAttrOr(ext, "cx", px(0)),
    height: getEmuAttrOr(ext, "cy", px(0)),
    rotation: getAngleAttr2(xfrm, "rot") ?? deg(0),
    flipH: getBoolAttrOr2(xfrm, "flipH", false),
    flipV: getBoolAttrOr2(xfrm, "flipV", false),
    childOffsetX: getEmuAttrOr(chOff, "x", px(0)),
    childOffsetY: getEmuAttrOr(chOff, "y", px(0)),
    childExtentWidth: getEmuAttrOr(chExt, "cx", px(0)),
    childExtentHeight: getEmuAttrOr(chExt, "cy", px(0))
  };
}
function getTransformFromProperties(spPr) {
  if (!spPr) {
    return;
  }
  return parseTransform(getChild(spPr, "a:xfrm"));
}
function getGroupTransformFromProperties(grpSpPr) {
  if (!grpSpPr) {
    return;
  }
  return parseGroupTransform(getChild(grpSpPr, "a:xfrm"));
}

// packages/@oxen-office/pptx/src/parser/graphics/effects-parser.ts
function parseOuterShadow(element, overrideColor) {
  return parseOuterShadowEffect(element, overrideColor);
}
function parseInnerShadow(element, overrideColor) {
  return parseInnerShadowEffect(element, overrideColor);
}
function parseGlow(element, overrideColor) {
  return parseGlowEffect(element, overrideColor);
}
function parseReflection(element) {
  return parseReflectionEffect(element);
}
function parseSoftEdge(element) {
  return parseSoftEdgeEffect(element);
}
function parseAlphaBiLevel(element) {
  const threshold = parseFixedPercentage2(getAttr(element, "thresh"));
  if (threshold === undefined) {
    return;
  }
  return { threshold };
}
function parseAlphaCeiling(element) {
  return { type: "alphaCeiling" };
}
function parseAlphaFloor(element) {
  return { type: "alphaFloor" };
}
function parseAlphaInverse(element) {
  return { type: "alphaInv" };
}
function parseAlphaModulate(element) {
  const cont = getChild(element, "a:cont");
  if (!cont) {
    return;
  }
  const container = parseEffectContainer(cont);
  return {
    type: "alphaMod",
    containerType: resolveContainerType(container),
    name: getAttr(cont, "name"),
    container
  };
}
function parseAlphaModulateFixed(element) {
  const amount = parsePositivePercentage2(getAttr(element, "amt")) ?? pct(100);
  return { amount };
}
function parseAlphaOutset(element) {
  const radius = getEmuAttr2(element, "rad");
  if (radius === undefined) {
    return;
  }
  return { radius };
}
function parseAlphaReplace(element) {
  const alpha = parseFixedPercentage2(getAttr(element, "a"));
  if (alpha === undefined) {
    return;
  }
  return { alpha };
}
function parseBiLevel(element) {
  const threshold = parseFixedPercentage2(getAttr(element, "thresh"));
  if (threshold === undefined) {
    return;
  }
  return { threshold };
}
function parseBlend(element) {
  const cont = getChild(element, "a:cont");
  if (!cont) {
    return;
  }
  const blendAttr = getAttr(element, "blend");
  if (blendAttr === undefined) {
    return;
  }
  if (blendAttr !== "over" && blendAttr !== "mult" && blendAttr !== "screen" && blendAttr !== "darken" && blendAttr !== "lighten") {
    return;
  }
  const container = parseEffectContainer(cont);
  return {
    type: "blend",
    blend: blendAttr,
    containerType: resolveContainerType(container),
    name: getAttr(cont, "name"),
    container
  };
}
function resolveContainerType(container) {
  if (container?.type === "sib" || container?.type === "tree") {
    return container.type;
  }
  return;
}
function parseColorChange(element) {
  const clrFrom = getChild(element, "a:clrFrom");
  const clrTo = getChild(element, "a:clrTo");
  if (!clrFrom || !clrTo) {
    return;
  }
  const from = parseColorFromParent2(clrFrom);
  const to = parseColorFromParent2(clrTo);
  if (!from || !to) {
    return;
  }
  return {
    from,
    to,
    useAlpha: getBoolAttrOr2(element, "useA", true)
  };
}
function parseColorReplace(element) {
  const color = parseColorFromParent2(element);
  if (!color) {
    return;
  }
  return { color };
}
function parseDuotone(element) {
  const colors = [];
  for (const child of element.children) {
    if (typeof child !== "object" || !("name" in child)) {
      continue;
    }
    const parsed = parseColor2(child);
    if (parsed) {
      colors.push(parsed);
    }
  }
  if (colors.length !== 2) {
    return;
  }
  return { colors: [colors[0], colors[1]] };
}
function parseFillOverlay(element) {
  const blendAttr = getAttr(element, "blend");
  if (blendAttr === undefined) {
    return;
  }
  if (blendAttr !== "over" && blendAttr !== "mult" && blendAttr !== "screen" && blendAttr !== "darken" && blendAttr !== "lighten") {
    return;
  }
  const fillElement = findFillOverlayElement(element);
  if (!fillElement) {
    return;
  }
  const fillType = mapFillOverlayType(fillElement.name);
  if (!fillType) {
    return;
  }
  const fill = parseFill(fillElement);
  return {
    blend: blendAttr,
    fillType,
    fill
  };
}
function findFillOverlayElement(element) {
  for (const child of element.children) {
    if (typeof child !== "object" || !("name" in child)) {
      continue;
    }
    const name = child.name;
    if (mapFillOverlayType(name) !== undefined) {
      return child;
    }
  }
  return;
}
function mapFillOverlayType(name) {
  switch (name) {
    case "a:solidFill":
      return "solidFill";
    case "a:gradFill":
      return "gradFill";
    case "a:blipFill":
      return "blipFill";
    case "a:pattFill":
      return "pattFill";
    case "a:grpFill":
      return "grpFill";
    default:
      return;
  }
}
function parseGrayscale(element) {
  return { type: "grayscl" };
}
function parsePresetShadow(element) {
  const prst = getAttr(element, "prst");
  if (!isPresetShadowValue(prst)) {
    return;
  }
  const color = parseColorFromParent2(element);
  if (!color) {
    return;
  }
  return {
    type: "preset",
    preset: prst,
    color,
    direction: getAngleAttr2(element, "dir") ?? deg(0),
    distance: getEmuAttr2(element, "dist") ?? px(0)
  };
}
function isPresetShadowValue(value) {
  return value === "shdw1" || value === "shdw2" || value === "shdw3" || value === "shdw4" || value === "shdw5" || value === "shdw6" || value === "shdw7" || value === "shdw8" || value === "shdw9" || value === "shdw10" || value === "shdw11" || value === "shdw12" || value === "shdw13" || value === "shdw14" || value === "shdw15" || value === "shdw16" || value === "shdw17" || value === "shdw18" || value === "shdw19" || value === "shdw20";
}
function parseRelativeOffset(element) {
  const offsetX = getPercentAttr(element, "tx");
  const offsetY = getPercentAttr(element, "ty");
  if (offsetX === undefined || offsetY === undefined) {
    return;
  }
  return { offsetX, offsetY };
}
function parseEffectContainer(element) {
  const typeAttr = getAttr(element, "type");
  const type = typeAttr === "sib" || typeAttr === "tree" ? typeAttr : undefined;
  return {
    name: getAttr(element, "name"),
    type
  };
}
function parseEffects(spPr) {
  if (!spPr) {
    return;
  }
  const effectLst = getChild(spPr, "a:effectLst");
  if (effectLst) {
    return parseEffectList(effectLst, undefined, "effectLst");
  }
  const effectDag = getChild(spPr, "a:effectDag");
  if (effectDag) {
    return parseEffectList(effectDag, undefined, "effectDag");
  }
  return;
}
function parseEffectsWithOverride(spPr, overrideColor) {
  if (!spPr) {
    return;
  }
  const effectLst = getChild(spPr, "a:effectLst");
  if (effectLst) {
    return parseEffectList(effectLst, overrideColor, "effectLst");
  }
  const effectDag = getChild(spPr, "a:effectDag");
  if (effectDag) {
    return parseEffectList(effectDag, overrideColor, "effectDag");
  }
  return;
}
function parseEffectList(effectLst, overrideColor, containerKind) {
  const effects = {};
  if (containerKind) {
    effects.containerKind = containerKind;
  }
  const outerShdw = getChild(effectLst, "a:outerShdw");
  if (outerShdw) {
    effects.shadow = parseOuterShadow(outerShdw, overrideColor);
  }
  const innerShdw = getChild(effectLst, "a:innerShdw");
  if (innerShdw && !effects.shadow) {
    effects.shadow = parseInnerShadow(innerShdw, overrideColor);
  }
  const glow = getChild(effectLst, "a:glow");
  if (glow) {
    effects.glow = parseGlow(glow, overrideColor);
  }
  const reflection = getChild(effectLst, "a:reflection");
  if (reflection) {
    effects.reflection = parseReflection(reflection);
  }
  const softEdge = getChild(effectLst, "a:softEdge");
  if (softEdge) {
    effects.softEdge = parseSoftEdge(softEdge);
  }
  const alphaBiLevel = getChild(effectLst, "a:alphaBiLevel");
  if (alphaBiLevel) {
    effects.alphaBiLevel = parseAlphaBiLevel(alphaBiLevel);
  }
  const alphaCeiling = getChild(effectLst, "a:alphaCeiling");
  if (alphaCeiling) {
    effects.alphaCeiling = parseAlphaCeiling(alphaCeiling);
  }
  const alphaFloor = getChild(effectLst, "a:alphaFloor");
  if (alphaFloor) {
    effects.alphaFloor = parseAlphaFloor(alphaFloor);
  }
  const alphaInv = getChild(effectLst, "a:alphaInv");
  if (alphaInv) {
    effects.alphaInv = parseAlphaInverse(alphaInv);
  }
  const alphaMod = getChild(effectLst, "a:alphaMod");
  if (alphaMod) {
    effects.alphaMod = parseAlphaModulate(alphaMod);
  }
  const alphaModFix = getChild(effectLst, "a:alphaModFix");
  if (alphaModFix) {
    effects.alphaModFix = parseAlphaModulateFixed(alphaModFix);
  }
  const alphaOutset = getChild(effectLst, "a:alphaOutset");
  if (alphaOutset) {
    effects.alphaOutset = parseAlphaOutset(alphaOutset);
  }
  const alphaRepl = getChild(effectLst, "a:alphaRepl");
  if (alphaRepl) {
    effects.alphaRepl = parseAlphaReplace(alphaRepl);
  }
  const biLevel = getChild(effectLst, "a:biLevel");
  if (biLevel) {
    effects.biLevel = parseBiLevel(biLevel);
  }
  const blend = getChild(effectLst, "a:blend");
  if (blend) {
    effects.blend = parseBlend(blend);
  }
  const clrChange = getChild(effectLst, "a:clrChange");
  if (clrChange) {
    effects.colorChange = parseColorChange(clrChange);
  }
  const clrRepl = getChild(effectLst, "a:clrRepl");
  if (clrRepl) {
    effects.colorReplace = parseColorReplace(clrRepl);
  }
  const duotone = getChild(effectLst, "a:duotone");
  if (duotone) {
    effects.duotone = parseDuotone(duotone);
  }
  const fillOverlay = getChild(effectLst, "a:fillOverlay");
  if (fillOverlay) {
    effects.fillOverlay = parseFillOverlay(fillOverlay);
  }
  const grayscl = getChild(effectLst, "a:grayscl");
  if (grayscl) {
    effects.grayscale = parseGrayscale(grayscl);
  }
  const prstShdw = getChild(effectLst, "a:prstShdw");
  if (prstShdw) {
    effects.presetShadow = parsePresetShadow(prstShdw);
  }
  const relOff = getChild(effectLst, "a:relOff");
  if (relOff) {
    effects.relativeOffset = parseRelativeOffset(relOff);
  }
  const hasEffect = Object.entries(effects).some(([key, value]) => key !== "containerKind" && value !== undefined);
  return hasEffect ? effects : undefined;
}
function resolveEffectsFromStyleReference(effectRef, effectStyles) {
  if (!effectRef || effectRef.index === 0) {
    return;
  }
  const styleIndex = effectRef.index - 1;
  if (styleIndex < 0 || styleIndex >= effectStyles.length) {
    return;
  }
  const overrideColor = effectRef.color?.type === "solidFill" ? effectRef.color.color : undefined;
  return parseEffectsWithOverride(effectStyles[styleIndex], overrideColor);
}

// packages/@oxen-office/pptx/src/parser/graphics/geometry-parser.ts
function mapPathFillMode(fill) {
  switch (fill) {
    case "none":
      return "none";
    case "norm":
      return "norm";
    case "lighten":
      return "lighten";
    case "lightenLess":
      return "lightenLess";
    case "darken":
      return "darken";
    case "darkenLess":
      return "darkenLess";
    default:
      return "norm";
  }
}
function parseAdjustValues(element) {
  if (!element)
    return [];
  const avLst = getChild(element, "a:avLst");
  if (!avLst)
    return [];
  const values = [];
  for (const gd of getChildren(avLst, "a:gd")) {
    const name = getAttr(gd, "name");
    const fmla = getAttr(gd, "fmla");
    if (name && fmla) {
      const match = fmla.match(/^val\s+(\d+)$/);
      if (match) {
        values.push({ name, value: parseInt(match[1], 10) });
      }
    }
  }
  return values;
}
function parseAdjustHandles(element) {
  if (!element)
    return [];
  const ahLst = getChild(element, "a:ahLst");
  if (!ahLst)
    return [];
  const handles = [];
  for (const child of ahLst.children) {
    if (!isXmlElement(child))
      continue;
    if (child.name === "a:ahXY") {
      const handle = parseAdjustHandleXY(child);
      if (handle)
        handles.push(handle);
    }
    if (child.name === "a:ahPolar") {
      const handle = parseAdjustHandlePolar(child);
      if (handle)
        handles.push(handle);
    }
  }
  return handles;
}
function parseAdjCoordinate(value) {
  if (!value)
    return;
  const parsed = parseInt(value, 10);
  return Number.isNaN(parsed) ? undefined : parsed;
}
function parseAdjAngleValue(element, attr) {
  const raw = getAttr(element, attr);
  if (!raw)
    return;
  const parsed = getAngleAttr2(element, attr);
  if (parsed !== undefined)
    return parsed;
  return raw;
}
function parseAdjustHandleXY(element) {
  const pos = getChild(element, "a:pos");
  if (!pos)
    return;
  return {
    type: "xy",
    position: parsePoint(pos),
    guideX: getAttr(element, "gdRefX"),
    guideY: getAttr(element, "gdRefY"),
    minX: parseAdjCoordinate(getAttr(element, "minX")),
    maxX: parseAdjCoordinate(getAttr(element, "maxX")),
    minY: parseAdjCoordinate(getAttr(element, "minY")),
    maxY: parseAdjCoordinate(getAttr(element, "maxY"))
  };
}
function parseAdjustHandlePolar(element) {
  const pos = getChild(element, "a:pos");
  if (!pos)
    return;
  return {
    type: "polar",
    position: parsePoint(pos),
    guideAngle: getAttr(element, "gdRefAng"),
    guideRadius: getAttr(element, "gdRefR"),
    minAngle: parseAdjAngleValue(element, "minAng"),
    maxAngle: parseAdjAngleValue(element, "maxAng"),
    minRadius: parseAdjCoordinate(getAttr(element, "minR")),
    maxRadius: parseAdjCoordinate(getAttr(element, "maxR"))
  };
}
function parsePresetGeometry(prstGeom) {
  const preset = getAttr(prstGeom, "prst");
  if (!preset)
    return;
  return {
    type: "preset",
    preset,
    adjustValues: parseAdjustValues(prstGeom)
  };
}
function parsePoint(element) {
  const x2 = getEmuAttr2(element, "x") ?? px(0);
  const y = getEmuAttr2(element, "y") ?? px(0);
  return { x: x2, y };
}
function parseMoveToCommand(element) {
  const pt2 = getChild(element, "a:pt");
  if (!pt2)
    return;
  return { type: "moveTo", point: parsePoint(pt2) };
}
function parseLineToCommand(element) {
  const pt2 = getChild(element, "a:pt");
  if (!pt2)
    return;
  return { type: "lineTo", point: parsePoint(pt2) };
}
function parseArcToCommand(element) {
  return {
    type: "arcTo",
    widthRadius: getEmuAttr2(element, "wR") ?? px(0),
    heightRadius: getEmuAttr2(element, "hR") ?? px(0),
    startAngle: getAngleAttr2(element, "stAng") ?? deg(0),
    swingAngle: getAngleAttr2(element, "swAng") ?? deg(0)
  };
}
function parseQuadBezierCommand(element) {
  const pts = getChildren(element, "a:pt");
  if (pts.length < 2)
    return;
  return {
    type: "quadBezierTo",
    control: parsePoint(pts[0]),
    end: parsePoint(pts[1])
  };
}
function parseCubicBezierCommand(element) {
  const pts = getChildren(element, "a:pt");
  if (pts.length < 3)
    return;
  return {
    type: "cubicBezierTo",
    control1: parsePoint(pts[0]),
    control2: parsePoint(pts[1]),
    end: parsePoint(pts[2])
  };
}
function parsePathCommands(path) {
  const commands = [];
  for (const child of path.children) {
    if (!isXmlElement(child))
      continue;
    switch (child.name) {
      case "a:moveTo": {
        const cmd = parseMoveToCommand(child);
        if (cmd)
          commands.push(cmd);
        break;
      }
      case "a:lnTo": {
        const cmd = parseLineToCommand(child);
        if (cmd)
          commands.push(cmd);
        break;
      }
      case "a:arcTo": {
        const cmd = parseArcToCommand(child);
        if (cmd)
          commands.push(cmd);
        break;
      }
      case "a:quadBezTo": {
        const cmd = parseQuadBezierCommand(child);
        if (cmd)
          commands.push(cmd);
        break;
      }
      case "a:cubicBezTo": {
        const cmd = parseCubicBezierCommand(child);
        if (cmd)
          commands.push(cmd);
        break;
      }
      case "a:close":
        commands.push({ type: "close" });
        break;
    }
  }
  return commands;
}
function parseGeometryPath(path) {
  return {
    width: getEmuAttr2(path, "w") ?? px(0),
    height: getEmuAttr2(path, "h") ?? px(0),
    fill: mapPathFillMode(getAttr(path, "fill")),
    stroke: getBoolAttrOr2(path, "stroke", true),
    extrusionOk: getBoolAttrOr2(path, "extrusionOk", true),
    commands: parsePathCommands(path)
  };
}
function parseGuides(element) {
  if (!element)
    return [];
  const gdLst = getChild(element, "a:gdLst");
  if (!gdLst)
    return [];
  const guides = [];
  for (const gd of getChildren(gdLst, "a:gd")) {
    const name = getAttr(gd, "name");
    const fmla = getAttr(gd, "fmla");
    if (name && fmla) {
      guides.push({ name, formula: fmla });
    }
  }
  return guides;
}
function parseConnectionSites(element) {
  if (!element)
    return [];
  const cxnLst = getChild(element, "a:cxnLst");
  if (!cxnLst)
    return [];
  const sites = [];
  for (const cxn of getChildren(cxnLst, "a:cxn")) {
    const ang = getAngleAttr2(cxn, "ang");
    const pos = getChild(cxn, "a:pos");
    if (ang !== undefined && pos) {
      sites.push({
        angle: ang,
        position: parsePoint(pos)
      });
    }
  }
  return sites;
}
function parseTextRect(element) {
  if (!element)
    return;
  const rect = getChild(element, "a:rect");
  if (!rect)
    return;
  return {
    left: getAttr(rect, "l") ?? "0",
    top: getAttr(rect, "t") ?? "0",
    right: getAttr(rect, "r") ?? "0",
    bottom: getAttr(rect, "b") ?? "0"
  };
}
function parseCustomGeometry(custGeom) {
  const pathLst = getChild(custGeom, "a:pathLst");
  if (!pathLst)
    return;
  const paths = [];
  for (const path of getChildren(pathLst, "a:path")) {
    paths.push(parseGeometryPath(path));
  }
  if (paths.length === 0)
    return;
  return {
    type: "custom",
    paths,
    adjustValues: parseAdjustValues(custGeom),
    adjustHandles: parseAdjustHandles(custGeom),
    guides: parseGuides(custGeom),
    connectionSites: parseConnectionSites(custGeom),
    textRect: parseTextRect(custGeom)
  };
}
function parseGeometry(spPr) {
  if (!spPr)
    return;
  const prstGeom = getChild(spPr, "a:prstGeom");
  if (prstGeom) {
    return parsePresetGeometry(prstGeom);
  }
  const custGeom = getChild(spPr, "a:custGeom");
  if (custGeom) {
    return parseCustomGeometry(custGeom);
  }
  return;
}

// packages/@oxen-office/pptx/src/parser/shape-parser/three-d.ts
function toSolidFill(color) {
  if (!color) {
    return;
  }
  return { type: "solidFill", color };
}
function parseRotation(element) {
  if (!element) {
    return;
  }
  const latitude = getAngleAttr2(element, "lat");
  const longitude = getAngleAttr2(element, "lon");
  const revolution = getAngleAttr2(element, "rev");
  if (latitude === undefined || longitude === undefined || revolution === undefined) {
    return;
  }
  return { latitude, longitude, revolution };
}
function isBevelPresetType2(value) {
  switch (value) {
    case "angle":
    case "artDeco":
    case "circle":
    case "convex":
    case "coolSlant":
    case "cross":
    case "divot":
    case "hardEdge":
    case "relaxedInset":
    case "riblet":
    case "slope":
    case "softRound":
      return true;
    default:
      return false;
  }
}
var DEFAULT_BEVEL_SIZE_EMU = 76200;
var DEFAULT_BEVEL_SIZE_PX = DEFAULT_BEVEL_SIZE_EMU / 914400 * 96;
function parseBevel2(element) {
  if (!element) {
    return;
  }
  const width = getEmuAttr2(element, "w") ?? px(DEFAULT_BEVEL_SIZE_PX);
  const height = getEmuAttr2(element, "h") ?? px(DEFAULT_BEVEL_SIZE_PX);
  const presetAttr = getAttr(element, "prst");
  const preset = isBevelPresetType2(presetAttr) ? presetAttr : "circle";
  return { width, height, preset };
}
function isPresetMaterialType2(value) {
  switch (value) {
    case "clear":
    case "dkEdge":
    case "flat":
    case "legacyMatte":
    case "legacyMetal":
    case "legacyPlastic":
    case "legacyWireframe":
    case "matte":
    case "metal":
    case "plastic":
    case "powder":
    case "softEdge":
    case "softmetal":
    case "translucentPowder":
    case "warmMatte":
      return true;
    default:
      return false;
  }
}
function parsePresetCameraType(value) {
  return isPresetCameraType(value) ? value : undefined;
}
function parseLightRigType(value) {
  return isLightRigType2(value) ? value : undefined;
}
function parseLightRigDirection(value) {
  return isLightRigDirection2(value) ? value : undefined;
}
function isPresetCameraType(value) {
  switch (value) {
    case "isometricBottomDown":
    case "isometricBottomUp":
    case "isometricLeftDown":
    case "isometricLeftUp":
    case "isometricOffAxis1Left":
    case "isometricOffAxis1Right":
    case "isometricOffAxis1Top":
    case "isometricOffAxis2Left":
    case "isometricOffAxis2Right":
    case "isometricOffAxis2Top":
    case "isometricOffAxis3Bottom":
    case "isometricOffAxis3Left":
    case "isometricOffAxis3Right":
    case "isometricOffAxis4Bottom":
    case "isometricOffAxis4Left":
    case "isometricOffAxis4Right":
    case "isometricRightDown":
    case "isometricRightUp":
    case "isometricTopDown":
    case "isometricTopUp":
    case "legacyObliqueBottom":
    case "legacyObliqueBottomLeft":
    case "legacyObliqueBottomRight":
    case "legacyObliqueFront":
    case "legacyObliqueLeft":
    case "legacyObliqueRight":
    case "legacyObliqueTop":
    case "legacyObliqueTopLeft":
    case "legacyObliqueTopRight":
    case "legacyPerspectiveBottom":
    case "legacyPerspectiveBottomLeft":
    case "legacyPerspectiveBottomRight":
    case "legacyPerspectiveFront":
    case "legacyPerspectiveLeft":
    case "legacyPerspectiveRight":
    case "legacyPerspectiveTop":
    case "legacyPerspectiveTopLeft":
    case "legacyPerspectiveTopRight":
    case "obliqueBottom":
    case "obliqueBottomLeft":
    case "obliqueBottomRight":
    case "obliqueLeft":
    case "obliqueRight":
    case "obliqueTop":
    case "obliqueTopLeft":
    case "obliqueTopRight":
    case "orthographicFront":
    case "perspectiveAbove":
    case "perspectiveAboveLeftFacing":
    case "perspectiveAboveRightFacing":
    case "perspectiveBelow":
    case "perspectiveContrastingLeftFacing":
    case "perspectiveContrastingRightFacing":
    case "perspectiveFront":
    case "perspectiveHeroicExtremeLeftFacing":
    case "perspectiveHeroicExtremeRightFacing":
    case "perspectiveHeroicLeftFacing":
    case "perspectiveHeroicRightFacing":
    case "perspectiveLeft":
    case "perspectiveRelaxed":
    case "perspectiveRelaxedModerately":
    case "perspectiveRight":
      return true;
    default:
      return false;
  }
}
function isLightRigType2(value) {
  switch (value) {
    case "balanced":
    case "brightRoom":
    case "chilly":
    case "contrasting":
    case "flat":
    case "flood":
    case "freezing":
    case "glow":
    case "harsh":
    case "legacyFlat1":
    case "legacyFlat2":
    case "legacyFlat3":
    case "legacyFlat4":
    case "legacyHarsh1":
    case "legacyHarsh2":
    case "legacyHarsh3":
    case "legacyHarsh4":
    case "legacyNormal1":
    case "legacyNormal2":
    case "legacyNormal3":
    case "legacyNormal4":
    case "morning":
    case "soft":
    case "sunrise":
    case "sunset":
    case "threePt":
    case "twoPt":
      return true;
    default:
      return false;
  }
}
function isLightRigDirection2(value) {
  switch (value) {
    case "b":
    case "bl":
    case "br":
    case "l":
    case "r":
    case "t":
    case "tl":
    case "tr":
      return true;
    default:
      return false;
  }
}
function parseScene3d(spPr) {
  if (!spPr) {
    return;
  }
  const scene3d = getChild(spPr, "a:scene3d");
  if (!scene3d) {
    return;
  }
  const cameraEl = getChild(scene3d, "a:camera");
  const lightRigEl = getChild(scene3d, "a:lightRig");
  if (!cameraEl || !lightRigEl) {
    return;
  }
  const cameraPreset = parsePresetCameraType(getAttr(cameraEl, "prst"));
  const lightRig = parseLightRigType(getAttr(lightRigEl, "rig"));
  const lightDir = parseLightRigDirection(getAttr(lightRigEl, "dir"));
  if (!cameraPreset || !lightRig || !lightDir) {
    return;
  }
  const cameraRotation = parseRotation(getChild(cameraEl, "a:rot"));
  const lightRotation = parseRotation(getChild(lightRigEl, "a:rot"));
  const flatTx = getChild(scene3d, "a:flatTx");
  const flatTextZ = flatTx ? getEmuAttr2(flatTx, "z") : undefined;
  return {
    camera: {
      preset: cameraPreset,
      fov: getAngleAttr2(cameraEl, "fov"),
      zoom: getPercent100kAttr2(cameraEl, "zoom"),
      rotation: cameraRotation
    },
    lightRig: {
      rig: lightRig,
      direction: lightDir,
      rotation: lightRotation
    },
    flatTextZ
  };
}
function parseShape3d(spPr) {
  if (!spPr) {
    return;
  }
  const sp3d = getChild(spPr, "a:sp3d");
  if (!sp3d) {
    return;
  }
  const extrusionColor = toSolidFill(parseColorFromParent2(getChild(sp3d, "a:extrusionClr")));
  const contourColor = toSolidFill(parseColorFromParent2(getChild(sp3d, "a:contourClr")));
  const bevelTop = parseBevel2(getChild(sp3d, "a:bevelT"));
  const bevelBottom = parseBevel2(getChild(sp3d, "a:bevelB"));
  const materialAttr = getAttr(sp3d, "prstMaterial");
  const material = isPresetMaterialType2(materialAttr) ? materialAttr : "warmMatte";
  return {
    z: getEmuAttr2(sp3d, "z"),
    extrusionHeight: getEmuAttr2(sp3d, "extrusionH"),
    contourWidth: getEmuAttr2(sp3d, "contourW"),
    preset: material,
    extrusionColor,
    contourColor,
    bevelTop,
    bevelBottom
  };
}

// packages/@oxen-office/pptx/src/parser/text/resolver/constants.ts
var TYPE_TO_MASTER_STYLE2 = {
  ctrTitle: "titleStyle",
  title: "titleStyle",
  subTitle: "bodyStyle",
  body: "bodyStyle",
  obj: "bodyStyle",
  chart: "bodyStyle",
  tbl: "bodyStyle",
  clipArt: "bodyStyle",
  dgm: "bodyStyle",
  media: "bodyStyle",
  pic: "bodyStyle",
  sldImg: "bodyStyle",
  dt: "otherStyle",
  ftr: "otherStyle",
  sldNum: "otherStyle",
  hdr: "otherStyle"
};

// packages/@oxen-office/pptx/src/parser/text/resolver/placeholder.ts
function lookupPlaceholder(tables, type, idx) {
  if (type !== undefined && tables.byType[type] !== undefined) {
    return tables.byType[type];
  }
  if (idx !== undefined) {
    const byIdx = tables.byIdx.get(idx);
    if (byIdx !== undefined) {
      return byIdx;
    }
  }
  return;
}

// packages/@oxen-office/pptx/src/parser/text/resolver/font-size.ts
function parseFontSize2(sz) {
  if (sz === undefined) {
    return;
  }
  const parsed = parseInt(sz, 10) / FONT_SIZE_CENTIPOINTS_TO_PT;
  return isNaN(parsed) ? undefined : pt(parsed);
}
function getFontSizeFromRPr(rPr) {
  if (rPr === undefined) {
    return;
  }
  return parseFontSize2(rPr.attrs?.sz);
}
function getFontSizeFromLstStyle(lstStyle, lvl) {
  if (lstStyle === undefined) {
    return;
  }
  const lvlpPr = `a:lvl${lvl}pPr`;
  const defRPr = getByPath(lstStyle, [lvlpPr, "a:defRPr"]);
  return getFontSizeFromRPr(defRPr);
}
function getFontSizeFromPlaceholder(placeholder, lvl) {
  if (placeholder === undefined) {
    return;
  }
  const txBody = getChild(placeholder, "p:txBody");
  const lstStyle = txBody ? getChild(txBody, "a:lstStyle") : undefined;
  return getFontSizeFromLstStyle(lstStyle, lvl);
}
function getFontSizeFromMasterTextStyles(masterTextStyles, placeholderType, lvl) {
  if (masterTextStyles === undefined || placeholderType === undefined) {
    return;
  }
  const styleKey = TYPE_TO_MASTER_STYLE2[placeholderType];
  if (styleKey === undefined) {
    return;
  }
  const style = masterTextStyles[styleKey];
  if (style === undefined) {
    return;
  }
  const lvlpPr = `a:lvl${lvl}pPr`;
  const defRPr = getByPath(style, [lvlpPr, "a:defRPr"]);
  return getFontSizeFromRPr(defRPr);
}
function resolveFontSize(directRPr, ...rest) {
  const [localLstStyle, lvl, ctx] = rest;
  const lvlKey = lvl + 1;
  const directSz = getFontSizeFromRPr(directRPr);
  if (directSz !== undefined) {
    return directSz;
  }
  const localSz = getFontSizeFromLstStyle(localLstStyle, lvlKey);
  if (localSz !== undefined) {
    return localSz;
  }
  if (ctx === undefined) {
    return pt(DEFAULT_FONT_SIZE_PT);
  }
  const layoutPh = lookupPlaceholder(ctx.layoutPlaceholders, ctx.placeholderType, ctx.placeholderIdx);
  const layoutSz = getFontSizeFromPlaceholder(layoutPh, lvlKey);
  if (layoutSz !== undefined) {
    return layoutSz;
  }
  const masterPh = lookupPlaceholder(ctx.masterPlaceholders, ctx.placeholderType, ctx.placeholderIdx);
  const masterPhSz = getFontSizeFromPlaceholder(masterPh, lvlKey);
  if (masterPhSz !== undefined) {
    return masterPhSz;
  }
  const masterStyleSz = getFontSizeFromMasterTextStyles(ctx.masterTextStyles, ctx.placeholderType, lvlKey);
  if (masterStyleSz !== undefined) {
    return masterStyleSz;
  }
  if (ctx.defaultTextStyle !== undefined) {
    const lvlpPr = `a:lvl${lvlKey}pPr`;
    const defRPr = getByPath(ctx.defaultTextStyle, [lvlpPr, "a:defRPr"]);
    const defaultSz = getFontSizeFromRPr(defRPr);
    if (defaultSz !== undefined) {
      return defaultSz;
    }
  }
  return pt(DEFAULT_FONT_SIZE_PT);
}
// packages/@oxen-office/pptx/src/parser/text/resolver/alignment.ts
function getAlignmentFromPPr(pPr) {
  if (pPr === undefined) {
    return;
  }
  const algn = pPr.attrs?.algn;
  if (algn === undefined) {
    return;
  }
  switch (algn) {
    case "l":
      return "left";
    case "ctr":
      return "center";
    case "r":
      return "right";
    case "just":
      return "justify";
    case "justLow":
      return "justifyLow";
    case "dist":
      return "distributed";
    case "thaiDist":
      return "thaiDistributed";
    default:
      return;
  }
}
function getAlignmentFromLstStyle(lstStyle, lvl) {
  if (lstStyle === undefined) {
    return;
  }
  const lvlpPr = `a:lvl${lvl}pPr`;
  const pPr = getChild(lstStyle, lvlpPr);
  return getAlignmentFromPPr(pPr);
}
function getAlignmentFromPlaceholder(placeholder, lvl) {
  if (placeholder === undefined) {
    return;
  }
  const txBody = getChild(placeholder, "p:txBody");
  const lstStyle = txBody ? getChild(txBody, "a:lstStyle") : undefined;
  return getAlignmentFromLstStyle(lstStyle, lvl);
}
function getAlignmentFromMasterTextStyles(masterTextStyles, placeholderType, lvl) {
  if (masterTextStyles === undefined || placeholderType === undefined) {
    return;
  }
  const styleKey = TYPE_TO_MASTER_STYLE2[placeholderType];
  if (styleKey === undefined) {
    return;
  }
  const style = masterTextStyles[styleKey];
  if (style === undefined) {
    return;
  }
  const lvlpPr = `a:lvl${lvl}pPr`;
  const pPr = getChild(style, lvlpPr);
  return getAlignmentFromPPr(pPr);
}
function resolveAlignment(directAlgn, ...rest) {
  const [localLstStyle, lvl, ctx] = rest;
  const lvlKey = lvl + 1;
  if (directAlgn !== undefined) {
    switch (directAlgn) {
      case "l":
        return "left";
      case "ctr":
        return "center";
      case "r":
        return "right";
      case "just":
        return "justify";
      case "justLow":
        return "justifyLow";
      case "dist":
        return "distributed";
      case "thaiDist":
        return "thaiDistributed";
    }
  }
  const localAlgn = getAlignmentFromLstStyle(localLstStyle, lvlKey);
  if (localAlgn !== undefined) {
    return localAlgn;
  }
  if (ctx === undefined) {
    return "left";
  }
  const layoutPh = lookupPlaceholder(ctx.layoutPlaceholders, ctx.placeholderType, ctx.placeholderIdx);
  const layoutAlgn = getAlignmentFromPlaceholder(layoutPh, lvlKey);
  if (layoutAlgn !== undefined) {
    return layoutAlgn;
  }
  const masterPh = lookupPlaceholder(ctx.masterPlaceholders, ctx.placeholderType, ctx.placeholderIdx);
  const masterPhAlgn = getAlignmentFromPlaceholder(masterPh, lvlKey);
  if (masterPhAlgn !== undefined) {
    return masterPhAlgn;
  }
  const masterStyleAlgn = getAlignmentFromMasterTextStyles(ctx.masterTextStyles, ctx.placeholderType, lvlKey);
  if (masterStyleAlgn !== undefined) {
    return masterStyleAlgn;
  }
  if (ctx.defaultTextStyle !== undefined) {
    const lvlpPr = `a:lvl${lvlKey}pPr`;
    const pPr = getChild(ctx.defaultTextStyle, lvlpPr);
    const defaultAlgn = getAlignmentFromPPr(pPr);
    if (defaultAlgn !== undefined) {
      return defaultAlgn;
    }
  }
  return "left";
}
// packages/@oxen-office/pptx/src/parser/text/resolver/color.ts
function getColorFromRPr(rPr) {
  if (rPr === undefined) {
    return;
  }
  const solidFill = getChild(rPr, "a:solidFill");
  if (solidFill === undefined) {
    return;
  }
  return parseColorFromParent2(solidFill);
}
function getColorFromLstStyle(lstStyle, lvl) {
  if (lstStyle === undefined) {
    return;
  }
  const lvlpPr = `a:lvl${lvl}pPr`;
  const defRPr = getByPath(lstStyle, [lvlpPr, "a:defRPr"]);
  return getColorFromRPr(defRPr);
}
function getColorFromPlaceholder(placeholder, lvl) {
  if (placeholder === undefined) {
    return;
  }
  const txBody = getChild(placeholder, "p:txBody");
  const lstStyle = txBody ? getChild(txBody, "a:lstStyle") : undefined;
  return getColorFromLstStyle(lstStyle, lvl);
}
function getColorFromMasterTextStyles(masterTextStyles, placeholderType, lvl) {
  if (masterTextStyles === undefined || placeholderType === undefined) {
    return;
  }
  const styleKey = TYPE_TO_MASTER_STYLE2[placeholderType];
  if (styleKey === undefined) {
    return;
  }
  const style = masterTextStyles[styleKey];
  if (style === undefined) {
    return;
  }
  const lvlpPr = `a:lvl${lvl}pPr`;
  const defRPr = getByPath(style, [lvlpPr, "a:defRPr"]);
  return getColorFromRPr(defRPr);
}
function resolveTextColor(directRPr, ...rest) {
  const [localLstStyle, lvl, ctx] = rest;
  const lvlKey = lvl + 1;
  const directColor = getColorFromRPr(directRPr);
  if (directColor !== undefined) {
    return directColor;
  }
  const localColor = getColorFromLstStyle(localLstStyle, lvlKey);
  if (localColor !== undefined) {
    return localColor;
  }
  if (ctx === undefined) {
    return;
  }
  const layoutPh = lookupPlaceholder(ctx.layoutPlaceholders, ctx.placeholderType, ctx.placeholderIdx);
  const layoutColor = getColorFromPlaceholder(layoutPh, lvlKey);
  if (layoutColor !== undefined) {
    return layoutColor;
  }
  const masterPh = lookupPlaceholder(ctx.masterPlaceholders, ctx.placeholderType, ctx.placeholderIdx);
  const masterPhColor = getColorFromPlaceholder(masterPh, lvlKey);
  if (masterPhColor !== undefined) {
    return masterPhColor;
  }
  if (ctx.shapeFontReferenceColor !== undefined) {
    return ctx.shapeFontReferenceColor;
  }
  const masterStyleColor = getColorFromMasterTextStyles(ctx.masterTextStyles, ctx.placeholderType, lvlKey);
  if (masterStyleColor !== undefined) {
    return masterStyleColor;
  }
  if (ctx.defaultTextStyle !== undefined) {
    const lvlpPr = `a:lvl${lvlKey}pPr`;
    const defRPr = getByPath(ctx.defaultTextStyle, [lvlpPr, "a:defRPr"]);
    const defaultColor = getColorFromRPr(defRPr);
    if (defaultColor !== undefined) {
      return defaultColor;
    }
  }
  return;
}
// packages/@oxen-office/pptx/src/parser/text/resolver/bullet.ts
function getBulletPropertiesFromPPr(pPr) {
  if (pPr === undefined) {
    return;
  }
  const result = {};
  const propertyState = { hasProperty: false };
  const buNone = getChild(pPr, "a:buNone");
  if (buNone !== undefined) {
    result.none = true;
    propertyState.hasProperty = true;
  }
  const buChar = getChild(pPr, "a:buChar");
  if (buChar !== undefined) {
    result.char = buChar.attrs?.char;
    propertyState.hasProperty = true;
  }
  const buAutoNum = getChild(pPr, "a:buAutoNum");
  if (buAutoNum !== undefined) {
    result.autoNumType = buAutoNum.attrs?.type;
    const startAt = buAutoNum.attrs?.startAt;
    if (startAt !== undefined) {
      result.autoNumStartAt = parseTextBulletStartAt(startAt);
    }
    propertyState.hasProperty = true;
  }
  const buBlip = getChild(pPr, "a:buBlip");
  if (buBlip !== undefined) {
    const blip = getChild(buBlip, "a:blip");
    if (blip !== undefined) {
      result.blipResourceId = blip.attrs?.["r:embed"] ?? blip.attrs?.["r:link"];
    }
    propertyState.hasProperty = true;
  }
  const buFont = getChild(pPr, "a:buFont");
  if (buFont !== undefined) {
    result.font = buFont.attrs?.typeface;
    propertyState.hasProperty = true;
  }
  const buFontTx = getChild(pPr, "a:buFontTx");
  if (buFontTx !== undefined) {
    result.fontFollowText = true;
    propertyState.hasProperty = true;
  }
  const buClr = getChild(pPr, "a:buClr");
  if (buClr !== undefined) {
    result.color = parseColorFromParent2(buClr);
    propertyState.hasProperty = true;
  }
  const buClrTx = getChild(pPr, "a:buClrTx");
  if (buClrTx !== undefined) {
    result.colorFollowText = true;
    propertyState.hasProperty = true;
  }
  const buSzPct = getChild(pPr, "a:buSzPct");
  if (buSzPct !== undefined) {
    const val = parseTextBulletSize(buSzPct.attrs?.val);
    if (val !== undefined) {
      result.sizePercent = val;
    }
    propertyState.hasProperty = true;
  }
  const buSzPts = getChild(pPr, "a:buSzPts");
  if (buSzPts !== undefined) {
    const val = buSzPts.attrs?.val;
    if (val !== undefined) {
      result.sizePoints = pt(parseInt(val, 10) / 100);
    }
    propertyState.hasProperty = true;
  }
  const buSzTx = getChild(pPr, "a:buSzTx");
  if (buSzTx !== undefined) {
    result.sizeFollowText = true;
    propertyState.hasProperty = true;
  }
  return propertyState.hasProperty ? result : undefined;
}
function getBulletPropertiesFromLstStyle(lstStyle, lvl) {
  if (lstStyle === undefined) {
    return;
  }
  const lvlpPr = `a:lvl${lvl}pPr`;
  const pPr = getChild(lstStyle, lvlpPr);
  return getBulletPropertiesFromPPr(pPr);
}
function getBulletPropertiesFromPlaceholder(placeholder, lvl) {
  if (placeholder === undefined) {
    return;
  }
  const txBody = getChild(placeholder, "p:txBody");
  const lstStyle = txBody ? getChild(txBody, "a:lstStyle") : undefined;
  return getBulletPropertiesFromLstStyle(lstStyle, lvl);
}
function getBulletPropertiesFromMasterTextStyles(masterTextStyles, placeholderType, lvl) {
  if (masterTextStyles === undefined || placeholderType === undefined) {
    return;
  }
  const styleKey = TYPE_TO_MASTER_STYLE2[placeholderType];
  if (styleKey === undefined) {
    return;
  }
  const style = masterTextStyles[styleKey];
  if (style === undefined) {
    return;
  }
  const lvlpPr = `a:lvl${lvl}pPr`;
  const pPr = getChild(style, lvlpPr);
  return getBulletPropertiesFromPPr(pPr);
}
function mergeBulletProperties(...sources) {
  const result = {};
  for (const source of sources) {
    if (source === undefined) {
      continue;
    }
    if (result.none === undefined && result.char === undefined && result.autoNumType === undefined && result.blipResourceId === undefined) {
      if (source.none !== undefined) {
        result.none = source.none;
      } else if (source.char !== undefined) {
        result.char = source.char;
      } else if (source.autoNumType !== undefined) {
        result.autoNumType = source.autoNumType;
        result.autoNumStartAt = source.autoNumStartAt;
      } else if (source.blipResourceId !== undefined) {
        result.blipResourceId = source.blipResourceId;
      }
    }
    if (result.font === undefined && result.fontFollowText === undefined) {
      if (source.fontFollowText !== undefined) {
        result.fontFollowText = source.fontFollowText;
      } else if (source.font !== undefined) {
        result.font = source.font;
      }
    }
    if (result.color === undefined && result.colorFollowText === undefined) {
      if (source.colorFollowText !== undefined) {
        result.colorFollowText = source.colorFollowText;
      } else if (source.color !== undefined) {
        result.color = source.color;
      }
    }
    if (result.sizePercent === undefined && result.sizePoints === undefined && result.sizeFollowText === undefined) {
      if (source.sizeFollowText !== undefined) {
        result.sizeFollowText = source.sizeFollowText;
      } else if (source.sizePercent !== undefined) {
        result.sizePercent = source.sizePercent;
      } else if (source.sizePoints !== undefined) {
        result.sizePoints = source.sizePoints;
      }
    }
  }
  return result;
}
function resolveBulletStyle(directPPr, ...rest) {
  const [localLstStyle, lvl, ctx] = rest;
  const lvlKey = lvl + 1;
  const directProps = getBulletPropertiesFromPPr(directPPr);
  const localProps = getBulletPropertiesFromLstStyle(localLstStyle, lvlKey);
  const contextProps = resolveContextBulletProps(ctx, lvlKey);
  const layoutProps = contextProps.layoutProps;
  const masterPhProps = contextProps.masterPhProps;
  const masterStyleProps = contextProps.masterStyleProps;
  const defaultProps = contextProps.defaultProps;
  const merged = mergeBulletProperties(directProps, localProps, layoutProps, masterPhProps, masterStyleProps, defaultProps);
  if (merged.none === undefined && merged.char === undefined && merged.autoNumType === undefined && merged.blipResourceId === undefined) {
    return;
  }
  const bullet = resolveBullet(merged);
  if (!bullet) {
    return;
  }
  return {
    bullet,
    color: merged.color,
    colorFollowText: merged.colorFollowText ?? false,
    sizePercent: merged.sizePercent,
    sizePoints: merged.sizePoints,
    sizeFollowText: merged.sizeFollowText ?? false,
    font: merged.font,
    fontFollowText: merged.fontFollowText ?? false
  };
}
function resolveContextBulletProps(ctx, lvlKey) {
  if (ctx === undefined) {
    return {
      layoutProps: undefined,
      masterPhProps: undefined,
      masterStyleProps: undefined,
      defaultProps: undefined
    };
  }
  const layoutPh = lookupPlaceholder(ctx.layoutPlaceholders, ctx.placeholderType, ctx.placeholderIdx);
  const layoutProps = getBulletPropertiesFromPlaceholder(layoutPh, lvlKey);
  const masterPh = lookupPlaceholder(ctx.masterPlaceholders, ctx.placeholderType, ctx.placeholderIdx);
  const masterPhProps = getBulletPropertiesFromPlaceholder(masterPh, lvlKey);
  const masterStyleProps = getBulletPropertiesFromMasterTextStyles(ctx.masterTextStyles, ctx.placeholderType, lvlKey);
  const defaultProps = resolveDefaultBulletProps(ctx.defaultTextStyle, lvlKey);
  return { layoutProps, masterPhProps, masterStyleProps, defaultProps };
}
function resolveDefaultBulletProps(defaultTextStyle, lvlKey) {
  if (defaultTextStyle === undefined) {
    return;
  }
  const lvlpPr = `a:lvl${lvlKey}pPr`;
  const pPr = getChild(defaultTextStyle, lvlpPr);
  return getBulletPropertiesFromPPr(pPr);
}
function resolveBullet(merged) {
  if (merged.none === true) {
    return { type: "none" };
  }
  if (merged.char !== undefined) {
    return { type: "char", char: merged.char };
  }
  if (merged.autoNumType !== undefined) {
    return {
      type: "auto",
      scheme: merged.autoNumType,
      startAt: merged.autoNumStartAt
    };
  }
  if (merged.blipResourceId !== undefined) {
    return { type: "blip", resourceId: merged.blipResourceId };
  }
  return;
}
// packages/@oxen-office/pptx/src/parser/text/resolver/spacing.ts
function parseSpacingElement(element) {
  if (element === undefined) {
    return;
  }
  const spcPct = getChild(element, "a:spcPct");
  if (spcPct !== undefined) {
    const val = parsePercentage100k2(spcPct.attrs?.val);
    if (val !== undefined) {
      return { type: "percent", value: val };
    }
  }
  const spcPts = getChild(element, "a:spcPts");
  if (spcPts !== undefined) {
    const val = parseTextSpacingPoint(spcPts.attrs?.val);
    if (val !== undefined) {
      return { type: "points", value: val };
    }
  }
  return;
}
function getSpacingFromPPr(pPr, spacingType) {
  if (pPr === undefined) {
    return;
  }
  const spacingElement = getChild(pPr, spacingType);
  return parseSpacingElement(spacingElement);
}
function getSpacingFromLstStyle(lstStyle, lvl, spacingType) {
  if (lstStyle === undefined) {
    return;
  }
  const lvlpPr = `a:lvl${lvl}pPr`;
  const pPr = getChild(lstStyle, lvlpPr);
  return getSpacingFromPPr(pPr, spacingType);
}
function getSpacingFromPlaceholder(placeholder, lvl, spacingType) {
  if (placeholder === undefined) {
    return;
  }
  const txBody = getChild(placeholder, "p:txBody");
  const lstStyle = txBody ? getChild(txBody, "a:lstStyle") : undefined;
  return getSpacingFromLstStyle(lstStyle, lvl, spacingType);
}
function getSpacingFromMasterTextStyles({ masterTextStyles, placeholderType, lvl, spacingType }) {
  if (masterTextStyles === undefined || placeholderType === undefined) {
    return;
  }
  const styleKey = TYPE_TO_MASTER_STYLE2[placeholderType];
  if (styleKey === undefined) {
    return;
  }
  const style = masterTextStyles[styleKey];
  if (style === undefined) {
    return;
  }
  const lvlpPr = `a:lvl${lvl}pPr`;
  const pPr = getChild(style, lvlpPr);
  return getSpacingFromPPr(pPr, spacingType);
}
function resolveSpacing({ directPPr, localLstStyle, lvl, ctx, spacingType }) {
  const lvlKey = lvl + 1;
  const directSpacing = getSpacingFromPPr(directPPr, spacingType);
  if (directSpacing !== undefined) {
    return directSpacing;
  }
  const localSpacing = getSpacingFromLstStyle(localLstStyle, lvlKey, spacingType);
  if (localSpacing !== undefined) {
    return localSpacing;
  }
  if (ctx === undefined) {
    return;
  }
  const layoutPh = lookupPlaceholder(ctx.layoutPlaceholders, ctx.placeholderType, ctx.placeholderIdx);
  const layoutSpacing = getSpacingFromPlaceholder(layoutPh, lvlKey, spacingType);
  if (layoutSpacing !== undefined) {
    return layoutSpacing;
  }
  const masterPh = lookupPlaceholder(ctx.masterPlaceholders, ctx.placeholderType, ctx.placeholderIdx);
  const masterPhSpacing = getSpacingFromPlaceholder(masterPh, lvlKey, spacingType);
  if (masterPhSpacing !== undefined) {
    return masterPhSpacing;
  }
  const masterStyleSpacing = getSpacingFromMasterTextStyles({ masterTextStyles: ctx.masterTextStyles, placeholderType: ctx.placeholderType, lvl: lvlKey, spacingType });
  if (masterStyleSpacing !== undefined) {
    return masterStyleSpacing;
  }
  if (ctx.defaultTextStyle !== undefined) {
    const lvlpPr = `a:lvl${lvlKey}pPr`;
    const pPr = getChild(ctx.defaultTextStyle, lvlpPr);
    const defaultSpacing = getSpacingFromPPr(pPr, spacingType);
    if (defaultSpacing !== undefined) {
      return defaultSpacing;
    }
  }
  return;
}
function resolveSpaceBefore({ directPPr, localLstStyle, lvl, ctx }) {
  return resolveSpacing({ directPPr, localLstStyle, lvl, ctx, spacingType: "a:spcBef" });
}
function resolveSpaceAfter({ directPPr, localLstStyle, lvl, ctx }) {
  return resolveSpacing({ directPPr, localLstStyle, lvl, ctx, spacingType: "a:spcAft" });
}
function resolveLineSpacing({ directPPr, localLstStyle, lvl, ctx }) {
  return resolveSpacing({ directPPr, localLstStyle, lvl, ctx, spacingType: "a:lnSpc" });
}
// packages/@oxen-office/pptx/src/parser/text/resolver/margin.ts
function getMarginFromPPr(pPr, attrName) {
  if (pPr === undefined) {
    return;
  }
  if (attrName === "indent") {
    return parseTextIndent(pPr.attrs?.indent);
  }
  return parseTextMargin(pPr.attrs?.[attrName]);
}
function getMarginFromLstStyle(lstStyle, lvl, attrName) {
  if (lstStyle === undefined) {
    return;
  }
  const lvlpPr = `a:lvl${lvl}pPr`;
  const pPr = getChild(lstStyle, lvlpPr);
  return getMarginFromPPr(pPr, attrName);
}
function getMarginFromPlaceholder(placeholder, lvl, attrName) {
  if (placeholder === undefined) {
    return;
  }
  const txBody = getChild(placeholder, "p:txBody");
  const lstStyle = txBody ? getChild(txBody, "a:lstStyle") : undefined;
  return getMarginFromLstStyle(lstStyle, lvl, attrName);
}
function getMarginFromMasterTextStyles({ masterTextStyles, placeholderType, lvl, attrName }) {
  if (masterTextStyles === undefined || placeholderType === undefined) {
    return;
  }
  const styleKey = TYPE_TO_MASTER_STYLE2[placeholderType];
  if (styleKey === undefined) {
    return;
  }
  const style = masterTextStyles[styleKey];
  if (style === undefined) {
    return;
  }
  const lvlpPr = `a:lvl${lvl}pPr`;
  const pPr = getChild(style, lvlpPr);
  return getMarginFromPPr(pPr, attrName);
}
function resolveMargin({ directPPr, localLstStyle, lvl, ctx, attrName }) {
  const lvlKey = lvl + 1;
  const directMargin = getMarginFromPPr(directPPr, attrName);
  if (directMargin !== undefined) {
    return directMargin;
  }
  const localMargin = getMarginFromLstStyle(localLstStyle, lvlKey, attrName);
  if (localMargin !== undefined) {
    return localMargin;
  }
  if (ctx === undefined) {
    return;
  }
  const layoutPh = lookupPlaceholder(ctx.layoutPlaceholders, ctx.placeholderType, ctx.placeholderIdx);
  const layoutMargin = getMarginFromPlaceholder(layoutPh, lvlKey, attrName);
  if (layoutMargin !== undefined) {
    return layoutMargin;
  }
  const masterPh = lookupPlaceholder(ctx.masterPlaceholders, ctx.placeholderType, ctx.placeholderIdx);
  const masterPhMargin = getMarginFromPlaceholder(masterPh, lvlKey, attrName);
  if (masterPhMargin !== undefined) {
    return masterPhMargin;
  }
  const masterStyleMargin = getMarginFromMasterTextStyles({ masterTextStyles: ctx.masterTextStyles, placeholderType: ctx.placeholderType, lvl: lvlKey, attrName });
  if (masterStyleMargin !== undefined) {
    return masterStyleMargin;
  }
  if (ctx.defaultTextStyle !== undefined) {
    const lvlpPr = `a:lvl${lvlKey}pPr`;
    const pPr = getChild(ctx.defaultTextStyle, lvlpPr);
    const defaultMargin = getMarginFromPPr(pPr, attrName);
    if (defaultMargin !== undefined) {
      return defaultMargin;
    }
  }
  return;
}
function resolveMarginLeft({ directPPr, localLstStyle, lvl, ctx }) {
  return resolveMargin({ directPPr, localLstStyle, lvl, ctx, attrName: "marL" });
}
function resolveMarginRight({ directPPr, localLstStyle, lvl, ctx }) {
  return resolveMargin({ directPPr, localLstStyle, lvl, ctx, attrName: "marR" });
}
function resolveIndent({ directPPr, localLstStyle, lvl, ctx }) {
  return resolveMargin({ directPPr, localLstStyle, lvl, ctx, attrName: "indent" });
}
// packages/@oxen-office/pptx/src/parser/text/text-parser.ts
function parseAutoFit(bodyPr) {
  if (getChild(bodyPr, "a:spAutoFit")) {
    return { type: "shape" };
  }
  const normAutofit = getChild(bodyPr, "a:normAutofit");
  if (normAutofit) {
    return {
      type: "normal",
      fontScale: parseTextFontScalePercent(getAttr(normAutofit, "fontScale")),
      lineSpaceReduction: getPercentAttr(normAutofit, "lnSpcReduction")
    };
  }
  return { type: "none" };
}
function parseTextWarp(bodyPr) {
  const prstTxWarp = getChild(bodyPr, "a:prstTxWarp");
  if (!prstTxWarp) {
    return;
  }
  const preset = parseTextShapeType(getAttr(prstTxWarp, "prst"));
  if (!preset) {
    return;
  }
  const adjustValues = [];
  const avLst = getChild(prstTxWarp, "a:avLst");
  if (avLst) {
    for (const gd of getChildren(avLst, "a:gd")) {
      const name = getAttr(gd, "name");
      const fmla = getAttr(gd, "fmla");
      if (name && fmla) {
        const match = fmla.match(/^val\s+(\d+)$/);
        if (match) {
          adjustValues.push({
            name,
            value: parseInt(match[1], 10)
          });
        }
      }
    }
  }
  return {
    preset,
    adjustValues
  };
}
function mapVerticalOverflow(overflow) {
  switch (overflow) {
    case "overflow":
      return "overflow";
    case "ellipsis":
      return "ellipsis";
    case "clip":
      return "clip";
    default:
      return;
  }
}
function parseBodyProperties(bodyPr) {
  if (!bodyPr) {
    return {
      verticalType: "horz",
      wrapping: "square",
      anchor: "top",
      anchorCenter: false,
      overflow: "overflow",
      autoFit: { type: "none" },
      insets: { left: px(0), top: px(0), right: px(0), bottom: px(0) }
    };
  }
  return {
    rotation: getAngleAttr2(bodyPr, "rot"),
    verticalType: mapVerticalType(getAttr(bodyPr, "vert")),
    wrapping: mapWrapping(getAttr(bodyPr, "wrap")),
    anchor: mapAnchor(getAttr(bodyPr, "anchor")),
    anchorCenter: getBoolAttrOr2(bodyPr, "anchorCtr", false),
    overflow: mapOverflow(getAttr(bodyPr, "horzOverflow")),
    verticalOverflow: mapVerticalOverflow(getAttr(bodyPr, "vertOverflow")),
    autoFit: parseAutoFit(bodyPr),
    insets: {
      left: getEmuAttrOr(bodyPr, "lIns", px(91440 * 96 / 914400)),
      top: getEmuAttrOr(bodyPr, "tIns", px(45720 * 96 / 914400)),
      right: getEmuAttrOr(bodyPr, "rIns", px(91440 * 96 / 914400)),
      bottom: getEmuAttrOr(bodyPr, "bIns", px(45720 * 96 / 914400))
    },
    columns: parseTextColumnCount(getAttr(bodyPr, "numCol")),
    columnSpacing: getEmuAttr2(bodyPr, "spcCol"),
    upright: getBoolAttr2(bodyPr, "upright"),
    compatibleLineSpacing: getBoolAttr2(bodyPr, "compatLnSpc"),
    rtlColumns: getBoolAttr2(bodyPr, "rtlCol"),
    spaceFirstLastPara: getBoolAttr2(bodyPr, "spcFirstLastPara"),
    forceAntiAlias: getBoolAttr2(bodyPr, "forceAA"),
    fromWordArt: getBoolAttr2(bodyPr, "fromWordArt"),
    textWarp: parseTextWarp(bodyPr),
    scene3d: parseScene3d(bodyPr),
    shape3d: parseShape3d(bodyPr)
  };
}
function parseLineSpacing(element) {
  if (!element) {
    return;
  }
  const spcPct = getChild(element, "a:spcPct");
  if (spcPct) {
    const val = getPercentAttr(spcPct, "val");
    if (val !== undefined) {
      return { type: "percent", value: val };
    }
  }
  const spcPts = getChild(element, "a:spcPts");
  if (spcPts) {
    const val = parseTextSpacingPoint(getAttr(spcPts, "val"));
    if (val !== undefined) {
      return { type: "points", value: val };
    }
  }
  return;
}
function parseBullet(pPr) {
  if (getChild(pPr, "a:buNone")) {
    return { type: "none" };
  }
  const buAutoNum = getChild(pPr, "a:buAutoNum");
  if (buAutoNum) {
    return {
      type: "auto",
      scheme: getAttr(buAutoNum, "type") ?? "arabicPeriod",
      startAt: parseTextBulletStartAt(getAttr(buAutoNum, "startAt"))
    };
  }
  const buChar = getChild(pPr, "a:buChar");
  if (buChar) {
    return {
      type: "char",
      char: getAttr(buChar, "char") ?? "\u2022"
    };
  }
  const buBlip = getChild(pPr, "a:buBlip");
  if (buBlip) {
    const blip = getChild(buBlip, "a:blip");
    const resourceId = blip ? getAttr(blip, "r:embed") ?? getAttr(blip, "r:link") : undefined;
    if (resourceId) {
      return { type: "blip", resourceId };
    }
  }
  return { type: "none" };
}
function parseBulletStyle(pPr) {
  const bullet = parseBullet(pPr);
  if (bullet.type === "none" && !getChild(pPr, "a:buNone")) {
    return;
  }
  const buClr = getChild(pPr, "a:buClr");
  const color = buClr ? parseColorFromParent2(buClr) : undefined;
  const colorFollowText = getChild(pPr, "a:buClrTx") !== undefined;
  const buSzPct = getChild(pPr, "a:buSzPct");
  const buSzPts = getChild(pPr, "a:buSzPts");
  const sizePercent = buSzPct ? parseTextBulletSize(getAttr(buSzPct, "val")) : undefined;
  const sizePoints = buSzPts ? pt((getIntAttr2(buSzPts, "val") ?? 0) / 100) : undefined;
  const sizeFollowText = getChild(pPr, "a:buSzTx") !== undefined;
  const buFont = getChild(pPr, "a:buFont");
  const font = buFont ? getAttr(buFont, "typeface") : undefined;
  const fontFollowText = getChild(pPr, "a:buFontTx") !== undefined;
  return {
    bullet,
    color,
    colorFollowText,
    sizePercent,
    sizePoints,
    sizeFollowText,
    font,
    fontFollowText
  };
}
function mapVerticalType(vert) {
  switch (vert) {
    case "horz":
      return "horz";
    case "vert":
      return "vert";
    case "vert270":
      return "vert270";
    case "wordArtVert":
      return "wordArtVert";
    case "eaVert":
      return "eaVert";
    case "mongolianVert":
      return "mongolianVert";
    case "wordArtVertRtl":
      return "wordArtVertRtl";
    default:
      return "horz";
  }
}
function mapAnchor(anchor) {
  switch (anchor) {
    case "t":
      return "top";
    case "ctr":
      return "center";
    case "b":
      return "bottom";
    default:
      return "top";
  }
}
function mapWrapping(wrap) {
  switch (wrap) {
    case "none":
      return "none";
    case "square":
      return "square";
    default:
      return "square";
  }
}
function mapOverflow(overflow) {
  switch (overflow) {
    case "overflow":
      return "overflow";
    case "ellipsis":
      return "ellipsis";
    case "clip":
      return "clip";
    default:
      return "overflow";
  }
}
function mapCaps(cap) {
  switch (cap) {
    case "none":
      return "none";
    case "small":
      return "small";
    case "all":
      return "all";
    default:
      return;
  }
}
function mapStrike(strike) {
  switch (strike) {
    case "noStrike":
      return "noStrike";
    case "sngStrike":
      return "sngStrike";
    case "dblStrike":
      return "dblStrike";
    default:
      return;
  }
}
function mapUnderline(u) {
  switch (u) {
    case "none":
      return "none";
    case "words":
      return "words";
    case "sng":
      return "sng";
    case "dbl":
      return "dbl";
    case "heavy":
      return "heavy";
    case "dotted":
      return "dotted";
    case "dottedHeavy":
      return "dottedHeavy";
    case "dash":
      return "dash";
    case "dashHeavy":
      return "dashHeavy";
    case "dashLong":
      return "dashLong";
    case "dashLongHeavy":
      return "dashLongHeavy";
    case "dotDash":
      return "dotDash";
    case "dotDashHeavy":
      return "dotDashHeavy";
    case "dotDotDash":
      return "dotDotDash";
    case "dotDotDashHeavy":
      return "dotDotDashHeavy";
    case "wavy":
      return "wavy";
    case "wavyHeavy":
      return "wavyHeavy";
    case "wavyDbl":
      return "wavyDbl";
    default:
      return;
  }
}
function mapParagraphAlignment(algn) {
  switch (algn) {
    case "l":
      return "left";
    case "ctr":
      return "center";
    case "r":
      return "right";
    case "just":
      return "justify";
    case "justLow":
      return "justifyLow";
    case "dist":
      return "distributed";
    case "thaiDist":
      return "thaiDistributed";
    default:
      return "left";
  }
}
function mapTabStopAlignment(algn) {
  switch (algn) {
    case "l":
      return "left";
    case "ctr":
      return "center";
    case "r":
      return "right";
    case "dec":
      return "decimal";
    default:
      return "left";
  }
}
function mapFontAlignment(fontAlgn) {
  switch (fontAlgn) {
    case "auto":
      return "auto";
    case "base":
      return "base";
    case "t":
      return "top";
    case "ctr":
      return "center";
    case "b":
      return "bottom";
    default:
      return;
  }
}
function parseTabStops(pPr) {
  const tabLst = getChild(pPr, "a:tabLst");
  if (!tabLst) {
    return;
  }
  const tabs = [];
  for (const tab of getChildren(tabLst, "a:tab")) {
    const pos = getEmuAttr2(tab, "pos");
    if (pos !== undefined) {
      tabs.push({
        position: pos,
        alignment: mapTabStopAlignment(getAttr(tab, "algn"))
      });
    }
  }
  return tabs.length > 0 ? tabs : undefined;
}
function parseParagraphProperties(pPr) {
  if (!pPr) {
    return {};
  }
  const defRPr = getChild(pPr, "a:defRPr");
  return {
    level: parseTextIndentLevel(getAttr(pPr, "lvl")),
    alignment: mapParagraphAlignment(getAttr(pPr, "algn")),
    defaultTabSize: getEmuAttr2(pPr, "defTabSz"),
    marginLeft: parseTextMargin(getAttr(pPr, "marL")),
    marginRight: parseTextMargin(getAttr(pPr, "marR")),
    indent: parseTextIndent(getAttr(pPr, "indent")),
    lineSpacing: parseLineSpacing(getChild(pPr, "a:lnSpc")),
    spaceBefore: parseLineSpacing(getChild(pPr, "a:spcBef")),
    spaceAfter: parseLineSpacing(getChild(pPr, "a:spcAft")),
    bulletStyle: parseBulletStyle(pPr),
    tabStops: parseTabStops(pPr),
    rtl: getBoolAttr2(pPr, "rtl"),
    fontAlignment: mapFontAlignment(getAttr(pPr, "fontAlgn")),
    eaLineBreak: getBoolAttr2(pPr, "eaLnBrk"),
    latinLineBreak: getBoolAttr2(pPr, "latinLnBrk"),
    hangingPunctuation: getBoolAttr2(pPr, "hangingPunct"),
    defaultRunProperties: parseRunProperties(defRPr)
  };
}
function parseHyperlinkSound(hlink) {
  const snd = getChild(hlink, "a:snd");
  if (!snd) {
    return;
  }
  const embed = getAttr(snd, "r:embed");
  if (!embed) {
    return;
  }
  return {
    embed,
    name: getAttr(snd, "name")
  };
}
function parseHyperlink(rPr) {
  const hlinkClick = getChild(rPr, "a:hlinkClick");
  if (!hlinkClick) {
    return;
  }
  const id = getAttr(hlinkClick, "r:id");
  if (!id) {
    return;
  }
  return {
    id,
    tooltip: getAttr(hlinkClick, "tooltip"),
    action: getAttr(hlinkClick, "action"),
    sound: parseHyperlinkSound(hlinkClick)
  };
}
function parseHyperlinkMouseOver(rPr) {
  const hlinkMouseOver = getChild(rPr, "a:hlinkMouseOver");
  if (!hlinkMouseOver) {
    return;
  }
  return {
    id: getAttr(hlinkMouseOver, "r:id"),
    tooltip: getAttr(hlinkMouseOver, "tooltip"),
    action: getAttr(hlinkMouseOver, "action"),
    highlightClick: getBoolAttr2(hlinkMouseOver, "highlightClick"),
    endSound: getBoolAttr2(hlinkMouseOver, "endSnd"),
    sound: parseHyperlinkSound(hlinkMouseOver)
  };
}
function resolveUnderlineColor({
  underlineColor,
  underlineLineFollowText,
  underlineFillFollowText,
  textColor,
  underlineFillFromText
}) {
  if (underlineColor) {
    return underlineColor;
  }
  const followText = underlineLineFollowText ? true : underlineFillFollowText;
  if (!followText) {
    return;
  }
  if (textColor) {
    return textColor;
  }
  if (underlineFillFromText?.type === "solidFill") {
    return underlineFillFromText.color;
  }
  return;
}
function resolveRunProperties(runProps, fontSize, color) {
  if (runProps !== undefined) {
    return { ...runProps, fontSize, color };
  }
  return { fontSize, color };
}
function parseRunProperties(rPr) {
  if (!rPr) {
    return;
  }
  const latin = getChild(rPr, "a:latin");
  const ea = getChild(rPr, "a:ea");
  const cs = getChild(rPr, "a:cs");
  const sym = getChild(rPr, "a:sym");
  const solidFill = getChild(rPr, "a:solidFill");
  const color = parseColorFromParent2(solidFill);
  const fill = parseFillFromParent(rPr);
  const highlight = getChild(rPr, "a:highlight");
  const highlightColor = highlight ? parseColorFromParent2(highlight) : undefined;
  const uLn = getChild(rPr, "a:uLn");
  const uLnTx = getChild(rPr, "a:uLnTx");
  const uFill = getChild(rPr, "a:uFill");
  const uFillTx = getChild(rPr, "a:uFillTx");
  const ln2 = getChild(rPr, "a:ln");
  const textOutline = ln2 ? parseLine2(ln2) : undefined;
  const effects = parseEffects(rPr);
  const underlineLine = uLn ? parseLine2(uLn) : uLnTx ? textOutline : undefined;
  const underlineFillFollowText = uFillTx !== undefined;
  const underlineLineFollowText = uLnTx !== undefined;
  const underlineFillFromText = fill ?? (color ? { type: "solidFill", color } : undefined);
  const underlineFill = uFill ? parseFillFromParent(uFill) : underlineFillFollowText ? underlineFillFromText : undefined;
  const underlineColor = resolveUnderlineColor({
    underlineColor: uLn ? parseColorFromParent2(uLn) : undefined,
    underlineLineFollowText,
    underlineFillFollowText,
    textColor: color,
    underlineFillFromText
  });
  return {
    fontSize: getFontSizeAttr(rPr, "sz"),
    fontFamily: latin ? getAttr(latin, "typeface") : undefined,
    fontFamilyPitchFamily: latin ? getIntAttr2(latin, "pitchFamily") : undefined,
    fontFamilyEastAsian: ea ? getAttr(ea, "typeface") : undefined,
    fontFamilyEastAsianPitchFamily: ea ? getIntAttr2(ea, "pitchFamily") : undefined,
    fontFamilyComplexScript: cs ? getAttr(cs, "typeface") : undefined,
    fontFamilyComplexScriptPitchFamily: cs ? getIntAttr2(cs, "pitchFamily") : undefined,
    fontFamilySymbol: sym ? getAttr(sym, "typeface") : undefined,
    fontFamilySymbolPitchFamily: sym ? getIntAttr2(sym, "pitchFamily") : undefined,
    bold: getBoolAttr2(rPr, "b"),
    italic: getBoolAttr2(rPr, "i"),
    underline: mapUnderline(getAttr(rPr, "u")),
    underlineColor,
    underlineFill,
    underlineLine,
    underlineLineFollowText,
    underlineFillFollowText,
    strike: mapStrike(getAttr(rPr, "strike")),
    caps: mapCaps(getAttr(rPr, "cap")),
    baseline: getIntAttr2(rPr, "baseline"),
    spacing: getCharacterSpacingAttr(rPr, "spc"),
    kerning: parseTextNonNegativePoint(getAttr(rPr, "kern")),
    color,
    fill,
    highlightColor,
    textOutline,
    effects,
    outline: getBoolAttr2(rPr, "outline"),
    shadow: getBoolAttr2(rPr, "shadow"),
    emboss: getBoolAttr2(rPr, "emboss"),
    hyperlink: parseHyperlink(rPr),
    hyperlinkMouseOver: parseHyperlinkMouseOver(rPr),
    language: getAttr(rPr, "lang"),
    altLanguage: getAttr(rPr, "altLang"),
    noProof: getBoolAttr2(rPr, "noProof"),
    dirty: getBoolAttr2(rPr, "dirty"),
    smartTagClean: getBoolAttr2(rPr, "smtClean"),
    bookmark: getAttr(rPr, "bmk"),
    error: getBoolAttr2(rPr, "err"),
    kumimoji: getBoolAttr2(rPr, "kumimoji"),
    normalizeHeights: getBoolAttr2(rPr, "normalizeH"),
    smartTagId: getIntAttr2(rPr, "smtId"),
    rtl: getChild(rPr, "a:rtl") !== undefined
  };
}
function parseTextBody(txBody, ctx) {
  if (!txBody) {
    return;
  }
  const bodyPr = getChild(txBody, "a:bodyPr");
  const lstStyle = getChild(txBody, "a:lstStyle");
  const paragraphs = [];
  for (const p of getChildren(txBody, "a:p")) {
    paragraphs.push(parseTextParagraph(p, lstStyle, ctx));
  }
  if (paragraphs.length === 0) {
    paragraphs.push({
      properties: {},
      runs: []
    });
  }
  return {
    bodyProperties: parseBodyProperties(bodyPr),
    paragraphs
  };
}
function parseTextRun({
  runElement,
  rPr,
  localLstStyle,
  lvl,
  ctx
}) {
  const runProps = parseRunProperties(rPr);
  const resolvedFontSize = runProps?.fontSize ?? resolveFontSize(rPr, localLstStyle, lvl, ctx);
  const resolvedColor = runProps?.color ?? resolveTextColor(rPr, localLstStyle, lvl, ctx);
  const resolvedProps = resolveRunProperties(runProps, resolvedFontSize, resolvedColor);
  if (runElement.name === "a:br") {
    return {
      type: "break",
      properties: resolvedProps
    };
  }
  if (runElement.name === "a:fld") {
    const t2 = getChild(runElement, "a:t");
    return {
      type: "field",
      fieldType: getAttr(runElement, "type") ?? "",
      id: getAttr(runElement, "id") ?? "",
      text: t2 ? getTextContent(t2) ?? "" : "",
      properties: resolvedProps
    };
  }
  const t = getChild(runElement, "a:t");
  return {
    type: "text",
    text: t ? getTextContent(t) ?? "" : "",
    properties: resolvedProps
  };
}
function parseTextRunsFromParagraph({
  paragraph,
  localLstStyle,
  lvl,
  ctx
}) {
  const runs = [];
  for (const child of paragraph.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    if (child.name === "a:r" || child.name === "a:br" || child.name === "a:fld") {
      const rPr = getChild(child, "a:rPr");
      runs.push(parseTextRun({ runElement: child, rPr, localLstStyle, lvl, ctx }));
    }
  }
  return runs;
}
function parseTextParagraph(element, localLstStyle, ctx) {
  const pPr = getChild(element, "a:pPr");
  const endParaRPr = getChild(element, "a:endParaRPr");
  const props = parseParagraphProperties(pPr);
  const lvl = props.level ?? 0;
  const directAlgn = pPr ? getAttr(pPr, "algn") : undefined;
  const resolvedAlignment = resolveAlignment(directAlgn, localLstStyle, lvl, ctx);
  const resolvedBulletStyle = resolveBulletStyle(pPr, localLstStyle, lvl, ctx);
  const resolvedSpaceBefore = props.spaceBefore ?? resolveSpaceBefore({ directPPr: pPr, localLstStyle, lvl, ctx });
  const resolvedSpaceAfter = props.spaceAfter ?? resolveSpaceAfter({ directPPr: pPr, localLstStyle, lvl, ctx });
  const resolvedLineSpacing = props.lineSpacing ?? resolveLineSpacing({ directPPr: pPr, localLstStyle, lvl, ctx });
  const resolvedMarginLeft = props.marginLeft ?? resolveMarginLeft({ directPPr: pPr, localLstStyle, lvl, ctx });
  const resolvedMarginRight = props.marginRight ?? resolveMarginRight({ directPPr: pPr, localLstStyle, lvl, ctx });
  const resolvedIndent = props.indent ?? resolveIndent({ directPPr: pPr, localLstStyle, lvl, ctx });
  return {
    properties: {
      ...props,
      alignment: resolvedAlignment,
      bulletStyle: resolvedBulletStyle,
      spaceBefore: resolvedSpaceBefore,
      spaceAfter: resolvedSpaceAfter,
      lineSpacing: resolvedLineSpacing,
      marginLeft: resolvedMarginLeft,
      marginRight: resolvedMarginRight,
      indent: resolvedIndent
    },
    runs: parseTextRunsFromParagraph({ paragraph: element, localLstStyle, lvl, ctx }),
    endProperties: parseRunProperties(endParaRPr)
  };
}

// packages/@oxen-office/pptx/src/parser/shape-parser/non-visual.ts
function parseNonVisualHyperlink(cNvPr, childName) {
  const hlink = getChild(cNvPr, childName);
  if (!hlink) {
    return;
  }
  const id = getAttr(hlink, "r:id");
  if (!id) {
    return;
  }
  const sound = (() => {
    const snd = getChild(hlink, "a:snd");
    if (!snd) {
      return;
    }
    const embed = getAttr(snd, "r:embed");
    if (!embed) {
      return;
    }
    const soundValue = {
      embed,
      name: getAttr(snd, "name")
    };
    return soundValue;
  })();
  return {
    id,
    tooltip: getAttr(hlink, "tooltip"),
    action: getAttr(hlink, "action"),
    sound
  };
}
function parseNonVisualProperties(cNvPr) {
  if (!cNvPr) {
    return { id: "", name: "" };
  }
  return {
    id: getAttr(cNvPr, "id") ?? "",
    name: getAttr(cNvPr, "name") ?? "",
    description: getAttr(cNvPr, "descr"),
    title: getAttr(cNvPr, "title"),
    hidden: getBoolAttr2(cNvPr, "hidden"),
    hyperlink: parseNonVisualHyperlink(cNvPr, "a:hlinkClick"),
    hyperlinkHover: parseNonVisualHyperlink(cNvPr, "a:hlinkHover")
  };
}
function parseNonVisualMedia(nvPr) {
  if (!nvPr) {
    return;
  }
  const audioCd = getChild(nvPr, "a:audioCd");
  const audioFile = parseLinkedMediaFile(getChild(nvPr, "a:audioFile"));
  const quickTimeFile = parseQuickTimeFile(getChild(nvPr, "a:quickTimeFile"));
  const videoFile = parseLinkedMediaFile(getChild(nvPr, "a:videoFile"));
  const wavAudioFile = parseEmbeddedWavAudioFile(getChild(nvPr, "a:wavAudioFile"));
  const audioCdValue = audioCd ? parseAudioCd(audioCd) : undefined;
  const hasMedia = [
    audioCdValue,
    audioFile,
    quickTimeFile,
    videoFile,
    wavAudioFile
  ].some((value) => value !== undefined);
  if (hasMedia) {
    return {
      audioCd: audioCdValue,
      audioFile,
      quickTimeFile,
      videoFile,
      wavAudioFile
    };
  }
  return;
}
function parseAudioCd(audioCd) {
  const parseAudioCdTime = (el) => {
    if (!el) {
      return;
    }
    const track = getIntAttr2(el, "track");
    if (track === undefined) {
      return;
    }
    const time = getIntAttr2(el, "time");
    return { track, time: time ?? undefined };
  };
  const start = parseAudioCdTime(getChild(audioCd, "a:st"));
  const end = parseAudioCdTime(getChild(audioCd, "a:end"));
  return { start, end };
}
function parseLinkedMediaFile(element) {
  if (!element) {
    return;
  }
  return {
    link: getAttr(element, "r:link"),
    contentType: getAttr(element, "contentType")
  };
}
function parseQuickTimeFile(element) {
  if (!element) {
    return;
  }
  return {
    link: getAttr(element, "r:link")
  };
}
function parseEmbeddedWavAudioFile(element) {
  if (!element) {
    return;
  }
  return {
    embed: getAttr(element, "r:embed"),
    name: getAttr(element, "name")
  };
}
function parsePlaceholder(nvSpPr) {
  if (!nvSpPr) {
    return;
  }
  const nvPr = getChild(nvSpPr, "p:nvPr");
  if (!nvPr) {
    return;
  }
  const ph = getChild(nvPr, "p:ph");
  if (!ph) {
    return;
  }
  return {
    type: getAttr(ph, "type"),
    idx: getIndexAttr(ph, "idx"),
    size: getAttr(ph, "sz"),
    hasCustomPrompt: getBoolAttr2(ph, "hasCustomPrompt")
  };
}

// packages/@oxen-office/pptx/src/parser/shape-parser/placeholder.ts
function getPlaceholderTypeFromNode(node) {
  if (!node) {
    return;
  }
  const nvSpPr = getChild(node, "p:nvSpPr");
  if (!nvSpPr) {
    return;
  }
  const nvPr = getChild(nvSpPr, "p:nvPr");
  if (!nvPr) {
    return;
  }
  const ph = getChild(nvPr, "p:ph");
  if (!ph) {
    return;
  }
  return getAttr(ph, "type");
}
function resolvePlaceholderType(directType, layoutNode, masterNode) {
  if (directType !== undefined) {
    return directType;
  }
  const layoutType = getPlaceholderTypeFromNode(layoutNode);
  if (layoutType !== undefined) {
    return layoutType;
  }
  const masterType = getPlaceholderTypeFromNode(masterNode);
  if (masterType !== undefined) {
    return masterType;
  }
  return;
}
function resolveLayoutAndMasterNodes(ctx, idx, type) {
  if (ctx === undefined) {
    return { layout: undefined, master: undefined };
  }
  if (idx !== undefined) {
    return {
      layout: ctx.layout.byIdx.get(idx),
      master: resolveMasterForIdx(ctx, idx, type)
    };
  }
  if (type !== undefined) {
    return {
      layout: ctx.layout.byType[type],
      master: ctx.master.byType[type]
    };
  }
  return { layout: undefined, master: undefined };
}
function resolveMasterForIdx(ctx, idx, type) {
  if (type !== undefined) {
    return ctx.master.byType[type];
  }
  return ctx.master.byIdx.get(idx);
}

// packages/@oxen-office/pptx/src/parser/shape-parser/properties.ts
function findFirstDefined(getter, ...sources) {
  for (const source of sources) {
    const value = getter(source);
    if (value !== undefined) {
      return value;
    }
  }
  return;
}
function parseShapePropertiesWithInheritance(spPr, layoutNode, masterNode) {
  const layoutSpPr = getSpPrChild(layoutNode);
  const masterSpPr = getSpPrChild(masterNode);
  const transform = findFirstDefined(getTransformFromProperties, spPr, layoutSpPr, masterSpPr);
  const geometry = findFirstDefined(parseGeometry, spPr, layoutSpPr, masterSpPr);
  const fill = findFirstDefined(parseFillFromParent, spPr, layoutSpPr, masterSpPr);
  const line = findFirstDefined(getLineFromProperties2, spPr, layoutSpPr, masterSpPr);
  const effects = findFirstDefined(parseEffects, spPr, layoutSpPr, masterSpPr);
  return {
    transform,
    geometry,
    fill,
    line,
    effects,
    scene3d: findFirstDefined(parseScene3d, spPr, layoutSpPr, masterSpPr),
    shape3d: findFirstDefined(parseShape3d, spPr, layoutSpPr, masterSpPr)
  };
}
function parseShapeProperties(spPr) {
  if (!spPr) {
    return {};
  }
  return {
    transform: getTransformFromProperties(spPr),
    geometry: parseGeometry(spPr),
    fill: parseFillFromParent(spPr),
    line: getLineFromProperties2(spPr),
    effects: parseEffects(spPr),
    scene3d: parseScene3d(spPr),
    shape3d: parseShape3d(spPr)
  };
}
function parseGroupShapeProperties(grpSpPr) {
  if (!grpSpPr) {
    return {};
  }
  return {
    transform: getGroupTransformFromProperties(grpSpPr),
    fill: parseFillFromParent(grpSpPr),
    effects: parseEffects(grpSpPr)
  };
}
function getSpPrChild(node) {
  if (!node) {
    return;
  }
  return getChild(node, "p:spPr");
}

// packages/@oxen-office/pptx/src/parser/shape-parser/sp.ts
function parseShapeLocksElement(element) {
  if (!element) {
    return;
  }
  const noGrp = getBoolAttr2(element, "noGrp");
  const noSelect = getBoolAttr2(element, "noSelect");
  const noRot = getBoolAttr2(element, "noRot");
  const noChangeAspect = getBoolAttr2(element, "noChangeAspect");
  const noMove = getBoolAttr2(element, "noMove");
  const noResize = getBoolAttr2(element, "noResize");
  const noEditPoints = getBoolAttr2(element, "noEditPoints");
  const noAdjustHandles = getBoolAttr2(element, "noAdjustHandles");
  const noChangeArrowheads = getBoolAttr2(element, "noChangeArrowheads");
  const noChangeShapeType = getBoolAttr2(element, "noChangeShapeType");
  const noTextEdit = getBoolAttr2(element, "noTextEdit");
  if (noGrp === undefined && noSelect === undefined && noRot === undefined && noChangeAspect === undefined && noMove === undefined && noResize === undefined && noEditPoints === undefined && noAdjustHandles === undefined && noChangeArrowheads === undefined && noChangeShapeType === undefined && noTextEdit === undefined) {
    return;
  }
  return {
    noGrp,
    noSelect,
    noRot,
    noChangeAspect,
    noMove,
    noResize,
    noEditPoints,
    noAdjustHandles,
    noChangeArrowheads,
    noChangeShapeType,
    noTextEdit
  };
}
function parseShapeLocksFromParent(parent) {
  if (!parent) {
    return;
  }
  return parseShapeLocksElement(getChild(parent, "a:spLocks"));
}
function resolveShapePropertiesWithFill(properties, shapeStyle, formatScheme) {
  if (!properties.fill) {
    if (shapeStyle?.fillReference && formatScheme) {
      const resolvedFill = resolveFillFromStyleReference(shapeStyle.fillReference, formatScheme.fillStyles);
      if (resolvedFill) {
        return { ...properties, fill: resolvedFill };
      }
    }
  }
  return properties;
}
function resolveShapePropertiesWithEffects(properties, shapeStyle, formatScheme) {
  if (!properties.effects) {
    if (shapeStyle?.effectReference && formatScheme) {
      const resolvedEffects = resolveEffectsFromStyleReference(shapeStyle.effectReference, formatScheme.effectStyles);
      if (resolvedEffects) {
        return { ...properties, effects: resolvedEffects };
      }
    }
  }
  return properties;
}
function resolveShapePropertiesWithStyle(properties, shapeStyle, formatScheme) {
  const withFill = resolveShapePropertiesWithFill(properties, shapeStyle, formatScheme);
  return resolveShapePropertiesWithEffects(withFill, shapeStyle, formatScheme);
}
function buildTextStyleContext({ ctx, resolvedPlaceholderType, placeholderIdx, masterStylesInfo, shapeStyle }) {
  const shapeFontReferenceColor = getShapeFontReferenceColor(shapeStyle);
  if (ctx !== undefined) {
    return {
      placeholderType: resolvedPlaceholderType,
      placeholderIdx,
      layoutPlaceholders: ctx.layout,
      masterPlaceholders: ctx.master,
      masterTextStyles: masterStylesInfo?.masterTextStyles,
      defaultTextStyle: masterStylesInfo?.defaultTextStyle,
      shapeFontReferenceColor
    };
  }
  if (shapeFontReferenceColor !== undefined) {
    return {
      placeholderType: undefined,
      placeholderIdx: undefined,
      layoutPlaceholders: { byType: {}, byIdx: new Map },
      masterPlaceholders: { byType: {}, byIdx: new Map },
      masterTextStyles: undefined,
      defaultTextStyle: undefined,
      shapeFontReferenceColor
    };
  }
  return;
}
function getShapeFontReferenceColor(shapeStyle) {
  const fill = shapeStyle?.fontReference?.color;
  if (fill?.type === "solidFill") {
    return fill.color;
  }
  return;
}
function parseSpShape({
  element,
  ctx,
  masterStylesInfo,
  formatScheme
}) {
  const nvSpPr = getChild(element, "p:nvSpPr");
  const cNvPr = nvSpPr ? getChild(nvSpPr, "p:cNvPr") : undefined;
  const cNvSpPr = nvSpPr ? getChild(nvSpPr, "p:cNvSpPr") : undefined;
  const textBox = getBoolAttr2(cNvSpPr, "txBox");
  const spPr = getChild(element, "p:spPr");
  const txBody = getChild(element, "p:txBody");
  const style = getChild(element, "p:style");
  const placeholder = parsePlaceholder(nvSpPr);
  const { layout, master } = resolveLayoutAndMasterNodes(ctx, placeholder?.idx, placeholder?.type);
  const baseProperties = getShapePropertiesWithOptionalInheritance({ ctx, spPr, layout, master });
  const shapeStyle = parseShapeStyle(style);
  const properties = resolveShapePropertiesWithStyle(baseProperties, shapeStyle, formatScheme);
  const resolvedPlaceholderType = resolvePlaceholderType(placeholder?.type, layout, master);
  const textStyleCtx = buildTextStyleContext({
    ctx,
    resolvedPlaceholderType,
    placeholderIdx: placeholder?.idx,
    masterStylesInfo,
    shapeStyle
  });
  return {
    type: "sp",
    nonVisual: {
      ...parseNonVisualProperties(cNvPr),
      textBox,
      shapeLocks: parseShapeLocksFromParent(cNvSpPr)
    },
    placeholder,
    properties,
    textBody: parseTextBody(txBody, textStyleCtx),
    style: shapeStyle
  };
}
function getShapePropertiesWithOptionalInheritance({
  ctx,
  spPr,
  layout,
  master
}) {
  if (ctx !== undefined) {
    return parseShapePropertiesWithInheritance(spPr, layout, master);
  }
  return parseShapeProperties(spPr);
}

// packages/@oxen-office/pptx/src/parser/shape-parser/alternate-content.ts
var SUPPORTED_NAMESPACES = new Set([]);
function isChoiceSupported(requires) {
  if (requires === undefined || requires === "") {
    return true;
  }
  const prefixes = requires.split(/\s+/).filter((p) => p.length > 0);
  return prefixes.every((prefix) => SUPPORTED_NAMESPACES.has(prefix));
}
function processAlternateContent(mcElement, childName) {
  const choices = getChildren(mcElement, "mc:Choice");
  for (const choice of choices) {
    const requires = getAttr(choice, "Requires");
    if (isChoiceSupported(requires)) {
      const child = getChild(choice, childName);
      if (child !== undefined) {
        return child;
      }
    }
  }
  const fallback = getChild(mcElement, "mc:Fallback");
  if (fallback !== undefined) {
    return getChild(fallback, childName);
  }
  return;
}
function getBlipFillElement(element) {
  const directBlipFill = getChild(element, "p:blipFill");
  if (directBlipFill !== undefined) {
    return directBlipFill;
  }
  const mcElement = getChild(element, "mc:AlternateContent");
  if (mcElement !== undefined) {
    return processAlternateContent(mcElement, "p:blipFill");
  }
  return;
}
function getOleObjElement(graphicData) {
  const directOleObj = getChild(graphicData, "p:oleObj");
  if (directOleObj !== undefined) {
    return directOleObj;
  }
  const mcElement = getChild(graphicData, "mc:AlternateContent");
  if (mcElement !== undefined) {
    return processAlternateContent(mcElement, "p:oleObj");
  }
  return;
}

// packages/@oxen-office/pptx/src/parser/shape-parser/pic.ts
function parseBlipFillProperties(blipFill, resourceContext, resourceStore) {
  if (!blipFill) {
    return;
  }
  const blip = getChild(blipFill, "a:blip");
  if (!blip) {
    return;
  }
  const resourceId = getAttr(blip, "r:embed") ?? getAttr(blip, "r:link");
  if (!resourceId) {
    return;
  }
  let resolvedResource;
  if (resourceContext !== undefined && !resourceId.startsWith("data:")) {
    resolvedResource = resourceContext.resolveBlipFill(resourceId);
    if (resourceStore && resolvedResource) {
      resourceStore.set(resourceId, {
        kind: "image",
        source: "parsed",
        data: resolvedResource.data,
        mimeType: resolvedResource.mimeType,
        path: resolvedResource.path
      });
    }
  }
  const sourceRect = parseSourceRect2(getChild(blipFill, "a:srcRect"));
  const stretch = getChild(blipFill, "a:stretch");
  const tileProps = parseTileProperties(getChild(blipFill, "a:tile"));
  return {
    resourceId,
    compressionState: parseBlipCompression(getAttr(blip, "cstate")),
    sourceRect,
    stretch: stretch !== undefined,
    tile: tileProps,
    rotateWithShape: getBoolAttr2(blipFill, "rotWithShape"),
    dpi: getIntAttr2(blipFill, "dpi")
  };
}
function parsePictureLocksElement(element) {
  if (!element) {
    return;
  }
  const noGrp = getBoolAttr2(element, "noGrp");
  const noSelect = getBoolAttr2(element, "noSelect");
  const noRot = getBoolAttr2(element, "noRot");
  const noChangeAspect = getBoolAttr2(element, "noChangeAspect");
  const noMove = getBoolAttr2(element, "noMove");
  const noResize = getBoolAttr2(element, "noResize");
  const noEditPoints = getBoolAttr2(element, "noEditPoints");
  const noAdjustHandles = getBoolAttr2(element, "noAdjustHandles");
  const noChangeArrowheads = getBoolAttr2(element, "noChangeArrowheads");
  const noChangeShapeType = getBoolAttr2(element, "noChangeShapeType");
  const noCrop = getBoolAttr2(element, "noCrop");
  if (noGrp === undefined && noSelect === undefined && noRot === undefined && noChangeAspect === undefined && noMove === undefined && noResize === undefined && noEditPoints === undefined && noAdjustHandles === undefined && noChangeArrowheads === undefined && noChangeShapeType === undefined && noCrop === undefined) {
    return;
  }
  return {
    noGrp,
    noSelect,
    noRot,
    noChangeAspect,
    noMove,
    noResize,
    noEditPoints,
    noAdjustHandles,
    noChangeArrowheads,
    noChangeShapeType,
    noCrop
  };
}
function detectMediaType(nvPicPr) {
  if (!nvPicPr) {
    return;
  }
  const nvPr = getChild(nvPicPr, "p:nvPr");
  if (!nvPr) {
    return;
  }
  if (hasAnyChild(nvPr, ["a:videoFile", "a:quickTimeFile"])) {
    return "video";
  }
  if (hasAnyChild(nvPr, ["a:audioFile", "a:audioCd", "a:wavAudioFile"])) {
    return "audio";
  }
  if (getChild(nvPr, "p:extLst")) {}
  return;
}
function parsePicShape(element, formatScheme, resourceContext) {
  const nvPicPr = getChild(element, "p:nvPicPr");
  const cNvPr = nvPicPr ? getChild(nvPicPr, "p:cNvPr") : undefined;
  const cNvPicPr = nvPicPr ? getChild(nvPicPr, "p:cNvPicPr") : undefined;
  const nvPr = nvPicPr ? getChild(nvPicPr, "p:nvPr") : undefined;
  const blipFill = getBlipFillElement(element);
  const blipFillProps = parseBlipFillProperties(blipFill, resourceContext);
  if (!blipFillProps) {
    return;
  }
  const spPr = getChild(element, "p:spPr");
  const style = getChild(element, "p:style");
  const nonVisual = parseNonVisualProperties(cNvPr);
  const preferRelativeResize = parsePreferRelativeResize(cNvPicPr);
  const pictureLocks = parsePictureLocksFromParent(cNvPicPr);
  const baseProperties = parseShapeProperties(spPr);
  const shapeStyle = parseShapeStyle(style);
  const properties = resolvePropertiesWithEffects(baseProperties, shapeStyle, formatScheme);
  return {
    type: "pic",
    nonVisual: { ...nonVisual, preferRelativeResize, pictureLocks },
    blipFill: blipFillProps,
    properties,
    style: shapeStyle,
    mediaType: detectMediaType(nvPicPr),
    media: parseNonVisualMedia(nvPr)
  };
}
function parseSourceRect2(srcRect) {
  if (!srcRect) {
    return;
  }
  return {
    left: pct((getIntAttr2(srcRect, "l") ?? 0) / 1e5 * 100),
    top: pct((getIntAttr2(srcRect, "t") ?? 0) / 1e5 * 100),
    right: pct((getIntAttr2(srcRect, "r") ?? 0) / 1e5 * 100),
    bottom: pct((getIntAttr2(srcRect, "b") ?? 0) / 1e5 * 100)
  };
}
function parseTileProperties(tile) {
  if (!tile) {
    return;
  }
  const flip = getAttr(tile, "flip") ?? "none";
  const alignment = parseRectAlignment(getAttr(tile, "algn")) ?? "tl";
  return {
    tx: px((getIntAttr2(tile, "tx") ?? 0) * 96 / 914400),
    ty: px((getIntAttr2(tile, "ty") ?? 0) * 96 / 914400),
    sx: pct((getIntAttr2(tile, "sx") ?? 1e5) / 1e5 * 100),
    sy: pct((getIntAttr2(tile, "sy") ?? 1e5) / 1e5 * 100),
    flip,
    alignment
  };
}
function parsePreferRelativeResize(cNvPicPr) {
  if (!cNvPicPr) {
    return;
  }
  return getBoolAttr2(cNvPicPr, "preferRelativeResize");
}
function parsePictureLocksFromParent(cNvPicPr) {
  if (!cNvPicPr) {
    return;
  }
  return parsePictureLocksElement(getChild(cNvPicPr, "a:picLocks"));
}
function resolvePropertiesWithEffects(properties, shapeStyle, formatScheme) {
  if (!properties.effects) {
    if (shapeStyle?.effectReference && formatScheme) {
      const resolvedEffects = resolveEffectsFromStyleReference(shapeStyle.effectReference, formatScheme.effectStyles);
      if (resolvedEffects) {
        return { ...properties, effects: resolvedEffects };
      }
    }
  }
  return properties;
}
function hasAnyChild(parent, names) {
  for (const name of names) {
    if (getChild(parent, name)) {
      return true;
    }
  }
  return false;
}

// packages/@oxen-office/pptx/src/parser/shape-parser/grp.ts
function parseGroupLocksElement(element) {
  if (!element) {
    return;
  }
  const noGrp = getBoolAttr2(element, "noGrp");
  const noUngrp = getBoolAttr2(element, "noUngrp");
  const noSelect = getBoolAttr2(element, "noSelect");
  const noRot = getBoolAttr2(element, "noRot");
  const noChangeAspect = getBoolAttr2(element, "noChangeAspect");
  const noMove = getBoolAttr2(element, "noMove");
  const noResize = getBoolAttr2(element, "noResize");
  if (noGrp === undefined && noUngrp === undefined && noSelect === undefined && noRot === undefined && noChangeAspect === undefined && noMove === undefined && noResize === undefined) {
    return;
  }
  return {
    noGrp,
    noUngrp,
    noSelect,
    noRot,
    noChangeAspect,
    noMove,
    noResize
  };
}
function parseGroupLocksFromParent(parent) {
  if (!parent) {
    return;
  }
  return parseGroupLocksElement(getChild(parent, "a:grpSpLocks"));
}
function parseGrpShape({ element, ctx, masterStylesInfo, formatScheme, parseShapeElement }) {
  const nvGrpSpPr = getChild(element, "p:nvGrpSpPr");
  const cNvPr = nvGrpSpPr ? getChild(nvGrpSpPr, "p:cNvPr") : undefined;
  const cNvGrpSpPr = nvGrpSpPr ? getChild(nvGrpSpPr, "p:cNvGrpSpPr") : undefined;
  const groupLocks = parseGroupLocksFromParent(cNvGrpSpPr);
  const grpSpPr = getChild(element, "p:grpSpPr");
  const children = [];
  for (const child of element.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    const shape = parseShapeElement({ element: child, ctx, masterStylesInfo, formatScheme });
    if (shape) {
      children.push(shape);
    }
  }
  return {
    type: "grpSp",
    nonVisual: {
      ...parseNonVisualProperties(cNvPr),
      groupLocks
    },
    properties: parseGroupShapeProperties(grpSpPr),
    children
  };
}

// packages/@oxen-office/pptx/src/parser/shape-parser/cxn.ts
function parseConnectionTarget(element) {
  if (!element) {
    return;
  }
  const id = getAttr(element, "id");
  const idx = getIntAttr2(element, "idx");
  if (!id || idx === undefined) {
    return;
  }
  return { shapeId: id, siteIndex: idx };
}
function parseConnectionTargetFromParent(parent, childName) {
  if (!parent) {
    return;
  }
  return parseConnectionTarget(getChild(parent, childName));
}
function resolvePropertiesWithFill(properties, shapeStyle, formatScheme) {
  if (!properties.fill) {
    if (shapeStyle?.fillReference && formatScheme) {
      const resolvedFill = resolveFillFromStyleReference(shapeStyle.fillReference, formatScheme.fillStyles);
      if (resolvedFill) {
        return { ...properties, fill: resolvedFill };
      }
    }
  }
  return properties;
}
function resolvePropertiesWithEffects2(properties, shapeStyle, formatScheme) {
  if (!properties.effects) {
    if (shapeStyle?.effectReference && formatScheme) {
      const resolvedEffects = resolveEffectsFromStyleReference(shapeStyle.effectReference, formatScheme.effectStyles);
      if (resolvedEffects) {
        return { ...properties, effects: resolvedEffects };
      }
    }
  }
  return properties;
}
function parseCxnShape(element, formatScheme) {
  const nvCxnSpPr = getChild(element, "p:nvCxnSpPr");
  const cNvPr = nvCxnSpPr ? getChild(nvCxnSpPr, "p:cNvPr") : undefined;
  const cNvCxnSpPr = nvCxnSpPr ? getChild(nvCxnSpPr, "p:cNvCxnSpPr") : undefined;
  const spPr = getChild(element, "p:spPr");
  const style = getChild(element, "p:style");
  const nonVisual = parseNonVisualProperties(cNvPr);
  const startConnection = parseConnectionTargetFromParent(cNvCxnSpPr, "a:stCxn");
  const endConnection = parseConnectionTargetFromParent(cNvCxnSpPr, "a:endCxn");
  const baseProperties = parseShapeProperties(spPr);
  const shapeStyle = parseShapeStyle(style);
  const propertiesWithFill = resolvePropertiesWithFill(baseProperties, shapeStyle, formatScheme);
  const properties = resolvePropertiesWithEffects2(propertiesWithFill, shapeStyle, formatScheme);
  return {
    type: "cxnSp",
    nonVisual: { ...nonVisual, startConnection, endConnection },
    properties,
    style: shapeStyle
  };
}

// packages/@oxen-office/pptx/src/parser/table/table-parser.ts
function parseTableProperties(tblPr) {
  if (!tblPr) {
    return {};
  }
  const tableStyleIdEl = getChild(tblPr, "a:tableStyleId");
  const tableStyleId = tableStyleIdEl ? getXmlText(tableStyleIdEl) : undefined;
  return {
    rtl: getBoolAttr2(tblPr, "rtl"),
    firstRow: getBoolAttr2(tblPr, "firstRow"),
    firstCol: getBoolAttr2(tblPr, "firstCol"),
    lastRow: getBoolAttr2(tblPr, "lastRow"),
    lastCol: getBoolAttr2(tblPr, "lastCol"),
    bandRow: getBoolAttr2(tblPr, "bandRow"),
    bandCol: getBoolAttr2(tblPr, "bandCol"),
    fill: parseFillFromParent(tblPr),
    effects: parseEffects(tblPr),
    tableStyleId
  };
}
function parseTableColumn(gridCol) {
  return {
    width: getEmuAttr2(gridCol, "w") ?? px(0)
  };
}
function parseTableGrid(tblGrid) {
  if (!tblGrid) {
    return { columns: [] };
  }
  const columns = [];
  for (const gridCol of getChildren(tblGrid, "a:gridCol")) {
    columns.push(parseTableColumn(gridCol));
  }
  return { columns };
}
function parseCellMargins(tcPr) {
  const left = getEmuAttr2(tcPr, "marL");
  const right = getEmuAttr2(tcPr, "marR");
  const top = getEmuAttr2(tcPr, "marT");
  const bottom = getEmuAttr2(tcPr, "marB");
  if (left === undefined && right === undefined && top === undefined && bottom === undefined) {
    return;
  }
  const defaultMargin = px(9.6);
  return {
    left: left ?? defaultMargin,
    right: right ?? defaultMargin,
    top: top ?? defaultMargin,
    bottom: bottom ?? defaultMargin
  };
}
function parseCellBorders(tcPr) {
  const lnL = getChild(tcPr, "a:lnL");
  const lnR = getChild(tcPr, "a:lnR");
  const lnT = getChild(tcPr, "a:lnT");
  const lnB = getChild(tcPr, "a:lnB");
  const lnTlToBr = getChild(tcPr, "a:lnTlToBr");
  const lnBlToTr = getChild(tcPr, "a:lnBlToTr");
  if (!lnL && !lnR && !lnT && !lnB && !lnTlToBr && !lnBlToTr) {
    return;
  }
  return {
    left: parseLine2(lnL),
    right: parseLine2(lnR),
    top: parseLine2(lnT),
    bottom: parseLine2(lnB),
    tlToBr: parseLine2(lnTlToBr),
    blToTr: parseLine2(lnBlToTr)
  };
}
function parseCellHeaders(tcPr) {
  const headersEl = getChild(tcPr, "a:headers");
  if (!headersEl) {
    return;
  }
  const headers = [];
  for (const header of getChildren(headersEl, "a:header")) {
    const valAttr = getAttr(header, "val");
    if (valAttr) {
      headers.push(valAttr);
      continue;
    }
    const textValue = getXmlText(header);
    if (textValue !== undefined && textValue.length > 0) {
      headers.push(textValue);
    }
  }
  return headers.length > 0 ? headers : undefined;
}
function parseTableCellProperties(tcPr) {
  if (!tcPr) {
    return {};
  }
  const anchor = resolveCellAnchor(getAttr(tcPr, "anchor"));
  const verticalType = resolveCellVerticalType(getAttr(tcPr, "vert"));
  const horzOverflow = resolveCellHorzOverflow(getAttr(tcPr, "horzOverflow"));
  return {
    margins: parseCellMargins(tcPr),
    anchor,
    anchorCenter: getBoolAttr2(tcPr, "anchorCtr"),
    horzOverflow,
    verticalType,
    fill: parseFillFromParent(tcPr),
    borders: parseCellBorders(tcPr),
    cell3d: parseCell3d(getChild(tcPr, "a:cell3D")),
    headers: parseCellHeaders(tcPr),
    rowSpan: getIntAttr2(tcPr, "rowSpan"),
    colSpan: getIntAttr2(tcPr, "gridSpan"),
    horizontalMerge: getBoolAttr2(tcPr, "hMerge"),
    verticalMerge: getBoolAttr2(tcPr, "vMerge")
  };
}
function resolveCellAnchor(value) {
  if (value === "t") {
    return "top";
  }
  if (value === "ctr") {
    return "center";
  }
  if (value === "b") {
    return "bottom";
  }
  return;
}
function resolveCellVerticalType(value) {
  if (!value) {
    return;
  }
  return value;
}
function resolveCellHorzOverflow(value) {
  if (value === "clip") {
    return "clip";
  }
  if (value === "overflow") {
    return "overflow";
  }
  return;
}
function parseTableCell(tc) {
  const txBody = getChild(tc, "a:txBody");
  const tcPr = getChild(tc, "a:tcPr");
  return {
    id: getAttr(tc, "id"),
    properties: parseTableCellProperties(tcPr),
    textBody: parseTextBody(txBody)
  };
}
function parseTableRow(tr) {
  const cells = [];
  for (const tc of getChildren(tr, "a:tc")) {
    cells.push(parseTableCell(tc));
  }
  return {
    height: getEmuAttr2(tr, "h") ?? px(0),
    cells
  };
}
function parseTable(tbl) {
  if (!tbl) {
    return;
  }
  const tblPr = getChild(tbl, "a:tblPr");
  const tblGrid = getChild(tbl, "a:tblGrid");
  const rows = [];
  for (const tr of getChildren(tbl, "a:tr")) {
    rows.push(parseTableRow(tr));
  }
  return {
    properties: parseTableProperties(tblPr),
    grid: parseTableGrid(tblGrid),
    rows
  };
}

// packages/@oxen-office/pptx/src/parser/shape-parser/graphic-frame.ts
function parseGraphicFrameLocks(element) {
  if (!element) {
    return;
  }
  const noGrp = getBoolAttr2(element, "noGrp");
  const noDrilldown = getBoolAttr2(element, "noDrilldown");
  const noSelect = getBoolAttr2(element, "noSelect");
  const noChangeAspect = getBoolAttr2(element, "noChangeAspect");
  const noMove = getBoolAttr2(element, "noMove");
  const noResize = getBoolAttr2(element, "noResize");
  if (noGrp === undefined && noDrilldown === undefined && noSelect === undefined && noChangeAspect === undefined && noMove === undefined && noResize === undefined) {
    return;
  }
  return {
    noGrp,
    noDrilldown,
    noSelect,
    noChangeAspect,
    noMove,
    noResize
  };
}
function parseOleObjectFollowColorScheme(value) {
  switch (value) {
    case "full":
    case "none":
    case "textAndBackground":
      return value;
    default:
      return;
  }
}
function parseGraphicContent(graphicData) {
  if (!graphicData) {
    return;
  }
  const uri = getAttr(graphicData, "uri") ?? "";
  const tbl = getChild(graphicData, "a:tbl");
  if (tbl) {
    const table = parseTable(tbl);
    if (table) {
      return { type: "table", data: { table } };
    }
  }
  const chart = getChild(graphicData, "c:chart");
  if (chart) {
    const resourceId = getAttr(chart, "r:id");
    if (resourceId) {
      return { type: "chart", data: { resourceId } };
    }
  }
  const relIds = getChild(graphicData, "dgm:relIds");
  if (relIds) {
    return {
      type: "diagram",
      data: {
        dataResourceId: getAttr(relIds, "r:dm"),
        layoutResourceId: getAttr(relIds, "r:lo"),
        styleResourceId: getAttr(relIds, "r:qs"),
        colorResourceId: getAttr(relIds, "r:cs")
      }
    };
  }
  const oleObj = getOleObjElement(graphicData);
  if (oleObj) {
    const embed = getChild(oleObj, "p:embed");
    const followColorScheme = parseFollowColorScheme(embed);
    const picProps = parseOleObjectPreview(oleObj);
    return {
      type: "oleObject",
      data: {
        resourceId: getAttr(oleObj, "r:id"),
        progId: getAttr(oleObj, "progId"),
        name: getAttr(oleObj, "name"),
        spid: parseShapeId(getAttr(oleObj, "spid")),
        imgW: getIntAttr2(oleObj, "imgW"),
        imgH: getIntAttr2(oleObj, "imgH"),
        showAsIcon: getBoolAttr2(oleObj, "showAsIcon"),
        followColorScheme,
        pic: picProps
      }
    };
  }
  return { type: "unknown", uri };
}
function parseGraphicFrame(element) {
  const nvGraphicFramePr = getChild(element, "p:nvGraphicFramePr");
  const cNvPr = nvGraphicFramePr ? getChild(nvGraphicFramePr, "p:cNvPr") : undefined;
  const cNvGraphicFramePr = nvGraphicFramePr ? getChild(nvGraphicFramePr, "p:cNvGraphicFramePr") : undefined;
  const graphicFrameLocks = parseGraphicFrameLocksFromParent(cNvGraphicFramePr);
  const xfrm = getChild(element, "p:xfrm");
  const transform = parseTransform(xfrm);
  if (!transform) {
    return;
  }
  const graphic = getChild(element, "a:graphic");
  const graphicData = graphic ? getChild(graphic, "a:graphicData") : undefined;
  const content = parseGraphicContent(graphicData);
  if (!content) {
    return;
  }
  return {
    type: "graphicFrame",
    nonVisual: {
      ...parseNonVisualProperties(cNvPr),
      graphicFrameLocks
    },
    transform,
    content
  };
}
function parseOleObjectPreview(oleObj) {
  const pic = getChild(oleObj, "p:pic");
  if (!pic) {
    return;
  }
  const blipFill = getChild(pic, "p:blipFill");
  return parseBlipFillProperties(blipFill);
}
function parseFollowColorScheme(embed) {
  if (!embed) {
    return;
  }
  return parseOleObjectFollowColorScheme(getAttr(embed, "followColorScheme"));
}
function parseGraphicFrameLocksFromParent(parent) {
  if (!parent) {
    return;
  }
  return parseGraphicFrameLocks(getChild(parent, "a:graphicFrameLocks"));
}

// packages/@oxen-office/pptx/src/parser/shape-parser/content-part.ts
function parseContentPartShape(element) {
  const id = getAttr(element, "r:id");
  if (!id) {
    return;
  }
  const bwMode = parseBlackWhiteMode(getAttr(element, "bwMode"));
  return {
    type: "contentPart",
    contentPart: {
      id,
      bwMode
    }
  };
}

// packages/@oxen-office/pptx/src/parser/shape-parser/parse-element.ts
var LOCKED_CANVAS_NAME_MAP = new Map([
  ["a:nvGrpSpPr", "p:nvGrpSpPr"],
  ["a:grpSpPr", "p:grpSpPr"],
  ["a:grpSp", "p:grpSp"],
  ["a:txSp", "p:sp"],
  ["a:sp", "p:sp"],
  ["a:pic", "p:pic"],
  ["a:cxnSp", "p:cxnSp"],
  ["a:graphicFrame", "p:graphicFrame"],
  ["a:nvSpPr", "p:nvSpPr"],
  ["a:cNvPr", "p:cNvPr"],
  ["a:cNvSpPr", "p:cNvSpPr"],
  ["a:nvPicPr", "p:nvPicPr"],
  ["a:cNvPicPr", "p:cNvPicPr"],
  ["a:nvCxnSpPr", "p:nvCxnSpPr"],
  ["a:cNvCxnSpPr", "p:cNvCxnSpPr"],
  ["a:nvGraphicFramePr", "p:nvGraphicFramePr"],
  ["a:cNvGraphicFramePr", "p:cNvGraphicFramePr"],
  ["a:spPr", "p:spPr"],
  ["a:txBody", "p:txBody"],
  ["a:style", "p:style"],
  ["a:blipFill", "p:blipFill"],
  ["a:oleObj", "p:oleObj"]
]);
function remapLockedCanvasName(name) {
  return LOCKED_CANVAS_NAME_MAP.get(name) ?? name;
}
function mapLockedCanvasElement(newName, source) {
  return {
    type: "element",
    name: newName,
    attrs: source.attrs,
    children: source.children.map((child) => {
      if (isXmlElement(child)) {
        const remapped = remapLockedCanvasName(child.name);
        if (remapped !== child.name) {
          return mapLockedCanvasElement(remapped, child);
        }
      }
      return child;
    })
  };
}
function parseShapeElement({ element, ctx, masterStylesInfo, formatScheme, resourceContext }) {
  switch (element.name) {
    case "p:sp":
      return parseSpShape({ element, ctx, masterStylesInfo, formatScheme });
    case "a:txSp": {
      const mapped = mapLockedCanvasElement("p:sp", element);
      const parsed = parseSpShape({ element: mapped, ctx, masterStylesInfo, formatScheme });
      if (parsed?.type !== "sp") {
        return parsed;
      }
      const useShapeTextRect = getChild(element, "a:useSpRect") !== undefined;
      return useShapeTextRect ? { ...parsed, useShapeTextRect } : parsed;
    }
    case "p:pic":
      return parsePicShape(element, formatScheme, resourceContext);
    case "p:grpSp":
      return parseGrpShape({
        element,
        ctx,
        masterStylesInfo,
        formatScheme,
        parseShapeElement: ({ element: el, ctx: c, masterStylesInfo: m, formatScheme: f }) => parseShapeElement({ element: el, ctx: c, masterStylesInfo: m, formatScheme: f, resourceContext })
      });
    case "p:cxnSp":
      return parseCxnShape(element, formatScheme);
    case "p:graphicFrame":
      return parseGraphicFrame(element);
    case "p:contentPart":
      return parseContentPartShape(element);
    case "lc:lockedCanvas": {
      const mapped = mapLockedCanvasElement("p:grpSp", element);
      return parseGrpShape({
        element: mapped,
        ctx,
        masterStylesInfo,
        formatScheme,
        parseShapeElement: ({ element: el, ctx: c, masterStylesInfo: m, formatScheme: f }) => parseShapeElement({ element: el, ctx: c, masterStylesInfo: m, formatScheme: f, resourceContext })
      });
    }
    case "mc:AlternateContent": {
      const choices = getChildren(element, "mc:Choice");
      for (const choice of choices) {
        const requires = getAttr(choice, "Requires");
        if (isChoiceSupported(requires)) {
          for (const child of choice.children) {
            if (isXmlElement(child)) {
              const shape = parseShapeElement({ element: child, ctx, masterStylesInfo, formatScheme, resourceContext });
              if (shape) {
                return shape;
              }
            }
          }
        }
      }
      const fallback = getChild(element, "mc:Fallback");
      if (fallback) {
        for (const child of fallback.children) {
          if (isXmlElement(child)) {
            const shape = parseShapeElement({ element: child, ctx, masterStylesInfo, formatScheme, resourceContext });
            if (shape) {
              return shape;
            }
          }
        }
      }
      return;
    }
    default:
      return;
  }
}
function parseShapeTree({ spTree, ctx, masterStylesInfo, formatScheme, resourceContext }) {
  if (!spTree) {
    return [];
  }
  const shapes = [];
  for (const child of spTree.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    if (child.name === "p:nvGrpSpPr" || child.name === "p:grpSpPr") {
      continue;
    }
    const shape = parseShapeElement({ element: child, ctx, masterStylesInfo, formatScheme, resourceContext });
    if (shape) {
      shapes.push(shape);
    }
  }
  return shapes;
}
// packages/@oxen-office/pptx/src/parser/slide/slide-parser.ts
function parseBackground(element) {
  if (!element) {
    return;
  }
  const bgPr = getChild(element, "p:bgPr");
  if (bgPr) {
    const fill = parseFillFromParent(bgPr);
    if (fill) {
      return {
        fill,
        shadeToTitle: getBoolAttr2(bgPr, "shadeToTitle")
      };
    }
  }
  const bgRef = getChild(element, "p:bgRef");
  if (bgRef) {
    const fill = parseFillFromParent(bgRef);
    if (fill) {
      return { fill };
    }
  }
  return;
}
function parseTransition(element) {
  if (!element) {
    return;
  }
  const { type, element: typeElement } = findTransitionType(element);
  const spd = getAttr(element, "spd");
  const duration = spd === "slow" ? 2000 : spd === "med" ? 1000 : 500;
  const { direction, orientation, spokes, inOutDirection } = parseTransitionAttributes(type, typeElement);
  return {
    type,
    duration,
    advanceOnClick: getBoolAttrOr2(element, "advClick", true),
    advanceAfter: getAdvanceAfter(element),
    sound: parseTransitionSound(element),
    direction,
    orientation,
    spokes,
    inOutDirection
  };
}
function parseTransitionAttributes(type, element) {
  if (!element) {
    return { direction: undefined, orientation: undefined, spokes: undefined, inOutDirection: undefined };
  }
  if (type === "wipe" || type === "push" || type === "cover" || type === "pull" || type === "strips") {
    const dir = getAttr(element, "dir");
    const validDirs = ["l", "r", "u", "d", "ld", "lu", "rd", "ru"];
    if (dir && validDirs.includes(dir)) {
      return {
        direction: dir,
        orientation: undefined,
        spokes: undefined,
        inOutDirection: undefined
      };
    }
  }
  if (type === "blinds" || type === "checker" || type === "comb" || type === "randomBar") {
    const dir = getAttr(element, "dir");
    if (dir === "horz" || dir === "vert") {
      return {
        direction: undefined,
        orientation: dir,
        spokes: undefined,
        inOutDirection: undefined
      };
    }
  }
  if (type === "wheel") {
    const spkCnt = getAttr(element, "spkCnt");
    const count = spkCnt ? parseInt(spkCnt, 10) : 1;
    const validSpokes = [1, 2, 3, 4, 8];
    const spokesVal = validSpokes.includes(count) ? count : 1;
    return {
      direction: undefined,
      orientation: undefined,
      spokes: spokesVal,
      inOutDirection: undefined
    };
  }
  if (type === "split" || type === "zoom") {
    const dir = getAttr(element, "dir");
    if (dir === "in" || dir === "out") {
      return {
        direction: undefined,
        orientation: undefined,
        spokes: undefined,
        inOutDirection: dir
      };
    }
  }
  return { direction: undefined, orientation: undefined, spokes: undefined, inOutDirection: undefined };
}
function getTransitionElement(parent) {
  if (!parent) {
    return;
  }
  const transition = getChild(parent, "p:transition");
  if (transition) {
    return transition;
  }
  const alternateContent = getChild(parent, "mc:AlternateContent");
  if (!alternateContent) {
    return;
  }
  return processAlternateContent(alternateContent, "p:transition");
}
function parseTransitionSound(element) {
  const sndAc = getChild(element, "p:sndAc");
  if (!sndAc) {
    return;
  }
  const stSnd = getChild(sndAc, "p:stSnd");
  if (!stSnd) {
    return;
  }
  const snd = getChild(stSnd, "p:snd");
  if (!snd) {
    return;
  }
  const resourceId = getAttr(snd, "r:embed");
  if (!resourceId) {
    return;
  }
  return {
    resourceId,
    name: getAttr(snd, "name"),
    loop: getBoolAttr2(stSnd, "loop")
  };
}
function isTransitionType(value) {
  const types = [
    "blinds",
    "checker",
    "circle",
    "comb",
    "cover",
    "cut",
    "diamond",
    "dissolve",
    "fade",
    "newsflash",
    "plus",
    "pull",
    "push",
    "random",
    "randomBar",
    "split",
    "strips",
    "wedge",
    "wheel",
    "wipe",
    "zoom",
    "none"
  ];
  return types.includes(value);
}
function findTransitionType(element) {
  for (const child of element.children) {
    if (typeof child !== "object" || !("type" in child)) {
      continue;
    }
    const el = child;
    if (el.type !== "element") {
      continue;
    }
    if (!el.name.startsWith("p:")) {
      continue;
    }
    const transType = el.name.substring(2);
    if (isTransitionType(transType)) {
      return { type: transType, element: el };
    }
  }
  return { type: "none", element: undefined };
}
function getAdvanceAfter(element) {
  const advTm = getAttr(element, "advTm");
  if (!advTm) {
    return;
  }
  return parseInt(advTm, 10);
}
function parseColorMapping(element) {
  return {
    bg1: getAttr(element, "bg1"),
    tx1: getAttr(element, "tx1"),
    bg2: getAttr(element, "bg2"),
    tx2: getAttr(element, "tx2"),
    accent1: getAttr(element, "accent1"),
    accent2: getAttr(element, "accent2"),
    accent3: getAttr(element, "accent3"),
    accent4: getAttr(element, "accent4"),
    accent5: getAttr(element, "accent5"),
    accent6: getAttr(element, "accent6"),
    hlink: getAttr(element, "hlink"),
    folHlink: getAttr(element, "folHlink")
  };
}
function parseColorMapOverride(element) {
  if (!element) {
    return;
  }
  if (getChild(element, "a:masterClrMapping")) {
    return { type: "none" };
  }
  const overrideClrMapping = getChild(element, "a:overrideClrMapping");
  if (overrideClrMapping) {
    return {
      type: "override",
      mappings: parseColorMapping(overrideClrMapping)
    };
  }
  return;
}
function parseCustomerDataList(element) {
  if (!element) {
    return;
  }
  const entries = getChildren(element, "p:custData").map((custData) => custData.attrs["r:id"]).filter((id) => typeof id === "string" && id.length > 0).map((rId) => ({ rId }));
  return entries.length > 0 ? entries : undefined;
}
function parseSlide(content, context) {
  if (!content) {
    return;
  }
  const sld = getByPath(content, ["p:sld"]);
  if (!sld) {
    return;
  }
  const cSld = getChild(sld, "p:cSld");
  if (!cSld) {
    return;
  }
  const spTree = getChild(cSld, "p:spTree");
  const bg = getChild(cSld, "p:bg");
  const custDataLst = getChild(cSld, "p:custDataLst");
  const clrMapOvr = getChild(sld, "p:clrMapOvr");
  const transition = getTransitionElement(sld);
  const placeholderCtx = context?.placeholderContext;
  const masterStylesInfo = context?.masterStylesInfo;
  const formatScheme = context?.formatScheme;
  return {
    background: parseBackground(bg),
    shapes: parseShapeTree({ spTree, ctx: placeholderCtx, masterStylesInfo, formatScheme }),
    colorMapOverride: parseColorMapOverride(clrMapOvr),
    customerData: parseCustomerDataList(custDataLst),
    transition: parseTransition(transition),
    showMasterShapes: getBoolAttr2(sld, "showMasterSp"),
    showMasterPhAnim: getBoolAttr2(sld, "showMasterPhAnim")
  };
}

// packages/@oxen-office/pptx/src/parser/metadata/comment-parser.ts
function parseCommentPosition(element) {
  if (!element) {
    return;
  }
  const x2 = getEmuAttr2(element, "x");
  const y = getEmuAttr2(element, "y");
  if (x2 === undefined || y === undefined) {
    return;
  }
  return { x: x2, y };
}
function parseCommentAuthor(element) {
  return {
    id: getIntAttrOr(element, "id", 0),
    name: getAttr(element, "name"),
    initials: getAttr(element, "initials"),
    lastIdx: getIntAttr2(element, "lastIdx"),
    colorIndex: getIntAttr2(element, "clrIdx")
  };
}
function parseCommentAuthorList(element) {
  const authors = getChildren(element, "p:cmAuthor").map(parseCommentAuthor);
  return { authors };
}
function parseComment(element) {
  const pos = getChild(element, "p:pos");
  const text = getChild(element, "p:text");
  return {
    authorId: getIntAttr2(element, "authorId"),
    dateTime: getAttr(element, "dt"),
    idx: getIntAttr2(element, "idx"),
    position: parseCommentPosition(pos),
    text: text ? getTextContent(text) : undefined
  };
}
function parseCommentList(element) {
  const comments = getChildren(element, "p:cm").map(parseComment);
  return { comments };
}

// packages/@oxen/buffer/src/base64.ts
var BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var BASE64_LOOKUP = new Uint8Array(256);
for (let i2 = 0;i2 < BASE64_CHARS.length; i2++) {
  BASE64_LOOKUP[BASE64_CHARS.charCodeAt(i2)] = i2;
}
function base64ArrayBuffer(arrayBuffer) {
  const bytes = new Uint8Array(arrayBuffer);
  const byteLength = bytes.byteLength;
  const byteRemainder = byteLength % 3;
  const mainLength = byteLength - byteRemainder;
  const chunks = [];
  for (let i2 = 0;i2 < mainLength; i2 += 3) {
    const chunk = bytes[i2] << 16 | bytes[i2 + 1] << 8 | bytes[i2 + 2];
    const a = (chunk & 16515072) >> 18;
    const b = (chunk & 258048) >> 12;
    const c = (chunk & 4032) >> 6;
    const d = chunk & 63;
    chunks.push(BASE64_CHARS[a] + BASE64_CHARS[b] + BASE64_CHARS[c] + BASE64_CHARS[d]);
  }
  if (byteRemainder === 1) {
    const chunk = bytes[mainLength];
    const a = (chunk & 252) >> 2;
    const b = (chunk & 3) << 4;
    chunks.push(BASE64_CHARS[a] + BASE64_CHARS[b] + "==");
  } else if (byteRemainder === 2) {
    const chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];
    const a = (chunk & 64512) >> 10;
    const b = (chunk & 1008) >> 4;
    const c = (chunk & 15) << 2;
    chunks.push(BASE64_CHARS[a] + BASE64_CHARS[b] + BASE64_CHARS[c] + "=");
  }
  return chunks.join("");
}
// packages/@oxen/buffer/src/data-url.ts
function toDataUrl(arrayBuffer, mimeType) {
  const base64Data = base64ArrayBuffer(arrayBuffer);
  return `data:${mimeType};base64,${base64Data}`;
}
// packages/@oxen-renderer/pptx/src/context/slide-context-adapter.ts
function createRenderContextFromSlideContext(ctx, slideSize, options) {
  const shapeId = { value: 0 };
  return {
    slideSize,
    options: { ...DEFAULT_RENDER_OPTIONS, ...options?.renderOptions },
    colorContext: buildColorContext2(ctx),
    resources: buildResourceResolver(ctx),
    warnings: createWarningCollector(),
    getNextShapeId: () => `shape-${shapeId.value++}`,
    resolvedBackground: options?.resolvedBackground,
    fontScheme: buildFontScheme(ctx),
    layoutShapes: options?.layoutShapes,
    tableStyles: ctx.presentation.tableStyles
  };
}
function buildColorContext2(ctx) {
  const scheme = ctx.presentation.theme.colorScheme;
  const masterMap = ctx.master.colorMap;
  const overrideMap = ctx.slide.colorMapOverride;
  const colorScheme = {};
  const schemeColors = [
    "dk1",
    "lt1",
    "dk2",
    "lt2",
    "accent1",
    "accent2",
    "accent3",
    "accent4",
    "accent5",
    "accent6",
    "hlink",
    "folHlink"
  ];
  for (const name of schemeColors) {
    const value = scheme[name];
    if (value !== undefined) {
      colorScheme[name] = value;
    }
  }
  const colorMap = {};
  const mappedColors = [
    "tx1",
    "tx2",
    "bg1",
    "bg2",
    "accent1",
    "accent2",
    "accent3",
    "accent4",
    "accent5",
    "accent6",
    "hlink",
    "folHlink"
  ];
  for (const name of mappedColors) {
    if (overrideMap !== undefined) {
      const value2 = overrideMap[name];
      if (value2 !== undefined) {
        colorMap[name] = value2;
        continue;
      }
    }
    const value = masterMap[name];
    if (value !== undefined) {
      colorMap[name] = value;
    }
  }
  return { colorScheme, colorMap };
}
function buildResourceResolver(ctx) {
  return {
    getTarget: (id) => ctx.slide.resources.getTarget(id),
    getType: (id) => ctx.slide.resources.getType(id),
    resolve: (id) => {
      const target = ctx.resolveResource(id);
      if (target === undefined) {
        return;
      }
      const data = ctx.readFile(target);
      if (data !== null) {
        const mimeType = getMimeTypeFromPath(target) ?? "application/octet-stream";
        return toDataUrl(data, mimeType);
      }
      return target;
    },
    getMimeType: (id) => {
      const target = ctx.resolveResource(id);
      if (target === undefined) {
        return;
      }
      return getMimeTypeFromPath(target);
    },
    getFilePath: (id) => {
      return ctx.resolveResource(id);
    },
    readFile: (path) => {
      const data = ctx.readFile(path);
      if (data === null) {
        return null;
      }
      return new Uint8Array(data);
    },
    getResourceByType: (relType) => {
      return ctx.slide.resources.getTargetByType(relType);
    }
  };
}
function buildFontScheme(ctx) {
  const fontScheme = ctx.presentation.theme.fontScheme;
  return {
    majorFont: {
      latin: fontScheme.majorFont.latin,
      eastAsian: fontScheme.majorFont.eastAsian,
      complexScript: fontScheme.majorFont.complexScript
    },
    minorFont: {
      latin: fontScheme.minorFont.latin,
      eastAsian: fontScheme.minorFont.eastAsian,
      complexScript: fontScheme.minorFont.complexScript
    }
  };
}

// packages/@oxen-office/pptx/src/parser/graphics/color-resolver.ts
var COLOR_ELEMENT_KEYS = [
  "a:srgbClr",
  "a:schemeClr",
  "a:scrgbClr",
  "a:prstClr",
  "a:hslClr",
  "a:sysClr"
];
var DEFAULT_SCHEME_MAPPING = {
  tx1: "dk1",
  tx2: "dk2",
  bg1: "lt1",
  bg2: "lt2"
};
var MAPPABLE_SCHEME_COLORS = new Set(["tx1", "tx2", "bg1", "bg2"]);
function resolveEffectiveSchemeColor(schmClrName, colorCtx) {
  if (!MAPPABLE_SCHEME_COLORS.has(schmClrName)) {
    return schmClrName;
  }
  if (colorCtx.colorMapOverride !== undefined) {
    const overrideValue = colorCtx.colorMapOverride[schmClrName];
    if (overrideValue !== undefined) {
      return overrideValue;
    }
  }
  const mappedValue = colorCtx.colorMap[schmClrName];
  if (mappedValue !== undefined) {
    return mappedValue;
  }
  return DEFAULT_SCHEME_MAPPING[schmClrName] ?? schmClrName;
}
function getSchemeColor(schemeClr, phClr, colorCtx) {
  const schmClrName = schemeClr.substring(2);
  if (schmClrName === "phClr" && phClr !== undefined) {
    return phClr;
  }
  const effectiveSchemeClr = resolveEffectiveSchemeColor(schmClrName, colorCtx);
  return colorCtx.colorScheme[effectiveSchemeClr];
}
function getSolidFill(node, phClr, colorCtx) {
  if (node === undefined || node === null) {
    return;
  }
  if (!isXmlElement(node)) {
    return;
  }
  const ctx = { colorCtx, phClr };
  const solidFillChild = getChild(node, "a:solidFill");
  const targetNode = solidFillChild ?? node;
  const found = findColorElement2(targetNode);
  if (found === undefined) {
    return;
  }
  const extractor = COLOR_EXTRACTORS[found.key];
  const baseColor = extractor(found.element, ctx);
  return applyColorTransformations(found.element, baseColor);
}
function findColorElement2(node) {
  for (const key of COLOR_ELEMENT_KEYS) {
    const element = getChild(node, key);
    if (element !== undefined) {
      return { key, element };
    }
  }
  return;
}
function extractSrgbColor(element) {
  return getAttr(element, "val") ?? "";
}
function extractSchemeColor(element, ctx) {
  const schemeClr = getAttr(element, "val");
  if (schemeClr === undefined) {
    return "";
  }
  return getSchemeColor("a:" + schemeClr, ctx.phClr, ctx.colorCtx) ?? "";
}
function extractScrgbColor(element) {
  const r = getAttr(element, "r");
  const g = getAttr(element, "g");
  const b = getAttr(element, "b");
  if (r === undefined || g === undefined || b === undefined) {
    return "";
  }
  const rVal = Math.round(Number(r) / OOXML_PERCENT_FACTOR * 255);
  const gVal = Math.round(Number(g) / OOXML_PERCENT_FACTOR * 255);
  const bVal = Math.round(Number(b) / OOXML_PERCENT_FACTOR * 255);
  return toHex(rVal) + toHex(gVal) + toHex(bVal);
}
function extractPrstColor(element) {
  const val = getAttr(element, "val");
  if (val === undefined) {
    return "";
  }
  return getColorName2Hex(val) ?? "";
}
function extractHslColor(element) {
  const h = getAttr(element, "hue");
  const s = getAttr(element, "sat");
  const l = getAttr(element, "lum");
  if (h === undefined || s === undefined || l === undefined) {
    return "";
  }
  const hue = Number(h) / 60000;
  const sat = Number(s) / OOXML_PERCENT_FACTOR;
  const lum = Number(l) / OOXML_PERCENT_FACTOR;
  const rgb = hslToRgb(hue, sat, lum);
  return toHex(rgb.r) + toHex(rgb.g) + toHex(rgb.b);
}
function extractSysColor(element) {
  const lastClr = getAttr(element, "lastClr");
  if (lastClr !== undefined) {
    return lastClr;
  }
  const val = getAttr(element, "val");
  if (val === undefined) {
    return "";
  }
  return val === "windowText" ? "000000" : val === "window" ? "FFFFFF" : "";
}
var COLOR_EXTRACTORS = {
  "a:srgbClr": extractSrgbColor,
  "a:schemeClr": extractSchemeColor,
  "a:scrgbClr": extractScrgbColor,
  "a:prstClr": extractPrstColor,
  "a:hslClr": extractHslColor,
  "a:sysClr": extractSysColor
};
function parsePercentageValue(value) {
  if (value.indexOf("%") !== -1) {
    return Number(value.split("%").shift());
  }
  return Number(value);
}
function applyColorTransformations(element, baseColor) {
  if (baseColor === undefined || baseColor === "") {
    return;
  }
  let result = baseColor;
  const alpha = getChild(element, "a:alpha");
  let hasAlpha = false;
  if (alpha !== undefined) {
    const val = getAttr(alpha, "val");
    if (val !== undefined) {
      const pct2 = parsePercentageValue(val) / OOXML_PERCENT_FACTOR;
      const hsl = parseColorToHsl(result);
      hsl.a = pct2;
      result = hslToHexString(hsl, true);
      hasAlpha = true;
    }
  }
  const hueMod = getChild(element, "a:hueMod");
  if (hueMod !== undefined) {
    const val = getAttr(hueMod, "val");
    if (val !== undefined) {
      const pct2 = parsePercentageValue(val) / OOXML_PERCENT_FACTOR;
      result = applyHueMod(result, pct2, hasAlpha);
    }
  }
  const lumMod = getChild(element, "a:lumMod");
  if (lumMod !== undefined) {
    const val = getAttr(lumMod, "val");
    if (val !== undefined) {
      const pct2 = parsePercentageValue(val) / OOXML_PERCENT_FACTOR;
      result = applyLumMod(result, pct2, hasAlpha);
    }
  }
  const lumOff = getChild(element, "a:lumOff");
  if (lumOff !== undefined) {
    const val = getAttr(lumOff, "val");
    if (val !== undefined) {
      const pct2 = parsePercentageValue(val) / OOXML_PERCENT_FACTOR;
      result = applyLumOff(result, pct2, hasAlpha);
    }
  }
  const satMod = getChild(element, "a:satMod");
  if (satMod !== undefined) {
    const val = getAttr(satMod, "val");
    if (val !== undefined) {
      const pct2 = parsePercentageValue(val) / OOXML_PERCENT_FACTOR;
      result = applySatMod(result, pct2, hasAlpha);
    }
  }
  const shade = getChild(element, "a:shade");
  if (shade !== undefined) {
    const val = getAttr(shade, "val");
    if (val !== undefined) {
      const pct2 = parsePercentageValue(val) / OOXML_PERCENT_FACTOR;
      result = applyShade(result, pct2, hasAlpha);
    }
  }
  const tint = getChild(element, "a:tint");
  if (tint !== undefined) {
    const val = getAttr(tint, "val");
    if (val !== undefined) {
      const pct2 = parsePercentageValue(val) / OOXML_PERCENT_FACTOR;
      result = applyTint(result, pct2, hasAlpha);
    }
  }
  return result;
}

// packages/@oxen-office/pptx/src/parser/graphics/fill-resolver.ts
var FILL_ELEMENT_KEYS = [
  "a:noFill",
  "a:solidFill",
  "a:gradFill",
  "a:pattFill",
  "a:blipFill",
  "a:grpFill"
];
function getFillType(node) {
  if (node === undefined || node === null) {
    return "";
  }
  if (!isXmlElement(node)) {
    return "";
  }
  const handler = findHandlerByXmlKey(node);
  if (handler === undefined) {
    return "";
  }
  return handler.type;
}
function getGradientFill(node, colorCtx, phClr) {
  if (!isXmlElement(node)) {
    return { color: [], rot: 0 };
  }
  const gsLst = getChild(node, "a:gsLst");
  const gsNodes = gsLst !== undefined ? getChildren(gsLst, "a:gs") : [];
  const colorArray = [];
  for (let i2 = 0;i2 < gsNodes.length; i2++) {
    const gsNode = gsNodes[i2];
    const color = getSolidFill(gsNode, phClr, colorCtx) ?? "";
    const pos = getAttr(gsNode, "pos");
    colorArray.push({
      pos: pos ?? String(i2 / (gsNodes.length - 1) * 1e5),
      color
    });
  }
  const pathGradient = parsePathGradient2(node);
  if (pathGradient !== null) {
    return {
      color: colorArray,
      rot: 0,
      type: "path",
      pathShadeType: pathGradient.pathShadeType,
      fillToRect: pathGradient.fillToRect
    };
  }
  const rot = getGradientRotation(node);
  return {
    color: colorArray,
    rot,
    type: "linear"
  };
}
function parsePathGradient2(gradFill) {
  const pathNode = getChild(gradFill, "a:path");
  if (pathNode === undefined) {
    return null;
  }
  const pathAttr = getAttr(pathNode, "path");
  const pathShadeType = pathAttr ?? "circle";
  const fillToRect = parseFillToRect2(pathNode);
  return { pathShadeType, fillToRect };
}
function parseFillToRect2(pathNode) {
  const fillToRectNode = getChild(pathNode, "a:fillToRect");
  if (fillToRectNode === undefined) {
    return;
  }
  return {
    l: parseInt(getAttr(fillToRectNode, "l") ?? "0", 10),
    t: parseInt(getAttr(fillToRectNode, "t") ?? "0", 10),
    r: parseInt(getAttr(fillToRectNode, "r") ?? "0", 10),
    b: parseInt(getAttr(fillToRectNode, "b") ?? "0", 10)
  };
}
function getGradientRotation(gradFill) {
  const lin = getChild(gradFill, "a:lin");
  if (lin === undefined) {
    return 0;
  }
  return angleToDegrees(getAttr(lin, "ang") ?? "0") + 90;
}
function getPicFillFromContext(node, resourceCtx) {
  if (!isXmlElement(node)) {
    return;
  }
  const blip = getChild(node, "a:blip");
  const rId = blip !== undefined ? getAttr(blip, "r:embed") : undefined;
  if (rId === undefined) {
    return;
  }
  const rawImgPath = resourceCtx.resolveResource(rId);
  if (rawImgPath === undefined) {
    return;
  }
  const imgPath = escapeXml(rawImgPath);
  const imgExt = imgPath.split(".").pop() ?? "";
  if (imgExt === "xml") {
    return;
  }
  const imgArrayBuffer = resourceCtx.readFile(imgPath);
  if (imgArrayBuffer === null) {
    return;
  }
  const imgMimeType = getMimeType(imgExt);
  return "data:" + imgMimeType + ";base64," + base64ArrayBuffer(imgArrayBuffer);
}
function detectImageFillMode(node) {
  if (!isXmlElement(node)) {
    return "cover";
  }
  if (getChild(node, "a:stretch") !== undefined) {
    return "stretch";
  }
  if (getChild(node, "a:tile") !== undefined) {
    return "tile";
  }
  return "cover";
}
var SOLID_FILL_HANDLER = {
  xmlKey: "a:solidFill",
  type: "SOLID_FILL",
  format: (fillColor, isSvgMode) => {
    if (isSvgMode) {
      return `#${fillColor}`;
    }
    return `background-color: #${fillColor};`;
  }
};
var GRADIENT_FILL_HANDLER = {
  xmlKey: "a:gradFill",
  type: "GRADIENT_FILL",
  format: (fillColor, isSvgMode) => {
    const gradFill = fillColor;
    if (isSvgMode) {
      return gradFill;
    }
    const colorStops = gradFill.color.map((c) => `#${c.color}`).join(", ");
    return `background: linear-gradient(${gradFill.rot}deg,${colorStops});`;
  }
};
var PATTERN_FILL_HANDLER = {
  xmlKey: "a:pattFill",
  type: "PATTERN_FILL",
  format: (fillColor) => {
    const patternFill = fillColor;
    const parts = [`background: ${patternFill[0]}`];
    if (patternFill[1]) {
      parts.push(` background-size:${patternFill[1]};`);
    }
    if (patternFill[2]) {
      parts.push(` background-position:${patternFill[2]};`);
    }
    return parts.join("");
  }
};
var PIC_FILL_HANDLER = {
  xmlKey: "a:blipFill",
  type: "PIC_FILL",
  format: (fillColor, isSvgMode) => {
    if (isSvgMode) {
      return fillColor;
    }
    return `background-image:url(${fillColor});`;
  }
};
var NO_FILL_HANDLER = {
  xmlKey: "a:noFill",
  type: "NO_FILL",
  format: (_, isSvgMode) => isSvgMode ? "none" : ""
};
var GROUP_FILL_HANDLER = {
  xmlKey: "a:grpFill",
  type: "GROUP_FILL",
  format: () => ""
};
var FILL_HANDLERS_BY_XML_KEY = {
  "a:noFill": NO_FILL_HANDLER,
  "a:solidFill": SOLID_FILL_HANDLER,
  "a:gradFill": GRADIENT_FILL_HANDLER,
  "a:pattFill": PATTERN_FILL_HANDLER,
  "a:blipFill": PIC_FILL_HANDLER,
  "a:grpFill": GROUP_FILL_HANDLER
};
var FILL_HANDLERS_BY_TYPE = {
  NO_FILL: NO_FILL_HANDLER,
  SOLID_FILL: SOLID_FILL_HANDLER,
  GRADIENT_FILL: GRADIENT_FILL_HANDLER,
  PATTERN_FILL: PATTERN_FILL_HANDLER,
  PIC_FILL: PIC_FILL_HANDLER,
  GROUP_FILL: GROUP_FILL_HANDLER
};
function formatFillResult(fillType, fillColor, isSvgMode) {
  const handler = FILL_HANDLERS_BY_TYPE[fillType];
  if (handler === undefined) {
    return isSvgMode ? "none" : "";
  }
  return handler.format(fillColor, isSvgMode);
}
function findHandlerByXmlKey(nodeObj) {
  const selfHandler = FILL_HANDLERS_BY_XML_KEY[nodeObj.name];
  if (selfHandler !== undefined) {
    return selfHandler;
  }
  for (const key of FILL_ELEMENT_KEYS) {
    if (getChild(nodeObj, key) !== undefined) {
      return FILL_HANDLERS_BY_XML_KEY[key];
    }
  }
  return;
}

// packages/@oxen-office/pptx/src/parser/slide/background-parser.ts
function getBackgroundElement(element) {
  if (element === undefined) {
    return;
  }
  const cSld = getChild(element, "p:cSld");
  if (cSld === undefined) {
    return;
  }
  const bg = getChild(cSld, "p:bg");
  if (bg === undefined) {
    return;
  }
  const bgPr = getChild(bg, "p:bgPr");
  const bgRef = getChild(bg, "p:bgRef");
  if (bgPr === undefined && bgRef === undefined) {
    return;
  }
  return { bgPr, bgRef };
}
function getBgPrFromElement(element) {
  const bgElement = getBackgroundElement(element);
  return bgElement?.bgPr;
}
function getBgRefFromElement(element) {
  const bgElement = getBackgroundElement(element);
  return bgElement?.bgRef;
}
function resolveBgRefToXmlElement(bgRef, ctx) {
  const idxAttr = bgRef.attrs?.idx;
  if (idxAttr === undefined) {
    return;
  }
  const idx = parseInt(idxAttr, 10);
  if (Number.isNaN(idx) || idx < 1) {
    return;
  }
  const formatScheme = ctx.presentation.theme.formatScheme;
  if (idx >= 1001) {
    const bgStyleIndex = idx - 1001;
    return formatScheme.bgFillStyles[bgStyleIndex];
  }
  const styleIndex = idx - 1;
  return formatScheme.fillStyles[styleIndex];
}
function extractPhClrFromBgRef(bgRef, ctx) {
  return getSolidFill(bgRef, undefined, ctx.toColorContext());
}
function parseBackgroundProperties(ctx) {
  const slideBgPr = getBgPrFromElement(ctx.slide.content);
  if (slideBgPr !== undefined) {
    return { fill: slideBgPr };
  }
  const slideBgRef = getBgRefFromElement(ctx.slide.content);
  if (slideBgRef !== undefined) {
    const resolved = resolveBgRefToXmlElement(slideBgRef, ctx);
    if (resolved !== undefined) {
      const phClr = extractPhClrFromBgRef(slideBgRef, ctx);
      return { fill: resolved, phClr, fromTheme: true };
    }
  }
  const layoutBgPr = getBgPrFromElement(ctx.layout.content);
  if (layoutBgPr !== undefined) {
    return { fill: layoutBgPr };
  }
  const layoutBgRef = getBgRefFromElement(ctx.layout.content);
  if (layoutBgRef !== undefined) {
    const resolved = resolveBgRefToXmlElement(layoutBgRef, ctx);
    if (resolved !== undefined) {
      const phClr = extractPhClrFromBgRef(layoutBgRef, ctx);
      return { fill: resolved, phClr, fromTheme: true };
    }
  }
  const masterBgPr = getBgPrFromElement(ctx.master.content);
  if (masterBgPr !== undefined) {
    return { fill: masterBgPr };
  }
  const masterBgRef = getBgRefFromElement(ctx.master.content);
  if (masterBgRef !== undefined) {
    const resolved = resolveBgRefToXmlElement(masterBgRef, ctx);
    if (resolved !== undefined) {
      const phClr = extractPhClrFromBgRef(masterBgRef, ctx);
      return { fill: resolved, phClr, fromTheme: true };
    }
  }
  return;
}
function generateGradientCSS(gradResult) {
  const sortedColors = [...gradResult.color].sort((a, b) => {
    const posA = parseInt(a.pos, 10);
    const posB = parseInt(b.pos, 10);
    return posA - posB;
  });
  const stopsWithPos = sortedColors.map((c) => {
    const pos = parseInt(c.pos, 10) / 1000;
    return `#${c.color} ${pos}%`;
  }).join(", ");
  if (gradResult.type === "path") {
    const fillToRect = gradResult.fillToRect;
    if (fillToRect !== undefined) {
      const centerX = (fillToRect.l + fillToRect.r) / 2000;
      const centerY = (fillToRect.t + fillToRect.b) / 2000;
      return `radial-gradient(circle at ${centerX}% ${centerY}%, ${stopsWithPos})`;
    }
    return `radial-gradient(circle at 50% 50%, ${stopsWithPos})`;
  }
  return `linear-gradient(${gradResult.rot}deg, ${stopsWithPos})`;
}
var SOLID_FILL_BG_HANDLER = {
  xmlKey: "a:solidFill",
  type: "SOLID_FILL",
  extractData: ({ fill, ctx, phClr }) => {
    const solidFill = getChild(fill, "a:solidFill") ?? fill;
    const colorHex = getSolidFill(solidFill, phClr, ctx.toColorContext());
    if (colorHex === undefined) {
      return null;
    }
    return {
      css: formatFillResult("SOLID_FILL", colorHex, false),
      isSolid: true,
      color: `#${colorHex}`
    };
  }
};
var GRADIENT_FILL_BG_HANDLER = {
  xmlKey: "a:gradFill",
  type: "GRADIENT_FILL",
  extractData: ({ fill, ctx, phClr }) => {
    const gradFill = getChild(fill, "a:gradFill") ?? fill;
    const gradResult = getGradientFill(gradFill, ctx.toColorContext(), phClr);
    const gradient = generateGradientCSS(gradResult);
    const sortedColors = [...gradResult.color].sort((a, b) => {
      const posA = parseInt(a.pos, 10);
      const posB = parseInt(b.pos, 10);
      return posA - posB;
    });
    const gradientData = {
      angle: gradResult.rot,
      type: gradResult.type,
      pathShadeType: gradResult.type === "path" ? gradResult.pathShadeType : undefined,
      fillToRect: gradResult.type === "path" ? gradResult.fillToRect : undefined,
      stops: sortedColors.map((c) => ({
        position: parseInt(c.pos, 10) / 1000,
        color: c.color
      }))
    };
    return {
      css: `background: ${gradient};`,
      isSolid: false,
      gradient,
      gradientData
    };
  }
};
function getBlipResourceContext(ctx, fromTheme) {
  if (fromTheme === true) {
    return ctx.toThemeResourceContext();
  }
  return ctx.toResourceContext();
}
function tryGetPicFill(blipFill, ctx, fromTheme) {
  const resourceContext = getBlipResourceContext(ctx, fromTheme);
  return getPicFillFromContext(blipFill, resourceContext);
}
var PIC_FILL_BG_HANDLER = {
  xmlKey: "a:blipFill",
  type: "PIC_FILL",
  extractData: ({ fill, ctx, fromTheme }) => {
    const blipFill = getChild(fill, "a:blipFill") ?? fill;
    const imgPath = tryGetPicFill(blipFill, ctx, fromTheme);
    if (imgPath === undefined) {
      return null;
    }
    const fillMode = detectImageFillMode(blipFill);
    const bgSize = fillMode === "stretch" ? "100% 100%" : "cover";
    return {
      css: `background-image: url(${imgPath}); background-size: ${bgSize};`,
      isSolid: false,
      image: imgPath,
      imageFillMode: fillMode
    };
  }
};
var BG_FILL_HANDLERS = {
  SOLID_FILL: SOLID_FILL_BG_HANDLER,
  GRADIENT_FILL: GRADIENT_FILL_BG_HANDLER,
  PIC_FILL: PIC_FILL_BG_HANDLER
};
var DEFAULT_BACKGROUND_FILL = {
  css: "",
  isSolid: true
};
function getBackgroundFillData(ctx) {
  const bgResult = parseBackgroundProperties(ctx);
  if (bgResult === undefined) {
    return DEFAULT_BACKGROUND_FILL;
  }
  const bgFillType = getFillType(bgResult.fill);
  const handler = BG_FILL_HANDLERS[bgFillType];
  const result = handler?.extractData({ fill: bgResult.fill, ctx, phClr: bgResult.phClr, fromTheme: bgResult.fromTheme });
  return result ?? DEFAULT_BACKGROUND_FILL;
}

// packages/@oxen-office/diagram/src/layout-engine/tree-builder.ts
function buildDiagramTree(dataModel) {
  const { points, connections } = dataModel;
  const pointMap = new Map;
  for (const point of points) {
    pointMap.set(point.modelId, point);
  }
  const parentMap = new Map;
  const childrenMap = new Map;
  for (const conn of connections) {
    if (conn.type === "parOf" && conn.sourceId && conn.destinationId) {
      parentMap.set(conn.sourceId, conn.destinationId);
      const children = childrenMap.get(conn.destinationId) ?? [];
      const insertIndex = conn.sourceOrder ?? children.length;
      children.splice(insertIndex, 0, conn.sourceId);
      childrenMap.set(conn.destinationId, children);
    }
  }
  const rootIds = [];
  for (const point of points) {
    if (!parentMap.has(point.modelId)) {
      rootIds.push(point.modelId);
    }
  }
  rootIds.sort((a, b) => {
    const pointA = pointMap.get(a);
    const pointB = pointMap.get(b);
    const typeA = pointA?.type ?? "node";
    const typeB = pointB?.type ?? "node";
    if (typeA === "doc" && typeB !== "doc") {
      return -1;
    }
    if (typeA !== "doc" && typeB === "doc") {
      return 1;
    }
    return 0;
  });
  const nodeMap = new Map;
  let maxDepth = 0;
  function buildNode(id, depth, siblingIndex, siblingCount, parent) {
    const point = pointMap.get(id);
    if (!point) {
      return;
    }
    const childIds = childrenMap.get(id) ?? [];
    if (depth > maxDepth) {
      maxDepth = depth;
    }
    const node = {
      id,
      type: parsePointType(point.type),
      propertySet: point.propertySet,
      shapeProperties: point.shapeProperties,
      textBody: point.textBody,
      children: [],
      depth,
      siblingIndex,
      siblingCount,
      parent
    };
    const children = [];
    for (let i2 = 0;i2 < childIds.length; i2++) {
      const child = buildNode(childIds[i2], depth + 1, i2, childIds.length, node);
      if (child) {
        children.push(child);
      }
    }
    const finalNode = {
      ...node,
      children
    };
    nodeMap.set(id, finalNode);
    return finalNode;
  }
  const roots = [];
  for (let i2 = 0;i2 < rootIds.length; i2++) {
    const root = buildNode(rootIds[i2], 0, i2, rootIds.length, undefined);
    if (root) {
      roots.push(root);
    }
  }
  return {
    roots,
    nodeCount: nodeMap.size,
    maxDepth,
    nodeMap
  };
}
function parsePointType(type) {
  switch (type) {
    case "doc":
      return "doc";
    case "asst":
      return "asst";
    case "parTrans":
      return "parTrans";
    case "sibTrans":
      return "sibTrans";
    case "pres":
      return "pres";
    case "node":
    default:
      return "node";
  }
}

// packages/@oxen-office/diagram/src/layout-engine/types.ts
function createDefaultContext(options) {
  const paramMap = new Map;
  if (options.params) {
    for (const param of options.params) {
      if (param.type && param.value !== undefined) {
        paramMap.set(param.type, param.value);
      }
    }
  }
  return {
    bounds: options.bounds,
    params: paramMap,
    constraints: options.constraints ?? [],
    currentNode: options.currentNode,
    position: options.position,
    totalCount: options.totalCount,
    allNodes: options.allNodes,
    parent: options.parent,
    variables: options.variables ?? new Map,
    resolvedConstraints: options.resolvedConstraints ?? new Map,
    namedNodes: options.namedNodes ?? new Map
  };
}
function getParam(context, key, defaultValue) {
  const value = context.params.get(key);
  if (value === undefined) {
    return defaultValue;
  }
  return value;
}
function getConstraint(context, type, defaultValue) {
  const value = context.resolvedConstraints.get(type);
  return value ?? defaultValue;
}
function createEmptyResult() {
  return {
    nodes: [],
    bounds: { x: 0, y: 0, width: 0, height: 0 }
  };
}
function mergeBounds(...bounds) {
  if (bounds.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (const b of bounds) {
    minX = Math.min(minX, b.x);
    minY = Math.min(minY, b.y);
    maxX = Math.max(maxX, b.x + b.width);
    maxY = Math.max(maxY, b.y + b.height);
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}

// packages/@oxen-office/diagram/src/layout-engine/algorithms.ts
var FALLBACK_NODE_WIDTH = 100;
var FALLBACK_NODE_HEIGHT = 60;
var FALLBACK_SPACING = 10;
function getNodeDimensions(context) {
  const width = getConstraint(context, "w", context.defaultNodeWidth ?? FALLBACK_NODE_WIDTH);
  const height = getConstraint(context, "h", context.defaultNodeHeight ?? FALLBACK_NODE_HEIGHT);
  return { width, height };
}
function getSpacing(context) {
  return getConstraint(context, "sibSp", context.defaultSpacing ?? FALLBACK_SPACING);
}
function alignHorizontally(bounds, nodeWidth, alignment) {
  switch (alignment) {
    case "l":
      return bounds.x;
    case "r":
      return bounds.x + bounds.width - nodeWidth;
    case "ctr":
    default:
      return bounds.x + (bounds.width - nodeWidth) / 2;
  }
}
function alignVertically(bounds, nodeHeight, alignment) {
  switch (alignment) {
    case "t":
      return bounds.y;
    case "b":
      return bounds.y + bounds.height - nodeHeight;
    case "mid":
    default:
      return bounds.y + (bounds.height - nodeHeight) / 2;
  }
}
function calculateTotalPrimarySize(nodeCount, nodeSize, spacing) {
  return nodeCount * nodeSize + (nodeCount - 1) * spacing;
}
function calculateVerticalStartPosition(bounds, totalSize, alignment) {
  switch (alignment) {
    case "b":
      return bounds.y + bounds.height - totalSize;
    case "mid":
      return bounds.y + (bounds.height - totalSize) / 2;
    case "t":
    default:
      return bounds.y;
  }
}
function calculateHorizontalStartPosition(bounds, totalSize, alignment) {
  switch (alignment) {
    case "r":
      return bounds.x + bounds.width - totalSize;
    case "ctr":
      return bounds.x + (bounds.width - totalSize) / 2;
    case "l":
    default:
      return bounds.x;
  }
}
function calculateLinearStartPosition(isVertical, bounds, totalSize, horzAlign, vertAlign) {
  if (isVertical) {
    return calculateVerticalStartPosition(bounds, totalSize, vertAlign);
  }
  return calculateHorizontalStartPosition(bounds, totalSize, horzAlign);
}
function buildLinearLayoutNodes(orderedNodes, startPosition, isVertical, bounds, nodeWidth, nodeHeight, nodeHorzAlign, nodeVertAlign, spacing) {
  return orderedNodes.reduce((acc, node) => {
    const x2 = isVertical ? alignHorizontally(bounds, nodeWidth, nodeHorzAlign) : acc.position;
    const y = isVertical ? acc.position : alignVertically(bounds, nodeHeight, nodeVertAlign);
    const layoutNode = {
      treeNode: node,
      x: x2,
      y,
      width: nodeWidth,
      height: nodeHeight,
      children: []
    };
    return {
      nodes: [...acc.nodes, layoutNode],
      position: acc.position + (isVertical ? nodeHeight : nodeWidth) + spacing
    };
  }, { nodes: [], position: startPosition }).nodes;
}
var linearLayout = (nodes, context) => {
  if (nodes.length === 0) {
    return createEmptyResult();
  }
  const linDir = getParam(context, "linDir", "fromL");
  const nodeHorzAlign = getParam(context, "nodeHorzAlign", "ctr");
  const nodeVertAlign = getParam(context, "nodeVertAlign", "mid");
  const isVertical = linDir === "fromT" || linDir === "fromB";
  const isReverse = linDir === "fromR" || linDir === "fromB";
  const { bounds } = context;
  const { width: nodeWidth, height: nodeHeight } = getNodeDimensions(context);
  const spacing = getSpacing(context);
  const orderedNodes = isReverse ? [...nodes].reverse() : nodes;
  const primaryNodeSize = isVertical ? nodeHeight : nodeWidth;
  const totalPrimarySize = calculateTotalPrimarySize(nodes.length, primaryNodeSize, spacing);
  const startPosition = calculateLinearStartPosition(isVertical, bounds, totalPrimarySize, nodeHorzAlign, nodeVertAlign);
  const layoutNodes = buildLinearLayoutNodes(orderedNodes, startPosition, isVertical, bounds, nodeWidth, nodeHeight, nodeHorzAlign, nodeVertAlign, spacing);
  const resultBounds = mergeBounds(...layoutNodes.map((n) => ({
    x: n.x,
    y: n.y,
    width: n.width,
    height: n.height
  })));
  return {
    nodes: layoutNodes,
    bounds: resultBounds
  };
};
var spaceLayout = (nodes, context) => {
  if (nodes.length === 0) {
    return createEmptyResult();
  }
  const { bounds } = context;
  const nodeHorzAlign = getParam(context, "nodeHorzAlign", "ctr");
  const nodeVertAlign = getParam(context, "nodeVertAlign", "mid");
  const { width: nodeWidth, height: nodeHeight } = getNodeDimensions(context);
  const node = nodes[0];
  const x2 = alignHorizontally(bounds, nodeWidth, nodeHorzAlign);
  const y = alignVertically(bounds, nodeHeight, nodeVertAlign);
  const layoutNode = {
    treeNode: node,
    x: x2,
    y,
    width: nodeWidth,
    height: nodeHeight,
    children: []
  };
  return {
    nodes: [layoutNode],
    bounds: {
      x: layoutNode.x,
      y: layoutNode.y,
      width: layoutNode.width,
      height: layoutNode.height
    }
  };
};
function calculateChildBounds(bounds, isVertical, currentPosition, nodeWidth, nodeHeight, spacing) {
  return {
    x: isVertical ? bounds.x + nodeWidth + spacing : bounds.x,
    y: isVertical ? currentPosition : bounds.y + nodeHeight + spacing,
    width: bounds.width - nodeWidth - spacing,
    height: bounds.height - nodeHeight - spacing
  };
}
function calculateChildTotalHeight(childResults, spacing) {
  if (childResults.length === 0) {
    return 0;
  }
  return childResults.reduce((sum, c) => sum + c.height + spacing, -spacing);
}
function calculateHierNodePosition(bounds, isVertical, currentPosition, nodeWidth, nodeHeight, nodeHorzAlign, nodeVertAlign, childResults, childTotalHeight) {
  if (isVertical) {
    const x2 = alignHorizontally(bounds, nodeWidth, nodeHorzAlign);
    const y = calculateVerticalChildOffset(childResults.length, currentPosition, childTotalHeight, nodeHeight);
    return { x: x2, y };
  }
  return {
    x: bounds.x,
    y: alignVertically(bounds, nodeHeight, nodeVertAlign)
  };
}
function calculateVerticalChildOffset(childCount, currentPosition, childTotalHeight, nodeHeight) {
  if (childCount > 0) {
    return currentPosition + (childTotalHeight - nodeHeight) / 2;
  }
  return currentPosition;
}
function getChildResults(children, childContext, childHorizontal, nodeWidth, nodeHeight, spacing) {
  if (children.length === 0) {
    return [];
  }
  return buildChildrenHierarchy(children, childContext, childHorizontal, nodeWidth, nodeHeight, spacing);
}
function buildHierarchyLayoutNodes(nodes, context, isVertical, childHorizontal, bounds, nodeWidth, nodeHeight, nodeHorzAlign, nodeVertAlign, spacing) {
  const startPosition = isVertical ? bounds.y : bounds.x;
  return nodes.reduce((acc, node) => {
    const childBounds = calculateChildBounds(bounds, isVertical, acc.position, nodeWidth, nodeHeight, spacing);
    const childContext = { ...context, bounds: childBounds };
    const childResults = getChildResults(node.children, childContext, childHorizontal, nodeWidth, nodeHeight, spacing);
    const childTotalHeight = calculateChildTotalHeight(childResults, spacing);
    const { x: nodeX, y: nodeY } = calculateHierNodePosition(bounds, isVertical, acc.position, nodeWidth, nodeHeight, nodeHorzAlign, nodeVertAlign, childResults, childTotalHeight);
    const layoutNode = {
      treeNode: node,
      x: nodeX,
      y: nodeY,
      width: nodeWidth,
      height: nodeHeight,
      children: childResults
    };
    const advanceAmount = Math.max(nodeHeight + spacing, childTotalHeight + spacing);
    const nextPosition = isVertical ? acc.position + advanceAmount : acc.position;
    return {
      nodes: [...acc.nodes, layoutNode],
      position: nextPosition
    };
  }, { nodes: [], position: startPosition }).nodes;
}
var hierChildLayout = (nodes, context) => {
  if (nodes.length === 0) {
    return createEmptyResult();
  }
  const linDir = getParam(context, "linDir", "fromT");
  const chDir = getParam(context, "chDir", "horz");
  const nodeHorzAlign = getParam(context, "nodeHorzAlign", "l");
  const nodeVertAlign = getParam(context, "nodeVertAlign", "t");
  const { bounds } = context;
  const { width: nodeWidth, height: nodeHeight } = getNodeDimensions(context);
  const spacing = getSpacing(context);
  const isVertical = linDir === "fromT" || linDir === "fromB";
  const childHorizontal = chDir === "horz";
  const layoutNodes = buildHierarchyLayoutNodes(nodes, context, isVertical, childHorizontal, bounds, nodeWidth, nodeHeight, nodeHorzAlign, nodeVertAlign, spacing);
  const allBounds = layoutNodes.flatMap((n) => [
    { x: n.x, y: n.y, width: n.width, height: n.height },
    ...flattenChildBounds(n.children)
  ]);
  return {
    nodes: layoutNodes,
    bounds: mergeBounds(...allBounds)
  };
};
function buildChildrenHierarchy(children, context, horizontal, nodeWidth, nodeHeight, spacing) {
  const { bounds } = context;
  const startPos = horizontal ? bounds.x : bounds.y;
  const step = (horizontal ? nodeWidth : nodeHeight) + spacing;
  return children.map((child, index) => ({
    treeNode: child,
    x: horizontal ? startPos + index * step : bounds.x,
    y: horizontal ? bounds.y : startPos + index * step,
    width: nodeWidth,
    height: nodeHeight,
    children: []
  }));
}
function flattenChildBounds(children) {
  return children.flatMap((child) => [
    { x: child.x, y: child.y, width: child.width, height: child.height },
    ...flattenChildBounds(child.children)
  ]);
}
function buildCycleLayoutNodes(cycleNodes, centerX, centerY, radius, nodeWidth, nodeHeight, startAngle, angleStep, rotPath) {
  return cycleNodes.map((node, index) => {
    const currentAngle = startAngle + index * angleStep;
    const x2 = centerX + radius * Math.cos(currentAngle) - nodeWidth / 2;
    const y = centerY + radius * Math.sin(currentAngle) - nodeHeight / 2;
    const rotation = calculateCycleRotation(rotPath, currentAngle);
    return {
      treeNode: node,
      x: x2,
      y,
      width: nodeWidth,
      height: nodeHeight,
      rotation,
      children: []
    };
  });
}
function calculateCycleRotation(rotPath, currentAngle) {
  if (rotPath === "alongPath") {
    return (currentAngle + Math.PI / 2) * (180 / Math.PI);
  }
  return;
}
function getCenterNodes(hasCenterNode, nodes, centerX, centerY, nodeWidth, nodeHeight) {
  if (!hasCenterNode) {
    return [];
  }
  return [createCenterNode(nodes[0], centerX, centerY, nodeWidth, nodeHeight)];
}
function createCenterNode(treeNode, centerX, centerY, nodeWidth, nodeHeight) {
  return {
    treeNode,
    x: centerX - nodeWidth / 2,
    y: centerY - nodeHeight / 2,
    width: nodeWidth,
    height: nodeHeight,
    children: []
  };
}
var cycleLayout = (nodes, context) => {
  if (nodes.length === 0) {
    return createEmptyResult();
  }
  const { bounds } = context;
  const stAng = getParam(context, "stAng", 0);
  const spanAng = getParam(context, "spanAng", 360);
  const ctrShpMap = getParam(context, "ctrShpMap", "none");
  const rotPath = getParam(context, "rotPath", "none");
  const { width: nodeWidth, height: nodeHeight } = getNodeDimensions(context);
  const centerX = bounds.x + bounds.width / 2;
  const centerY = bounds.y + bounds.height / 2;
  const diameter = getConstraint(context, "diam", Math.min(bounds.width, bounds.height));
  const radius = diameter / 2 - Math.max(nodeWidth, nodeHeight) / 2;
  const hasCenterNode = ctrShpMap === "fNode" && nodes.length > 0;
  const centerNodes = getCenterNodes(hasCenterNode, nodes, centerX, centerY, nodeWidth, nodeHeight);
  const cycleNodes = hasCenterNode ? nodes.slice(1) : nodes;
  const nodeCount = cycleNodes.length;
  if (nodeCount === 0) {
    return {
      nodes: centerNodes,
      bounds: mergeBounds(...centerNodes.map((n) => ({
        x: n.x,
        y: n.y,
        width: n.width,
        height: n.height
      })))
    };
  }
  const angleStep = spanAng / nodeCount * (Math.PI / 180);
  const startAngle = (stAng - 90) * (Math.PI / 180);
  const cycleLayoutNodes = buildCycleLayoutNodes(cycleNodes, centerX, centerY, radius, nodeWidth, nodeHeight, startAngle, angleStep, rotPath);
  const allNodes = [...centerNodes, ...cycleLayoutNodes];
  return {
    nodes: allNodes,
    bounds: mergeBounds(...allNodes.map((n) => ({
      x: n.x,
      y: n.y,
      width: n.width,
      height: n.height
    })))
  };
};
function shouldReverseSnakeRow(reverseDirection, row, startFromRight) {
  if (reverseDirection) {
    return row % 2 === 0 ? startFromRight : !startFromRight;
  }
  return startFromRight;
}
function calculateSnakeRowY(bounds, row, nodeHeight, spacing, startFromBottom) {
  if (startFromBottom) {
    return bounds.y + bounds.height - (row + 1) * (nodeHeight + spacing) + spacing;
  }
  return bounds.y + row * (nodeHeight + spacing);
}
function calculateSnakeColX(bounds, row, nodeWidth, spacing, startFromRight) {
  if (startFromRight) {
    return bounds.x + bounds.width - (row + 1) * (nodeWidth + spacing) + spacing;
  }
  return bounds.x + row * (nodeWidth + spacing);
}
function calculateNodesPerRow(isRowFlow, bounds, nodeWidth, nodeHeight, spacing) {
  if (isRowFlow) {
    return Math.floor((bounds.width + spacing) / (nodeWidth + spacing));
  }
  return Math.floor((bounds.height + spacing) / (nodeHeight + spacing));
}
function calculateSnakePosition(index, config) {
  const { bounds, nodeWidth, nodeHeight, spacing, maxPerRow, isRowFlow, startFromRight, startFromBottom, reverseDirection } = config;
  const row = Math.floor(index / maxPerRow);
  const col = index % maxPerRow;
  const shouldReverse = shouldReverseSnakeRow(reverseDirection, row, startFromRight);
  const rawActualCol = shouldReverse ? maxPerRow - 1 - col : col;
  const actualCol = Math.max(0, rawActualCol);
  if (isRowFlow) {
    const x3 = bounds.x + actualCol * (nodeWidth + spacing);
    const y2 = calculateSnakeRowY(bounds, row, nodeHeight, spacing, startFromBottom);
    return { x: x3, y: y2 };
  }
  const x2 = calculateSnakeColX(bounds, row, nodeWidth, spacing, startFromRight);
  const y = bounds.y + actualCol * (nodeHeight + spacing);
  return { x: x2, y };
}
function buildSnakeLayoutNodes(nodes, config) {
  return nodes.map((node, index) => {
    const { x: x2, y } = calculateSnakePosition(index, config);
    return {
      treeNode: node,
      x: x2,
      y,
      width: config.nodeWidth,
      height: config.nodeHeight,
      children: []
    };
  });
}
var snakeLayout = (nodes, context) => {
  if (nodes.length === 0) {
    return createEmptyResult();
  }
  const { bounds } = context;
  const flowDir = getParam(context, "flowDir", "row");
  const grDir = getParam(context, "grDir", "tL");
  const contDir = getParam(context, "contDir", "revDir");
  const { width: nodeWidth, height: nodeHeight } = getNodeDimensions(context);
  const spacing = getSpacing(context);
  const isRowFlow = flowDir === "row";
  const nodesPerRow = calculateNodesPerRow(isRowFlow, bounds, nodeWidth, nodeHeight, spacing);
  const maxPerRow = Math.max(1, nodesPerRow);
  const startFromRight = grDir === "tR" || grDir === "bR";
  const startFromBottom = grDir === "bL" || grDir === "bR";
  const config = {
    bounds,
    nodeWidth,
    nodeHeight,
    spacing,
    maxPerRow,
    isRowFlow,
    startFromRight,
    startFromBottom,
    reverseDirection: contDir === "revDir"
  };
  const layoutNodes = buildSnakeLayoutNodes(nodes, config);
  return {
    nodes: layoutNodes,
    bounds: mergeBounds(...layoutNodes.map((n) => ({
      x: n.x,
      y: n.y,
      width: n.width,
      height: n.height
    })))
  };
};
function calculatePyramidWidthStep(nodeCount, boundsWidth, baseWidth) {
  if (nodeCount <= 1) {
    return 0;
  }
  return (boundsWidth - baseWidth) / (nodeCount - 1);
}
var pyramidLayout = (nodes, context) => {
  if (nodes.length === 0) {
    return createEmptyResult();
  }
  const { bounds } = context;
  const linDir = getParam(context, "linDir", "fromT");
  const isFromTop = linDir === "fromT";
  const { width: baseWidth, height: nodeHeight } = getNodeDimensions(context);
  const spacing = getSpacing(context);
  const centerX = bounds.x + bounds.width / 2;
  const layoutNodes = [];
  const widthStep = calculatePyramidWidthStep(nodes.length, bounds.width, baseWidth);
  for (let i2 = 0;i2 < nodes.length; i2++) {
    const node = nodes[isFromTop ? i2 : nodes.length - 1 - i2];
    const levelIndex = isFromTop ? i2 : nodes.length - 1 - i2;
    const levelWidth = baseWidth + widthStep * levelIndex;
    const x2 = centerX - levelWidth / 2;
    const y = bounds.y + i2 * (nodeHeight + spacing);
    const layoutNode = {
      treeNode: node,
      x: x2,
      y,
      width: levelWidth,
      height: nodeHeight,
      children: []
    };
    layoutNodes.push(layoutNode);
  }
  return {
    nodes: layoutNodes,
    bounds: mergeBounds(...layoutNodes.map((n) => ({
      x: n.x,
      y: n.y,
      width: n.width,
      height: n.height
    })))
  };
};
var compositeLayout = (nodes, context) => {
  if (nodes.length === 0) {
    return createEmptyResult();
  }
  const { bounds } = context;
  const { width: nodeWidth, height: nodeHeight } = getNodeDimensions(context);
  const layoutNodes = [];
  for (const node of nodes) {
    const x2 = bounds.x + (bounds.width - nodeWidth) / 2;
    const y = bounds.y + (bounds.height - nodeHeight) / 2;
    const layoutNode = {
      treeNode: node,
      x: x2,
      y,
      width: nodeWidth,
      height: nodeHeight,
      children: []
    };
    layoutNodes.push(layoutNode);
  }
  return {
    nodes: layoutNodes,
    bounds: mergeBounds(...layoutNodes.map((n) => ({
      x: n.x,
      y: n.y,
      width: n.width,
      height: n.height
    })))
  };
};
var connectorLayout = (nodes, context) => {
  if (nodes.length === 0) {
    return createEmptyResult();
  }
  const { bounds } = context;
  const connWidth = getConstraint(context, "connDist", 20);
  const { height: nodeHeight } = getNodeDimensions(context);
  const layoutNodes = [];
  for (const node of nodes) {
    const layoutNode = {
      treeNode: node,
      x: bounds.x,
      y: bounds.y,
      width: connWidth,
      height: nodeHeight,
      children: [],
      isConnector: true
    };
    layoutNodes.push(layoutNode);
  }
  if (layoutNodes.length === 0) {
    return createEmptyResult();
  }
  return {
    nodes: layoutNodes,
    bounds: mergeBounds(...layoutNodes.map((n) => ({
      x: n.x,
      y: n.y,
      width: n.width,
      height: n.height
    })))
  };
};
var textLayout = (nodes, context) => {
  if (nodes.length === 0) {
    return createEmptyResult();
  }
  const { bounds } = context;
  const nodeHorzAlign = getParam(context, "nodeHorzAlign", "ctr");
  const nodeVertAlign = getParam(context, "nodeVertAlign", "mid");
  const { width: nodeWidth, height: nodeHeight } = getNodeDimensions(context);
  const node = nodes[0];
  const x2 = alignHorizontally(bounds, nodeWidth, nodeHorzAlign);
  const y = alignVertically(bounds, nodeHeight, nodeVertAlign);
  const layoutNode = {
    treeNode: node,
    x: x2,
    y,
    width: nodeWidth,
    height: nodeHeight,
    children: []
  };
  return {
    nodes: [layoutNode],
    bounds: {
      x: layoutNode.x,
      y: layoutNode.y,
      width: layoutNode.width,
      height: layoutNode.height
    }
  };
};
function createAlgorithmRegistry() {
  const registry = new Map;
  registry.set("lin", linearLayout);
  registry.set("sp", spaceLayout);
  registry.set("hierChild", hierChildLayout);
  registry.set("hierRoot", hierChildLayout);
  registry.set("cycle", cycleLayout);
  registry.set("snake", snakeLayout);
  registry.set("pyra", pyramidLayout);
  registry.set("composite", compositeLayout);
  registry.set("conn", connectorLayout);
  registry.set("tx", textLayout);
  return registry;
}
function getLayoutAlgorithm(registry, type) {
  if (!type) {
    return linearLayout;
  }
  const algorithm = registry.get(type);
  if (!algorithm) {
    console.warn(`Unknown layout algorithm: ${type}, using linear`);
    return linearLayout;
  }
  return algorithm;
}

// packages/@oxen-office/diagram/src/layout-engine/constraints.ts
function resolveConstraint(constraint, context) {
  const { type } = constraint;
  if (!type) {
    return;
  }
  const numericValue = parseConstraintValue(constraint.value);
  const factor = parseConstraintValue(constraint.factor) ?? 1;
  const min = parseConstraintValue(constraint.min);
  const max2 = parseConstraintValue(constraint.max);
  if (constraint.referenceType) {
    const refKey = buildConstraintKey(constraint.referenceType, constraint.referenceForName);
    const refValue = context.resolvedConstraints.get(refKey);
    if (refValue !== undefined) {
      const resolvedValue2 = applyMinMax(refValue * factor, min, max2);
      return {
        type,
        value: resolvedValue2,
        isReference: true,
        forName: constraint.forName
      };
    }
  }
  const baseValue = resolveConstraintType(type, numericValue, context);
  const resolvedValue = applyMinMax(baseValue * factor, min, max2);
  return {
    type,
    value: resolvedValue,
    isReference: false,
    forName: constraint.forName
  };
}
function resolveConstraintType(type, explicitValue, context) {
  const { bounds } = context;
  if (explicitValue !== undefined) {
    return explicitValue;
  }
  switch (type) {
    case "w":
      return bounds.width;
    case "h":
      return bounds.height;
    case "l":
      return bounds.x;
    case "t":
      return bounds.y;
    case "r":
      return bounds.x + bounds.width;
    case "b":
      return bounds.y + bounds.height;
    case "ctrX":
      return bounds.x + bounds.width / 2;
    case "ctrY":
      return bounds.y + bounds.height / 2;
    case "wOff":
    case "hOff":
    case "lOff":
    case "tOff":
    case "rOff":
    case "bOff":
    case "ctrXOff":
    case "ctrYOff":
      return 0;
    case "lMarg":
    case "rMarg":
    case "tMarg":
    case "bMarg":
      return 10;
    case "sp":
    case "sibSp":
    case "secSibSp":
      return 10;
    case "primFontSz":
      return 18;
    case "secFontSz":
      return 14;
    case "connDist":
    case "bendDist":
      return 20;
    case "begPad":
    case "endPad":
    case "begMarg":
    case "endMarg":
      return 5;
    case "wArH":
    case "hArH":
      return 10;
    case "pyraAcctRatio":
      return 0.3;
    case "stemThick":
      return 2;
    case "diam":
      return Math.min(bounds.width, bounds.height);
    case "alignOff":
      return 0;
    default:
      if (type.startsWith("user")) {
        return 0;
      }
      return 0;
  }
}
function applyConstraints(node, constraints, context) {
  let x2 = node.x;
  let y = node.y;
  let width = node.width;
  let height = node.height;
  for (const constraint of constraints) {
    if (constraint.forName && constraint.forRelationship === "self") {}
    const resolved = resolveConstraint(constraint, context);
    if (!resolved) {
      continue;
    }
    const key = buildConstraintKey(resolved.type, resolved.forName);
    context.resolvedConstraints.set(key, resolved.value);
    switch (resolved.type) {
      case "w":
        width = resolved.value;
        break;
      case "h":
        height = resolved.value;
        break;
      case "l":
        x2 = resolved.value;
        break;
      case "t":
        y = resolved.value;
        break;
      case "r":
        x2 = resolved.value - width;
        break;
      case "b":
        y = resolved.value - height;
        break;
      case "ctrX":
        x2 = resolved.value - width / 2;
        break;
      case "ctrY":
        y = resolved.value - height / 2;
        break;
      case "wOff":
        width += resolved.value;
        break;
      case "hOff":
        height += resolved.value;
        break;
      case "lOff":
        x2 += resolved.value;
        break;
      case "tOff":
        y += resolved.value;
        break;
      case "rOff":
        x2 -= resolved.value;
        break;
      case "bOff":
        y -= resolved.value;
        break;
      case "ctrXOff":
        x2 += resolved.value;
        break;
      case "ctrYOff":
        y += resolved.value;
        break;
      default:
        break;
    }
  }
  return { x: x2, y, width, height };
}
function applyConstraintsToLayout(nodes, constraints, bounds) {
  const resolvedConstraints = new Map;
  const namedNodes = new Map;
  for (const node of nodes) {
    if (node.treeNode.propertySet?.presentationName) {
      namedNodes.set(node.treeNode.propertySet.presentationName, node);
    }
  }
  return nodes.map((node) => {
    const context = {
      bounds,
      siblings: nodes,
      namedNodes,
      resolvedConstraints
    };
    const result = applyConstraints(node, constraints, context);
    return {
      ...node,
      x: result.x,
      y: result.y,
      width: result.width,
      height: result.height
    };
  });
}
function parseConstraintValue(value) {
  if (value === undefined) {
    return;
  }
  const num = parseFloat(value);
  if (isNaN(num)) {
    return;
  }
  return num;
}
function applyMinMax(value, min, max2) {
  const clampedMin = min !== undefined && value < min ? min : value;
  return max2 !== undefined && clampedMin > max2 ? max2 : clampedMin;
}
function buildConstraintKey(type, forName) {
  return forName ? `${type}:${forName}` : type;
}

// packages/@oxen-office/diagram/src/layout-engine/iteration.ts
function processForEach(forEach, context) {
  const { currentNode } = context;
  let selectedNodes = selectNodesByAxis(currentNode, forEach.axis ?? ["ch"], context.allNodes);
  if (forEach.pointType && forEach.pointType.length > 0) {
    selectedNodes = filterNodesByPointType(selectedNodes, forEach.pointType);
  }
  selectedNodes = applyIterationParams(selectedNodes, forEach.start?.[0], forEach.step?.[0], forEach.count?.[0]);
  if (forEach.hideLastTransition?.[0] === true) {
    selectedNodes = hideLastTransitionNode(selectedNodes);
  }
  return {
    selectedNodes,
    content: forEach.content
  };
}
function selectNodesByAxis(currentNode, axes, allNodes) {
  const result = [];
  for (const axis of axes) {
    const axisNodes = selectNodesBySingleAxis(currentNode, axis, allNodes);
    for (const node of axisNodes) {
      if (!result.some((n) => n.id === node.id)) {
        result.push(node);
      }
    }
  }
  return result;
}
function selectNodesBySingleAxis(currentNode, axis, allNodes) {
  switch (axis) {
    case "self":
      return [currentNode];
    case "ch":
      return [...currentNode.children];
    case "des":
      return getDescendants(currentNode, false);
    case "desOrSelf":
      return getDescendants(currentNode, true);
    case "par":
      return findParent(currentNode, allNodes);
    case "ancst":
      return getAncestors(currentNode, allNodes, false);
    case "ancstOrSelf":
      return getAncestors(currentNode, allNodes, true);
    case "root":
      return getRootNode(currentNode, allNodes);
    case "follow":
      return getFollowingSiblings(currentNode, allNodes);
    case "followSib":
      return getFollowingSiblings(currentNode, allNodes);
    case "preced":
      return getPrecedingSiblings(currentNode, allNodes);
    case "precedSib":
      return getPrecedingSiblings(currentNode, allNodes);
    case "none":
      return [];
    default:
      return [];
  }
}
function getDescendants(node, includeSelf) {
  const result = [];
  if (includeSelf) {
    result.push(node);
  }
  function collectDescendants(n) {
    for (const child of n.children) {
      result.push(child);
      collectDescendants(child);
    }
  }
  collectDescendants(node);
  return result;
}
function findParent(node, allNodes) {
  function findInTree(searchNode, parent) {
    if (searchNode.id === node.id) {
      return parent;
    }
    for (const child of searchNode.children) {
      const found = findInTree(child, searchNode);
      if (found) {
        return found;
      }
    }
    return;
  }
  for (const root of allNodes) {
    const parent = findInTree(root, undefined);
    if (parent) {
      return [parent];
    }
  }
  return [];
}
function getAncestors(node, allNodes, includeSelf) {
  const result = [];
  if (includeSelf) {
    result.push(node);
  }
  let current = node;
  let parent = findParent(current, allNodes);
  while (parent.length > 0) {
    result.push(parent[0]);
    current = parent[0];
    parent = findParent(current, allNodes);
  }
  return result;
}
function getRootNode(node, allNodes) {
  const ancestors = getAncestors(node, allNodes, true);
  if (ancestors.length > 0) {
    return [ancestors[ancestors.length - 1]];
  }
  return [node];
}
function getFollowingSiblings(node, allNodes) {
  const parent = findParent(node, allNodes);
  if (parent.length === 0) {
    return [];
  }
  const siblings = parent[0].children;
  const index = siblings.findIndex((s) => s.id === node.id);
  if (index === -1) {
    return [];
  }
  return siblings.slice(index + 1);
}
function getPrecedingSiblings(node, allNodes) {
  const parent = findParent(node, allNodes);
  if (parent.length === 0) {
    return [];
  }
  const siblings = parent[0].children;
  const index = siblings.findIndex((s) => s.id === node.id);
  if (index === -1) {
    return [];
  }
  return siblings.slice(0, index);
}
function filterNodesByPointType(nodes, pointTypes) {
  return nodes.filter((node) => {
    for (const pt2 of pointTypes) {
      if (matchesPointType(node, pt2)) {
        return true;
      }
    }
    return false;
  });
}
function matchesPointType(node, pointType) {
  switch (pointType) {
    case "all":
      return true;
    case "node":
      return node.type === "node";
    case "doc":
      return node.type === "doc";
    case "asst":
      return node.type === "asst";
    case "parTrans":
      return node.type === "parTrans";
    case "sibTrans":
      return node.type === "sibTrans";
    case "pres":
      return node.type === "pres";
    case "nonAsst":
      return node.type !== "asst";
    case "nonNorm":
      return node.type !== "node";
    case "norm":
      return node.type === "node";
    default:
      return false;
  }
}
function applyIterationParams(nodes, start, step, count) {
  const startIndex = (start ?? 1) - 1;
  const stepValue = step ?? 1;
  const maxCount = count ?? nodes.length;
  const result = [];
  let collected = 0;
  for (let i2 = startIndex;i2 < nodes.length && collected < maxCount; i2 += stepValue) {
    if (i2 >= 0 && i2 < nodes.length) {
      result.push(nodes[i2]);
      collected++;
    }
  }
  return result;
}
function hideLastTransitionNode(nodes) {
  if (nodes.length === 0) {
    return [];
  }
  const lastNode = nodes[nodes.length - 1];
  if (lastNode.type === "parTrans" || lastNode.type === "sibTrans") {
    return nodes.slice(0, -1);
  }
  return [...nodes];
}
function processChoose(choose, context) {
  if (choose.if) {
    const ifResult = evaluateIf(choose.if, context);
    if (ifResult) {
      return {
        matched: true,
        content: choose.if,
        branchName: choose.if.name
      };
    }
  }
  if (choose.else) {
    return {
      matched: true,
      content: choose.else,
      branchName: choose.else.name
    };
  }
  return { matched: false };
}
function evaluateIf(ifElement, context) {
  const { function: funcType, argument, operator, value } = ifElement;
  if (!funcType) {
    return true;
  }
  const leftValue = evaluateFunction(funcType, argument, context);
  const rightValue = value;
  return evaluateOperator(leftValue, operator, rightValue);
}
function evaluateFunction(funcType, argument, context) {
  const { currentNode, position, allNodes, variables } = context;
  switch (funcType) {
    case "cnt":
      return currentNode.children.length;
    case "depth":
      return currentNode.depth;
    case "maxDepth":
      return calculateMaxDepth(allNodes);
    case "pos":
      return position;
    case "posEven":
      return position % 2 === 0;
    case "posOdd":
      return position % 2 === 1;
    case "revPos":
      return context.count - position + 1;
    case "var":
      if (argument) {
        return variables.get(argument) ?? 0;
      }
      return 0;
    default:
      return 0;
  }
}
function calculateMaxDepth(nodes) {
  let maxDepth = 0;
  function traverse(node) {
    if (node.depth > maxDepth) {
      maxDepth = node.depth;
    }
    for (const child of node.children) {
      traverse(child);
    }
  }
  for (const node of nodes) {
    traverse(node);
  }
  return maxDepth;
}
function toNumericValue(value) {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "boolean") {
    return value ? 1 : 0;
  }
  return parseFloat(String(value)) || 0;
}
function evaluateOperator(leftValue, operator, rightValue) {
  if (!operator || rightValue === undefined) {
    return true;
  }
  const left = toNumericValue(leftValue);
  const right = toNumericValue(rightValue);
  switch (operator) {
    case "equ":
      if (typeof leftValue === "string" && typeof rightValue === "string") {
        return leftValue === rightValue;
      }
      return left === right;
    case "neq":
      if (typeof leftValue === "string" && typeof rightValue === "string") {
        return leftValue !== rightValue;
      }
      return left !== right;
    case "gt":
      return left > right;
    case "gte":
      return left >= right;
    case "lt":
      return left < right;
    case "lte":
      return left <= right;
    default:
      return true;
  }
}
function createForEachContext(currentNode, allNodes, variables) {
  return {
    currentNode,
    allNodes,
    position: 1,
    count: 1,
    variables: variables ?? new Map
  };
}

// packages/@oxen-office/diagram/src/layout-engine/style-resolver.ts
function getStyleLabelIfPresent(styleLbl, styleDefinition) {
  if (!styleLbl) {
    return;
  }
  return findStyleLabel(styleLbl, styleDefinition);
}
function getColorStyleLabelIfPresent(styleLbl, colorDefinition) {
  if (!styleLbl) {
    return;
  }
  return findColorStyleLabel(styleLbl, colorDefinition);
}
function resolveNodeStyle(options) {
  const { node, nodeIndex, totalNodes, context } = options;
  const { styleDefinition, colorDefinition } = context;
  const styleLbl = node.propertySet?.presentationStyleLabel;
  const styleLabel = getStyleLabelIfPresent(styleLbl, styleDefinition);
  const colorStyleLabel = getColorStyleLabelIfPresent(styleLbl, colorDefinition);
  const fill = resolveFillFromList(colorStyleLabel?.fillColors, nodeIndex, totalNodes);
  const line = resolveLineFromList(colorStyleLabel?.lineColors, nodeIndex, totalNodes);
  const effectFill = resolveFillFromList(colorStyleLabel?.effectColors, nodeIndex, totalNodes);
  const textFill = resolveFillFromList(colorStyleLabel?.textFillColors, nodeIndex, totalNodes);
  const textLine = resolveLineFromList(colorStyleLabel?.textLineColors, nodeIndex, totalNodes);
  const textEffectFill = resolveFillFromList(colorStyleLabel?.textEffectColors, nodeIndex, totalNodes);
  return {
    fill,
    line,
    effectFill,
    textFill,
    textLine,
    textEffectFill,
    shapeStyle: styleLabel?.style,
    textProperties: styleLabel?.textProperties,
    styleLabel: styleLbl
  };
}
function findStyleLabel(name, styleDefinition) {
  if (!styleDefinition?.styleLabels) {
    return;
  }
  return styleDefinition.styleLabels.find((sl) => sl.name === name);
}
function findColorStyleLabel(name, colorDefinition) {
  if (!colorDefinition?.styleLabels) {
    return;
  }
  return colorDefinition.styleLabels.find((sl) => sl.name === name);
}
function resolveFillFromList(colorList, nodeIndex, totalNodes) {
  if (!colorList || colorList.colors.length === 0) {
    return;
  }
  const { colors, method } = colorList;
  const colorIndex = calculateColorIndex({
    nodeIndex,
    totalNodes,
    colorCount: colors.length,
    method
  });
  const color = colors[colorIndex];
  if (!color) {
    return;
  }
  const fill = {
    type: "solidFill",
    color
  };
  return fill;
}
function resolveLineFromList(colorList, nodeIndex, totalNodes) {
  const fill = resolveFillFromList(colorList, nodeIndex, totalNodes);
  if (!fill) {
    return;
  }
  const line = {
    width: px(1),
    cap: "flat",
    compound: "sng",
    alignment: "ctr",
    fill,
    dash: "solid",
    join: "round"
  };
  return line;
}
function calculateColorIndex(options) {
  const { nodeIndex, totalNodes, colorCount, method } = options;
  if (colorCount === 0) {
    return 0;
  }
  switch (method) {
    case "cycle":
      return nodeIndex % colorCount;
    case "repeat": {
      const segmentSize = Math.ceil(totalNodes / colorCount);
      return Math.min(Math.floor(nodeIndex / segmentSize), colorCount - 1);
    }
    case "span": {
      if (totalNodes <= 1) {
        return 0;
      }
      const ratio = nodeIndex / (totalNodes - 1);
      return Math.min(Math.floor(ratio * colorCount), colorCount - 1);
    }
    default:
      return nodeIndex % colorCount;
  }
}
function createStyleContext(colorContext, styleDefinition, colorDefinition) {
  return {
    styleDefinition,
    colorDefinition,
    colorContext
  };
}
function createEmptyColorContext() {
  return {
    colorScheme: {},
    colorMap: {}
  };
}

// packages/@oxen-office/diagram/src/layout-engine/shape-generator.ts
function generateShapesFromLayout(layoutNode, roots, config, styleContext, algorithmRegistry) {
  if (layoutNode) {
    return processLayoutNode(layoutNode, roots, config, styleContext, algorithmRegistry);
  }
  return generateDefaultLayout(roots, config, styleContext);
}
function generateDiagramLayoutResults(dataModel, layoutDefinition, styleDefinition, colorDefinition, config) {
  const treeResult = buildDiagramTree(dataModel);
  if (treeResult.roots.length === 0) {
    return {
      shapes: [],
      bounds: config.bounds,
      treeResult
    };
  }
  const algorithmRegistry = createAlgorithmRegistry();
  const colorContext = config.colorContext ?? createEmptyColorContext();
  const styleContext = createStyleContext(colorContext, styleDefinition, colorDefinition);
  const layoutNode = layoutDefinition?.layoutNode;
  const shapes = generateShapesFromLayout(layoutNode, treeResult.roots, config, styleContext, algorithmRegistry);
  const bounds = calculateTotalBounds(shapes, config.bounds);
  return {
    shapes,
    bounds,
    treeResult
  };
}
function applyConstraintsIfPresent(nodes, constraints, bounds) {
  if (constraints) {
    return applyConstraintsToLayout(nodes, constraints, bounds);
  }
  return nodes;
}
function processLayoutNode(layoutNode, dataNodes, config, styleContext, algorithmRegistry) {
  const shapes = [];
  const algorithmType = layoutNode.algorithm?.type ?? "lin";
  const algorithm = getLayoutAlgorithm(algorithmRegistry, algorithmType);
  const layoutContext = createLayoutContext(layoutNode, config);
  const rootNode = dataNodes[0];
  const forEachContext = createForEachContext(rootNode, dataNodes);
  const processedNodes = processLayoutContent(layoutNode, dataNodes, forEachContext);
  const layoutResult = algorithm(processedNodes, layoutContext);
  const constrainedNodes = applyConstraintsIfPresent(layoutResult.nodes, layoutNode.constraints, config.bounds);
  collectShapesFromLayoutNodes(constrainedNodes, layoutNode, styleContext, config, shapes);
  return shapes;
}
function collectShapesFromLayoutNodes(layoutNodes, layoutDef, styleContext, config, shapes) {
  for (let i2 = 0;i2 < layoutNodes.length; i2++) {
    const layoutNode = layoutNodes[i2];
    const style = resolveNodeStyle({
      node: layoutNode.treeNode,
      nodeIndex: i2,
      totalNodes: layoutNodes.length,
      context: styleContext
    });
    const shape = createLayoutShapeResultFromLayoutNode(layoutNode, layoutDef, style, config);
    shapes.push(shape);
    if (layoutNode.children.length > 0) {
      collectShapesFromLayoutNodes(layoutNode.children, undefined, styleContext, config, shapes);
    }
  }
}
function processLayoutContent(content, dataNodes, context) {
  let result = [...dataNodes];
  if (content.forEach && content.forEach.length > 0) {
    const forEachResults = [];
    for (const forEach of content.forEach) {
      const forEachResult = processForEach(forEach, context);
      forEachResults.push(...forEachResult.selectedNodes);
    }
    result = forEachResults;
  }
  if (content.choose && content.choose.length > 0) {
    for (const choose of content.choose) {
      processChoose(choose, context);
    }
  }
  return result;
}
function generateDefaultLayout(dataNodes, config, styleContext) {
  const shapes = [];
  const algorithmRegistry = createAlgorithmRegistry();
  const algorithm = getLayoutAlgorithm(algorithmRegistry, "lin");
  const layoutContext = {
    bounds: config.bounds,
    params: new Map,
    constraints: [],
    defaultSpacing: config.defaultSpacing ?? 10,
    defaultNodeWidth: config.defaultNodeWidth ?? 100,
    defaultNodeHeight: config.defaultNodeHeight ?? 60,
    variables: new Map,
    resolvedConstraints: new Map,
    namedNodes: new Map
  };
  const contentNodes = dataNodes.flatMap((n) => getContentNodesFlat(n));
  const layoutResult = algorithm(contentNodes, layoutContext);
  collectShapesFromLayoutNodes(layoutResult.nodes, undefined, styleContext, config, shapes);
  return shapes;
}
function getContentNodesFlat(node) {
  const result = [];
  if (node.type === "node" || node.type === "doc" || node.type === "asst") {
    result.push(node);
  }
  for (const child of node.children) {
    result.push(...getContentNodesFlat(child));
  }
  return result;
}
function createLayoutContext(layoutNode, config) {
  return createDefaultContext({
    bounds: config.bounds,
    params: layoutNode.algorithm?.params,
    constraints: layoutNode.constraints
  });
}
function createLayoutShapeResultFromLayoutNode(layoutNode, layoutDef, style, config) {
  const { treeNode, isConnector } = layoutNode;
  const shapeSpec = layoutDef?.shape;
  let shapeType = config.defaultShapeType ?? "rect";
  let isHidden = false;
  if (shapeSpec?.type) {
    if (shapeSpec.type === "none") {
      isHidden = true;
    } else if (shapeSpec.type === "conn") {
      shapeType = "line";
    } else {
      shapeType = shapeSpec.type;
    }
  }
  if (isConnector) {
    shapeType = "straightConnector1";
  }
  const transform = {
    x: layoutNode.x,
    y: layoutNode.y,
    width: layoutNode.width,
    height: layoutNode.height,
    rotation: layoutNode.rotation ?? 0,
    flipHorizontal: false,
    flipVertical: false
  };
  const adjustValues = [];
  if (shapeSpec?.adjustments) {
    for (const adj of shapeSpec.adjustments) {
      if (adj.index !== undefined && adj.value !== undefined) {
        const numValue = parseFloat(adj.value);
        if (!isNaN(numValue)) {
          const name = `adj${adj.index + 1}`;
          adjustValues.push({ name, value: numValue });
        }
      }
    }
  }
  const geometry = {
    type: "preset",
    preset: shapeType,
    adjustValues
  };
  return {
    id: `shape-${treeNode.id}`,
    name: `Diagram Shape ${treeNode.id}`,
    modelId: treeNode.id,
    transform,
    geometry: isHidden ? undefined : geometry,
    fill: isHidden ? undefined : style.fill,
    line: isHidden ? undefined : style.line,
    textFill: style.textFill,
    textLine: style.textLine,
    textBody: treeNode.textBody
  };
}
function calculateTotalBounds(shapes, defaultBounds) {
  if (shapes.length === 0) {
    return defaultBounds;
  }
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (const shape of shapes) {
    const transform = shape.transform;
    minX = Math.min(minX, transform.x);
    minY = Math.min(minY, transform.y);
    maxX = Math.max(maxX, transform.x + transform.width);
    maxY = Math.max(maxY, transform.y + transform.height);
  }
  if (minX === Infinity) {
    return defaultBounds;
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
// packages/@oxen-office/pptx/src/domain/diagram/format-guards.ts
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isTextBody(value) {
  if (!isObject(value)) {
    return false;
  }
  if (!("bodyProperties" in value) || !isObject(value.bodyProperties)) {
    return false;
  }
  return "paragraphs" in value && Array.isArray(value.paragraphs);
}

// packages/@oxen-office/pptx/src/adapters/diagram-to-shape.ts
function applyStyleFillToTextBody(textBody, textFill) {
  const updatedParagraphs = textBody.paragraphs.map((paragraph) => {
    if (!paragraph.runs) {
      return paragraph;
    }
    const updatedRuns = paragraph.runs.map((run) => {
      if (run.type === "text" && !run.properties?.fill) {
        return {
          ...run,
          properties: {
            ...run.properties,
            fill: textFill
          }
        };
      }
      return run;
    });
    return {
      ...paragraph,
      runs: updatedRuns
    };
  });
  return {
    ...textBody,
    paragraphs: updatedParagraphs
  };
}
function toPresetGeometry(geometry) {
  if (geometry === undefined) {
    return;
  }
  return {
    type: "preset",
    preset: geometry.preset,
    adjustValues: geometry.adjustValues
  };
}
function toTextBody(result) {
  if (!isTextBody(result.textBody)) {
    return;
  }
  if (!result.textFill) {
    return result.textBody;
  }
  return applyStyleFillToTextBody(result.textBody, result.textFill);
}
function convertLayoutResultToSpShape(result) {
  const geometry = toPresetGeometry(result.geometry);
  return {
    type: "sp",
    nonVisual: {
      id: result.id,
      name: result.name
    },
    properties: {
      transform: {
        x: px(result.transform.x),
        y: px(result.transform.y),
        width: px(result.transform.width),
        height: px(result.transform.height),
        rotation: deg(result.transform.rotation ?? 0),
        flipH: result.transform.flipHorizontal ?? false,
        flipV: result.transform.flipVertical ?? false
      },
      geometry,
      fill: result.fill,
      line: result.line,
      effects: result.effects
    },
    textBody: toTextBody(result),
    modelId: result.modelId
  };
}

// packages/@oxen-office/pptx/src/domain/diagram/layout-engine/shape-generator.ts
function generateDiagramShapes({
  dataModel,
  layoutDefinition,
  styleDefinition,
  colorDefinition,
  config
}) {
  const result = generateDiagramLayoutResults(dataModel, layoutDefinition, styleDefinition, colorDefinition, config);
  return {
    shapes: result.shapes.map(convertLayoutResultToSpShape),
    bounds: result.bounds,
    treeResult: result.treeResult
  };
}
// packages/@oxen-office/chart/src/parser/shape-properties.ts
function parseChartShapeProperties(spPr) {
  if (!spPr) {
    return;
  }
  const fill = parseBaseFillFromParent(spPr);
  const line = getLineFromProperties(spPr);
  if (!fill && !line) {
    return;
  }
  return { fill, line };
}
function parseChartLines(linesEl) {
  if (!linesEl) {
    return;
  }
  return {
    shapeProperties: parseChartShapeProperties(getChild(linesEl, "c:spPr"))
  };
}

// packages/@oxen-office/chart/src/parser/layout.ts
function getAttr2(element, name) {
  if (!element) {
    return;
  }
  return getAttr(element, name);
}
function parseManualLayout(manualLayoutEl) {
  const layoutTargetEl = getChild(manualLayoutEl, "c:layoutTarget");
  const xModeEl = getChild(manualLayoutEl, "c:xMode");
  const yModeEl = getChild(manualLayoutEl, "c:yMode");
  const wModeEl = getChild(manualLayoutEl, "c:wMode");
  const hModeEl = getChild(manualLayoutEl, "c:hMode");
  const xEl = getChild(manualLayoutEl, "c:x");
  const yEl = getChild(manualLayoutEl, "c:y");
  const wEl = getChild(manualLayoutEl, "c:w");
  const hEl = getChild(manualLayoutEl, "c:h");
  return {
    layoutTarget: getAttr2(layoutTargetEl, "val"),
    xMode: getAttr2(xModeEl, "val"),
    yMode: getAttr2(yModeEl, "val"),
    wMode: getAttr2(wModeEl, "val"),
    hMode: getAttr2(hModeEl, "val"),
    x: getFloatAttr(xEl, "val"),
    y: getFloatAttr(yEl, "val"),
    w: getFloatAttr(wEl, "val"),
    h: getFloatAttr(hEl, "val")
  };
}
function parseLayout(layoutEl) {
  if (!layoutEl) {
    return;
  }
  const manualLayoutEl = getChild(layoutEl, "c:manualLayout");
  if (!manualLayoutEl) {
    return {};
  }
  return {
    manualLayout: parseManualLayout(manualLayoutEl)
  };
}

// packages/@oxen-office/chart/src/parser/text-body.ts
function parseFontSize3(value) {
  const num = parseInt32(value);
  if (num === undefined) {
    return;
  }
  return pt(num / 100);
}
function mapParagraphAlignment2(algn) {
  switch (algn) {
    case "l":
      return "left";
    case "ctr":
      return "center";
    case "r":
      return "right";
    case "just":
      return "justify";
    case "justLow":
      return "justifyLow";
    case "dist":
      return "distributed";
    case "thaiDist":
      return "thaiDistributed";
    default:
      return;
  }
}
function parseRunProperties2(rPr) {
  if (!rPr) {
    return;
  }
  const latin = getChild(rPr, "a:latin");
  const solidFill = getChild(rPr, "a:solidFill");
  const color = solidFill ? parseColorFromParent(solidFill) : undefined;
  const bold = parseBoolean(getAttr(rPr, "b"));
  const italic = parseBoolean(getAttr(rPr, "i"));
  const fontSize = parseFontSize3(getAttr(rPr, "sz"));
  const fontFamily = latin ? getAttr(latin, "typeface") : undefined;
  const props = {
    fontSize,
    fontFamily,
    bold,
    italic,
    color
  };
  const hasAny = props.fontSize !== undefined || props.fontFamily !== undefined || props.bold !== undefined || props.italic !== undefined || props.color !== undefined;
  return hasAny ? props : undefined;
}
function parseParagraphProperties2(pPr) {
  if (!pPr) {
    return {};
  }
  const defRPr = getChild(pPr, "a:defRPr");
  return {
    alignment: mapParagraphAlignment2(getAttr(pPr, "algn")),
    defaultRunProperties: parseRunProperties2(defRPr)
  };
}
function parseTextRun2(child) {
  if (child.name !== "a:r" && child.name !== "a:br" && child.name !== "a:fld") {
    return;
  }
  const rPr = getChild(child, "a:rPr");
  const properties = parseRunProperties2(rPr);
  if (child.name === "a:br") {
    return { type: "break", properties };
  }
  if (child.name === "a:fld") {
    const t2 = getChild(child, "a:t");
    return {
      type: "field",
      fieldType: getAttr(child, "type") ?? "",
      id: getAttr(child, "id") ?? "",
      text: t2 ? getTextContent(t2) ?? "" : "",
      properties
    };
  }
  const t = getChild(child, "a:t");
  return {
    type: "text",
    text: t ? getTextContent(t) ?? "" : "",
    properties
  };
}
function parseParagraph(element) {
  const pPr = getChild(element, "a:pPr");
  const endParaRPr = getChild(element, "a:endParaRPr");
  const runs = [];
  for (const child of element.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    const run = parseTextRun2(child);
    if (run) {
      runs.push(run);
    }
  }
  return {
    properties: parseParagraphProperties2(pPr),
    runs,
    endProperties: parseRunProperties2(endParaRPr)
  };
}
function parseTextBody2(txBody) {
  if (!txBody) {
    return;
  }
  const paragraphs = [];
  for (const p of getChildren(txBody, "a:p")) {
    paragraphs.push(parseParagraph(p));
  }
  if (paragraphs.length === 0) {
    paragraphs.push({ properties: {}, runs: [] });
  }
  return {
    bodyProperties: {},
    paragraphs
  };
}

// packages/@oxen-office/chart/src/parser/mapping.ts
function mapMarkerSymbol(val) {
  switch (val) {
    case "circle":
      return "circle";
    case "dash":
      return "dash";
    case "diamond":
      return "diamond";
    case "dot":
      return "dot";
    case "none":
      return "none";
    case "picture":
      return "picture";
    case "plus":
      return "plus";
    case "square":
      return "square";
    case "star":
      return "star";
    case "triangle":
      return "triangle";
    case "x":
      return "x";
    default:
      return;
  }
}
function mapDataLabelPosition(val) {
  switch (val) {
    case "bestFit":
      return "bestFit";
    case "b":
      return "b";
    case "ctr":
      return "ctr";
    case "inBase":
      return "inBase";
    case "inEnd":
      return "inEnd";
    case "l":
      return "l";
    case "outEnd":
      return "outEnd";
    case "r":
      return "r";
    case "t":
      return "t";
    default:
      return;
  }
}
function mapLegendPosition(val) {
  switch (val) {
    case "b":
      return "b";
    case "l":
      return "l";
    case "r":
      return "r";
    case "t":
      return "t";
    case "tr":
      return "tr";
    default:
      return "r";
  }
}
function mapTrendlineType(val) {
  switch (val) {
    case "exp":
      return "exp";
    case "linear":
      return "linear";
    case "log":
      return "log";
    case "movingAvg":
      return "movingAvg";
    case "poly":
      return "poly";
    case "power":
      return "power";
    default:
      return "linear";
  }
}
function mapErrorBarDirection(val) {
  switch (val) {
    case "x":
      return "x";
    case "y":
      return "y";
    default:
      return;
  }
}
function mapErrorBarType(val) {
  switch (val) {
    case "both":
      return "both";
    case "minus":
      return "minus";
    case "plus":
      return "plus";
    default:
      return "both";
  }
}
function mapErrorValueType(val) {
  switch (val) {
    case "cust":
      return "cust";
    case "fixedVal":
      return "fixedVal";
    case "percentage":
      return "percentage";
    case "stdDev":
      return "stdDev";
    case "stdErr":
      return "stdErr";
    default:
      return "fixedVal";
  }
}

// packages/@oxen-office/chart/src/parser/title-legend.ts
function getAttr3(element, name) {
  if (!element) {
    return;
  }
  return getAttr(element, name);
}
function parseChartTitle(titleElement) {
  if (!titleElement) {
    return;
  }
  const overlayEl = getChild(titleElement, "c:overlay");
  const txElement = getChild(titleElement, "c:tx");
  const txPr = txElement ? getChild(txElement, "c:rich") : undefined;
  const layoutEl = getChild(titleElement, "c:layout");
  return {
    textBody: txPr ? parseTextBody2(txPr) : undefined,
    layout: parseLayout(layoutEl),
    overlay: overlayEl ? getBoolAttr(overlayEl, "val") : undefined,
    shapeProperties: parseChartShapeProperties(getChild(titleElement, "c:spPr"))
  };
}
function parseLegendEntry(entryEl) {
  const idxEl = getChild(entryEl, "c:idx");
  const deleteEl = getChild(entryEl, "c:delete");
  const txPrEl = getChild(entryEl, "c:txPr");
  return {
    idx: idxEl ? getIntAttr(idxEl, "val") ?? 0 : 0,
    delete: deleteEl ? getBoolAttr(deleteEl, "val") : undefined,
    textProperties: txPrEl ? parseTextBody2(txPrEl) : undefined
  };
}
function parseLegend(legendElement) {
  if (!legendElement) {
    return;
  }
  const legendPosEl = getChild(legendElement, "c:legendPos");
  const overlayEl = getChild(legendElement, "c:overlay");
  const txPrEl = getChild(legendElement, "c:txPr");
  const entryElements = getChildren(legendElement, "c:legendEntry");
  const entries = entryElements.length > 0 ? entryElements.map(parseLegendEntry) : undefined;
  return {
    position: mapLegendPosition(getAttr3(legendPosEl, "val")),
    layout: parseLayout(getChild(legendElement, "c:layout")),
    overlay: overlayEl ? getBoolAttr(overlayEl, "val") : undefined,
    shapeProperties: parseChartShapeProperties(getChild(legendElement, "c:spPr")),
    textProperties: txPrEl ? parseTextBody2(txPrEl) : undefined,
    entries
  };
}

// packages/@oxen-office/chart/src/parser/percent.ts
function parseChartPercent(value) {
  if (!value) {
    return;
  }
  const trimmed = value.trim();
  if (!trimmed) {
    return;
  }
  const numeric = trimmed.endsWith("%") ? trimmed.slice(0, -1) : trimmed;
  if (!numeric) {
    return;
  }
  const num = Number.parseFloat(numeric);
  if (Number.isNaN(num)) {
    return;
  }
  return pct(num);
}
function getChartPercentAttr(element, name) {
  if (!element) {
    return;
  }
  return parseChartPercent(getAttr(element, name));
}

// packages/@oxen-office/chart/src/parser/axis.ts
function getAttr4(element, name) {
  if (!element) {
    return;
  }
  return getAttr(element, name);
}
function parseDisplayUnits(dispUnitsEl) {
  if (!dispUnitsEl) {
    return;
  }
  const builtInUnitEl = getChild(dispUnitsEl, "c:builtInUnit");
  const custUnitEl = getChild(dispUnitsEl, "c:custUnit");
  const dispUnitsLblEl = getChild(dispUnitsEl, "c:dispUnitsLbl");
  return {
    builtInUnit: getAttr4(builtInUnitEl, "val"),
    customUnit: custUnitEl ? getFloatAttr(custUnitEl, "val") : undefined,
    dispUnitsLbl: parseChartTitle(dispUnitsLblEl)
  };
}
function parseAxisBase(axElement) {
  const axIdEl = getChild(axElement, "c:axId");
  const axPosEl = getChild(axElement, "c:axPos");
  const scalingEl = getChild(axElement, "c:scaling");
  const orientationEl = scalingEl ? getChild(scalingEl, "c:orientation") : undefined;
  const deleteEl = getChild(axElement, "c:delete");
  const majorTickMarkEl = getChild(axElement, "c:majorTickMark");
  const minorTickMarkEl = getChild(axElement, "c:minorTickMark");
  const tickLblPosEl = getChild(axElement, "c:tickLblPos");
  const crossAxEl = getChild(axElement, "c:crossAx");
  const crossesEl = getChild(axElement, "c:crosses");
  const crossesAtEl = getChild(axElement, "c:crossesAt");
  const majorGridlinesEl = getChild(axElement, "c:majorGridlines");
  const minorGridlinesEl = getChild(axElement, "c:minorGridlines");
  const txPrEl = getChild(axElement, "c:txPr");
  return {
    id: axIdEl ? getIntAttr(axIdEl, "val") ?? 0 : 0,
    position: getAttr4(axPosEl, "val") ?? "b",
    orientation: getAttr4(orientationEl, "val") ?? "minMax",
    delete: deleteEl ? getBoolAttr(deleteEl, "val") : undefined,
    majorTickMark: getAttr4(majorTickMarkEl, "val") ?? "none",
    minorTickMark: getAttr4(minorTickMarkEl, "val") ?? "none",
    tickLabelPosition: getAttr4(tickLblPosEl, "val") ?? "nextTo",
    crossAxisId: crossAxEl ? getIntAttr(crossAxEl, "val") ?? 0 : 0,
    crosses: getAttr4(crossesEl, "val"),
    crossesAt: crossesAtEl ? getFloatAttr(crossesAtEl, "val") : undefined,
    majorGridlines: majorGridlinesEl ? { shapeProperties: parseChartShapeProperties(getChild(majorGridlinesEl, "c:spPr")) } : undefined,
    minorGridlines: minorGridlinesEl ? { shapeProperties: parseChartShapeProperties(getChild(minorGridlinesEl, "c:spPr")) } : undefined,
    shapeProperties: parseChartShapeProperties(getChild(axElement, "c:spPr")),
    textProperties: txPrEl ? parseTextBody2(txPrEl) : undefined
  };
}
function parseCategoryAxis(catAx) {
  const base = parseAxisBase(catAx);
  if (!base) {
    return;
  }
  const autoEl = getChild(catAx, "c:auto");
  const lblAlgnEl = getChild(catAx, "c:lblAlgn");
  const lblOffsetEl = getChild(catAx, "c:lblOffset");
  const tickLblSkipEl = getChild(catAx, "c:tickLblSkip");
  const tickMarkSkipEl = getChild(catAx, "c:tickMarkSkip");
  const noMultiLvlLblEl = getChild(catAx, "c:noMultiLvlLbl");
  return {
    type: "catAx",
    ...base,
    auto: autoEl ? getBoolAttr(autoEl, "val") : undefined,
    labelAlignment: getAttr4(lblAlgnEl, "val"),
    labelOffset: getChartPercentAttr(lblOffsetEl, "val"),
    tickLabelSkip: tickLblSkipEl ? getIntAttr(tickLblSkipEl, "val") : undefined,
    tickMarkSkip: tickMarkSkipEl ? getIntAttr(tickMarkSkipEl, "val") : undefined,
    noMultiLevelLabels: noMultiLvlLblEl ? getBoolAttr(noMultiLvlLblEl, "val") : undefined
  };
}
function parseValueAxis(valAx) {
  const base = parseAxisBase(valAx);
  if (!base) {
    return;
  }
  const crossBetweenEl = getChild(valAx, "c:crossBetween");
  const majorUnitEl = getChild(valAx, "c:majorUnit");
  const minorUnitEl = getChild(valAx, "c:minorUnit");
  const scaling = getChild(valAx, "c:scaling");
  const maxEl = scaling ? getChild(scaling, "c:max") : undefined;
  const minEl = scaling ? getChild(scaling, "c:min") : undefined;
  const logBaseEl = scaling ? getChild(scaling, "c:logBase") : undefined;
  const dispUnitsEl = getChild(valAx, "c:dispUnits");
  return {
    type: "valAx",
    ...base,
    crossBetween: getAttr4(crossBetweenEl, "val"),
    majorUnit: majorUnitEl ? getFloatAttr(majorUnitEl, "val") : undefined,
    minorUnit: minorUnitEl ? getFloatAttr(minorUnitEl, "val") : undefined,
    max: maxEl ? getFloatAttr(maxEl, "val") : undefined,
    min: minEl ? getFloatAttr(minEl, "val") : undefined,
    logBase: logBaseEl ? getFloatAttr(logBaseEl, "val") : undefined,
    dispUnits: parseDisplayUnits(dispUnitsEl)
  };
}
function parseDateAxis(dateAx) {
  const base = parseAxisBase(dateAx);
  if (!base) {
    return;
  }
  const autoEl = getChild(dateAx, "c:auto");
  const baseTimeUnitEl = getChild(dateAx, "c:baseTimeUnit");
  const majorTimeUnitEl = getChild(dateAx, "c:majorTimeUnit");
  const minorTimeUnitEl = getChild(dateAx, "c:minorTimeUnit");
  const majorUnitEl = getChild(dateAx, "c:majorUnit");
  const minorUnitEl = getChild(dateAx, "c:minorUnit");
  const scaling = getChild(dateAx, "c:scaling");
  const maxEl = scaling ? getChild(scaling, "c:max") : undefined;
  const minEl = scaling ? getChild(scaling, "c:min") : undefined;
  return {
    type: "dateAx",
    ...base,
    auto: autoEl ? getBoolAttr(autoEl, "val") : undefined,
    baseTimeUnit: getAttr4(baseTimeUnitEl, "val"),
    majorTimeUnit: getAttr4(majorTimeUnitEl, "val"),
    minorTimeUnit: getAttr4(minorTimeUnitEl, "val"),
    majorUnit: majorUnitEl ? getFloatAttr(majorUnitEl, "val") : undefined,
    minorUnit: minorUnitEl ? getFloatAttr(minorUnitEl, "val") : undefined,
    max: maxEl ? getFloatAttr(maxEl, "val") : undefined,
    min: minEl ? getFloatAttr(minEl, "val") : undefined
  };
}
function parseSeriesAxis(serAx) {
  const base = parseAxisBase(serAx);
  if (!base) {
    return;
  }
  const tickLblSkipEl = getChild(serAx, "c:tickLblSkip");
  const tickMarkSkipEl = getChild(serAx, "c:tickMarkSkip");
  return {
    type: "serAx",
    ...base,
    tickLabelSkip: tickLblSkipEl ? getIntAttr(tickLblSkipEl, "val") : undefined,
    tickMarkSkip: tickMarkSkipEl ? getIntAttr(tickMarkSkipEl, "val") : undefined
  };
}
function parseAxes(plotArea) {
  const axes = [];
  for (const catAx of getChildren(plotArea, "c:catAx")) {
    const axis = parseCategoryAxis(catAx);
    if (axis) {
      axes.push(axis);
    }
  }
  for (const valAx of getChildren(plotArea, "c:valAx")) {
    const axis = parseValueAxis(valAx);
    if (axis) {
      axes.push(axis);
    }
  }
  for (const dateAx of getChildren(plotArea, "c:dateAx")) {
    const axis = parseDateAxis(dateAx);
    if (axis) {
      axes.push(axis);
    }
  }
  for (const serAx of getChildren(plotArea, "c:serAx")) {
    const axis = parseSeriesAxis(serAx);
    if (axis) {
      axes.push(axis);
    }
  }
  return axes;
}

// packages/@oxen-office/chart/src/parser/data-reference.ts
function parseNumericPoint(pt2) {
  const idx = getIntAttr(pt2, "idx");
  if (idx === undefined) {
    return;
  }
  const vElement = getChild(pt2, "c:v");
  const value = vElement ? parseFloat(getXmlText(vElement) ?? "0") : 0;
  if (isNaN(value)) {
    return;
  }
  return {
    idx,
    value,
    formatCode: getAttr(pt2, "formatCode")
  };
}
function parseNumericCache(numCache) {
  const formatCodeElement = getChild(numCache, "c:formatCode");
  const formatCode = formatCodeElement ? getXmlText(formatCodeElement) : undefined;
  const ptCountElement = getChild(numCache, "c:ptCount");
  const count = ptCountElement ? getIntAttr(ptCountElement, "val") ?? 0 : 0;
  const points = [];
  for (const pt2 of getChildren(numCache, "c:pt")) {
    const point = parseNumericPoint(pt2);
    if (point) {
      points.push(point);
    }
  }
  return { formatCode, count, points };
}
function parseNumericReference(numRef) {
  const fElement = getChild(numRef, "c:f");
  const formula = fElement ? getXmlText(fElement) ?? "" : "";
  const numCache = getChild(numRef, "c:numCache");
  const cache = numCache ? parseNumericCache(numCache) : undefined;
  return { formula, cache };
}
function parseStringPoint(pt2) {
  const idx = getIntAttr(pt2, "idx");
  if (idx === undefined) {
    return;
  }
  const vElement = getChild(pt2, "c:v");
  const value = vElement ? getXmlText(vElement) ?? "" : "";
  return { idx, value };
}
function parseStringCache(strCache) {
  const ptCountElement = getChild(strCache, "c:ptCount");
  const count = ptCountElement ? getIntAttr(ptCountElement, "val") ?? 0 : 0;
  const points = [];
  for (const pt2 of getChildren(strCache, "c:pt")) {
    const point = parseStringPoint(pt2);
    if (point) {
      points.push(point);
    }
  }
  return { count, points };
}
function parseStringReference(strRef) {
  const fElement = getChild(strRef, "c:f");
  const formula = fElement ? getXmlText(fElement) ?? "" : "";
  const strCache = getChild(strRef, "c:strCache");
  const cache = strCache ? parseStringCache(strCache) : undefined;
  return { formula, cache };
}
function parseMultiLevelStringLevel(lvl) {
  const points = [];
  for (const pt2 of getChildren(lvl, "c:pt")) {
    const point = parseStringPoint(pt2);
    if (point) {
      points.push(point);
    }
  }
  return { points };
}
function parseMultiLevelStringCache(cache) {
  const ptCountElement = getChild(cache, "c:ptCount");
  const count = ptCountElement ? getIntAttr(ptCountElement, "val") ?? 0 : 0;
  const levels = [];
  for (const lvl of getChildren(cache, "c:lvl")) {
    levels.push(parseMultiLevelStringLevel(lvl));
  }
  return { count, levels };
}
function parseMultiLevelStringReference(ref) {
  const fElement = getChild(ref, "c:f");
  const formula = fElement ? getXmlText(fElement) ?? "" : "";
  const cacheElement = getChild(ref, "c:multiLvlStrCache");
  const cache = cacheElement ? parseMultiLevelStringCache(cacheElement) : undefined;
  return { formula, cache };
}
function parseDataReference(element) {
  if (!element) {
    return {};
  }
  const numRef = getChild(element, "c:numRef");
  const strRef = getChild(element, "c:strRef");
  const numLit = getChild(element, "c:numLit");
  const strLit = getChild(element, "c:strLit");
  const multiLvlStrRef = getChild(element, "c:multiLvlStrRef");
  return {
    numRef: numRef ? parseNumericReference(numRef) : undefined,
    strRef: strRef ? parseStringReference(strRef) : undefined,
    numLit: numLit ? parseNumericCache(numLit) : undefined,
    strLit: strLit ? parseStringCache(strLit) : undefined,
    multiLvlStrRef: multiLvlStrRef ? parseMultiLevelStringReference(multiLvlStrRef) : undefined
  };
}
function parseSeriesText(tx) {
  if (!tx) {
    return;
  }
  const strRef = getChild(tx, "c:strRef");
  if (strRef) {
    const ref = parseStringReference(strRef);
    const firstPoint = ref?.cache?.points[0];
    return {
      value: firstPoint?.value,
      reference: ref?.formula
    };
  }
  const vElement = getChild(tx, "c:v");
  if (vElement) {
    return { value: getXmlText(vElement) };
  }
  return;
}

// packages/@oxen-office/chart/src/parser/components.ts
function getAttr5(element, name) {
  if (!element) {
    return;
  }
  return getAttr(element, name);
}
function parseDataLabelShared(el) {
  const numFmtEl = getChild(el, "c:numFmt");
  const spPrEl = getChild(el, "c:spPr");
  const txPrEl = getChild(el, "c:txPr");
  const dLblPosEl = getChild(el, "c:dLblPos");
  const separatorEl = getChild(el, "c:separator");
  return {
    numFormat: numFmtEl ? getAttr5(numFmtEl, "formatCode") : undefined,
    shapeProperties: parseChartShapeProperties(spPrEl),
    textProperties: txPrEl ? parseTextBody2(txPrEl) : undefined,
    position: mapDataLabelPosition(getAttr5(dLblPosEl, "val")),
    showLegendKey: getBoolAttr(getChild(el, "c:showLegendKey"), "val"),
    showVal: getBoolAttr(getChild(el, "c:showVal"), "val"),
    showCatName: getBoolAttr(getChild(el, "c:showCatName"), "val"),
    showSerName: getBoolAttr(getChild(el, "c:showSerName"), "val"),
    showPercent: getBoolAttr(getChild(el, "c:showPercent"), "val"),
    showBubbleSize: getBoolAttr(getChild(el, "c:showBubbleSize"), "val"),
    separator: separatorEl ? getXmlText(separatorEl) : undefined
  };
}
function parseDataLabel(dLbl) {
  if (!dLbl) {
    return;
  }
  const idxEl = getChild(dLbl, "c:idx");
  if (!idxEl) {
    return;
  }
  const idx = getIntAttr(idxEl, "val") ?? 0;
  const deleteEl = getChild(dLbl, "c:delete");
  if (deleteEl) {
    return {
      idx,
      delete: getBoolAttr(deleteEl, "val")
    };
  }
  const shared = parseDataLabelShared(dLbl);
  const layoutEl = getChild(dLbl, "c:layout");
  const txEl = getChild(dLbl, "c:tx");
  return {
    idx,
    layout: parseLayout(layoutEl),
    text: txEl ? parseTextBody2(getChild(txEl, "c:rich") ?? txEl) : undefined,
    ...shared
  };
}
function parseMarker(marker) {
  if (!marker) {
    return;
  }
  const symbolElement = getChild(marker, "c:symbol");
  if (!symbolElement) {
    return;
  }
  const symbol = mapMarkerSymbol(getAttr5(symbolElement, "val"));
  if (!symbol) {
    return;
  }
  const sizeVal = getIntAttr(getChild(marker, "c:size"), "val");
  const spPr = getChild(marker, "c:spPr");
  return {
    symbol,
    size: sizeVal !== undefined ? pt(sizeVal) : undefined,
    shapeProperties: parseChartShapeProperties(spPr)
  };
}
function parseDataPoints(ser) {
  const dPtElements = getChildren(ser, "c:dPt");
  if (dPtElements.length === 0) {
    return;
  }
  const dataPoints = [];
  for (const dPt of dPtElements) {
    const idxEl = getChild(dPt, "c:idx");
    if (!idxEl) {
      continue;
    }
    const idx = getIntAttr(idxEl, "val") ?? 0;
    const explosionEl = getChild(dPt, "c:explosion");
    dataPoints.push({
      idx,
      invertIfNegative: getBoolAttr(getChild(dPt, "c:invertIfNegative"), "val"),
      marker: parseMarker(getChild(dPt, "c:marker")),
      bubble3D: getBoolAttr(getChild(dPt, "c:bubble3D"), "val"),
      explosion: getChartPercentAttr(explosionEl, "val"),
      shapeProperties: parseChartShapeProperties(getChild(dPt, "c:spPr"))
    });
  }
  return dataPoints.length > 0 ? dataPoints : undefined;
}
function parseDataLabels(dLbls) {
  if (!dLbls) {
    return;
  }
  const deleteEl = getChild(dLbls, "c:delete");
  const showLeaderLinesEl = getChild(dLbls, "c:showLeaderLines");
  const leaderLinesEl = getChild(dLbls, "c:leaderLines");
  const parseChartLines2 = (linesEl) => {
    if (!linesEl) {
      return;
    }
    return { shapeProperties: parseChartShapeProperties(getChild(linesEl, "c:spPr")) };
  };
  const labels = getChildren(dLbls, "c:dLbl").map(parseDataLabel).filter((label) => Boolean(label));
  if (deleteEl) {
    return {
      labels: labels.length > 0 ? labels : undefined,
      delete: getBoolAttr(deleteEl, "val")
    };
  }
  const shared = parseDataLabelShared(dLbls);
  return {
    labels: labels.length > 0 ? labels : undefined,
    ...shared,
    showLeaderLines: showLeaderLinesEl ? getBoolAttr(showLeaderLinesEl, "val") : undefined,
    leaderLines: parseChartLines2(leaderLinesEl)
  };
}
function parseTrendlineLabel(el) {
  if (!el) {
    return;
  }
  const layoutEl = getChild(el, "c:layout");
  const txEl = getChild(el, "c:tx");
  const numFmtEl = getChild(el, "c:numFmt");
  const spPrEl = getChild(el, "c:spPr");
  const txPrEl = getChild(el, "c:txPr");
  return {
    layout: parseLayout(layoutEl),
    text: txEl ? parseTextBody2(getChild(txEl, "c:rich") ?? txEl) : undefined,
    numFormat: numFmtEl ? getAttr5(numFmtEl, "formatCode") : undefined,
    shapeProperties: parseChartShapeProperties(spPrEl),
    textProperties: txPrEl ? parseTextBody2(txPrEl) : undefined
  };
}
function parseTrendline(el) {
  const nameEl = getChild(el, "c:name");
  const typeEl = getChild(el, "c:trendlineType");
  const orderEl = getChild(el, "c:order");
  const periodEl = getChild(el, "c:period");
  const forwardEl = getChild(el, "c:forward");
  const backwardEl = getChild(el, "c:backward");
  const interceptEl = getChild(el, "c:intercept");
  const dispRSqrEl = getChild(el, "c:dispRSqr");
  const dispEqEl = getChild(el, "c:dispEq");
  const trendlineLblEl = getChild(el, "c:trendlineLbl");
  return {
    name: nameEl ? getXmlText(nameEl) : undefined,
    trendlineType: mapTrendlineType(getAttr5(typeEl, "val")),
    order: orderEl ? getIntAttr(orderEl, "val") : undefined,
    period: periodEl ? getIntAttr(periodEl, "val") : undefined,
    forward: forwardEl ? getFloatAttr(forwardEl, "val") : undefined,
    backward: backwardEl ? getFloatAttr(backwardEl, "val") : undefined,
    intercept: interceptEl ? getFloatAttr(interceptEl, "val") : undefined,
    dispRSqr: dispRSqrEl ? getBoolAttr(dispRSqrEl, "val") : undefined,
    dispEq: dispEqEl ? getBoolAttr(dispEqEl, "val") : undefined,
    shapeProperties: parseChartShapeProperties(getChild(el, "c:spPr")),
    trendlineLabel: parseTrendlineLabel(trendlineLblEl)
  };
}
function parseTrendlines(ser) {
  const trendlineElements = getChildren(ser, "c:trendline");
  if (trendlineElements.length === 0) {
    return;
  }
  return trendlineElements.map(parseTrendline);
}
function parseErrorBarsElement(el) {
  const errDirEl = getChild(el, "c:errDir");
  const errBarTypeEl = getChild(el, "c:errBarType");
  const errValTypeEl = getChild(el, "c:errValType");
  const noEndCapEl = getChild(el, "c:noEndCap");
  const valEl = getChild(el, "c:val");
  return {
    errDir: mapErrorBarDirection(getAttr5(errDirEl, "val")),
    errBarType: mapErrorBarType(getAttr5(errBarTypeEl, "val")),
    errValType: mapErrorValueType(getAttr5(errValTypeEl, "val")),
    noEndCap: noEndCapEl ? getBoolAttr(noEndCapEl, "val") : undefined,
    val: valEl ? getFloatAttr(valEl, "val") : undefined,
    plus: parseDataReference(getChild(el, "c:plus")),
    minus: parseDataReference(getChild(el, "c:minus")),
    shapeProperties: parseChartShapeProperties(getChild(el, "c:spPr"))
  };
}
function parseErrorBars(ser) {
  const errBarsElements = getChildren(ser, "c:errBars");
  if (errBarsElements.length === 0) {
    return;
  }
  return errBarsElements.map(parseErrorBarsElement);
}
function parseUpDownBars(upDownBarsEl) {
  if (!upDownBarsEl) {
    return;
  }
  const gapWidthEl = getChild(upDownBarsEl, "c:gapWidth");
  const upBarsEl = getChild(upDownBarsEl, "c:upBars");
  const downBarsEl = getChild(upDownBarsEl, "c:downBars");
  return {
    gapWidth: getChartPercentAttr(gapWidthEl, "val"),
    upBars: upBarsEl ? parseChartShapeProperties(getChild(upBarsEl, "c:spPr")) : undefined,
    downBars: downBarsEl ? parseChartShapeProperties(getChild(downBarsEl, "c:spPr")) : undefined
  };
}

// packages/@oxen-office/chart/src/parser/chart-space.ts
function getAttr6(element, name) {
  if (!element) {
    return;
  }
  return getAttr(element, name);
}
function parseRotation2(el) {
  const raw = getAttr6(el, "val");
  if (!raw) {
    return;
  }
  const parsed = parseFloat(raw);
  if (Number.isNaN(parsed)) {
    return;
  }
  return deg(parsed);
}
function parseView3D(view3d) {
  if (!view3d) {
    return;
  }
  return {
    rotX: parseRotation2(getChild(view3d, "c:rotX")),
    hPercent: getChartPercentAttr(getChild(view3d, "c:hPercent"), "val"),
    rotY: parseRotation2(getChild(view3d, "c:rotY")),
    depthPercent: getChartPercentAttr(getChild(view3d, "c:depthPercent"), "val"),
    rAngAx: getBoolAttr(getChild(view3d, "c:rAngAx"), "val"),
    perspective: getIntAttr(getChild(view3d, "c:perspective"), "val")
  };
}
function parsePictureOptions(el) {
  if (!el) {
    return;
  }
  const pictureFormatEl = getChild(el, "c:pictureFormat");
  const pictureStackUnitEl = getChild(el, "c:pictureStackUnit");
  return {
    applyToFront: getBoolAttr(getChild(el, "c:applyToFront"), "val"),
    applyToSides: getBoolAttr(getChild(el, "c:applyToSides"), "val"),
    applyToEnd: getBoolAttr(getChild(el, "c:applyToEnd"), "val"),
    pictureFormat: getAttr6(pictureFormatEl, "val") ?? undefined,
    pictureStackUnit: parseFloat64(getAttr6(pictureStackUnitEl, "val"))
  };
}
function parseChartSurface(el) {
  if (!el) {
    return;
  }
  return {
    thickness: getChartPercentAttr(getChild(el, "c:thickness"), "val"),
    shapeProperties: parseChartShapeProperties(getChild(el, "c:spPr")),
    pictureOptions: parsePictureOptions(getChild(el, "c:pictureOptions"))
  };
}
function parseDataTable(el) {
  if (!el) {
    return;
  }
  const txPrEl = getChild(el, "c:txPr");
  return {
    showHorzBorder: getBoolAttr(getChild(el, "c:showHorzBorder"), "val"),
    showVertBorder: getBoolAttr(getChild(el, "c:showVertBorder"), "val"),
    showOutline: getBoolAttr(getChild(el, "c:showOutline"), "val"),
    showKeys: getBoolAttr(getChild(el, "c:showKeys"), "val"),
    shapeProperties: parseChartShapeProperties(getChild(el, "c:spPr")),
    textProperties: txPrEl ? parseTextBody2(txPrEl) : undefined
  };
}
function parsePivotSource(el) {
  if (!el) {
    return;
  }
  const nameEl = getChild(el, "c:name");
  const fmtIdEl = getChild(el, "c:fmtId");
  const name = nameEl ? getXmlText(nameEl) : undefined;
  const fmtId = fmtIdEl ? getIntAttr(fmtIdEl, "val") : undefined;
  if (!name || fmtId === undefined) {
    return;
  }
  return {
    name,
    fmtId
  };
}
function parsePivotFormat(el) {
  const idxEl = getChild(el, "c:idx");
  if (!idxEl) {
    return;
  }
  const idx = getIntAttr(idxEl, "val") ?? 0;
  const txPrEl = getChild(el, "c:txPr");
  return {
    idx,
    shapeProperties: parseChartShapeProperties(getChild(el, "c:spPr")),
    textProperties: txPrEl ? parseTextBody2(txPrEl) : undefined,
    marker: parseMarker(getChild(el, "c:marker")),
    dataLabel: parseDataLabel(getChild(el, "c:dLbl"))
  };
}
function parsePivotFormats(el) {
  if (!el) {
    return;
  }
  const formats = getChildren(el, "c:pivotFmt").map(parsePivotFormat).filter((format) => Boolean(format));
  if (formats.length === 0) {
    return;
  }
  return { formats };
}
function parseProtection(el) {
  if (!el) {
    return;
  }
  return {
    chartObject: getBoolAttr(getChild(el, "c:chartObject"), "val"),
    data: getBoolAttr(getChild(el, "c:data"), "val"),
    formatting: getBoolAttr(getChild(el, "c:formatting"), "val"),
    selection: getBoolAttr(getChild(el, "c:selection"), "val"),
    userInterface: getBoolAttr(getChild(el, "c:userInterface"), "val")
  };
}
function parseHeaderFooter(el) {
  if (!el) {
    return;
  }
  const oddHeaderEl = getChild(el, "c:oddHeader");
  const oddFooterEl = getChild(el, "c:oddFooter");
  const evenHeaderEl = getChild(el, "c:evenHeader");
  const evenFooterEl = getChild(el, "c:evenFooter");
  const firstHeaderEl = getChild(el, "c:firstHeader");
  const firstFooterEl = getChild(el, "c:firstFooter");
  return {
    oddHeader: oddHeaderEl ? getXmlText(oddHeaderEl) : undefined,
    oddFooter: oddFooterEl ? getXmlText(oddFooterEl) : undefined,
    evenHeader: evenHeaderEl ? getXmlText(evenHeaderEl) : undefined,
    evenFooter: evenFooterEl ? getXmlText(evenFooterEl) : undefined,
    firstHeader: firstHeaderEl ? getXmlText(firstHeaderEl) : undefined,
    firstFooter: firstFooterEl ? getXmlText(firstFooterEl) : undefined,
    alignWithMargins: parseBoolean(getAttr6(el, "alignWithMargins")),
    differentOddEven: parseBoolean(getAttr6(el, "differentOddEven")),
    differentFirst: parseBoolean(getAttr6(el, "differentFirst"))
  };
}
function parsePageMargins(el) {
  if (!el) {
    return;
  }
  const left = parseFloat64(getAttr6(el, "l"));
  const right = parseFloat64(getAttr6(el, "r"));
  const top = parseFloat64(getAttr6(el, "t"));
  const bottom = parseFloat64(getAttr6(el, "b"));
  const header = parseFloat64(getAttr6(el, "header"));
  const footer = parseFloat64(getAttr6(el, "footer"));
  if ([left, right, top, bottom, header, footer].some((value) => value === undefined)) {
    return;
  }
  return {
    left: left ?? 0,
    right: right ?? 0,
    top: top ?? 0,
    bottom: bottom ?? 0,
    header: header ?? 0,
    footer: footer ?? 0
  };
}
function parsePageSetup(el) {
  if (!el) {
    return;
  }
  return {
    paperSize: parseInt32(getAttr6(el, "paperSize")),
    paperHeight: parseFloat64(getAttr6(el, "paperHeight")),
    paperWidth: parseFloat64(getAttr6(el, "paperWidth")),
    firstPageNumber: parseInt32(getAttr6(el, "firstPageNumber")),
    orientation: getAttr6(el, "orientation"),
    blackAndWhite: parseBoolean(getAttr6(el, "blackAndWhite")),
    draft: parseBoolean(getAttr6(el, "draft")),
    useFirstPageNumber: parseBoolean(getAttr6(el, "useFirstPageNumber")),
    horizontalDpi: parseInt32(getAttr6(el, "horizontalDpi")),
    verticalDpi: parseInt32(getAttr6(el, "verticalDpi")),
    copies: parseInt32(getAttr6(el, "copies"))
  };
}
function parsePrintSettings(el) {
  if (!el) {
    return;
  }
  return {
    headerFooter: parseHeaderFooter(getChild(el, "c:headerFooter")),
    pageMargins: parsePageMargins(getChild(el, "c:pageMargins")),
    pageSetup: parsePageSetup(getChild(el, "c:pageSetup"))
  };
}
function parseUserShapesRelId(el) {
  if (!el) {
    return;
  }
  return getAttr6(el, "r:id");
}

// packages/@oxen-office/chart/src/parser/series/bar.ts
function getAttr7(element, name) {
  if (!element) {
    return;
  }
  return getAttr(element, name);
}
function parseBarSeries(ser) {
  const idxEl = getChild(ser, "c:idx");
  const orderEl = getChild(ser, "c:order");
  return {
    idx: idxEl ? getIntAttr(idxEl, "val") ?? 0 : 0,
    order: orderEl ? getIntAttr(orderEl, "val") ?? 0 : 0,
    tx: parseSeriesText(getChild(ser, "c:tx")),
    shapeProperties: parseChartShapeProperties(getChild(ser, "c:spPr")),
    invertIfNegative: getBoolAttr(getChild(ser, "c:invertIfNegative"), "val"),
    dataPoints: parseDataPoints(ser),
    categories: parseDataReference(getChild(ser, "c:cat")),
    values: parseDataReference(getChild(ser, "c:val")),
    trendlines: parseTrendlines(ser),
    errorBars: parseErrorBars(ser)
  };
}
function parseBarChart(barChart, index) {
  const barDirEl = getChild(barChart, "c:barDir");
  const groupingEl = getChild(barChart, "c:grouping");
  const varyColorsEl = getChild(barChart, "c:varyColors");
  const gapWidthEl = getChild(barChart, "c:gapWidth");
  const gapDepthEl = getChild(barChart, "c:gapDepth");
  const shapeEl = getChild(barChart, "c:shape");
  const overlapEl = getChild(barChart, "c:overlap");
  const series = [];
  for (const ser of getChildren(barChart, "c:ser")) {
    const s = parseBarSeries(ser);
    if (s) {
      series.push(s);
    }
  }
  return {
    type: "barChart",
    index,
    order: index,
    barDir: getAttr7(barDirEl, "val") ?? "col",
    grouping: getAttr7(groupingEl, "val") ?? "clustered",
    varyColors: varyColorsEl ? getBoolAttr(varyColorsEl, "val") : undefined,
    gapWidth: getChartPercentAttr(gapWidthEl, "val"),
    gapDepth: getChartPercentAttr(gapDepthEl, "val"),
    shape: getAttr7(shapeEl, "val"),
    overlap: overlapEl ? getIntAttr(overlapEl, "val") : undefined,
    series,
    dataLabels: parseDataLabels(getChild(barChart, "c:dLbls")),
    shapeProperties: parseChartShapeProperties(getChild(barChart, "c:spPr"))
  };
}

// packages/@oxen-office/chart/src/parser/series/line.ts
function getAttr8(element, name) {
  if (!element) {
    return;
  }
  return getAttr(element, name);
}
function parseLineSeries(ser) {
  const idxEl = getChild(ser, "c:idx");
  const orderEl = getChild(ser, "c:order");
  return {
    idx: idxEl ? getIntAttr(idxEl, "val") ?? 0 : 0,
    order: orderEl ? getIntAttr(orderEl, "val") ?? 0 : 0,
    tx: parseSeriesText(getChild(ser, "c:tx")),
    shapeProperties: parseChartShapeProperties(getChild(ser, "c:spPr")),
    marker: parseMarker(getChild(ser, "c:marker")),
    dataPoints: parseDataPoints(ser),
    categories: parseDataReference(getChild(ser, "c:cat")),
    values: parseDataReference(getChild(ser, "c:val")),
    smooth: getBoolAttr(getChild(ser, "c:smooth"), "val"),
    trendlines: parseTrendlines(ser),
    errorBars: parseErrorBars(ser)
  };
}
function parseLineChart(lineChart, index) {
  const groupingEl = getChild(lineChart, "c:grouping");
  const varyColorsEl = getChild(lineChart, "c:varyColors");
  const markerEl = getChild(lineChart, "c:marker");
  const smoothEl = getChild(lineChart, "c:smooth");
  const gapDepthEl = getChild(lineChart, "c:gapDepth");
  const series = [];
  for (const ser of getChildren(lineChart, "c:ser")) {
    const s = parseLineSeries(ser);
    if (s) {
      series.push(s);
    }
  }
  return {
    type: "lineChart",
    index,
    order: index,
    grouping: getAttr8(groupingEl, "val") ?? "standard",
    varyColors: varyColorsEl ? getBoolAttr(varyColorsEl, "val") : undefined,
    gapDepth: getChartPercentAttr(gapDepthEl, "val"),
    marker: markerEl ? getBoolAttr(markerEl, "val") : undefined,
    smooth: smoothEl ? getBoolAttr(smoothEl, "val") : undefined,
    series,
    dataLabels: parseDataLabels(getChild(lineChart, "c:dLbls")),
    shapeProperties: parseChartShapeProperties(getChild(lineChart, "c:spPr"))
  };
}

// packages/@oxen-office/chart/src/parser/series/pie.ts
function parsePieSeries(ser) {
  const idxEl = getChild(ser, "c:idx");
  const orderEl = getChild(ser, "c:order");
  const explosionEl = getChild(ser, "c:explosion");
  return {
    idx: idxEl ? getIntAttr(idxEl, "val") ?? 0 : 0,
    order: orderEl ? getIntAttr(orderEl, "val") ?? 0 : 0,
    tx: parseSeriesText(getChild(ser, "c:tx")),
    shapeProperties: parseChartShapeProperties(getChild(ser, "c:spPr")),
    dataPoints: parseDataPoints(ser),
    categories: parseDataReference(getChild(ser, "c:cat")),
    values: parseDataReference(getChild(ser, "c:val")),
    explosion: getChartPercentAttr(explosionEl, "val")
  };
}
function parsePieChart(pieChart, index, type) {
  const varyColorsEl = getChild(pieChart, "c:varyColors");
  const firstSliceAngEl = getChild(pieChart, "c:firstSliceAng");
  const holeSizeEl = getChild(pieChart, "c:holeSize");
  const series = [];
  for (const ser of getChildren(pieChart, "c:ser")) {
    const s = parsePieSeries(ser);
    if (s) {
      series.push(s);
    }
  }
  return {
    type,
    index,
    order: index,
    varyColors: varyColorsEl ? getBoolAttr(varyColorsEl, "val") : undefined,
    firstSliceAng: firstSliceAngEl ? deg(getIntAttr(firstSliceAngEl, "val") ?? 0) : undefined,
    holeSize: getChartPercentAttr(holeSizeEl, "val"),
    series,
    dataLabels: parseDataLabels(getChild(pieChart, "c:dLbls")),
    shapeProperties: parseChartShapeProperties(getChild(pieChart, "c:spPr"))
  };
}
function parseOfPieChart(ofPieChart, index) {
  const ofPieTypeEl = getChild(ofPieChart, "c:ofPieType");
  const ofPieTypeVal = ofPieTypeEl ? getAttr(ofPieTypeEl, "val") : "pie";
  const ofPieType = ofPieTypeVal === "bar" ? "bar" : "pie";
  const varyColorsEl = getChild(ofPieChart, "c:varyColors");
  const gapWidthEl = getChild(ofPieChart, "c:gapWidth");
  const splitTypeEl = getChild(ofPieChart, "c:splitType");
  const splitPosEl = getChild(ofPieChart, "c:splitPos");
  const secondPieSizeEl = getChild(ofPieChart, "c:secondPieSize");
  const splitType = parseOfPieSplitType(splitTypeEl);
  const custSplitEl = getChild(ofPieChart, "c:custSplit");
  const custSplit = parseCustomSplit(custSplitEl);
  const series = [];
  for (const ser of getChildren(ofPieChart, "c:ser")) {
    const s = parsePieSeries(ser);
    if (s) {
      series.push(s);
    }
  }
  const serLinesEl = getChild(ofPieChart, "c:serLines");
  const serLines = serLinesEl ? parseChartLines(serLinesEl) : undefined;
  return {
    type: "ofPieChart",
    index,
    order: index,
    ofPieType,
    varyColors: varyColorsEl ? getBoolAttr(varyColorsEl, "val") : undefined,
    gapWidth: getChartPercentAttr(gapWidthEl, "val"),
    splitType,
    splitPos: splitPosEl ? getFloatAttr(splitPosEl, "val") : undefined,
    custSplit: custSplit && custSplit.length > 0 ? custSplit : undefined,
    secondPieSize: getChartPercentAttr(secondPieSizeEl, "val"),
    serLines,
    series,
    dataLabels: parseDataLabels(getChild(ofPieChart, "c:dLbls")),
    shapeProperties: parseChartShapeProperties(getChild(ofPieChart, "c:spPr"))
  };
}
function parseOfPieSplitType(element) {
  if (!element) {
    return;
  }
  const val = getAttr(element, "val");
  if (val === "auto" || val === "cust" || val === "percent" || val === "pos" || val === "val") {
    return val;
  }
  return;
}
function parseCustomSplit(element) {
  if (!element) {
    return;
  }
  const values = getChildren(element, "c:secondPiePt").map((secondPiePt) => getIntAttr(secondPiePt, "val")).filter((value) => value !== undefined);
  return values.length > 0 ? values : undefined;
}

// packages/@oxen-office/chart/src/parser/series/scatter.ts
function getAttr9(element, name) {
  if (!element) {
    return;
  }
  return getAttr(element, name);
}
function parseScatterSeries(ser) {
  const idxEl = getChild(ser, "c:idx");
  const orderEl = getChild(ser, "c:order");
  return {
    idx: idxEl ? getIntAttr(idxEl, "val") ?? 0 : 0,
    order: orderEl ? getIntAttr(orderEl, "val") ?? 0 : 0,
    tx: parseSeriesText(getChild(ser, "c:tx")),
    shapeProperties: parseChartShapeProperties(getChild(ser, "c:spPr")),
    marker: parseMarker(getChild(ser, "c:marker")),
    dataPoints: parseDataPoints(ser),
    xValues: parseDataReference(getChild(ser, "c:xVal")),
    yValues: parseDataReference(getChild(ser, "c:yVal")),
    smooth: getBoolAttr(getChild(ser, "c:smooth"), "val"),
    trendlines: parseTrendlines(ser),
    errorBars: parseErrorBars(ser)
  };
}
function parseScatterChart(scatterChart, index) {
  const scatterStyleEl = getChild(scatterChart, "c:scatterStyle");
  const varyColorsEl = getChild(scatterChart, "c:varyColors");
  const series = [];
  for (const ser of getChildren(scatterChart, "c:ser")) {
    const s = parseScatterSeries(ser);
    if (s) {
      series.push(s);
    }
  }
  return {
    type: "scatterChart",
    index,
    order: index,
    scatterStyle: getAttr9(scatterStyleEl, "val") ?? "marker",
    varyColors: varyColorsEl ? getBoolAttr(varyColorsEl, "val") : undefined,
    series,
    dataLabels: parseDataLabels(getChild(scatterChart, "c:dLbls")),
    shapeProperties: parseChartShapeProperties(getChild(scatterChart, "c:spPr"))
  };
}

// packages/@oxen-office/chart/src/parser/series/area.ts
function getAttr10(element, name) {
  if (!element) {
    return;
  }
  return getAttr(element, name);
}
function parseAreaSeries(ser) {
  const idxEl = getChild(ser, "c:idx");
  const orderEl = getChild(ser, "c:order");
  return {
    idx: idxEl ? getIntAttr(idxEl, "val") ?? 0 : 0,
    order: orderEl ? getIntAttr(orderEl, "val") ?? 0 : 0,
    tx: parseSeriesText(getChild(ser, "c:tx")),
    shapeProperties: parseChartShapeProperties(getChild(ser, "c:spPr")),
    marker: parseMarker(getChild(ser, "c:marker")),
    dataPoints: parseDataPoints(ser),
    categories: parseDataReference(getChild(ser, "c:cat")),
    values: parseDataReference(getChild(ser, "c:val")),
    trendlines: parseTrendlines(ser),
    errorBars: parseErrorBars(ser)
  };
}
function parseAreaChart(areaChart, index) {
  const groupingEl = getChild(areaChart, "c:grouping");
  const varyColorsEl = getChild(areaChart, "c:varyColors");
  const gapDepthEl = getChild(areaChart, "c:gapDepth");
  const series = [];
  for (const ser of getChildren(areaChart, "c:ser")) {
    const s = parseAreaSeries(ser);
    if (s) {
      series.push(s);
    }
  }
  return {
    type: "areaChart",
    index,
    order: index,
    grouping: getAttr10(groupingEl, "val") ?? "standard",
    varyColors: varyColorsEl ? getBoolAttr(varyColorsEl, "val") : undefined,
    gapDepth: getChartPercentAttr(gapDepthEl, "val"),
    series,
    dataLabels: parseDataLabels(getChild(areaChart, "c:dLbls")),
    shapeProperties: parseChartShapeProperties(getChild(areaChart, "c:spPr"))
  };
}

// packages/@oxen-office/chart/src/parser/series/radar.ts
function getAttr11(element, name) {
  if (!element) {
    return;
  }
  return getAttr(element, name);
}
function parseRadarSeries(ser) {
  const idxEl = getChild(ser, "c:idx");
  const orderEl = getChild(ser, "c:order");
  return {
    idx: idxEl ? getIntAttr(idxEl, "val") ?? 0 : 0,
    order: orderEl ? getIntAttr(orderEl, "val") ?? 0 : 0,
    tx: parseSeriesText(getChild(ser, "c:tx")),
    shapeProperties: parseChartShapeProperties(getChild(ser, "c:spPr")),
    marker: parseMarker(getChild(ser, "c:marker")),
    dataPoints: parseDataPoints(ser),
    categories: parseDataReference(getChild(ser, "c:cat")),
    values: parseDataReference(getChild(ser, "c:val"))
  };
}
function parseRadarChart(radarChart, index) {
  const radarStyleEl = getChild(radarChart, "c:radarStyle");
  const varyColorsEl = getChild(radarChart, "c:varyColors");
  const series = [];
  for (const ser of getChildren(radarChart, "c:ser")) {
    const s = parseRadarSeries(ser);
    if (s) {
      series.push(s);
    }
  }
  return {
    type: "radarChart",
    index,
    order: index,
    radarStyle: getAttr11(radarStyleEl, "val") ?? "standard",
    varyColors: varyColorsEl ? getBoolAttr(varyColorsEl, "val") : undefined,
    series,
    dataLabels: parseDataLabels(getChild(radarChart, "c:dLbls")),
    shapeProperties: parseChartShapeProperties(getChild(radarChart, "c:spPr"))
  };
}

// packages/@oxen-office/chart/src/parser/series/bubble.ts
function getAttr12(element, name) {
  if (!element) {
    return;
  }
  return getAttr(element, name);
}
function parseBubbleSeries(ser) {
  const idxEl = getChild(ser, "c:idx");
  const orderEl = getChild(ser, "c:order");
  const invertIfNegativeEl = getChild(ser, "c:invertIfNegative");
  const bubble3DEl = getChild(ser, "c:bubble3D");
  return {
    idx: idxEl ? getIntAttr(idxEl, "val") ?? 0 : 0,
    order: orderEl ? getIntAttr(orderEl, "val") ?? 0 : 0,
    tx: parseSeriesText(getChild(ser, "c:tx")),
    shapeProperties: parseChartShapeProperties(getChild(ser, "c:spPr")),
    invertIfNegative: invertIfNegativeEl ? getBoolAttr(invertIfNegativeEl, "val") : undefined,
    dataPoints: parseDataPoints(ser),
    xValues: parseDataReference(getChild(ser, "c:xVal")),
    yValues: parseDataReference(getChild(ser, "c:yVal")),
    bubbleSize: parseDataReference(getChild(ser, "c:bubbleSize")),
    bubble3D: bubble3DEl ? getBoolAttr(bubble3DEl, "val") : undefined
  };
}
function parseBubbleChart(bubbleChart, index) {
  const varyColorsEl = getChild(bubbleChart, "c:varyColors");
  const bubbleScaleEl = getChild(bubbleChart, "c:bubbleScale");
  const showNegBubblesEl = getChild(bubbleChart, "c:showNegBubbles");
  const sizeRepresentsEl = getChild(bubbleChart, "c:sizeRepresents");
  const series = [];
  for (const ser of getChildren(bubbleChart, "c:ser")) {
    const s = parseBubbleSeries(ser);
    if (s) {
      series.push(s);
    }
  }
  return {
    type: "bubbleChart",
    index,
    order: index,
    varyColors: varyColorsEl ? getBoolAttr(varyColorsEl, "val") : undefined,
    bubbleScale: getChartPercentAttr(bubbleScaleEl, "val"),
    showNegBubbles: showNegBubblesEl ? getBoolAttr(showNegBubblesEl, "val") : undefined,
    sizeRepresents: getAttr12(sizeRepresentsEl, "val"),
    series,
    dataLabels: parseDataLabels(getChild(bubbleChart, "c:dLbls")),
    shapeProperties: parseChartShapeProperties(getChild(bubbleChart, "c:spPr"))
  };
}

// packages/@oxen-office/chart/src/parser/series/stock.ts
function parseStockChart(stockChart, index) {
  const series = [];
  for (const ser of getChildren(stockChart, "c:ser")) {
    const s = parseLineSeries(ser);
    if (s) {
      series.push(s);
    }
  }
  return {
    type: "stockChart",
    index,
    order: index,
    series,
    dropLines: parseChartLines(getChild(stockChart, "c:dropLines")),
    hiLowLines: parseChartLines(getChild(stockChart, "c:hiLowLines")),
    upDownBars: parseUpDownBars(getChild(stockChart, "c:upDownBars")),
    dataLabels: parseDataLabels(getChild(stockChart, "c:dLbls")),
    shapeProperties: parseChartShapeProperties(getChild(stockChart, "c:spPr"))
  };
}

// packages/@oxen-office/chart/src/parser/series/surface.ts
function parseBandFormats(bandFmtsEl) {
  if (!bandFmtsEl) {
    return;
  }
  const formats = [];
  for (const bandFmt of getChildren(bandFmtsEl, "c:bandFmt")) {
    const idxEl = getChild(bandFmt, "c:idx");
    if (!idxEl) {
      continue;
    }
    const idx = getIntAttr(idxEl, "val") ?? 0;
    formats.push({
      idx,
      shapeProperties: parseChartShapeProperties(getChild(bandFmt, "c:spPr"))
    });
  }
  return formats.length > 0 ? formats : undefined;
}
function parseSurfaceSeries(ser) {
  const idxEl = getChild(ser, "c:idx");
  const orderEl = getChild(ser, "c:order");
  return {
    idx: idxEl ? getIntAttr(idxEl, "val") ?? 0 : 0,
    order: orderEl ? getIntAttr(orderEl, "val") ?? 0 : 0,
    tx: parseSeriesText(getChild(ser, "c:tx")),
    shapeProperties: parseChartShapeProperties(getChild(ser, "c:spPr")),
    categories: parseDataReference(getChild(ser, "c:cat")),
    values: parseDataReference(getChild(ser, "c:val"))
  };
}
function parseSurfaceChart(surfaceChart, index, type) {
  const wireframeEl = getChild(surfaceChart, "c:wireframe");
  const series = [];
  for (const ser of getChildren(surfaceChart, "c:ser")) {
    const s = parseSurfaceSeries(ser);
    if (s) {
      series.push(s);
    }
  }
  return {
    type,
    index,
    order: index,
    wireframe: wireframeEl ? getBoolAttr(wireframeEl, "val") : undefined,
    bandFormats: parseBandFormats(getChild(surfaceChart, "c:bandFmts")),
    series,
    dataLabels: parseDataLabels(getChild(surfaceChart, "c:dLbls")),
    shapeProperties: parseChartShapeProperties(getChild(surfaceChart, "c:spPr"))
  };
}

// packages/@oxen-office/chart/src/parser/parse-chart.ts
function getAttr13(element, name) {
  if (!element) {
    return;
  }
  return getAttr(element, name);
}
function parseExternalData(externalDataEl) {
  if (!externalDataEl) {
    return;
  }
  return {
    resourceId: getAttr13(externalDataEl, "r:id") ?? "",
    autoUpdate: getBoolAttr(getChild(externalDataEl, "c:autoUpdate"), "val")
  };
}
function parseChartSeries(plotArea) {
  const charts = [];
  const indexRef = { value: 0 };
  const nextIndex = () => {
    const current = indexRef.value;
    indexRef.value += 1;
    return current;
  };
  for (const barChart of getChildren(plotArea, "c:barChart")) {
    charts.push(parseBarChart(barChart, nextIndex()));
  }
  for (const bar3DChart of getChildren(plotArea, "c:bar3DChart")) {
    const chart = parseBarChart(bar3DChart, nextIndex());
    charts.push({ ...chart, type: "bar3DChart" });
  }
  for (const lineChart of getChildren(plotArea, "c:lineChart")) {
    charts.push(parseLineChart(lineChart, nextIndex()));
  }
  for (const line3DChart of getChildren(plotArea, "c:line3DChart")) {
    const chart = parseLineChart(line3DChart, nextIndex());
    charts.push({ ...chart, type: "line3DChart" });
  }
  for (const pieChart of getChildren(plotArea, "c:pieChart")) {
    charts.push(parsePieChart(pieChart, nextIndex(), "pieChart"));
  }
  for (const pie3DChart of getChildren(plotArea, "c:pie3DChart")) {
    charts.push(parsePieChart(pie3DChart, nextIndex(), "pie3DChart"));
  }
  for (const doughnutChart of getChildren(plotArea, "c:doughnutChart")) {
    charts.push(parsePieChart(doughnutChart, nextIndex(), "doughnutChart"));
  }
  for (const ofPieChart of getChildren(plotArea, "c:ofPieChart")) {
    charts.push(parseOfPieChart(ofPieChart, nextIndex()));
  }
  for (const scatterChart of getChildren(plotArea, "c:scatterChart")) {
    charts.push(parseScatterChart(scatterChart, nextIndex()));
  }
  for (const areaChart of getChildren(plotArea, "c:areaChart")) {
    charts.push(parseAreaChart(areaChart, nextIndex()));
  }
  for (const area3DChart of getChildren(plotArea, "c:area3DChart")) {
    const chart = parseAreaChart(area3DChart, nextIndex());
    charts.push({ ...chart, type: "area3DChart" });
  }
  for (const radarChart of getChildren(plotArea, "c:radarChart")) {
    charts.push(parseRadarChart(radarChart, nextIndex()));
  }
  for (const bubbleChart of getChildren(plotArea, "c:bubbleChart")) {
    charts.push(parseBubbleChart(bubbleChart, nextIndex()));
  }
  for (const stockChart of getChildren(plotArea, "c:stockChart")) {
    charts.push(parseStockChart(stockChart, nextIndex()));
  }
  for (const surfaceChart of getChildren(plotArea, "c:surfaceChart")) {
    charts.push(parseSurfaceChart(surfaceChart, nextIndex(), "surfaceChart"));
  }
  for (const surface3DChart of getChildren(plotArea, "c:surface3DChart")) {
    charts.push(parseSurfaceChart(surface3DChart, nextIndex(), "surface3DChart"));
  }
  return charts;
}
function parsePlotArea(plotAreaElement) {
  return {
    layout: parseLayout(getChild(plotAreaElement, "c:layout")),
    charts: parseChartSeries(plotAreaElement),
    axes: parseAxes(plotAreaElement),
    dataTable: parseDataTable(getChild(plotAreaElement, "c:dTable")),
    shapeProperties: parseChartShapeProperties(getChild(plotAreaElement, "c:spPr"))
  };
}
function parseChart(chartDoc) {
  const chartSpace = getByPath(chartDoc, ["c:chartSpace"]);
  if (!chartSpace) {
    return;
  }
  const chart = getChild(chartSpace, "c:chart");
  if (!chart) {
    return;
  }
  const plotAreaEl = getChild(chart, "c:plotArea");
  if (!plotAreaEl) {
    return;
  }
  const view3dEl = getChild(chart, "c:view3D");
  const floorEl = getChild(chart, "c:floor");
  const sideWallEl = getChild(chart, "c:sideWall");
  const backWallEl = getChild(chart, "c:backWall");
  const autoTitleDeletedEl = getChild(chart, "c:autoTitleDeleted");
  const pivotFmtsEl = getChild(chart, "c:pivotFmts");
  const plotVisOnlyEl = getChild(chart, "c:plotVisOnly");
  const dispBlanksAsEl = getChild(chart, "c:dispBlanksAs");
  const showDLblsOverMaxEl = getChild(chart, "c:showDLblsOverMax");
  const date1904El = getChild(chartSpace, "c:date1904");
  const roundedCornersEl = getChild(chartSpace, "c:roundedCorners");
  const pivotSourceEl = getChild(chartSpace, "c:pivotSource");
  const protectionEl = getChild(chartSpace, "c:protection");
  const printSettingsEl = getChild(chartSpace, "c:printSettings");
  const userShapesEl = getChild(chartSpace, "c:userShapes");
  const externalDataEl = getChild(chartSpace, "c:externalData");
  const externalData = parseExternalData(externalDataEl);
  const styleEl = getChild(chartSpace, "c:style");
  const style = styleEl ? getIntAttr(styleEl, "val") : undefined;
  return {
    title: parseChartTitle(getChild(chart, "c:title")),
    autoTitleDeleted: autoTitleDeletedEl ? getBoolAttr(autoTitleDeletedEl, "val") : undefined,
    pivotFormats: parsePivotFormats(pivotFmtsEl),
    view3D: parseView3D(view3dEl),
    floor: parseChartSurface(floorEl),
    sideWall: parseChartSurface(sideWallEl),
    backWall: parseChartSurface(backWallEl),
    plotArea: parsePlotArea(plotAreaEl),
    legend: parseLegend(getChild(chart, "c:legend")),
    plotVisOnly: plotVisOnlyEl ? getBoolAttr(plotVisOnlyEl, "val") : undefined,
    dispBlanksAs: getAttr13(dispBlanksAsEl, "val"),
    showDataLabelsOverMax: showDLblsOverMaxEl ? getBoolAttr(showDLblsOverMaxEl, "val") : undefined,
    style,
    externalData,
    date1904: date1904El ? getBoolAttr(date1904El, "val") : undefined,
    roundedCorners: roundedCornersEl ? getBoolAttr(roundedCornersEl, "val") : undefined,
    pivotSource: parsePivotSource(pivotSourceEl),
    protection: parseProtection(protectionEl),
    printSettings: parsePrintSettings(printSettingsEl),
    userShapes: parseUserShapesRelId(userShapesEl)
  };
}
// packages/@oxen-office/pptx/src/parser/slide/diagram-drawing-parser.ts
function parseDiagramDrawing(drawingDoc) {
  const drawingSpTree = getByPath(drawingDoc, ["p:drawing", "p:spTree"]);
  if (drawingSpTree) {
    return {
      shapes: parseShapeTree({ spTree: drawingSpTree })
    };
  }
  const dspSpTree = getByPath(drawingDoc, ["dsp:drawing", "dsp:spTree"]);
  if (dspSpTree) {
    return {
      shapes: parseDiagramShapeTree(dspSpTree)
    };
  }
  const dgmDrawing = getByPath(drawingDoc, ["dgm:drawing"]);
  if (dgmDrawing) {
    const spTree = getChild(dgmDrawing, "dgm:spTree");
    if (spTree) {
      return {
        shapes: parseDiagramShapeTree(spTree)
      };
    }
  }
  return { shapes: [] };
}
function parseDiagramShapeTree(spTree) {
  const shapes = [];
  for (const child of spTree.children) {
    if (!isXmlElement(child))
      continue;
    const mappedElement = mapDiagramElement(child);
    if (mappedElement) {
      const shape = parseShapeElement({ element: mappedElement });
      if (shape) {
        const enrichedShape = addDiagramAttributes(shape, child);
        shapes.push(enrichedShape);
      }
    }
  }
  return shapes;
}
function addDiagramAttributes(shape, originalElement) {
  if (shape.type !== "sp") {
    return shape;
  }
  if (originalElement.name !== "dsp:sp" && originalElement.name !== "dgm:sp") {
    return shape;
  }
  const modelId = getAttr(originalElement, "modelId");
  const txXfrmElement = getChild(originalElement, "dsp:txXfrm");
  const textTransform = parseTextTransform(txXfrmElement);
  if (modelId || textTransform) {
    return {
      ...shape,
      modelId,
      textTransform
    };
  }
  return shape;
}
function parseTextTransform(txXfrm) {
  return parseTransform(txXfrm);
}
function mapDiagramElement(element) {
  switch (element.name) {
    case "dsp:sp":
      return createMappedElement("p:sp", element);
    case "dgm:sp":
      return createMappedElement("p:sp", element);
    case "dsp:pic":
      return createMappedElement("p:pic", element);
    case "dsp:grpSp":
      return createMappedElement("p:grpSp", element);
    case "dsp:cxnSp":
      return createMappedElement("p:cxnSp", element);
    case "p:sp":
    case "p:pic":
    case "p:grpSp":
    case "p:cxnSp":
    case "p:graphicFrame":
      return element;
    default:
      return;
  }
}
function createMappedElement(newName, source) {
  return {
    type: "element",
    name: newName,
    attrs: source.attrs,
    children: source.children.map((child) => {
      if (isXmlElement(child)) {
        const newChildName = remapElementName(child.name);
        if (newChildName !== child.name) {
          return createMappedElement(newChildName, child);
        }
      }
      return child;
    })
  };
}
function remapElementName(name) {
  if (name.startsWith("dsp:nvSpPr"))
    return "p:nvSpPr";
  if (name.startsWith("dsp:spPr"))
    return "p:spPr";
  if (name.startsWith("dsp:txBody"))
    return "p:txBody";
  if (name.startsWith("dsp:style"))
    return "p:style";
  if (name.startsWith("dsp:"))
    return name.replace("dsp:", "p:");
  if (name.startsWith("dgm:"))
    return name.replace("dgm:", "p:");
  return name;
}

// packages/@oxen-office/diagram/src/parser/diagram/color-parser.ts
function parseDiagramColorsDefinition(doc) {
  const colorsDef = getByPath(doc, ["dgm:colorsDef"]);
  if (!colorsDef || !isXmlElement(colorsDef))
    return;
  const title = getAttrFromChild(colorsDef, "dgm:title", "val");
  const description = getAttrFromChild(colorsDef, "dgm:desc", "val");
  const categories = parseCategoryList(getChild(colorsDef, "dgm:catLst"));
  const styleLabels = parseStyleLabels(getChildren(colorsDef, "dgm:styleLbl"));
  return {
    uniqueId: getAttr(colorsDef, "uniqueId"),
    title,
    description,
    categories,
    styleLabels
  };
}
function parseCategoryList(element) {
  if (!element)
    return;
  const categories = getChildren(element, "dgm:cat").map((cat) => ({
    type: getAttr(cat, "type"),
    priority: getIntAttr(cat, "pri")
  }));
  if (categories.length === 0)
    return;
  return categories;
}
function parseStyleLabels(elements) {
  if (elements.length === 0)
    return;
  const labels = elements.map(parseStyleLabel).filter((label) => label !== undefined);
  if (labels.length === 0)
    return;
  return labels;
}
function parseStyleLabel(element) {
  const name = getAttr(element, "name");
  const fillColors = parseColorList(getChild(element, "dgm:fillClrLst"));
  const lineColors = parseColorList(getChild(element, "dgm:linClrLst"));
  const effectColors = parseColorList(getChild(element, "dgm:effectClrLst"));
  const textLineColors = parseColorList(getChild(element, "dgm:txLinClrLst"));
  const textFillColors = parseColorList(getChild(element, "dgm:txFillClrLst"));
  const textEffectColors = parseColorList(getChild(element, "dgm:txEffectClrLst"));
  if (!name && !fillColors && !lineColors && !effectColors && !textLineColors && !textFillColors && !textEffectColors) {
    return;
  }
  return {
    name,
    fillColors,
    lineColors,
    effectColors,
    textLineColors,
    textFillColors,
    textEffectColors
  };
}
function parseColorList(element) {
  if (!element)
    return;
  const colors = [];
  for (const child of element.children) {
    if (!isXmlElement(child))
      continue;
    const color = parseColor(child);
    if (color)
      colors.push(color);
  }
  if (colors.length === 0)
    return;
  return {
    method: parseClrAppMethod(getAttr(element, "meth")),
    hueDirection: parseHueDir(getAttr(element, "hueDir")),
    colors
  };
}
function parseClrAppMethod(value) {
  return isClrAppMethod(value) ? value : undefined;
}
function isClrAppMethod(value) {
  switch (value) {
    case "cycle":
    case "repeat":
    case "span":
      return true;
    default:
      return false;
  }
}
function parseHueDir(value) {
  return isHueDir(value) ? value : undefined;
}
function isHueDir(value) {
  switch (value) {
    case "cw":
    case "ccw":
      return true;
    default:
      return false;
  }
}
function getAttrFromChild(parent, childName, attrName) {
  const child = getChild(parent, childName);
  return child ? getAttr(child, attrName) : undefined;
}

// packages/@oxen-office/diagram/src/parser/diagram/data-parser.ts
function parseDiagramDataModel(doc, options) {
  const dataModel = getByPath(doc, ["dgm:dataModel"]);
  if (!dataModel || !isXmlElement(dataModel))
    return;
  return parseDiagramDataModelElement(dataModel, options);
}
function parseDiagramDataModelElement(element, options) {
  if (!element)
    return;
  const points = parsePointList(getChild(element, "dgm:ptLst"), options);
  const connections = parseConnectionList(getChild(element, "dgm:cxnLst"));
  const background = parseBackground2(getChild(element, "dgm:bg"));
  const whole = parseWhole(getChild(element, "dgm:whole"));
  const extensions = parseExtensionList(getChild(element, "dgm:extLst"));
  return {
    points,
    connections,
    background,
    whole,
    extensions
  };
}
function parsePointList(element, options) {
  if (!element)
    return [];
  return getChildren(element, "dgm:pt").map((pt2) => parsePoint2(pt2, options));
}
function parsePoint2(element, options) {
  const modelId = parseModelId(getAttr(element, "modelId")) ?? "";
  const type = parseElementType(getAttr(element, "type"));
  const connectionId = getAttr(element, "cxnId");
  const propertySet = parsePropertySet(getChild(element, "dgm:prSet"));
  const shapeProperties = options.parseShapeProperties(getChild(element, "dgm:spPr"));
  const textBody = options.parseTextBody(getChild(element, "dgm:t"));
  const extensions = parseExtensionList(getChild(element, "dgm:extLst"));
  return {
    modelId,
    type,
    connectionId,
    propertySet,
    shapeProperties,
    textBody,
    extensions
  };
}
function parsePropertySet(element) {
  if (!element)
    return;
  const placeholder = getBoolAttr(element, "phldr");
  return {
    layoutTypeId: getAttr(element, "loTypeId"),
    layoutCategoryId: getAttr(element, "loCatId"),
    quickStyleTypeId: getAttr(element, "qsTypeId"),
    quickStyleCategoryId: getAttr(element, "qsCatId"),
    colorTypeId: getAttr(element, "csTypeId"),
    colorCategoryId: getAttr(element, "csCatId"),
    coherent3DOff: getBoolAttr(element, "coherent3DOff"),
    customAngle: getIntAttr(element, "custAng"),
    customFlipHorizontal: getBoolAttr(element, "custFlipHor"),
    customFlipVertical: getBoolAttr(element, "custFlipVert"),
    customSizeX: getIntAttr(element, "custSzX"),
    customSizeY: getIntAttr(element, "custSzY"),
    customScaleX: parsePrSetCustVal(getAttr(element, "custScaleX")),
    customScaleY: parsePrSetCustVal(getAttr(element, "custScaleY")),
    customText: getBoolAttr(element, "custT"),
    customLinearFactorX: parsePrSetCustVal(getAttr(element, "custLinFactX")),
    customLinearFactorY: parsePrSetCustVal(getAttr(element, "custLinFactY")),
    customLinearFactorNeighborX: parsePrSetCustVal(getAttr(element, "custLinFactNeighborX")),
    customLinearFactorNeighborY: parsePrSetCustVal(getAttr(element, "custLinFactNeighborY")),
    customRadiusScale: parsePrSetCustVal(getAttr(element, "custRadScaleRad")),
    customRadiusScaleInclude: parsePrSetCustVal(getAttr(element, "custRadScaleInc")),
    placeholder,
    placeholderText: getAttr(element, "phldrT"),
    presentationAssocId: getAttr(element, "presAssocID"),
    presentationName: getAttr(element, "presName"),
    presentationStyleLabel: getAttr(element, "presStyleLbl"),
    presentationStyleIndex: getIntAttr(element, "presStyleIdx"),
    presentationStyleCount: getIntAttr(element, "presStyleCnt"),
    presentationLayoutVars: parseVariableList(getChild(element, "dgm:presLayoutVars"))
  };
}
function parsePrSetCustVal(value) {
  return parsePercentage(value);
}
function parseVariableList(element) {
  if (!element)
    return;
  const variables = element.children.filter(isXmlElement).map((child) => ({
    name: stripPrefix(child.name),
    value: parseVariableValue(stripPrefix(child.name), getAttr(child, "val"))
  }));
  if (variables.length === 0)
    return;
  return { variables };
}
function parseVariableValue(name, value) {
  if (name === "animLvl")
    return parseAnimLvlStr(value);
  if (name === "animOne")
    return parseAnimOneStr(value);
  if (name === "begSty" || name === "endSty")
    return parseArrowheadStyle(value);
  if (name === "autoTxRot")
    return parseAutoTextRotation(value);
  if (name === "bendPt")
    return parseBendPoint(value);
  if (name === "break")
    return parseBreakpoint(value);
  if (name === "ctrShpMap")
    return parseCenterShapeMapping(value);
  if (name === "chAlign")
    return parseChildAlignment(value);
  if (name === "chDir")
    return parseChildDirection(value);
  if (name === "dim")
    return parseConnectorDimension(value);
  if (name === "begPts" || name === "endPts")
    return parseConnectorPoint(value);
  if (name === "connRout")
    return parseConnectorRouting(value);
  if (name === "contDir")
    return parseContinueDirection(value);
  if (name === "horzAlign")
    return parseHorizontalAlignment(value);
  if (name === "nodeHorzAlign")
    return parseNodeHorizontalAlignment(value);
  if (name === "nodeVertAlign")
    return parseNodeVerticalAlignment(value);
  if (name === "off")
    return parseOffset(value);
  if (name === "alignTx" || name === "parTxLTRAlign" || name === "parTxRTLAlign" || name === "shpTxLTRAlignCh" || name === "shpTxRTLAlignCh") {
    return parseDiagramTextAlignment(value);
  }
  if (name === "dir")
    return parseDiagramDirection(value);
  if (name === "fallback")
    return parseFallbackDimension(value);
  if (name === "hierBranch")
    return parseHierBranchStyle(value);
  if (name === "resizeHandles")
    return parseResizeHandlesStr(value);
  if (name === "flowDir")
    return parseFlowDirection(value);
  if (name === "linDir")
    return parseLinearDirection(value);
  if (name === "grDir")
    return parseGrowDirection(value);
  if (name === "hierAlign")
    return parseHierarchyAlignment(value);
  return value;
}
function parseAnimLvlStr(value) {
  return isAnimLvlStr(value) ? value : undefined;
}
function isAnimLvlStr(value) {
  switch (value) {
    case "ctr":
    case "lvl":
    case "none":
      return true;
    default:
      return false;
  }
}
function parseAnimOneStr(value) {
  return isAnimOneStr(value) ? value : undefined;
}
function isAnimOneStr(value) {
  switch (value) {
    case "branch":
    case "none":
    case "one":
      return true;
    default:
      return false;
  }
}
function parseArrowheadStyle(value) {
  return isArrowheadStyle(value) ? value : undefined;
}
function isArrowheadStyle(value) {
  switch (value) {
    case "auto":
    case "arr":
    case "noArr":
      return true;
    default:
      return false;
  }
}
function parseAutoTextRotation(value) {
  return isAutoTextRotation(value) ? value : undefined;
}
function isAutoTextRotation(value) {
  switch (value) {
    case "grav":
    case "none":
    case "upr":
      return true;
    default:
      return false;
  }
}
function parseBendPoint(value) {
  return isBendPoint(value) ? value : undefined;
}
function isBendPoint(value) {
  switch (value) {
    case "beg":
    case "def":
    case "end":
      return true;
    default:
      return false;
  }
}
function parseBreakpoint(value) {
  return isBreakpoint(value) ? value : undefined;
}
function isBreakpoint(value) {
  switch (value) {
    case "bal":
    case "endCnv":
    case "fixed":
      return true;
    default:
      return false;
  }
}
function parseCenterShapeMapping(value) {
  return isCenterShapeMapping(value) ? value : undefined;
}
function isCenterShapeMapping(value) {
  switch (value) {
    case "fNode":
    case "none":
      return true;
    default:
      return false;
  }
}
function parseChildAlignment(value) {
  return isChildAlignment(value) ? value : undefined;
}
function isChildAlignment(value) {
  switch (value) {
    case "b":
    case "l":
    case "r":
    case "t":
      return true;
    default:
      return false;
  }
}
function parseChildDirection(value) {
  return isChildDirection(value) ? value : undefined;
}
function isChildDirection(value) {
  switch (value) {
    case "horz":
    case "vert":
      return true;
    default:
      return false;
  }
}
function parseConnectorDimension(value) {
  return isConnectorDimension(value) ? value : undefined;
}
function isConnectorDimension(value) {
  switch (value) {
    case "1D":
    case "2D":
    case "cust":
      return true;
    default:
      return false;
  }
}
function parseConnectorPoint(value) {
  return isConnectorPoint(value) ? value : undefined;
}
function isConnectorPoint(value) {
  switch (value) {
    case "auto":
    case "bCtr":
    case "bL":
    case "bR":
    case "ctr":
    case "midL":
    case "midR":
    case "radial":
    case "tCtr":
    case "tL":
    case "tR":
      return true;
    default:
      return false;
  }
}
function parseConnectorRouting(value) {
  return isConnectorRouting(value) ? value : undefined;
}
function isConnectorRouting(value) {
  switch (value) {
    case "bend":
    case "curve":
    case "longCurve":
    case "stra":
      return true;
    default:
      return false;
  }
}
function parseContinueDirection(value) {
  return isContinueDirection(value) ? value : undefined;
}
function isContinueDirection(value) {
  switch (value) {
    case "revDir":
    case "sameDir":
      return true;
    default:
      return false;
  }
}
function parseHorizontalAlignment(value) {
  return isHorizontalAlignment(value) ? value : undefined;
}
function isHorizontalAlignment(value) {
  switch (value) {
    case "ctr":
    case "l":
    case "none":
    case "r":
      return true;
    default:
      return false;
  }
}
function parseNodeHorizontalAlignment(value) {
  return isNodeHorizontalAlignment(value) ? value : undefined;
}
function isNodeHorizontalAlignment(value) {
  switch (value) {
    case "ctr":
    case "l":
    case "r":
      return true;
    default:
      return false;
  }
}
function parseNodeVerticalAlignment(value) {
  return isNodeVerticalAlignment(value) ? value : undefined;
}
function isNodeVerticalAlignment(value) {
  switch (value) {
    case "b":
    case "mid":
    case "t":
      return true;
    default:
      return false;
  }
}
function parseOffset(value) {
  return isOffset(value) ? value : undefined;
}
function isOffset(value) {
  switch (value) {
    case "ctr":
    case "off":
      return true;
    default:
      return false;
  }
}
function parseDiagramTextAlignment(value) {
  return isDiagramTextAlignment(value) ? value : undefined;
}
function isDiagramTextAlignment(value) {
  switch (value) {
    case "ctr":
    case "l":
    case "r":
      return true;
    default:
      return false;
  }
}
function parseDiagramDirection(value) {
  return isDiagramDirection(value) ? value : undefined;
}
function isDiagramDirection(value) {
  switch (value) {
    case "norm":
    case "rev":
      return true;
    default:
      return false;
  }
}
function parseElementType(value) {
  return isElementType(value) ? value : undefined;
}
function isElementType(value) {
  switch (value) {
    case "all":
    case "asst":
    case "doc":
    case "node":
    case "nonAsst":
    case "nonNorm":
    case "norm":
    case "parTrans":
    case "pres":
    case "sibTrans":
      return true;
    default:
      return false;
  }
}
function parseFallbackDimension(value) {
  return isFallbackDimension(value) ? value : undefined;
}
function isFallbackDimension(value) {
  switch (value) {
    case "1D":
    case "2D":
      return true;
    default:
      return false;
  }
}
function parseHierBranchStyle(value) {
  return isHierBranchStyle(value) ? value : undefined;
}
function isHierBranchStyle(value) {
  switch (value) {
    case "hang":
    case "init":
    case "l":
    case "r":
    case "std":
      return true;
    default:
      return false;
  }
}
function parseResizeHandlesStr(value) {
  return isResizeHandlesStr(value) ? value : undefined;
}
function isResizeHandlesStr(value) {
  switch (value) {
    case "exact":
    case "rel":
      return true;
    default:
      return false;
  }
}
function parseGrowDirection(value) {
  return isGrowDirection(value) ? value : undefined;
}
function isGrowDirection(value) {
  switch (value) {
    case "bL":
    case "bR":
    case "tL":
    case "tR":
      return true;
    default:
      return false;
  }
}
function parseHierarchyAlignment(value) {
  return isHierarchyAlignment(value) ? value : undefined;
}
function isHierarchyAlignment(value) {
  switch (value) {
    case "bCtrCh":
    case "bCtrDes":
    case "bL":
    case "bR":
    case "lB":
    case "lCtrCh":
    case "lCtrDes":
    case "lT":
    case "rB":
    case "rCtrCh":
    case "rCtrDes":
    case "rT":
    case "tCtrCh":
    case "tCtrDes":
    case "tL":
    case "tR":
      return true;
    default:
      return false;
  }
}
function parseFlowDirection(value) {
  return isFlowDirection(value) ? value : undefined;
}
function isFlowDirection(value) {
  switch (value) {
    case "col":
    case "row":
      return true;
    default:
      return false;
  }
}
function parseLinearDirection(value) {
  return isLinearDirection(value) ? value : undefined;
}
function isLinearDirection(value) {
  switch (value) {
    case "fromB":
    case "fromL":
    case "fromR":
    case "fromT":
      return true;
    default:
      return false;
  }
}
function parseModelId(value) {
  if (!value)
    return;
  if (isGuid(value))
    return value;
  if (isModelIdInt(value))
    return value;
  return;
}
function isGuid(value) {
  return /^\{?[0-9A-Fa-f]{8}(?:-[0-9A-Fa-f]{4}){3}-[0-9A-Fa-f]{12}\}?$/.test(value);
}
function isModelIdInt(value) {
  return /^-?\d+$/.test(value);
}
function parseCxnType(value) {
  return isCxnType(value) ? value : undefined;
}
function isCxnType(value) {
  switch (value) {
    case "parOf":
    case "presOf":
    case "presParOf":
    case "unknownRelationship":
      return true;
    default:
      return false;
  }
}
function parseConnectionList(element) {
  if (!element)
    return [];
  return getChildren(element, "dgm:cxn").map(parseConnection);
}
function parseConnection(element) {
  const modelId = parseModelId(getAttr(element, "modelId")) ?? "";
  return {
    modelId,
    type: parseCxnType(getAttr(element, "type")),
    sourceId: getAttr(element, "srcId"),
    destinationId: getAttr(element, "destId"),
    sourceOrder: getIntAttr(element, "srcOrd"),
    destinationOrder: getIntAttr(element, "destOrd"),
    parentTransitionId: getAttr(element, "parTransId"),
    siblingTransitionId: getAttr(element, "sibTransId"),
    presentationId: getAttr(element, "presId")
  };
}
function parseBackground2(element) {
  if (!element)
    return;
  return { present: true };
}
function parseWhole(element) {
  if (!element)
    return;
  return { present: true };
}
function parseExtensionList(element) {
  if (!element)
    return;
  const extensions = getChildren(element, "a:ext").map((ext) => {
    const dataModelExt = getChild(ext, "dsp:dataModelExt");
    const dataModelExtValue = parseDataModelExt(dataModelExt);
    return {
      uri: getAttr(ext, "uri"),
      dataModelExt: dataModelExtValue
    };
  });
  if (extensions.length === 0)
    return;
  return extensions;
}
function stripPrefix(name) {
  const idx = name.indexOf(":");
  return idx === -1 ? name : name.slice(idx + 1);
}
function parseDataModelExt(element) {
  if (!element) {
    return;
  }
  return {
    relId: getAttr(element, "relId"),
    minVersion: getAttr(element, "minVer")
  };
}

// packages/@oxen-office/diagram/src/parser/diagram/layout-parser.ts
function parseDiagramLayoutDefinition(doc, options) {
  const layoutDef = getByPath(doc, ["dgm:layoutDef"]);
  if (!layoutDef || !isXmlElement(layoutDef))
    return;
  const title = getAttrFromChild2(layoutDef, "dgm:title", "val");
  const description = getAttrFromChild2(layoutDef, "dgm:desc", "val");
  const categories = parseCategoryList2(getChild(layoutDef, "dgm:catLst"));
  const sampDataEl = getChild(layoutDef, "dgm:sampData");
  const styleDataEl = getChild(layoutDef, "dgm:styleData");
  const colorDataEl = getChild(layoutDef, "dgm:clrData");
  const sampleData = parseDiagramDataModelElement(sampDataEl ? getChild(sampDataEl, "dgm:dataModel") : undefined, options);
  const styleData = parseDiagramDataModelElement(styleDataEl ? getChild(styleDataEl, "dgm:dataModel") : undefined, options);
  const colorData = parseDiagramDataModelElement(colorDataEl ? getChild(colorDataEl, "dgm:dataModel") : undefined, options);
  const layoutNode = parseLayoutNode(getChild(layoutDef, "dgm:layoutNode"));
  return {
    uniqueId: getAttr(layoutDef, "uniqueId"),
    title,
    description,
    categories,
    sampleData,
    styleData,
    colorData,
    layoutNode
  };
}
function parseCategoryList2(element) {
  if (!element)
    return;
  const categories = getChildren(element, "dgm:cat").map((cat) => ({
    type: getAttr(cat, "type"),
    priority: getIntAttr(cat, "pri")
  }));
  if (categories.length === 0)
    return;
  return categories;
}
function parseLayoutNode(element) {
  if (!element)
    return;
  const content = parseLayoutContent(element);
  return {
    name: getAttr(element, "name"),
    childOrder: parseChildOrderType(getAttr(element, "chOrder")),
    moveWith: getAttr(element, "moveWith"),
    styleLabel: getAttr(element, "styleLbl"),
    ...content
  };
}
function parseLayoutContent(element) {
  const variables = parseVariableList2(getChild(element, "dgm:varLst"));
  const algorithm = parseAlgorithm(getChild(element, "dgm:alg"));
  const shape = parseLayoutShape(getChild(element, "dgm:shape"));
  const presentationOf = parsePresentationOf(getChild(element, "dgm:presOf"));
  const constraints = parseConstraintList(getChild(element, "dgm:constrLst"));
  const rules = parseRuleList(getChild(element, "dgm:ruleLst"));
  const forEach = parseForEachList(getChildren(element, "dgm:forEach"));
  const choose = parseChooseList(getChildren(element, "dgm:choose"));
  const children = getChildren(element, "dgm:layoutNode").map(parseLayoutNode).filter((node) => node !== undefined);
  return {
    variables,
    algorithm,
    shape,
    presentationOf,
    constraints,
    rules,
    forEach,
    choose,
    children: children.length === 0 ? undefined : children
  };
}
function parseVariableList2(element) {
  if (!element)
    return;
  const variables = element.children.filter(isXmlElement).map((child) => ({
    name: stripPrefix2(child.name),
    value: parseVariableValue2(stripPrefix2(child.name), getAttr(child, "val"))
  }));
  if (variables.length === 0)
    return;
  return { variables };
}
function parseAlgorithm(element) {
  if (!element)
    return;
  const params = getChildren(element, "dgm:param").map(parseAlgorithmParam);
  return {
    type: parseAlgorithmType(getAttr(element, "type")),
    params: params.length === 0 ? undefined : params
  };
}
function parseAlgorithmParam(element) {
  const type = parseParameterId(getAttr(element, "type"));
  return {
    type,
    value: parseParameterValue(type, getAttr(element, "val"))
  };
}
function parseVariableValue2(name, value) {
  if (name === "animLvl")
    return parseAnimLvlStr2(value);
  if (name === "animOne")
    return parseAnimOneStr2(value);
  if (name === "begSty" || name === "endSty")
    return parseArrowheadStyle2(value);
  if (name === "autoTxRot")
    return parseAutoTextRotation2(value);
  if (name === "bendPt")
    return parseBendPoint2(value);
  if (name === "break")
    return parseBreakpoint2(value);
  if (name === "ctrShpMap")
    return parseCenterShapeMapping2(value);
  if (name === "chAlign")
    return parseChildAlignment2(value);
  if (name === "chDir")
    return parseChildDirection2(value);
  if (name === "dim")
    return parseConnectorDimension2(value);
  if (name === "begPts" || name === "endPts")
    return parseConnectorPoint2(value);
  if (name === "connRout")
    return parseConnectorRouting2(value);
  if (name === "contDir")
    return parseContinueDirection2(value);
  if (name === "horzAlign")
    return parseHorizontalAlignment2(value);
  if (name === "nodeHorzAlign")
    return parseNodeHorizontalAlignment2(value);
  if (name === "nodeVertAlign")
    return parseNodeVerticalAlignment2(value);
  if (name === "off")
    return parseOffset2(value);
  if (name === "alignTx" || name === "parTxLTRAlign" || name === "parTxRTLAlign" || name === "shpTxLTRAlignCh" || name === "shpTxRTLAlignCh") {
    return parseDiagramTextAlignment2(value);
  }
  if (name === "dir")
    return parseDiagramDirection2(value);
  if (name === "fallback")
    return parseFallbackDimension2(value);
  if (name === "hierBranch")
    return parseHierBranchStyle2(value);
  if (name === "resizeHandles")
    return parseResizeHandlesStr2(value);
  if (name === "flowDir")
    return parseFlowDirection2(value);
  if (name === "linDir")
    return parseLinearDirection2(value);
  if (name === "grDir")
    return parseGrowDirection2(value);
  if (name === "hierAlign")
    return parseHierarchyAlignment2(value);
  return value;
}
function parseAnimLvlStr2(value) {
  return isAnimLvlStr2(value) ? value : undefined;
}
function isAnimLvlStr2(value) {
  switch (value) {
    case "ctr":
    case "lvl":
    case "none":
      return true;
    default:
      return false;
  }
}
function parseAnimOneStr2(value) {
  return isAnimOneStr2(value) ? value : undefined;
}
function isAnimOneStr2(value) {
  switch (value) {
    case "branch":
    case "none":
    case "one":
      return true;
    default:
      return false;
  }
}
function parseArrowheadStyle2(value) {
  return isArrowheadStyle2(value) ? value : undefined;
}
function isArrowheadStyle2(value) {
  switch (value) {
    case "auto":
    case "arr":
    case "noArr":
      return true;
    default:
      return false;
  }
}
function parseAutoTextRotation2(value) {
  return isAutoTextRotation2(value) ? value : undefined;
}
function isAutoTextRotation2(value) {
  switch (value) {
    case "grav":
    case "none":
    case "upr":
      return true;
    default:
      return false;
  }
}
function parseAxisType(value) {
  return isAxisType(value) ? value : undefined;
}
function parseAxisTypes(value) {
  if (!value)
    return;
  const tokens = value.trim().split(/\s+/).filter(Boolean);
  if (tokens.length === 0)
    return;
  const parsed = tokens.map(parseAxisType);
  if (parsed.some((token) => token === undefined))
    return;
  return parsed;
}
function parseBooleans(value) {
  if (!value)
    return;
  const tokens = value.trim().split(/\s+/).filter(Boolean);
  if (tokens.length === 0)
    return;
  const parsed = tokens.map(parseBooleanToken);
  if (parsed.some((token) => token === undefined))
    return;
  return parsed;
}
function parseBooleanToken(value) {
  switch (value) {
    case "1":
    case "true":
      return true;
    case "0":
    case "false":
      return false;
    default:
      return;
  }
}
function parseBoolOperator(value) {
  return isBoolOperator(value) ? value : undefined;
}
function isBoolOperator(value) {
  switch (value) {
    case "equ":
    case "gte":
    case "lte":
    case "none":
      return true;
    default:
      return false;
  }
}
function parseBreakpoint2(value) {
  return isBreakpoint2(value) ? value : undefined;
}
function isBreakpoint2(value) {
  switch (value) {
    case "bal":
    case "endCnv":
    case "fixed":
      return true;
    default:
      return false;
  }
}
function parseCenterShapeMapping2(value) {
  return isCenterShapeMapping2(value) ? value : undefined;
}
function isCenterShapeMapping2(value) {
  switch (value) {
    case "fNode":
    case "none":
      return true;
    default:
      return false;
  }
}
function parseChildAlignment2(value) {
  return isChildAlignment2(value) ? value : undefined;
}
function isChildAlignment2(value) {
  switch (value) {
    case "b":
    case "l":
    case "r":
    case "t":
      return true;
    default:
      return false;
  }
}
function parseChildDirection2(value) {
  return isChildDirection2(value) ? value : undefined;
}
function isChildDirection2(value) {
  switch (value) {
    case "horz":
    case "vert":
      return true;
    default:
      return false;
  }
}
function parseConnectorDimension2(value) {
  return isConnectorDimension2(value) ? value : undefined;
}
function isConnectorDimension2(value) {
  switch (value) {
    case "1D":
    case "2D":
    case "cust":
      return true;
    default:
      return false;
  }
}
function parseConnectorPoint2(value) {
  return isConnectorPoint2(value) ? value : undefined;
}
function isConnectorPoint2(value) {
  switch (value) {
    case "auto":
    case "bCtr":
    case "bL":
    case "bR":
    case "ctr":
    case "midL":
    case "midR":
    case "radial":
    case "tCtr":
    case "tL":
    case "tR":
      return true;
    default:
      return false;
  }
}
function parseConnectorRouting2(value) {
  return isConnectorRouting2(value) ? value : undefined;
}
function isConnectorRouting2(value) {
  switch (value) {
    case "bend":
    case "curve":
    case "longCurve":
    case "stra":
      return true;
    default:
      return false;
  }
}
function parseConstraintType(value) {
  return isConstraintType(value) ? value : undefined;
}
function isConstraintType(value) {
  switch (value) {
    case "alignOff":
    case "b":
    case "begMarg":
    case "begPad":
    case "bendDist":
    case "bMarg":
    case "bOff":
    case "connDist":
    case "ctrX":
    case "ctrXOff":
    case "ctrY":
    case "ctrYOff":
    case "diam":
    case "endMarg":
    case "endPad":
    case "h":
    case "hArH":
    case "hOff":
    case "l":
    case "lMarg":
    case "lOff":
    case "none":
    case "primFontSz":
    case "pyraAcctRatio":
    case "r":
    case "rMarg":
    case "rOff":
    case "secFontSz":
    case "secSibSp":
    case "sibSp":
    case "sp":
    case "stemThick":
    case "t":
    case "tMarg":
    case "tOff":
    case "userA":
    case "userB":
    case "userC":
    case "userD":
    case "userE":
    case "userF":
    case "userG":
    case "userH":
    case "userI":
    case "userJ":
    case "userK":
    case "userL":
    case "userM":
    case "userN":
    case "userO":
    case "userP":
    case "userQ":
    case "userR":
    case "userS":
    case "userT":
    case "userU":
    case "userV":
    case "userW":
    case "userX":
    case "userY":
    case "userZ":
    case "w":
    case "wArH":
    case "wOff":
      return true;
    default:
      return false;
  }
}
function parseContinueDirection2(value) {
  return isContinueDirection2(value) ? value : undefined;
}
function isContinueDirection2(value) {
  switch (value) {
    case "revDir":
    case "sameDir":
      return true;
    default:
      return false;
  }
}
function parseHorizontalAlignment2(value) {
  return isHorizontalAlignment2(value) ? value : undefined;
}
function isHorizontalAlignment2(value) {
  switch (value) {
    case "ctr":
    case "l":
    case "none":
    case "r":
      return true;
    default:
      return false;
  }
}
function parseNodeHorizontalAlignment2(value) {
  return isNodeHorizontalAlignment2(value) ? value : undefined;
}
function isNodeHorizontalAlignment2(value) {
  switch (value) {
    case "ctr":
    case "l":
    case "r":
      return true;
    default:
      return false;
  }
}
function parseNodeVerticalAlignment2(value) {
  return isNodeVerticalAlignment2(value) ? value : undefined;
}
function isNodeVerticalAlignment2(value) {
  switch (value) {
    case "b":
    case "mid":
    case "t":
      return true;
    default:
      return false;
  }
}
function parseOffset2(value) {
  return isOffset2(value) ? value : undefined;
}
function isOffset2(value) {
  switch (value) {
    case "ctr":
    case "off":
      return true;
    default:
      return false;
  }
}
function parseDiagramTextAlignment2(value) {
  return isDiagramTextAlignment2(value) ? value : undefined;
}
function isDiagramTextAlignment2(value) {
  switch (value) {
    case "ctr":
    case "l":
    case "r":
      return true;
    default:
      return false;
  }
}
function parseDiagramDirection2(value) {
  return isDiagramDirection2(value) ? value : undefined;
}
function isDiagramDirection2(value) {
  switch (value) {
    case "norm":
    case "rev":
      return true;
    default:
      return false;
  }
}
function parseElementType2(value) {
  return isElementType2(value) ? value : undefined;
}
function parseElementTypes(value) {
  if (!value)
    return;
  const tokens = value.trim().split(/\s+/).filter(Boolean);
  if (tokens.length === 0)
    return;
  const parsed = tokens.map(parseElementType2);
  if (parsed.some((token) => token === undefined))
    return;
  return parsed;
}
function isElementType2(value) {
  switch (value) {
    case "all":
    case "asst":
    case "doc":
    case "node":
    case "nonAsst":
    case "nonNorm":
    case "norm":
    case "parTrans":
    case "pres":
    case "sibTrans":
      return true;
    default:
      return false;
  }
}
function parseFallbackDimension2(value) {
  return isFallbackDimension2(value) ? value : undefined;
}
function isFallbackDimension2(value) {
  switch (value) {
    case "1D":
    case "2D":
      return true;
    default:
      return false;
  }
}
function parseFlowDirection2(value) {
  return isFlowDirection2(value) ? value : undefined;
}
function isFlowDirection2(value) {
  switch (value) {
    case "col":
    case "row":
      return true;
    default:
      return false;
  }
}
function parseLinearDirection2(value) {
  return isLinearDirection2(value) ? value : undefined;
}
function isLinearDirection2(value) {
  switch (value) {
    case "fromB":
    case "fromL":
    case "fromR":
    case "fromT":
      return true;
    default:
      return false;
  }
}
function parseFunctionArgument(value) {
  return isVariableType(value) ? value : undefined;
}
function isVariableType(value) {
  switch (value) {
    case "animLvl":
    case "animOne":
    case "bulEnabled":
    case "chMax":
    case "chPref":
    case "dir":
    case "hierBranch":
    case "none":
    case "orgChart":
    case "resizeHandles":
      return true;
    default:
      return false;
  }
}
function parseFunctionOperator(value) {
  return isFunctionOperator(value) ? value : undefined;
}
function isFunctionOperator(value) {
  switch (value) {
    case "equ":
    case "gt":
    case "gte":
    case "lt":
    case "lte":
    case "neq":
      return true;
    default:
      return false;
  }
}
function parseFunctionType(value) {
  return isFunctionType(value) ? value : undefined;
}
function isFunctionType(value) {
  switch (value) {
    case "cnt":
    case "depth":
    case "maxDepth":
    case "pos":
    case "posEven":
    case "posOdd":
    case "revPos":
    case "var":
      return true;
    default:
      return false;
  }
}
function parseFunctionValue(value) {
  if (value === undefined)
    return;
  const animLvl = parseAnimLvlStr2(value);
  if (animLvl)
    return animLvl;
  const animOne = parseAnimOneStr2(value);
  if (animOne)
    return animOne;
  const direction = parseDiagramDirection2(value);
  if (direction)
    return direction;
  const hierBranch = parseHierBranchStyle2(value);
  if (hierBranch)
    return hierBranch;
  const resizeHandles = parseResizeHandlesStr2(value);
  if (resizeHandles)
    return resizeHandles;
  if (value === "true")
    return true;
  if (value === "false")
    return false;
  if (/^-?\d+$/.test(value)) {
    return Number.parseInt(value, 10);
  }
  return;
}
function parseIndex1(value) {
  if (value === undefined)
    return;
  if (!/^-?\d+$/.test(value))
    return;
  const parsed = Number.parseInt(value, 10);
  if (Number.isNaN(parsed) || parsed < 1)
    return;
  return parsed;
}
function parseInts(value) {
  if (!value)
    return;
  const tokens = value.trim().split(/\s+/).filter(Boolean);
  if (tokens.length === 0)
    return;
  const parsed = tokens.map(parseIntToken);
  if (parsed.some((token) => token === undefined))
    return;
  return parsed;
}
function parseIntToken(value) {
  if (!/^-?\d+$/.test(value))
    return;
  const parsed = Number.parseInt(value, 10);
  if (Number.isNaN(parsed))
    return;
  return parsed;
}
function parseHierBranchStyle2(value) {
  return isHierBranchStyle2(value) ? value : undefined;
}
function isHierBranchStyle2(value) {
  switch (value) {
    case "hang":
    case "init":
    case "l":
    case "r":
    case "std":
      return true;
    default:
      return false;
  }
}
function parseResizeHandlesStr2(value) {
  return isResizeHandlesStr2(value) ? value : undefined;
}
function isResizeHandlesStr2(value) {
  switch (value) {
    case "exact":
    case "rel":
      return true;
    default:
      return false;
  }
}
function parseGrowDirection2(value) {
  return isGrowDirection2(value) ? value : undefined;
}
function isGrowDirection2(value) {
  switch (value) {
    case "bL":
    case "bR":
    case "tL":
    case "tR":
      return true;
    default:
      return false;
  }
}
function parseHierarchyAlignment2(value) {
  return isHierarchyAlignment2(value) ? value : undefined;
}
function isHierarchyAlignment2(value) {
  switch (value) {
    case "bCtrCh":
    case "bCtrDes":
    case "bL":
    case "bR":
    case "lB":
    case "lCtrCh":
    case "lCtrDes":
    case "lT":
    case "rB":
    case "rCtrCh":
    case "rCtrDes":
    case "rT":
    case "tCtrCh":
    case "tCtrDes":
    case "tL":
    case "tR":
      return true;
    default:
      return false;
  }
}
function parseConstraintRelationship(value) {
  return isConstraintRelationship(value) ? value : undefined;
}
function isConstraintRelationship(value) {
  switch (value) {
    case "ch":
    case "des":
    case "self":
      return true;
    default:
      return false;
  }
}
function parseChildOrderType(value) {
  return isChildOrderType(value) ? value : undefined;
}
function isChildOrderType(value) {
  switch (value) {
    case "b":
    case "t":
      return true;
    default:
      return false;
  }
}
function parseBendPoint2(value) {
  return isBendPoint2(value) ? value : undefined;
}
function isBendPoint2(value) {
  switch (value) {
    case "beg":
    case "def":
    case "end":
      return true;
    default:
      return false;
  }
}
function isAxisType(value) {
  switch (value) {
    case "ancst":
    case "ancstOrSelf":
    case "ch":
    case "des":
    case "desOrSelf":
    case "follow":
    case "followSib":
    case "none":
    case "par":
    case "preced":
    case "precedSib":
    case "root":
    case "self":
      return true;
    default:
      return false;
  }
}
function parseAlgorithmType(value) {
  return isAlgorithmType(value) ? value : undefined;
}
function isAlgorithmType(value) {
  switch (value) {
    case "composite":
    case "conn":
    case "cycle":
    case "hierChild":
    case "hierRoot":
    case "lin":
    case "pyra":
    case "snake":
    case "sp":
    case "tx":
      return true;
    default:
      return false;
  }
}
function parseLayoutShapeType(value) {
  if (!value)
    return;
  if (isOutputShapeType(value))
    return value;
  return value;
}
function isOutputShapeType(value) {
  switch (value) {
    case "conn":
    case "none":
      return true;
    default:
      return false;
  }
}
function parseParameterId(value) {
  return isParameterId(value) ? value : undefined;
}
function isParameterId(value) {
  switch (value) {
    case "alignTx":
    case "ar":
    case "autoTxRot":
    case "begPts":
    case "begSty":
    case "bendPt":
    case "bkpt":
    case "bkPtFixedVal":
    case "chAlign":
    case "chDir":
    case "connRout":
    case "contDir":
    case "ctrShpMap":
    case "dim":
    case "dstNode":
    case "endPts":
    case "endSty":
    case "fallback":
    case "flowDir":
    case "grDir":
    case "hierAlign":
    case "horzAlign":
    case "linDir":
    case "lnSpAfChP":
    case "lnSpAfParP":
    case "lnSpCh":
    case "lnSpPar":
    case "nodeHorzAlign":
    case "nodeVertAlign":
    case "off":
    case "parTxLTRAlign":
    case "parTxRTLAlign":
    case "pyraAcctBkgdNode":
    case "pyraAcctPos":
    case "pyraAcctTxMar":
    case "pyraAcctTxNode":
    case "pyraLvlNode":
    case "rotPath":
    case "rtShortDist":
    case "secChAlign":
    case "secLinDir":
    case "shpTxLTRAlignCh":
    case "shpTxRTLAlignCh":
    case "spanAng":
    case "srcNode":
    case "stAng":
    case "stBulletLvl":
    case "stElem":
    case "txAnchorHorz":
    case "txAnchorHorzCh":
    case "txAnchorVert":
    case "txAnchorVertCh":
    case "txBlDir":
    case "txDir":
    case "vertAlign":
      return true;
    default:
      return false;
  }
}
function parseParameterValue(type, value) {
  if (!type)
    return value;
  switch (type) {
    case "alignTx":
    case "parTxLTRAlign":
    case "parTxRTLAlign":
    case "shpTxLTRAlignCh":
    case "shpTxRTLAlignCh":
      return parseDiagramTextAlignment2(value);
    case "horzAlign":
      return parseHorizontalAlignment2(value);
    case "nodeHorzAlign":
      return parseNodeHorizontalAlignment2(value);
    case "nodeVertAlign":
      return parseNodeVerticalAlignment2(value);
    case "autoTxRot":
      return parseAutoTextRotation2(value);
    case "begPts":
    case "endPts":
      return parseConnectorPoint2(value);
    case "begSty":
    case "endSty":
      return parseArrowheadStyle2(value);
    case "bendPt":
      return parseBendPoint2(value);
    case "bkpt":
      return parseBreakpoint2(value);
    case "chAlign":
      return parseChildAlignment2(value);
    case "chDir":
      return parseChildDirection2(value);
    case "connRout":
      return parseConnectorRouting2(value);
    case "contDir":
      return parseContinueDirection2(value);
    case "ctrShpMap":
      return parseCenterShapeMapping2(value);
    case "dim":
      return parseConnectorDimension2(value);
    case "fallback":
      return parseFallbackDimension2(value);
    case "flowDir":
      return parseFlowDirection2(value);
    case "grDir":
      return parseGrowDirection2(value);
    case "hierAlign":
      return parseHierarchyAlignment2(value);
    case "linDir":
      return parseLinearDirection2(value);
    case "off":
      return parseOffset2(value);
    case "pyraAcctPos":
      return parsePyramidAccentPosition(value);
    case "pyraAcctTxMar":
      return parsePyramidAccentTextMargin(value);
    case "rotPath":
      return parseRotationPath(value);
    case "ar":
    case "bkPtFixedVal":
    case "lnSpAfChP":
    case "lnSpAfParP":
    case "lnSpCh":
    case "lnSpPar":
    case "spanAng":
    case "stAng":
      return parseFloat64(value);
    case "stBulletLvl":
      return parseInt32(value);
    case "rtShortDist":
      return parseBoolean(value);
    case "secChAlign":
      return parseSecondaryChildAlignment(value);
    case "secLinDir":
      return parseSecondaryLinearDirection(value);
    case "stElem":
      return parseStartingElement(value);
    case "txAnchorHorz":
    case "txAnchorHorzCh":
      return parseTextAnchorHorizontal(value);
    case "txAnchorVert":
    case "txAnchorVertCh":
      return parseTextAnchorVertical(value);
    case "txBlDir":
      return parseTextBlockDirection(value);
    case "txDir":
      return parseTextDirection(value);
    case "vertAlign":
      return parseVerticalAlignment(value);
    default:
      return value;
  }
}
function parsePyramidAccentPosition(value) {
  return isPyramidAccentPosition(value) ? value : undefined;
}
function isPyramidAccentPosition(value) {
  switch (value) {
    case "aft":
    case "bef":
      return true;
    default:
      return false;
  }
}
function parsePyramidAccentTextMargin(value) {
  return isPyramidAccentTextMargin(value) ? value : undefined;
}
function isPyramidAccentTextMargin(value) {
  switch (value) {
    case "stack":
    case "step":
      return true;
    default:
      return false;
  }
}
function parseRotationPath(value) {
  return isRotationPath(value) ? value : undefined;
}
function isRotationPath(value) {
  switch (value) {
    case "alongPath":
    case "none":
      return true;
    default:
      return false;
  }
}
function parseSecondaryChildAlignment(value) {
  return isSecondaryChildAlignment(value) ? value : undefined;
}
function isSecondaryChildAlignment(value) {
  switch (value) {
    case "b":
    case "l":
    case "none":
    case "r":
    case "t":
      return true;
    default:
      return false;
  }
}
function parseSecondaryLinearDirection(value) {
  return isSecondaryLinearDirection(value) ? value : undefined;
}
function isSecondaryLinearDirection(value) {
  switch (value) {
    case "fromB":
    case "fromL":
    case "fromR":
    case "fromT":
    case "none":
      return true;
    default:
      return false;
  }
}
function parseStartingElement(value) {
  return isStartingElement(value) ? value : undefined;
}
function isStartingElement(value) {
  switch (value) {
    case "node":
    case "trans":
      return true;
    default:
      return false;
  }
}
function parseTextAnchorHorizontal(value) {
  return isTextAnchorHorizontal(value) ? value : undefined;
}
function isTextAnchorHorizontal(value) {
  switch (value) {
    case "ctr":
    case "none":
      return true;
    default:
      return false;
  }
}
function parseTextAnchorVertical(value) {
  return isTextAnchorVertical(value) ? value : undefined;
}
function isTextAnchorVertical(value) {
  switch (value) {
    case "b":
    case "mid":
    case "t":
      return true;
    default:
      return false;
  }
}
function parseTextBlockDirection(value) {
  return isTextBlockDirection(value) ? value : undefined;
}
function isTextBlockDirection(value) {
  switch (value) {
    case "horz":
    case "vert":
      return true;
    default:
      return false;
  }
}
function parseTextDirection(value) {
  return isTextDirection(value) ? value : undefined;
}
function isTextDirection(value) {
  switch (value) {
    case "fromB":
    case "fromT":
      return true;
    default:
      return false;
  }
}
function parseVerticalAlignment(value) {
  return isVerticalAlignment(value) ? value : undefined;
}
function isVerticalAlignment(value) {
  switch (value) {
    case "b":
    case "mid":
    case "none":
    case "t":
      return true;
    default:
      return false;
  }
}
function parseUnsignedInts(value) {
  if (!value)
    return;
  const tokens = value.trim().split(/\s+/).filter(Boolean);
  if (tokens.length === 0)
    return;
  const parsed = tokens.map(parseInt32);
  if (parsed.some((token) => token === undefined))
    return;
  if (parsed.some((token) => token < 0))
    return;
  return parsed;
}
function parseLayoutShape(element) {
  if (!element)
    return;
  const adjustments = parseAdjustList(getChild(element, "dgm:adjLst"));
  return {
    type: parseLayoutShapeType(getAttr(element, "type")),
    blipId: getAttr(element, "r:blip"),
    adjustments
  };
}
function parseAdjustList(element) {
  if (!element)
    return;
  const adjustments = getChildren(element, "dgm:adj").map((adj) => ({
    index: parseIndex1(getAttr(adj, "idx")),
    value: getAttr(adj, "val")
  }));
  if (adjustments.length === 0)
    return;
  return adjustments;
}
function parsePresentationOf(element) {
  if (!element)
    return;
  return {
    axis: parseAxisTypes(getAttr(element, "axis")),
    pointType: parseElementTypes(getAttr(element, "ptType")),
    count: parseUnsignedInts(getAttr(element, "cnt")),
    hideLastTransition: parseBooleans(getAttr(element, "hideLastTrans")),
    start: parseInts(getAttr(element, "st")),
    step: parseInts(getAttr(element, "step"))
  };
}
function parseConstraintList(element) {
  if (!element)
    return;
  const constraints = getChildren(element, "dgm:constr").map(parseConstraint);
  if (constraints.length === 0)
    return;
  return constraints;
}
function parseConstraint(element) {
  return {
    type: parseConstraintType(getAttr(element, "type")),
    forRelationship: parseConstraintRelationship(getAttr(element, "for")),
    forName: getAttr(element, "forName"),
    referenceType: parseConstraintType(getAttr(element, "refType")),
    referenceForRelationship: parseConstraintRelationship(getAttr(element, "refFor")),
    referenceForName: getAttr(element, "refForName"),
    operator: parseBoolOperator(getAttr(element, "op")),
    value: getAttr(element, "val"),
    factor: getAttr(element, "fact"),
    max: getAttr(element, "max"),
    min: getAttr(element, "min")
  };
}
function parseRuleList(element) {
  if (!element)
    return;
  const rules = getChildren(element, "dgm:rule").map(parseRule);
  if (rules.length === 0)
    return;
  return rules;
}
function parseRule(element) {
  return {
    type: getAttr(element, "type"),
    value: getAttr(element, "val"),
    factor: getAttr(element, "fact"),
    max: getAttr(element, "max"),
    min: getAttr(element, "min")
  };
}
function parseForEachList(elements) {
  if (elements.length === 0)
    return;
  const forEach = elements.map(parseForEach);
  if (forEach.length === 0)
    return;
  return forEach;
}
function parseForEach(element) {
  return {
    name: getAttr(element, "name"),
    axis: parseAxisTypes(getAttr(element, "axis")),
    pointType: parseElementTypes(getAttr(element, "ptType")),
    count: parseUnsignedInts(getAttr(element, "cnt")),
    hideLastTransition: parseBooleans(getAttr(element, "hideLastTrans")),
    start: parseInts(getAttr(element, "st")),
    step: parseInts(getAttr(element, "step")),
    content: parseLayoutContent(element)
  };
}
function parseChooseList(elements) {
  if (elements.length === 0)
    return;
  const choose = elements.map(parseChoose).filter((value) => value !== undefined);
  if (choose.length === 0)
    return;
  return choose;
}
function parseChoose(element) {
  const ifElement = getChild(element, "dgm:if");
  const elseElement = getChild(element, "dgm:else");
  if (!ifElement && !elseElement)
    return;
  return {
    name: getAttr(element, "name"),
    if: ifElement ? parseIf(ifElement) : undefined,
    else: elseElement ? parseElse(elseElement) : undefined
  };
}
function parseIf(element) {
  return {
    name: getAttr(element, "name"),
    function: parseFunctionType(getAttr(element, "func")),
    argument: parseFunctionArgument(getAttr(element, "arg")),
    operator: parseFunctionOperator(getAttr(element, "op")),
    value: parseFunctionValue(getAttr(element, "val")),
    ...parseLayoutContent(element)
  };
}
function parseElse(element) {
  return {
    name: getAttr(element, "name"),
    ...parseLayoutContent(element)
  };
}
function stripPrefix2(name) {
  const idx = name.indexOf(":");
  return idx === -1 ? name : name.slice(idx + 1);
}
function getAttrFromChild2(parent, childName, attrName) {
  const child = getChild(parent, childName);
  return child ? getAttr(child, attrName) : undefined;
}

// packages/@oxen-office/diagram/src/parser/diagram/style-parser.ts
function parseDiagramStyleDefinition(doc, options) {
  const styleDef = getByPath(doc, ["dgm:styleDef"]);
  if (!styleDef || !isXmlElement(styleDef))
    return;
  const title = getAttrFromChild3(styleDef, "dgm:title", "val");
  const description = getAttrFromChild3(styleDef, "dgm:desc", "val");
  const categories = parseCategoryList3(getChild(styleDef, "dgm:catLst"));
  const scene3d = parseDiagramScene3d(getChild(styleDef, "dgm:scene3d"));
  const styleLabels = parseStyleLabels2(getChildren(styleDef, "dgm:styleLbl"), options);
  return {
    uniqueId: getAttr(styleDef, "uniqueId"),
    title,
    description,
    categories,
    scene3d,
    styleLabels
  };
}
function parseCategoryList3(element) {
  if (!element)
    return;
  const categories = getChildren(element, "dgm:cat").map((cat) => ({
    type: getAttr(cat, "type"),
    priority: getIntAttr(cat, "pri")
  }));
  if (categories.length === 0)
    return;
  return categories;
}
function parseStyleLabels2(elements, options) {
  if (elements.length === 0)
    return;
  const labels = elements.map((el) => parseStyleLabel2(el, options)).filter((label) => label !== undefined);
  if (labels.length === 0)
    return;
  return labels;
}
function parseStyleLabel2(element, options) {
  const name = getAttr(element, "name");
  const scene3d = parseDiagramScene3d(getChild(element, "dgm:scene3d"));
  const shape3d = parseDiagramShape3d(getChild(element, "dgm:sp3d"));
  const textProperties = options.parseTextBody(getChild(element, "dgm:txPr"));
  const style = options.parseShapeStyle(getChild(element, "dgm:style"));
  if (!name && !scene3d && !shape3d && !textProperties && !style)
    return;
  return {
    name,
    scene3d,
    shape3d,
    textProperties,
    style
  };
}
function parseDiagramScene3d(element) {
  if (!element)
    return;
  const cameraEl = getChild(element, "a:camera");
  const lightRigEl = getChild(element, "a:lightRig");
  if (!cameraEl || !lightRigEl)
    return;
  const cameraPreset = parsePresetCameraType2(getAttr(cameraEl, "prst"));
  const lightRig = parseLightRigType2(getAttr(lightRigEl, "rig"));
  const lightDir = parseLightRigDirection2(getAttr(lightRigEl, "dir"));
  if (!cameraPreset || !lightRig || !lightDir)
    return;
  const cameraRotation = parseRotation3(getChild(cameraEl, "a:rot"));
  const lightRotation = parseRotation3(getChild(lightRigEl, "a:rot"));
  const flatTx = getChild(element, "a:flatTx");
  const flatTextZ = flatTx ? getEmuAttr(flatTx, "z") : undefined;
  return {
    camera: {
      preset: cameraPreset,
      fov: getAngleAttr(cameraEl, "fov"),
      zoom: getPercent100kAttr(cameraEl, "zoom"),
      rotation: cameraRotation
    },
    lightRig: {
      rig: lightRig,
      direction: lightDir,
      rotation: lightRotation
    },
    flatTextZ
  };
}
function parseRotation3(element) {
  if (!element)
    return;
  const latitude = getAngleAttr(element, "lat");
  const longitude = getAngleAttr(element, "lon");
  const revolution = getAngleAttr(element, "rev");
  if (latitude === undefined || longitude === undefined || revolution === undefined) {
    return;
  }
  return { latitude, longitude, revolution };
}
function parseDiagramShape3d(element) {
  if (!element)
    return;
  const extrusionColor = toSolidFill2(parseColorFromParent(getChild(element, "a:extrusionClr")));
  const contourColor = toSolidFill2(parseColorFromParent(getChild(element, "a:contourClr")));
  const bevelTop = parseBevel3(getChild(element, "a:bevelT"));
  const bevelBottom = parseBevel3(getChild(element, "a:bevelB"));
  return {
    z: getEmuAttr(element, "z"),
    extrusionHeight: getEmuAttr(element, "extrusionH"),
    contourWidth: getEmuAttr(element, "contourW"),
    preset: parsePresetMaterialType2(getAttr(element, "prstMaterial")),
    extrusionColor,
    contourColor,
    bevelTop,
    bevelBottom
  };
}
function parseBevel3(element) {
  if (!element)
    return;
  const width = getEmuAttr(element, "w");
  const height = getEmuAttr(element, "h");
  const preset = getAttr(element, "prst");
  if (!width || !height || !isBevelPresetType3(preset))
    return;
  return {
    width,
    height,
    preset
  };
}
function toSolidFill2(color) {
  if (!color)
    return;
  return { type: "solidFill", color };
}
function isBevelPresetType3(value) {
  switch (value) {
    case "angle":
    case "artDeco":
    case "circle":
    case "convex":
    case "coolSlant":
    case "cross":
    case "divot":
    case "hardEdge":
    case "relaxedInset":
    case "riblet":
    case "slope":
    case "softRound":
      return true;
    default:
      return false;
  }
}
function isPresetMaterialType3(value) {
  switch (value) {
    case "clear":
    case "dkEdge":
    case "flat":
    case "legacyMatte":
    case "legacyMetal":
    case "legacyPlastic":
    case "legacyWireframe":
    case "matte":
    case "metal":
    case "plastic":
    case "powder":
    case "softEdge":
    case "softmetal":
    case "translucentPowder":
    case "warmMatte":
      return true;
    default:
      return false;
  }
}
function parsePresetMaterialType2(value) {
  return isPresetMaterialType3(value) ? value : undefined;
}
function getAttrFromChild3(parent, childName, attrName) {
  const child = getChild(parent, childName);
  return child ? getAttr(child, attrName) : undefined;
}
function parsePresetCameraType2(value) {
  return isPresetCameraType2(value) ? value : undefined;
}
function parseLightRigType2(value) {
  return isLightRigType3(value) ? value : undefined;
}
function parseLightRigDirection2(value) {
  return isLightRigDirection3(value) ? value : undefined;
}
function isPresetCameraType2(value) {
  switch (value) {
    case "isometricBottomDown":
    case "isometricBottomUp":
    case "isometricLeftDown":
    case "isometricLeftUp":
    case "isometricOffAxis1Left":
    case "isometricOffAxis1Right":
    case "isometricOffAxis1Top":
    case "isometricOffAxis2Left":
    case "isometricOffAxis2Right":
    case "isometricOffAxis2Top":
    case "isometricOffAxis3Bottom":
    case "isometricOffAxis3Left":
    case "isometricOffAxis3Right":
    case "isometricOffAxis4Bottom":
    case "isometricOffAxis4Left":
    case "isometricOffAxis4Right":
    case "isometricRightDown":
    case "isometricRightUp":
    case "isometricTopDown":
    case "isometricTopUp":
    case "legacyObliqueBottom":
    case "legacyObliqueBottomLeft":
    case "legacyObliqueBottomRight":
    case "legacyObliqueFront":
    case "legacyObliqueLeft":
    case "legacyObliqueRight":
    case "legacyObliqueTop":
    case "legacyObliqueTopLeft":
    case "legacyObliqueTopRight":
    case "legacyPerspectiveBottom":
    case "legacyPerspectiveBottomLeft":
    case "legacyPerspectiveBottomRight":
    case "legacyPerspectiveFront":
    case "legacyPerspectiveLeft":
    case "legacyPerspectiveRight":
    case "legacyPerspectiveTop":
    case "legacyPerspectiveTopLeft":
    case "legacyPerspectiveTopRight":
    case "obliqueBottom":
    case "obliqueBottomLeft":
    case "obliqueBottomRight":
    case "obliqueLeft":
    case "obliqueRight":
    case "obliqueTop":
    case "obliqueTopLeft":
    case "obliqueTopRight":
    case "orthographicFront":
    case "perspectiveAbove":
    case "perspectiveAboveLeftFacing":
    case "perspectiveAboveRightFacing":
    case "perspectiveBelow":
    case "perspectiveContrastingLeftFacing":
    case "perspectiveContrastingRightFacing":
    case "perspectiveFront":
    case "perspectiveHeroicExtremeLeftFacing":
    case "perspectiveHeroicExtremeRightFacing":
    case "perspectiveHeroicLeftFacing":
    case "perspectiveHeroicRightFacing":
    case "perspectiveLeft":
    case "perspectiveRelaxed":
    case "perspectiveRelaxedModerately":
    case "perspectiveRight":
      return true;
    default:
      return false;
  }
}
function isLightRigType3(value) {
  switch (value) {
    case "balanced":
    case "brightRoom":
    case "chilly":
    case "contrasting":
    case "flat":
    case "flood":
    case "freezing":
    case "glow":
    case "harsh":
    case "legacyFlat1":
    case "legacyFlat2":
    case "legacyFlat3":
    case "legacyFlat4":
    case "legacyHarsh1":
    case "legacyHarsh2":
    case "legacyHarsh3":
    case "legacyHarsh4":
    case "legacyNormal1":
    case "legacyNormal2":
    case "legacyNormal3":
    case "legacyNormal4":
    case "morning":
    case "soft":
    case "sunrise":
    case "sunset":
    case "threePt":
    case "twoPt":
      return true;
    default:
      return false;
  }
}
function isLightRigDirection3(value) {
  switch (value) {
    case "b":
    case "bl":
    case "br":
    case "l":
    case "r":
    case "t":
    case "tl":
    case "tr":
      return true;
    default:
      return false;
  }
}

// packages/@oxen-office/pptx/src/parser/external/vml-parser.ts
function findVmlShapeImage(vmlXml, vmlRelsXml, spid) {
  const xmlRoot = getByPath(vmlXml, ["xml"]);
  if (!xmlRoot) {
    return;
  }
  const shape = findShapeById(xmlRoot, spid);
  if (!shape) {
    return;
  }
  const imagedata = getChild(shape, "v:imagedata");
  if (!imagedata) {
    return;
  }
  const relId = getAttr(imagedata, "o:relid");
  if (!relId) {
    return;
  }
  if (!vmlRelsXml) {
    return;
  }
  const imagePath = resolveVmlRelationship(vmlRelsXml, relId);
  if (!imagePath) {
    return;
  }
  return { imagePath, relId };
}
function findShapeById(root, spid) {
  for (const child of root.children) {
    if (typeof child !== "object" || child === null) {
      continue;
    }
    if (!("type" in child)) {
      continue;
    }
    if (child.type !== "element") {
      continue;
    }
    const el = child;
    if (el.name === "v:shape") {
      const oSpid = getAttr(el, "o:spid");
      if (oSpid === spid) {
        return el;
      }
      const id = getAttr(el, "id");
      if (id === spid) {
        return el;
      }
    }
  }
  return;
}
function resolveVmlRelationship(relsXml, relId) {
  const relationships = getByPath(relsXml, ["Relationships"]);
  if (!relationships) {
    return;
  }
  const rels = getChildren(relationships, "Relationship");
  for (const rel of rels) {
    const id = getAttr(rel, "Id");
    if (id === relId) {
      return getAttr(rel, "Target");
    }
  }
  return;
}
function getVmlRelsPath(vmlPath) {
  const parts = vmlPath.split("/");
  const filename = parts.pop() ?? "";
  return [...parts, "_rels", `${filename}.rels`].join("/");
}
function normalizeVmlImagePath(vmlPath, imagePath) {
  if (!imagePath.startsWith("..")) {
    return imagePath;
  }
  const parts = vmlPath.split("/");
  parts.pop();
  const imageParts = imagePath.split("/");
  for (const part of imageParts) {
    if (part === "..") {
      parts.pop();
    } else if (part !== ".") {
      parts.push(part);
    }
  }
  return parts.join("/");
}

// packages/@oxen-office/pptx/src/parser/external/emf-parser.ts
var EMR_HEADER = 1;
var EMR_POLYGON = 3;
var EMR_POLYLINE = 4;
var EMR_POLYPOLYGON = 8;
var EMR_SETWINDOWEXTEX = 9;
var EMR_SETWINDOWORGEX = 10;
var EMR_SETVIEWPORTEXTEX = 11;
var EMR_SETVIEWPORTORGEX = 12;
var EMR_EOF = 14;
var EMR_SETBKMODE = 18;
var EMR_SETPOLYFILLMODE = 19;
var EMR_SETTEXTALIGN = 22;
var EMR_SETTEXTCOLOR = 24;
var EMR_SETBKCOLOR = 25;
var EMR_MOVETOEX = 27;
var EMR_SELECTOBJECT = 37;
var EMR_CREATEPEN = 38;
var EMR_CREATEBRUSHINDIRECT = 39;
var EMR_DELETEOBJECT = 40;
var EMR_ELLIPSE = 42;
var EMR_RECTANGLE = 43;
var EMR_LINETO = 54;
var EMR_BEGINPATH = 59;
var EMR_ENDPATH = 60;
var EMR_CLOSEFIGURE = 61;
var EMR_FILLPATH = 62;
var EMR_STROKEANDFILLPATH = 63;
var EMR_STROKEPATH = 64;
var EMR_COMMENT = 70;
var EMR_BITBLT = 76;
var EMR_STRETCHDIBITS = 81;
var EMR_EXTCREATEFONTINDIRECTW = 82;
var EMR_EXTTEXTOUTW = 84;
var EMR_POLYGON16 = 86;
var EMR_POLYLINE16 = 87;
var EMR_POLYPOLYGON16 = 91;
function emfToSvg(data) {
  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  const offsetState = { value: 0 };
  const header = parseHeader(view, offsetState.value);
  if (header === null) {
    return null;
  }
  const boundsWidth = header.bounds.right - header.bounds.left;
  const boundsHeight = header.bounds.bottom - header.bounds.top;
  const frameWidth = header.frame.right - header.frame.left;
  const frameHeight = header.frame.bottom - header.frame.top;
  if (boundsWidth <= 0 || boundsHeight <= 0) {
    return null;
  }
  const viewBoxWidth = frameWidth > 0 ? frameWidth : boundsWidth;
  const viewBoxHeight = frameHeight > 0 ? frameHeight : boundsHeight;
  const state = {
    currentPos: { x: 0, y: 0 },
    windowOrg: { x: header.frame.left, y: header.frame.top },
    windowExt: { x: viewBoxWidth, y: viewBoxHeight },
    viewportOrg: { x: 0, y: 0 },
    viewportExt: { x: boundsWidth, y: boundsHeight },
    textColor: "#000000",
    bkColor: "#ffffff",
    bkMode: 1,
    textAlign: 0,
    polyFillMode: 1,
    currentPen: { style: 0, width: 1, color: "#000000" },
    currentBrush: { style: 0, color: "#ffffff", hatch: 0 },
    currentFont: null,
    objects: new Map,
    pathData: "",
    inPath: false,
    transform: { m11: 1, m12: 0, m21: 0, m22: 1, dx: 0, dy: 0 }
  };
  const elements = [];
  offsetState.value = 0;
  while (offsetState.value < data.length) {
    const offset = offsetState.value;
    const recordType = view.getUint32(offset, true);
    const recordSize = view.getUint32(offset + 4, true);
    if (recordSize < 8 || offset + recordSize > data.length) {
      break;
    }
    const element = processRecord({ view, offset, recordType, recordSize, state });
    if (element !== null) {
      elements.push(element);
    }
    if (recordType === EMR_EOF) {
      break;
    }
    offsetState.value += recordSize;
  }
  const viewBox = `${header.frame.left} ${header.frame.top} ${viewBoxWidth} ${viewBoxHeight}`;
  return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}" width="${boundsWidth}" height="${boundsHeight}" preserveAspectRatio="xMidYMid meet">${elements.join("")}</svg>`;
}
function parseHeader(view, offset) {
  const recordType = view.getUint32(offset, true);
  if (recordType !== EMR_HEADER) {
    return null;
  }
  const bounds = {
    left: view.getInt32(offset + 8, true),
    top: view.getInt32(offset + 12, true),
    right: view.getInt32(offset + 16, true),
    bottom: view.getInt32(offset + 20, true)
  };
  const frame = {
    left: view.getInt32(offset + 24, true),
    top: view.getInt32(offset + 28, true),
    right: view.getInt32(offset + 32, true),
    bottom: view.getInt32(offset + 36, true)
  };
  const signature = view.getUint32(offset + 40, true);
  if (signature !== 1179469088) {
    return null;
  }
  return {
    bounds,
    frame,
    version: view.getUint32(offset + 44, true),
    size: view.getUint32(offset + 48, true),
    records: view.getUint32(offset + 52, true),
    handles: view.getUint16(offset + 56, true),
    description: "",
    deviceWidth: view.getUint32(offset + 64, true),
    deviceHeight: view.getUint32(offset + 68, true),
    millimetersWidth: view.getUint32(offset + 72, true),
    millimetersHeight: view.getUint32(offset + 76, true)
  };
}
function processRecord({ view, offset, recordType, recordSize, state }) {
  switch (recordType) {
    case EMR_HEADER:
      return null;
    case EMR_EOF:
      return null;
    case EMR_SETWINDOWEXTEX:
      state.windowExt.x = view.getInt32(offset + 8, true);
      state.windowExt.y = view.getInt32(offset + 12, true);
      return null;
    case EMR_SETWINDOWORGEX:
      state.windowOrg.x = view.getInt32(offset + 8, true);
      state.windowOrg.y = view.getInt32(offset + 12, true);
      return null;
    case EMR_SETVIEWPORTEXTEX:
      state.viewportExt.x = view.getInt32(offset + 8, true);
      state.viewportExt.y = view.getInt32(offset + 12, true);
      return null;
    case EMR_SETVIEWPORTORGEX:
      state.viewportOrg.x = view.getInt32(offset + 8, true);
      state.viewportOrg.y = view.getInt32(offset + 12, true);
      return null;
    case EMR_SETTEXTCOLOR:
      state.textColor = parseColorRef(view, offset + 8);
      return null;
    case EMR_SETBKCOLOR:
      state.bkColor = parseColorRef(view, offset + 8);
      return null;
    case EMR_SETBKMODE:
      state.bkMode = view.getUint32(offset + 8, true);
      return null;
    case EMR_SETTEXTALIGN:
      state.textAlign = view.getUint32(offset + 8, true);
      return null;
    case EMR_SETPOLYFILLMODE:
      state.polyFillMode = view.getUint32(offset + 8, true);
      return null;
    case EMR_MOVETOEX:
      state.currentPos.x = view.getInt32(offset + 8, true);
      state.currentPos.y = view.getInt32(offset + 12, true);
      if (state.inPath) {
        state.pathData += `M${state.currentPos.x},${state.currentPos.y}`;
      }
      return null;
    case EMR_LINETO:
      return processLineTo(view, offset, state);
    case EMR_RECTANGLE:
      return processRectangle(view, offset, state);
    case EMR_ELLIPSE:
      return processEllipse(view, offset, state);
    case EMR_POLYGON:
      return processPolygon({ view, offset, recordSize, state, isPolyline: false });
    case EMR_POLYGON16:
      return processPolygon16({ view, offset, recordSize, state, isPolyline: false });
    case EMR_POLYLINE:
      return processPolygon({ view, offset, recordSize, state, isPolyline: true });
    case EMR_POLYLINE16:
      return processPolygon16({ view, offset, recordSize, state, isPolyline: true });
    case EMR_POLYPOLYGON:
      return processPolyPolygon({ view, offset, recordSize, state });
    case EMR_POLYPOLYGON16:
      return processPolyPolygon16({ view, offset, recordSize, state });
    case EMR_CREATEPEN:
      return processCreatePen(view, offset, state);
    case EMR_CREATEBRUSHINDIRECT:
      return processCreateBrush(view, offset, state);
    case EMR_EXTCREATEFONTINDIRECTW:
      return processCreateFont({ view, offset, recordSize, state });
    case EMR_SELECTOBJECT:
      return processSelectObject(view, offset, state);
    case EMR_DELETEOBJECT:
      return processDeleteObject(view, offset, state);
    case EMR_BEGINPATH:
      state.inPath = true;
      state.pathData = "";
      return null;
    case EMR_ENDPATH:
      state.inPath = false;
      return null;
    case EMR_CLOSEFIGURE:
      state.pathData += "Z";
      return null;
    case EMR_FILLPATH:
      return processFillPath(state);
    case EMR_STROKEPATH:
      return processStrokePath(state);
    case EMR_STROKEANDFILLPATH:
      return processStrokeAndFillPath(state);
    case EMR_STRETCHDIBITS:
      return processStretchDIBits(view, offset);
    case EMR_BITBLT:
      return processBitBlt(view, offset);
    case EMR_EXTTEXTOUTW:
      return processExtTextOutW({ view, offset, recordSize, state });
    case EMR_COMMENT:
      return processComment(view, offset);
    default:
      return null;
  }
}
function parseColorRef(view, offset) {
  const r = view.getUint8(offset);
  const g = view.getUint8(offset + 1);
  const b = view.getUint8(offset + 2);
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
}
function processLineTo(view, offset, state) {
  const x2 = view.getInt32(offset + 8, true);
  const y = view.getInt32(offset + 12, true);
  if (state.inPath) {
    state.pathData += `L${x2},${y}`;
    state.currentPos.x = x2;
    state.currentPos.y = y;
    return null;
  }
  const result = `<line x1="${state.currentPos.x}" y1="${state.currentPos.y}" x2="${x2}" y2="${y}" stroke="${state.currentPen.color}" stroke-width="${state.currentPen.width}"/>`;
  state.currentPos.x = x2;
  state.currentPos.y = y;
  return result;
}
function processRectangle(view, offset, state) {
  const left = view.getInt32(offset + 8, true);
  const top = view.getInt32(offset + 12, true);
  const right = view.getInt32(offset + 16, true);
  const bottom = view.getInt32(offset + 20, true);
  const fill = state.currentBrush.style === 1 ? "none" : state.currentBrush.color;
  return `<rect x="${left}" y="${top}" width="${right - left}" height="${bottom - top}" fill="${fill}" stroke="${state.currentPen.color}" stroke-width="${state.currentPen.width}"/>`;
}
function processEllipse(view, offset, state) {
  const left = view.getInt32(offset + 8, true);
  const top = view.getInt32(offset + 12, true);
  const right = view.getInt32(offset + 16, true);
  const bottom = view.getInt32(offset + 20, true);
  const cx = (left + right) / 2;
  const cy = (top + bottom) / 2;
  const rx = (right - left) / 2;
  const ry = (bottom - top) / 2;
  const fill = state.currentBrush.style === 1 ? "none" : state.currentBrush.color;
  return `<ellipse cx="${cx}" cy="${cy}" rx="${rx}" ry="${ry}" fill="${fill}" stroke="${state.currentPen.color}" stroke-width="${state.currentPen.width}"/>`;
}
function processPolygon({ view, offset, recordSize, state, isPolyline }) {
  const count = view.getUint32(offset + 24, true);
  if (count < 2) {
    return null;
  }
  const points = readPointList({
    startOffset: offset + 28,
    endOffset: offset + recordSize,
    count,
    stride: 8,
    readPoint: (pointOffset) => ({
      x: view.getInt32(pointOffset, true),
      y: view.getInt32(pointOffset + 4, true)
    })
  });
  return renderPolygon(points, state, isPolyline);
}
function processPolygon16({ view, offset, recordSize, state, isPolyline }) {
  const count = view.getUint32(offset + 24, true);
  if (count < 2) {
    return null;
  }
  const points = readPointList({
    startOffset: offset + 28,
    endOffset: offset + recordSize,
    count,
    stride: 4,
    readPoint: (pointOffset) => ({
      x: view.getInt16(pointOffset, true),
      y: view.getInt16(pointOffset + 2, true)
    })
  });
  return renderPolygon(points, state, isPolyline);
}
function readPointList({ startOffset, endOffset, count, stride, readPoint }) {
  const points = [];
  const offsetState = { value: startOffset };
  range(count).some(() => {
    if (offsetState.value + stride > endOffset) {
      return true;
    }
    points.push(readPoint(offsetState.value));
    offsetState.value += stride;
    return false;
  });
  return points;
}
function renderPolygon(points, state, isPolyline) {
  const d = points.map((p, i2) => i2 === 0 ? `M${p.x},${p.y}` : `L${p.x},${p.y}`).join("");
  const closePath = isPolyline ? "" : "Z";
  const fill = isPolyline ? "none" : state.currentBrush.style === 1 ? "none" : state.currentBrush.color;
  const fillRule = state.polyFillMode === 1 ? "evenodd" : "nonzero";
  return `<path d="${d}${closePath}" fill="${fill}" fill-rule="${fillRule}" stroke="${state.currentPen.color}" stroke-width="${state.currentPen.width}"/>`;
}
function processPolyPolygon({ view, offset, recordSize, state }) {
  const numPolygons = view.getUint32(offset + 24, true);
  const totalPoints = view.getUint32(offset + 28, true);
  if (numPolygons === 0 || totalPoints === 0) {
    return null;
  }
  const { counts: polygonCounts, nextOffset } = readPolygonCounts({
    view,
    startOffset: offset + 32,
    endOffset: offset + recordSize,
    count: numPolygons
  });
  const d = buildPolyPolygonPath({
    startOffset: nextOffset,
    endOffset: offset + recordSize,
    polygonCounts,
    stride: 8,
    readPoint: (pointOffset) => ({
      x: view.getInt32(pointOffset, true),
      y: view.getInt32(pointOffset + 4, true)
    })
  });
  const fill = state.currentBrush.style === 1 ? "none" : state.currentBrush.color;
  const fillRule = state.polyFillMode === 1 ? "evenodd" : "nonzero";
  return `<path d="${d}" fill="${fill}" fill-rule="${fillRule}" stroke="${state.currentPen.color}" stroke-width="${state.currentPen.width}"/>`;
}
function processPolyPolygon16({ view, offset, recordSize, state }) {
  const numPolygons = view.getUint32(offset + 24, true);
  const totalPoints = view.getUint32(offset + 28, true);
  if (numPolygons === 0 || totalPoints === 0) {
    return null;
  }
  const { counts: polygonCounts, nextOffset } = readPolygonCounts({
    view,
    startOffset: offset + 32,
    endOffset: offset + recordSize,
    count: numPolygons
  });
  const d = buildPolyPolygonPath({
    startOffset: nextOffset,
    endOffset: offset + recordSize,
    polygonCounts,
    stride: 4,
    readPoint: (pointOffset) => ({
      x: view.getInt16(pointOffset, true),
      y: view.getInt16(pointOffset + 2, true)
    })
  });
  const fill = state.currentBrush.style === 1 ? "none" : state.currentBrush.color;
  const fillRule = state.polyFillMode === 1 ? "evenodd" : "nonzero";
  return `<path d="${d}" fill="${fill}" fill-rule="${fillRule}" stroke="${state.currentPen.color}" stroke-width="${state.currentPen.width}"/>`;
}
function readPolygonCounts({ view, startOffset, endOffset, count }) {
  const counts = [];
  const offsetState = { value: startOffset };
  range(count).some(() => {
    if (offsetState.value + 4 > endOffset) {
      return true;
    }
    counts.push(view.getUint32(offsetState.value, true));
    offsetState.value += 4;
    return false;
  });
  return { counts, nextOffset: offsetState.value };
}
function buildPolyPolygonPath({ startOffset, endOffset, polygonCounts, stride, readPoint }) {
  const offsetState = { value: startOffset };
  const segments = [];
  polygonCounts.forEach((count) => {
    const pointIndexState = { value: 0 };
    range(count).some(() => {
      if (offsetState.value + stride > endOffset) {
        return true;
      }
      const point = readPoint(offsetState.value);
      segments.push(pointIndexState.value === 0 ? `M${point.x},${point.y}` : `L${point.x},${point.y}`);
      pointIndexState.value += 1;
      offsetState.value += stride;
      return false;
    });
    segments.push("Z");
  });
  return segments.join("");
}
function processCreatePen(view, offset, state) {
  const index = view.getUint32(offset + 8, true);
  const style = view.getUint32(offset + 12, true);
  const width = view.getUint32(offset + 16, true);
  const color = parseColorRef(view, offset + 24);
  const normalizedWidth = width === 0 ? 1 : width;
  state.objects.set(index, { style, width: normalizedWidth, color });
  return null;
}
function processCreateBrush(view, offset, state) {
  const index = view.getUint32(offset + 8, true);
  const style = view.getUint32(offset + 12, true);
  const color = parseColorRef(view, offset + 16);
  const hatch = view.getUint32(offset + 20, true);
  state.objects.set(index, { style, color, hatch });
  return null;
}
function processCreateFont({ view, offset, recordSize, state }) {
  const index = view.getUint32(offset + 8, true);
  const height = view.getInt32(offset + 12, true);
  const width = view.getInt32(offset + 16, true);
  const weight = view.getUint32(offset + 28, true);
  const italic = view.getUint8(offset + 32) !== 0;
  const underline = view.getUint8(offset + 33) !== 0;
  const strikeOut = view.getUint8(offset + 34) !== 0;
  const faceNameOffset = offset + 48;
  const faceChars = [];
  range(32).some((i2) => {
    const charOffset = faceNameOffset + i2 * 2;
    if (charOffset + 2 > offset + recordSize) {
      return true;
    }
    const charCode = view.getUint16(charOffset, true);
    if (charCode === 0) {
      return true;
    }
    faceChars.push(String.fromCharCode(charCode));
    return false;
  });
  const faceName = faceChars.join("");
  state.objects.set(index, { height: Math.abs(height), width, weight, italic, underline, strikeOut, faceName });
  return null;
}
function processSelectObject(view, offset, state) {
  const index = view.getUint32(offset + 8, true);
  if (index & 2147483648) {
    const stockId = index & 2147483647;
    switch (stockId) {
      case 0:
        state.currentBrush = { style: 0, color: "#ffffff", hatch: 0 };
        break;
      case 1:
        state.currentBrush = { style: 0, color: "#c0c0c0", hatch: 0 };
        break;
      case 2:
        state.currentBrush = { style: 0, color: "#808080", hatch: 0 };
        break;
      case 3:
        state.currentBrush = { style: 0, color: "#404040", hatch: 0 };
        break;
      case 4:
        state.currentBrush = { style: 0, color: "#000000", hatch: 0 };
        break;
      case 5:
        state.currentBrush = { style: 1, color: "none", hatch: 0 };
        break;
      case 6:
        state.currentPen = { style: 0, width: 1, color: "#ffffff" };
        break;
      case 7:
        state.currentPen = { style: 0, width: 1, color: "#000000" };
        break;
      case 8:
        state.currentPen = { style: 5, width: 0, color: "none" };
        break;
    }
    return null;
  }
  const obj = state.objects.get(index);
  if (isEmfPen(obj)) {
    state.currentPen = obj;
  } else if (isEmfBrush(obj)) {
    state.currentBrush = obj;
  } else if (isEmfFont(obj)) {
    state.currentFont = obj;
  }
  return null;
}
function processDeleteObject(view, offset, state) {
  const index = view.getUint32(offset + 8, true);
  state.objects.delete(index);
  return null;
}
function processFillPath(state) {
  if (state.pathData === "") {
    return null;
  }
  const fill = state.currentBrush.style === 1 ? "none" : state.currentBrush.color;
  const fillRule = state.polyFillMode === 1 ? "evenodd" : "nonzero";
  const result = `<path d="${state.pathData}" fill="${fill}" fill-rule="${fillRule}" stroke="none"/>`;
  state.pathData = "";
  return result;
}
function processStrokePath(state) {
  if (state.pathData === "") {
    return null;
  }
  const result = `<path d="${state.pathData}" fill="none" stroke="${state.currentPen.color}" stroke-width="${state.currentPen.width}"/>`;
  state.pathData = "";
  return result;
}
function processStrokeAndFillPath(state) {
  if (state.pathData === "") {
    return null;
  }
  const fill = state.currentBrush.style === 1 ? "none" : state.currentBrush.color;
  const fillRule = state.polyFillMode === 1 ? "evenodd" : "nonzero";
  const result = `<path d="${state.pathData}" fill="${fill}" fill-rule="${fillRule}" stroke="${state.currentPen.color}" stroke-width="${state.currentPen.width}"/>`;
  state.pathData = "";
  return result;
}
function processStretchDIBits(view, offset) {
  const bmiOffset = view.getUint32(offset + 48, true);
  const bmiSize = view.getUint32(offset + 52, true);
  const bitsOffset = view.getUint32(offset + 56, true);
  const bitsSize = view.getUint32(offset + 60, true);
  if (bmiOffset === 0 || bitsOffset === 0 || bitsSize === 0) {
    return null;
  }
  const destX = view.getInt32(offset + 8, true);
  const destY = view.getInt32(offset + 12, true);
  const destW = view.getInt32(offset + 32, true);
  const destH = view.getInt32(offset + 36, true);
  const bmiStart = offset + bmiOffset;
  const biCompression = view.getUint32(bmiStart + 16, true);
  if (biCompression !== 0 && biCompression !== 3) {
    return null;
  }
  const dibData = extractDIBToPng({
    view,
    bmiOffset: offset + bmiOffset,
    bmiSize,
    bitsOffset: offset + bitsOffset,
    bitsSize
  });
  if (dibData === null) {
    return null;
  }
  return `<image href="${dibData}" x="${destX}" y="${destY}" width="${destW}" height="${Math.abs(destH)}" preserveAspectRatio="none"/>`;
}
function processBitBlt(view, offset) {
  const bmiOffset = view.getUint32(offset + 84, true);
  const bmiSize = view.getUint32(offset + 88, true);
  const bitsOffset = view.getUint32(offset + 92, true);
  const bitsSize = view.getUint32(offset + 96, true);
  if (bmiOffset === 0 || bitsOffset === 0 || bitsSize === 0) {
    return null;
  }
  const destX = view.getInt32(offset + 8, true);
  const destY = view.getInt32(offset + 12, true);
  const destW = view.getInt32(offset + 16, true);
  const destH = view.getInt32(offset + 20, true);
  const dibData = extractDIBToPng({
    view,
    bmiOffset: offset + bmiOffset,
    bmiSize,
    bitsOffset: offset + bitsOffset,
    bitsSize
  });
  if (dibData === null) {
    return null;
  }
  return `<image href="${dibData}" x="${destX}" y="${destY}" width="${destW}" height="${destH}" preserveAspectRatio="none"/>`;
}
function extractDIBToPng({ view, bmiOffset, bmiSize, bitsOffset, bitsSize }) {
  const biCompression = view.getUint32(bmiOffset + 16, true);
  if (biCompression !== 0 && biCompression !== 3) {
    return null;
  }
  const bmpHeader = new Uint8Array(14);
  const bmpView = new DataView(bmpHeader.buffer);
  bmpView.setUint16(0, 19778, true);
  bmpView.setUint32(2, 14 + bmiSize + bitsSize, true);
  bmpView.setUint32(10, 14 + bmiSize, true);
  const bmpData = new Uint8Array(14 + bmiSize + bitsSize);
  bmpData.set(bmpHeader);
  bmpData.set(new Uint8Array(view.buffer, view.byteOffset + bmiOffset, bmiSize), 14);
  bmpData.set(new Uint8Array(view.buffer, view.byteOffset + bitsOffset, bitsSize), 14 + bmiSize);
  const base64 = base64ArrayBuffer(bmpData.buffer);
  return `data:image/bmp;base64,${base64}`;
}
function processExtTextOutW({ view, offset, recordSize, state }) {
  const x2 = view.getInt32(offset + 24, true);
  const y = view.getInt32(offset + 28, true);
  const stringLen = view.getUint32(offset + 32, true);
  const stringOffset = view.getUint32(offset + 36, true);
  if (stringLen === 0 || stringOffset === 0) {
    return null;
  }
  const textStart = offset + stringOffset;
  const textChars = [];
  range(stringLen).some((i2) => {
    const charOffset = textStart + i2 * 2;
    if (charOffset + 2 > offset + recordSize) {
      return true;
    }
    const charCode = view.getUint16(charOffset, true);
    textChars.push(String.fromCharCode(charCode));
    return false;
  });
  const text = textChars.join("");
  const fontSize = state.currentFont?.height ?? 12;
  const fontFamily = state.currentFont?.faceName ?? "sans-serif";
  const fontWeight = (state.currentFont?.weight ?? 400) >= 700 ? "bold" : "normal";
  const fontStyle = state.currentFont?.italic ? "italic" : "normal";
  const textAnchor = resolveTextAnchor(state.textAlign);
  const escapedText = escapeXml2(text);
  return `<text x="${x2}" y="${y}" fill="${state.textColor}" font-family="${fontFamily}" font-size="${fontSize}" font-weight="${fontWeight}" font-style="${fontStyle}" text-anchor="${textAnchor}">${escapedText}</text>`;
}
function processComment(view, offset) {
  const dataSize = view.getUint32(offset + 8, true);
  if (dataSize < 4) {
    return null;
  }
  const signature = view.getUint32(offset + 12, true);
  if (signature === 726027589) {
    return null;
  }
  return null;
}
function escapeXml2(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
function resolveTextAnchor(textAlign) {
  const hAlign = textAlign & 6;
  if (hAlign === 2) {
    return "end";
  }
  if (hAlign === 6) {
    return "middle";
  }
  return "start";
}
function isEmfPen(obj) {
  if (!obj) {
    return false;
  }
  return "width" in obj && "style" in obj && !("hatch" in obj);
}
function isEmfBrush(obj) {
  if (!obj) {
    return false;
  }
  return "hatch" in obj;
}
function isEmfFont(obj) {
  if (!obj) {
    return false;
  }
  return "faceName" in obj;
}
function range(count) {
  return Array.from({ length: count }, (_, index) => index);
}

// packages/@oxen-office/pptx/src/parser/slide/external-content-loader.ts
function enrichSlideContent(slide, fileReader, resourceStore) {
  const ctx = { fileReader, resourceStore };
  const enrichedShapes = slide.shapes.map((shape) => enrichShape(shape, ctx));
  if (enrichedShapes.every((s, i2) => s === slide.shapes[i2])) {
    return slide;
  }
  return {
    ...slide,
    shapes: enrichedShapes
  };
}
function enrichShape(shape, ctx) {
  if (shape.type !== "graphicFrame") {
    return shape;
  }
  const frame = shape;
  if (frame.content.type === "chart") {
    return enrichChartFrame(frame, ctx);
  }
  if (frame.content.type === "diagram") {
    return enrichDiagramFrame(frame, ctx);
  }
  if (frame.content.type === "oleObject") {
    return enrichOleFrame(frame, ctx);
  }
  return shape;
}
function enrichChartFrame(frame, ctx) {
  if (frame.content.type !== "chart") {
    return frame;
  }
  const { fileReader, resourceStore } = ctx;
  const chartRef = frame.content.data;
  if (resourceStore?.has(chartRef.resourceId)) {
    return frame;
  }
  const chartPath = fileReader.resolveResource(chartRef.resourceId);
  if (chartPath === undefined) {
    return frame;
  }
  const chartData = fileReader.readFile(chartPath);
  if (chartData === null) {
    return frame;
  }
  const decoder = new TextDecoder;
  const chartXmlText = decoder.decode(chartData);
  const chartDoc = parseXml(chartXmlText);
  if (chartDoc === undefined) {
    return frame;
  }
  const parsedChart = parseChart(chartDoc);
  if (parsedChart === undefined) {
    return frame;
  }
  if (resourceStore !== undefined) {
    resourceStore.set(chartRef.resourceId, {
      kind: "chart",
      source: "parsed",
      data: chartData,
      path: chartPath,
      parsed: parsedChart
    });
  }
  return frame;
}
function enrichDiagramFrame(frame, ctx) {
  if (frame.content.type !== "diagram") {
    return frame;
  }
  const { fileReader, resourceStore } = ctx;
  const diagramRef = frame.content.data;
  if (resourceStore?.has(diagramRef.dataResourceId ?? "")) {
    return frame;
  }
  const dataModel = loadDiagramDataModel(diagramRef.dataResourceId, fileReader);
  const layoutDefinition = loadDiagramLayoutDefinition(diagramRef.layoutResourceId, fileReader);
  const styleDefinition = loadDiagramStyleDefinition(diagramRef.styleResourceId, fileReader);
  const colorsDefinition = loadDiagramColorsDefinition(diagramRef.colorResourceId, fileReader);
  let shapes = tryParseDiagramDrawing(frame, fileReader);
  if (shapes === undefined || shapes.length === 0) {
    shapes = tryGenerateDiagramShapes({ frame, dataModel, layoutDefinition, styleDefinition, colorsDefinition });
  }
  if (resourceStore !== undefined && diagramRef.dataResourceId !== undefined) {
    resourceStore.set(diagramRef.dataResourceId, {
      kind: "diagram",
      source: "parsed",
      data: new ArrayBuffer(0),
      parsed: {
        shapes: shapes ?? [],
        dataModel,
        layoutDefinition,
        styleDefinition,
        colorsDefinition
      }
    });
  }
  return frame;
}
function tryParseDiagramDrawing(frame, fileReader) {
  const diagramPath = fileReader.getResourceByType?.(RELATIONSHIP_TYPES.DIAGRAM_DRAWING);
  if (diagramPath === undefined) {
    return;
  }
  const diagramData = fileReader.readFile(diagramPath);
  if (diagramData === null) {
    return;
  }
  const decoder = new TextDecoder;
  const diagramXmlText = decoder.decode(diagramData);
  const diagramDoc = parseXml(diagramXmlText);
  if (diagramDoc === undefined) {
    return;
  }
  const parsedContent = parseDiagramDrawing(diagramDoc);
  if (parsedContent.shapes.length === 0) {
    return;
  }
  const diagramRelsPath = getRelationshipPath2(diagramPath);
  const diagramRelsData = fileReader.readFile(diagramRelsPath);
  const diagramResources = loadDiagramResources(diagramRelsData, diagramPath);
  return resolveDiagramShapeResources({ shapes: parsedContent.shapes, diagramResources, diagramPath, fileReader });
}
function tryGenerateDiagramShapes({ frame, dataModel, layoutDefinition, styleDefinition, colorsDefinition }) {
  if (dataModel === undefined) {
    return;
  }
  const transform = frame.transform;
  const bounds = {
    x: 0,
    y: 0,
    width: transform?.width ?? 500,
    height: transform?.height ?? 400
  };
  const config = {
    bounds,
    defaultNodeWidth: 100,
    defaultNodeHeight: 60,
    defaultSpacing: 10
  };
  try {
    const result = generateDiagramShapes({
      dataModel,
      layoutDefinition,
      styleDefinition,
      colorDefinition: colorsDefinition,
      config
    });
    return result.shapes;
  } catch (error) {
    console.warn("Failed to generate diagram shapes dynamically:", error instanceof Error ? error.message : String(error));
    return;
  }
}
function loadDiagramResources(relsData, sourcePath) {
  if (relsData === null) {
    return createEmptyResourceMap();
  }
  const decoder = new TextDecoder;
  const relsXmlText = decoder.decode(relsData);
  const relsDoc = parseXml(relsXmlText);
  if (relsDoc === undefined) {
    return createEmptyResourceMap();
  }
  return parseRelationships2(relsDoc, sourcePath);
}
function loadDiagramDataModel(resourceId, fileReader) {
  const doc = loadDiagramResourceXml(resourceId, fileReader);
  if (!doc) {
    return;
  }
  return parseDiagramDataModel(doc, { parseShapeProperties, parseTextBody });
}
function loadDiagramLayoutDefinition(resourceId, fileReader) {
  const doc = loadDiagramResourceXml(resourceId, fileReader);
  if (!doc) {
    return;
  }
  return parseDiagramLayoutDefinition(doc, { parseShapeProperties, parseTextBody });
}
function loadDiagramStyleDefinition(resourceId, fileReader) {
  const doc = loadDiagramResourceXml(resourceId, fileReader);
  if (!doc) {
    return;
  }
  return parseDiagramStyleDefinition(doc, { parseTextBody, parseShapeStyle });
}
function loadDiagramColorsDefinition(resourceId, fileReader) {
  const doc = loadDiagramResourceXml(resourceId, fileReader);
  if (!doc) {
    return;
  }
  return parseDiagramColorsDefinition(doc);
}
function loadDiagramResourceXml(resourceId, fileReader) {
  if (!resourceId) {
    return;
  }
  const path = fileReader.resolveResource(resourceId);
  if (!path) {
    return;
  }
  const data = fileReader.readFile(path);
  if (data === null) {
    return;
  }
  const decoder = new TextDecoder;
  const xmlText = decoder.decode(data);
  return parseXml(xmlText);
}
function resolveDiagramShapeResources({
  shapes,
  diagramResources,
  diagramPath,
  fileReader
}) {
  const diagramDir = diagramPath.substring(0, diagramPath.lastIndexOf("/") + 1);
  const ctx = { resources: diagramResources, baseDir: diagramDir, fileReader };
  return shapes.map((shape) => resolveShapeResources({ shape, ...ctx }));
}
function resolveShapeResources({ shape, resources, baseDir, fileReader }) {
  switch (shape.type) {
    case "sp":
      return resolveSpShapeResources({ shape, resources, baseDir, fileReader });
    case "pic":
      return resolvePicShapeResources({ shape, resources, baseDir, fileReader });
    case "grpSp":
      return {
        ...shape,
        children: shape.children.map((child) => resolveShapeResources({ shape: child, resources, baseDir, fileReader }))
      };
    default:
      return shape;
  }
}
function resolveSpShapeResources({ shape, resources, baseDir, fileReader }) {
  const fill = shape.properties?.fill;
  if (fill?.type !== "blipFill") {
    return shape;
  }
  const resolvedFill = resolveBlipFill({ fill, resources, baseDir, fileReader });
  if (resolvedFill === fill) {
    return shape;
  }
  return {
    ...shape,
    properties: {
      ...shape.properties,
      fill: resolvedFill
    }
  };
}
function resolvePicShapeResources({ shape, resources, baseDir, fileReader }) {
  const resolved = resolveBlipFillProperties({ blipFill: shape.blipFill, resources, baseDir, fileReader });
  if (resolved === shape.blipFill) {
    return shape;
  }
  return {
    ...shape,
    blipFill: resolved
  };
}
function resolveBlipFill({ fill, resources, baseDir, fileReader }) {
  const resolved = resolveResourceToDataUrl({ resourceId: fill.resourceId, resources, baseDir, fileReader });
  if (resolved === undefined) {
    return fill;
  }
  return {
    ...fill,
    resourceId: resolved
  };
}
function resolveBlipFillProperties({ blipFill, resources, baseDir, fileReader }) {
  const resolved = resolveResourceToDataUrl({ resourceId: blipFill.resourceId, resources, baseDir, fileReader });
  if (resolved === undefined) {
    return blipFill;
  }
  return {
    ...blipFill,
    resourceId: resolved
  };
}
function resolveResourceToDataUrl({ resourceId, resources, baseDir, fileReader }) {
  if (resourceId.startsWith("data:")) {
    return;
  }
  const target = resources.getTarget(resourceId);
  if (target === undefined) {
    return;
  }
  const targetPath = target.startsWith("ppt/") ? target : resolvePartPath2(baseDir, target);
  const data = fileReader.readFile(targetPath);
  if (data === null) {
    return;
  }
  const mimeType = getMimeTypeFromPath(targetPath) ?? "application/octet-stream";
  return toDataUrl(data, mimeType);
}
function enrichOleFrame(frame, ctx) {
  if (frame.content.type !== "oleObject") {
    return frame;
  }
  const { fileReader, resourceStore } = ctx;
  const oleRef = frame.content.data;
  if (resourceStore?.has(oleRef.resourceId ?? "")) {
    return frame;
  }
  if (oleRef.spid === undefined) {
    return frame;
  }
  const previewImageUrl = resolveVmlPreviewImage(oleRef, fileReader);
  if (previewImageUrl === undefined) {
    return frame;
  }
  if (resourceStore !== undefined && oleRef.resourceId !== undefined) {
    resourceStore.set(oleRef.resourceId, {
      kind: "ole",
      source: "parsed",
      data: new ArrayBuffer(0),
      previewUrl: previewImageUrl
    });
  }
  return frame;
}
function resolveVmlPreviewImage(oleRef, fileReader) {
  if (oleRef.spid === undefined || fileReader.getResourceByType === undefined) {
    return;
  }
  const vmlPath = fileReader.getResourceByType(RELATIONSHIP_TYPES.VML_DRAWING);
  if (vmlPath === undefined) {
    return;
  }
  const vmlData = fileReader.readFile(vmlPath);
  if (vmlData === null) {
    return;
  }
  const vmlText = new TextDecoder().decode(vmlData);
  const vmlDoc = parseXml(vmlText);
  if (vmlDoc === undefined) {
    return;
  }
  const vmlRelsPath = getVmlRelsPath(vmlPath);
  const vmlRelsData = fileReader.readFile(vmlRelsPath);
  const vmlRelsDoc = vmlRelsData !== null ? parseXml(new TextDecoder().decode(vmlRelsData)) : null;
  const imageInfo = findVmlShapeImage(vmlDoc, vmlRelsDoc ?? null, oleRef.spid);
  if (imageInfo === undefined) {
    return;
  }
  const normalizedPath = normalizeVmlImagePath(vmlPath, imageInfo.imagePath);
  const imageData = fileReader.readFile(normalizedPath);
  if (imageData === null) {
    return;
  }
  const ext = normalizedPath.split(".").pop()?.toLowerCase();
  if (ext === "emf") {
    const svg = emfToSvg(new Uint8Array(imageData));
    if (svg !== null) {
      const base64 = btoa(svg);
      return `data:image/svg+xml;base64,${base64}`;
    }
  }
  const mimeType = getMimeTypeFromPath(normalizedPath) ?? "application/octet-stream";
  return toDataUrl(imageData, mimeType);
}

// packages/@oxen-office/pptx/src/parser/slide/theme-parser.ts
function extractFontSpec(fontElement) {
  if (fontElement === undefined) {
    return { latin: undefined, eastAsian: undefined, complexScript: undefined };
  }
  const latin = getChild(fontElement, "a:latin");
  const ea = getChild(fontElement, "a:ea");
  const cs = getChild(fontElement, "a:cs");
  return {
    latin: latin?.attrs?.typeface,
    eastAsian: ea?.attrs?.typeface,
    complexScript: cs?.attrs?.typeface
  };
}
function parseFontScheme(themeContent) {
  if (themeContent === null) {
    return {
      majorFont: { latin: undefined, eastAsian: undefined, complexScript: undefined },
      minorFont: { latin: undefined, eastAsian: undefined, complexScript: undefined }
    };
  }
  const fontScheme = getByPath(themeContent, [
    "a:theme",
    "a:themeElements",
    "a:fontScheme"
  ]);
  const majorFont = fontScheme !== undefined ? getChild(fontScheme, "a:majorFont") : undefined;
  const minorFont = fontScheme !== undefined ? getChild(fontScheme, "a:minorFont") : undefined;
  return {
    majorFont: extractFontSpec(majorFont),
    minorFont: extractFontSpec(minorFont)
  };
}
function collectColorScheme(clrScheme) {
  const colors = {};
  if (clrScheme === undefined) {
    return colors;
  }
  for (const child of clrScheme.children) {
    if (typeof child === "object" && "name" in child && "children" in child) {
      const colorElement = child;
      const colorName = colorElement.name.replace("a:", "");
      const srgbClr = getChild(colorElement, "a:srgbClr");
      if (srgbClr !== undefined) {
        colors[colorName] = srgbClr.attrs?.val ?? "";
      } else {
        const sysClr = getChild(colorElement, "a:sysClr");
        if (sysClr !== undefined) {
          colors[colorName] = sysClr.attrs?.lastClr ?? "";
        }
      }
    }
  }
  return colors;
}
function parseColorScheme(themeContent) {
  if (themeContent === null) {
    return {};
  }
  const clrScheme = getByPath(themeContent, [
    "a:theme",
    "a:themeElements",
    "a:clrScheme"
  ]);
  return collectColorScheme(clrScheme);
}
function collectColorMap(clrMap) {
  const mapping = {};
  if (clrMap === undefined) {
    return mapping;
  }
  for (const [key, value] of Object.entries(clrMap.attrs)) {
    mapping[key] = value;
  }
  return mapping;
}
function parseColorMap(clrMapElement) {
  return collectColorMap(clrMapElement);
}
function filterElementChildren(children) {
  return children.filter((child) => typeof child === "object" && child !== null && ("name" in child));
}
function parseFormatScheme(themeContent) {
  if (themeContent === null) {
    return { lineStyles: [], fillStyles: [], effectStyles: [], bgFillStyles: [] };
  }
  const fmtScheme = getByPath(themeContent, [
    "a:theme",
    "a:themeElements",
    "a:fmtScheme"
  ]);
  if (fmtScheme === undefined) {
    return { lineStyles: [], fillStyles: [], effectStyles: [], bgFillStyles: [] };
  }
  const lnStyleLst = getChild(fmtScheme, "a:lnStyleLst");
  const fillStyleLst = getChild(fmtScheme, "a:fillStyleLst");
  const effectStyleLst = getChild(fmtScheme, "a:effectStyleLst");
  const bgFillStyleLst = getChild(fmtScheme, "a:bgFillStyleLst");
  return {
    lineStyles: lnStyleLst !== undefined ? getChildren(lnStyleLst, "a:ln") : [],
    fillStyles: fillStyleLst !== undefined ? filterElementChildren(fillStyleLst.children) : [],
    effectStyles: effectStyleLst !== undefined ? getChildren(effectStyleLst, "a:effectStyle") : [],
    bgFillStyles: bgFillStyleLst !== undefined ? filterElementChildren(bgFillStyleLst.children) : []
  };
}
function parseObjectDefaults(themeContent) {
  if (themeContent === null) {
    return {};
  }
  const objectDefaults = getByPath(themeContent, [
    "a:theme",
    "a:themeElements",
    "a:objectDefaults"
  ]);
  if (objectDefaults === undefined) {
    return {};
  }
  return {
    lineDefault: getChild(objectDefaults, "a:lnDef"),
    shapeDefault: getChild(objectDefaults, "a:spDef"),
    textDefault: getChild(objectDefaults, "a:txDef")
  };
}
function parseCustomColorList(themeContent) {
  if (themeContent === null) {
    return [];
  }
  const custClrLst = getByPath(themeContent, ["a:theme", "a:themeElements", "a:custClrLst"]) ?? getByPath(themeContent, ["a:theme", "a:custClrLst"]);
  if (custClrLst === undefined) {
    return [];
  }
  const customColors = [];
  for (const child of custClrLst.children) {
    if (typeof child !== "object" || !("name" in child)) {
      continue;
    }
    const custClr = child;
    if (custClr.name !== "a:custClr") {
      continue;
    }
    const name = custClr.attrs?.name;
    const srgbClr = getChild(custClr, "a:srgbClr");
    if (srgbClr !== undefined) {
      customColors.push({
        name,
        color: srgbClr.attrs?.val,
        type: "srgb"
      });
      continue;
    }
    const sysClr = getChild(custClr, "a:sysClr");
    if (sysClr !== undefined) {
      customColors.push({
        name,
        color: sysClr.attrs?.lastClr,
        type: "system",
        systemColor: sysClr.attrs?.val
      });
    }
  }
  return customColors;
}
function parseExtraColorSchemes(themeContent) {
  if (themeContent === null) {
    return [];
  }
  const extraClrSchemeLst = getByPath(themeContent, [
    "a:theme",
    "a:extraClrSchemeLst"
  ]);
  if (extraClrSchemeLst === undefined) {
    return [];
  }
  const schemes = [];
  for (const extra of getChildren(extraClrSchemeLst, "a:extraClrScheme")) {
    const clrScheme = getChild(extra, "a:clrScheme");
    const clrMap = getChild(extra, "a:clrMap");
    if (!clrScheme || !clrMap) {
      continue;
    }
    schemes.push({
      name: getAttr(clrScheme, "name"),
      colorScheme: collectColorScheme(clrScheme),
      colorMap: collectColorMap(clrMap)
    });
  }
  return schemes;
}
function parseTheme(themeContent, themeOverrides = []) {
  return {
    fontScheme: parseFontScheme(themeContent),
    colorScheme: parseColorScheme(themeContent),
    formatScheme: parseFormatScheme(themeContent),
    customColors: parseCustomColorList(themeContent),
    extraColorSchemes: parseExtraColorSchemes(themeContent),
    themeElements: getByPath(themeContent, ["a:theme", "a:themeElements"]),
    themeManager: getByPath(themeContent, ["a:theme", "a:themeManager"]),
    themeOverrides,
    objectDefaults: parseObjectDefaults(themeContent)
  };
}
function parseMasterTextStyles(txStyles) {
  if (txStyles === undefined) {
    return {
      titleStyle: undefined,
      bodyStyle: undefined,
      otherStyle: undefined
    };
  }
  return {
    titleStyle: getChild(txStyles, "p:titleStyle"),
    bodyStyle: getChild(txStyles, "p:bodyStyle"),
    otherStyle: getChild(txStyles, "p:otherStyle")
  };
}

// packages/@oxen-office/pptx/src/parser/slide/resource-adapters.ts
function createPlaceholderTable(tables) {
  return {
    byIdx: tables.idxTable,
    byType: tables.typeTable
  };
}
function createColorMap(clrMapElement) {
  return parseColorMap(clrMapElement);
}

// packages/@oxen-renderer/pptx/src/context/api-render-context.ts
function createRenderContext({
  apiSlide,
  zip,
  slideSize,
  defaultTextStyle = null,
  renderOptions
}) {
  const slideRenderCtx = (() => {
    const masterClrMap = getByPath(apiSlide.master, ["p:sldMaster", "p:clrMap"]);
    const slideClrMapOvr = getByPath(apiSlide.content, ["p:sld", "p:clrMapOvr", "a:overrideClrMapping"]);
    const slideContent = getByPath(apiSlide.content, ["p:sld"]);
    const slide = {
      content: slideContent,
      resources: apiSlide.relationships,
      colorMapOverride: slideClrMapOvr !== undefined ? createColorMap(slideClrMapOvr) : undefined
    };
    const layoutContent = getByPath(apiSlide.layout, ["p:sldLayout"]);
    const masterContent = getByPath(apiSlide.master, ["p:sldMaster"]);
    const layout = {
      placeholders: createPlaceholderTable(apiSlide.layoutTables),
      resources: apiSlide.layoutRelationships,
      content: layoutContent
    };
    const master = {
      textStyles: parseMasterTextStyles(apiSlide.masterTextStyles),
      placeholders: createPlaceholderTable(apiSlide.masterTables),
      colorMap: createColorMap(masterClrMap),
      resources: apiSlide.masterRelationships,
      content: masterContent
    };
    const theme = parseTheme(apiSlide.theme, undefined);
    const presentation = {
      theme,
      defaultTextStyle,
      zip,
      renderOptions: renderOptions ?? DEFAULT_RENDER_OPTIONS,
      themeResources: apiSlide.themeRelationships
    };
    return createSlideContext({ slide, layout, master, presentation });
  })();
  const bgFillData = getBackgroundFillData(slideRenderCtx);
  const resolvedBackground = toResolvedBackgroundFill(bgFillData);
  const layoutShapes = getLayoutNonPlaceholderShapes(apiSlide);
  const renderContext = createRenderContextFromSlideContext(slideRenderCtx, slideSize, {
    resolvedBackground,
    layoutShapes
  });
  return {
    slideRenderContext: slideRenderCtx,
    slideSize: renderContext.slideSize,
    options: renderContext.options,
    colorContext: renderContext.colorContext,
    resources: renderContext.resources,
    warnings: renderContext.warnings,
    getNextShapeId: renderContext.getNextShapeId,
    fontScheme: renderContext.fontScheme,
    resolvedBackground: renderContext.resolvedBackground,
    layoutShapes: renderContext.layoutShapes
  };
}
function isPlaceholder(shape) {
  if (shape.type !== "sp") {
    return false;
  }
  return shape.placeholder !== undefined;
}
function getLayoutNonPlaceholderShapes(apiSlide) {
  const layoutContent = getByPath(apiSlide.layout, ["p:sldLayout"]);
  if (layoutContent === undefined) {
    return [];
  }
  const cSld = getChild(layoutContent, "p:cSld");
  if (cSld === undefined) {
    return [];
  }
  const spTree = getChild(cSld, "p:spTree");
  if (spTree === undefined) {
    return [];
  }
  const layoutShapes = parseShapeTree({ spTree });
  return layoutShapes.filter((shape) => !isPlaceholder(shape));
}
// packages/@oxen-office/pptx/src/parser/timing-parser/mapping.ts
function parseDuration(dur) {
  if (!dur) {
    return;
  }
  if (dur === "indefinite") {
    return "indefinite";
  }
  return parseInt(dur, 10);
}
function parseRepeatCount(val) {
  if (!val) {
    return;
  }
  if (val === "indefinite") {
    return "indefinite";
  }
  return parseInt(val, 10) / 1000;
}
function mapFillBehavior(val) {
  switch (val) {
    case "hold":
      return "hold";
    case "transition":
      return "transition";
    case "freeze":
      return "freeze";
    case "remove":
      return "remove";
    default:
      return;
  }
}
function mapRestartBehavior(val) {
  switch (val) {
    case "always":
      return "always";
    case "whenNotActive":
      return "whenNotActive";
    case "never":
      return "never";
    default:
      return;
  }
}
function mapTimeNodeSyncType(val) {
  switch (val) {
    case "canSlip":
      return "canSlip";
    case "locked":
      return "locked";
    default:
      return;
  }
}
function mapTimeNodeMasterRelation(val) {
  switch (val) {
    case "lastClick":
      return "lastClick";
    case "nextClick":
      return "nextClick";
    case "sameClick":
      return "sameClick";
    default:
      return;
  }
}
function mapTimeNodeType(val) {
  switch (val) {
    case "tmRoot":
      return "tmRoot";
    case "mainSeq":
      return "mainSeq";
    case "interactiveSeq":
      return "interactiveSeq";
    case "clickEffect":
      return "clickEffect";
    case "withEffect":
      return "withEffect";
    case "afterEffect":
      return "afterEffect";
    case "clickPar":
      return "clickPar";
    case "withGroup":
      return "withGroup";
    case "afterGroup":
      return "afterGroup";
    default:
      return;
  }
}
function mapPresetClass(val) {
  switch (val) {
    case "entr":
      return "entrance";
    case "exit":
      return "exit";
    case "emph":
      return "emphasis";
    case "path":
      return "motion";
    case "verb":
      return "verb";
    case "mediacall":
      return "mediaCall";
    default:
      return;
  }
}
function mapConditionEvent(val) {
  switch (val) {
    case "begin":
      return "begin";
    case "end":
      return "end";
    case "onBegin":
      return "onBegin";
    case "onEnd":
      return "onEnd";
    case "onClick":
      return "onClick";
    case "onDblClick":
      return "onDoubleClick";
    case "onMouseOver":
      return "onMouseOver";
    case "onMouseOut":
      return "onMouseOut";
    case "onNext":
      return "onNext";
    case "onPrev":
      return "onPrev";
    case "onStopAudio":
      return "onStopAudio";
    default:
      return;
  }
}
function mapTriggerRuntimeNode(val) {
  switch (val) {
    case "all":
      return "all";
    case "first":
      return "first";
    case "last":
      return "last";
    default:
      return;
  }
}
function mapIterateType(val) {
  switch (val) {
    case "el":
      return "element";
    case "wd":
      return "word";
    case "lt":
      return "letter";
    default:
      return;
  }
}
function mapNextAction(val) {
  switch (val) {
    case "none":
      return "none";
    case "seek":
      return "seek";
    default:
      return;
  }
}
function mapPrevAction(val) {
  switch (val) {
    case "none":
      return "none";
    case "skip":
      return "skip";
    default:
      return;
  }
}
function mapCalcMode(val) {
  switch (val) {
    case "discrete":
      return "discrete";
    case "lin":
      return "linear";
    case "fmla":
      return "formula";
    default:
      return;
  }
}
function mapValueType(val) {
  switch (val) {
    case "str":
      return "string";
    case "num":
      return "number";
    case "clr":
      return "color";
    default:
      return;
  }
}
function mapAdditiveMode(val) {
  switch (val) {
    case "base":
      return "base";
    case "sum":
      return "sum";
    case "repl":
      return "replace";
    case "mult":
      return "multiply";
    case "none":
      return "none";
    default:
      return;
  }
}
function mapAccumulateMode(val) {
  switch (val) {
    case "always":
      return "always";
    case "none":
      return "none";
    default:
      return;
  }
}
function mapOverrideMode(val) {
  switch (val) {
    case "normal":
      return "normal";
    case "childStyle":
      return "childStyle";
    default:
      return;
  }
}
function mapTransformType(val) {
  switch (val) {
    case "pt":
      return "pt";
    case "img":
      return "img";
    default:
      return;
  }
}
function mapBuildType(val) {
  switch (val) {
    case "allAtOnce":
      return "allAtOnce";
    case "p":
      return "paragraph";
    case "wd":
      return "word";
    case "char":
      return "character";
    default:
      return;
  }
}
function mapParaBuildType(val) {
  switch (val) {
    case "allAtOnce":
      return "allAtOnce";
    case "p":
      return "paragraph";
    case "cust":
      return "custom";
    case "whole":
      return "whole";
    default:
      return;
  }
}
function mapChartOnlyBuildType(val) {
  switch (val) {
    case "category":
      return "category";
    case "categoryEl":
      return "categoryEl";
    case "series":
      return "series";
    case "seriesEl":
      return "seriesEl";
    default:
      return;
  }
}
function mapChartBuildType(val) {
  return mapBuildType(val) ?? mapChartOnlyBuildType(val);
}
function mapChartSubelementType(val) {
  switch (val) {
    case "category":
      return "category";
    case "gridLegend":
      return "gridLegend";
    case "ptInCategory":
      return "ptInCategory";
    case "ptInSeries":
      return "ptInSeries";
    case "series":
      return "series";
    default:
      return;
  }
}
function mapCommandType(val) {
  switch (val) {
    case "call":
      return "call";
    case "evt":
      return "event";
    case "verb":
      return "verb";
    default:
      return;
  }
}
function mapDgmOnlyBuildType(val) {
  switch (val) {
    case "whole":
      return "whole";
    case "depthByNode":
      return "depthByNode";
    case "depthByBranch":
      return "depthByBranch";
    case "breadthByNode":
      return "breadthByNode";
    case "breadthByLvl":
      return "breadthByLvl";
    case "cw":
      return "cw";
    case "cwIn":
      return "cwIn";
    case "cwOut":
      return "cwOut";
    case "ccw":
      return "ccw";
    case "ccwIn":
      return "ccwIn";
    case "ccwOut":
      return "ccwOut";
    case "inByRing":
      return "inByRing";
    case "outByRing":
      return "outByRing";
    case "up":
      return "up";
    case "down":
      return "down";
    case "allAtOnce":
      return "allAtOnce";
    case "cust":
      return "cust";
    default:
      return;
  }
}
function mapDgmBuildType(val) {
  return mapDgmOnlyBuildType(val);
}
function mapOleChartBuildType(val) {
  if (val === "allAtOnce") {
    return "allAtOnce";
  }
  return mapChartOnlyBuildType(val);
}

// packages/@oxen-office/pptx/src/parser/timing-parser/target.ts
function parseTextElementTarget(txEl) {
  const pRg = getChild(txEl, "p:pRg");
  if (pRg) {
    return {
      type: "paragraph",
      start: parseInt(getAttr(pRg, "st") ?? "0", 10),
      end: parseInt(getAttr(pRg, "end") ?? "0", 10)
    };
  }
  const charRg = getChild(txEl, "p:charRg");
  if (charRg) {
    return {
      type: "character",
      start: parseInt(getAttr(charRg, "st") ?? "0", 10),
      end: parseInt(getAttr(charRg, "end") ?? "0", 10)
    };
  }
  return;
}
function parseGraphicElementTarget(graphicEl) {
  for (const child of graphicEl.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    const id = getAttr(child, "id") ?? getAttr(child, "r:id");
    switch (child.name) {
      case "a:dgm":
        return { type: "diagram", id };
      case "c:chart":
        return { type: "chart", id };
      case "a:tbl":
        return { type: "table", id };
      case "a:graphic":
        return { type: "graphic", id };
      default:
        return { type: "unknown", name: child.name, id };
    }
  }
  return;
}
function parseShapeTarget(spTgt) {
  const shapeId = parseShapeId(getAttr(spTgt, "spid")) ?? "";
  const txEl = getChild(spTgt, "p:txEl");
  const textElement = txEl ? parseTextElementTarget(txEl) : undefined;
  const bg = getChild(spTgt, "p:bg");
  const targetBackground = bg !== undefined;
  const graphicEl = getChild(spTgt, "p:graphicEl");
  const graphicElement = graphicEl ? parseGraphicElementTarget(graphicEl) : undefined;
  const oleChartEl = getChild(spTgt, "p:oleChartEl");
  const oleChartElement = oleChartEl ? parseOleChartElement(oleChartEl) : undefined;
  const subSp = getChild(spTgt, "p:subSp");
  const subShapeId = subSp ? parseShapeId(getAttr(subSp, "spid")) : undefined;
  return {
    type: "shape",
    shapeId,
    textElement,
    subShapeId,
    targetBackground,
    graphicElement,
    oleChartElement
  };
}
function parseOleChartElement(oleChartEl) {
  const levelValue = getAttr(oleChartEl, "lvl");
  return {
    type: mapChartSubelementType(getAttr(oleChartEl, "type")),
    level: levelValue ? parseInt(levelValue, 10) : undefined
  };
}
function parseTargetElement(tgtEl) {
  const spTgt = getChild(tgtEl, "p:spTgt");
  if (spTgt) {
    return parseShapeTarget(spTgt);
  }
  const sldTgt = getChild(tgtEl, "p:sldTgt");
  if (sldTgt) {
    return { type: "slide" };
  }
  const sndTgt = getChild(tgtEl, "p:sndTgt");
  if (sndTgt) {
    return {
      type: "sound",
      resourceId: getAttr(sndTgt, "r:embed") ?? "",
      name: getAttr(sndTgt, "name")
    };
  }
  const inkTgt = getChild(tgtEl, "p:inkTgt");
  if (inkTgt) {
    return {
      type: "ink",
      shapeId: parseShapeId(getAttr(inkTgt, "spid")) ?? ""
    };
  }
  return;
}

// packages/@oxen-office/pptx/src/parser/timing-parser/condition.ts
function parseDelayValue(delayStr) {
  if (!delayStr) {
    return;
  }
  if (delayStr === "indefinite") {
    return "indefinite";
  }
  return parseInt(delayStr, 10);
}
function parseTimeCondition(condition) {
  const delay = parseDelayValue(getAttr(condition, "delay"));
  const event = mapConditionEvent(getAttr(condition, "evt"));
  const tgtEl = getChild(condition, "p:tgtEl");
  const target = tgtEl ? parseTargetElement(tgtEl) : undefined;
  const tn = getChild(condition, "p:tn");
  const timeNodeRef = tn ? parseInt(getAttr(tn, "val") ?? "0", 10) : undefined;
  const rtn = getChild(condition, "p:rtn");
  const runtimeNode = rtn ? mapTriggerRuntimeNode(getAttr(rtn, "val")) : undefined;
  return { delay, event, target, timeNodeRef, runtimeNode };
}
function parseCondition(cond) {
  return parseTimeCondition(cond);
}
function parseConditionList(condLst) {
  const conditions = [];
  for (const cond of getChildren(condLst, "p:cond")) {
    const condition = parseCondition(cond);
    if (condition) {
      conditions.push(condition);
    }
  }
  return conditions;
}

// packages/@oxen-office/pptx/src/parser/timing-parser/common.ts
function parsePresetInfo(cTn) {
  const presetID = getAttr(cTn, "presetID");
  const presetClass = getAttr(cTn, "presetClass");
  if (!presetID || !presetClass) {
    return;
  }
  const mappedClass = mapPresetClass(presetClass);
  if (!mappedClass) {
    return;
  }
  const presetSubtype = getAttr(cTn, "presetSubtype");
  return {
    id: parseInt(presetID, 10),
    class: mappedClass,
    subtype: presetSubtype ? parseInt(presetSubtype, 10) : undefined
  };
}
function parseCommonTimeNode(cTn) {
  const id = parseInt(getAttr(cTn, "id") ?? "0", 10);
  const duration = parseDuration(getAttr(cTn, "dur"));
  const fill = mapFillBehavior(getAttr(cTn, "fill"));
  const restart = mapRestartBehavior(getAttr(cTn, "restart"));
  const syncBehavior = mapTimeNodeSyncType(getAttr(cTn, "syncBehavior"));
  const masterRelation = mapTimeNodeMasterRelation(getAttr(cTn, "masterRel"));
  const nodeType = mapTimeNodeType(getAttr(cTn, "nodeType"));
  const preset = parsePresetInfo(cTn);
  const stCondLst = getChild(cTn, "p:stCondLst");
  const endCondLst = getChild(cTn, "p:endCondLst");
  const endSync = getChild(cTn, "p:endSync");
  const startConditions = stCondLst ? parseConditionList(stCondLst) : undefined;
  const endConditions = endCondLst ? parseConditionList(endCondLst) : undefined;
  const endSyncCondition = endSync ? parseTimeCondition(endSync) : undefined;
  const iterate = parseIterateData(cTn);
  const accel = getAttr(cTn, "accel");
  const decel = getAttr(cTn, "decel");
  const autoRev = getAttr(cTn, "autoRev");
  const repeatCount = parseRepeatCount(getAttr(cTn, "repeatCount"));
  const spd = getAttr(cTn, "spd");
  return {
    id,
    duration,
    fill,
    restart,
    syncBehavior,
    masterRelation,
    nodeType,
    preset,
    startConditions,
    endConditions,
    endSync: endSyncCondition,
    iterate,
    acceleration: accel ? parseInt(accel, 10) / 1000 : undefined,
    deceleration: decel ? parseInt(decel, 10) / 1000 : undefined,
    autoReverse: autoRev === "1",
    repeatCount,
    speed: spd ? parseInt(spd, 10) / 1000 : undefined
  };
}
function parseIterateInterval(iterate) {
  const tmAbs = getChild(iterate, "p:tmAbs");
  if (tmAbs) {
    const val = getAttr(tmAbs, "val");
    if (val !== undefined) {
      const parsed = parseInt(val, 10);
      if (!Number.isNaN(parsed)) {
        return { type: "absolute", value: parsed };
      }
    }
  }
  const tmPct = getChild(iterate, "p:tmPct");
  if (tmPct) {
    const raw = getAttr(tmPct, "val");
    const pct2 = parseIteratePercentage(raw);
    if (pct2 !== undefined) {
      return { type: "percentage", value: pct2 };
    }
  }
  return;
}
function parseIterateData(cTn) {
  const iterate = getChild(cTn, "p:iterate");
  if (!iterate) {
    return;
  }
  const type = mapIterateType(getAttr(iterate, "type")) ?? "element";
  const backwards = getBoolAttr2(iterate, "backwards");
  const interval = parseIterateInterval(iterate);
  return {
    type,
    backwards,
    interval
  };
}
function parseIteratePercentage(raw) {
  if (!raw) {
    return;
  }
  if (raw.endsWith("%")) {
    return parsePositiveFixedPercentage(raw);
  }
  return parsePositivePercentage2(raw);
}
function extractFirstAttributeName(attrNameLst) {
  if (!attrNameLst) {
    return;
  }
  const attrNames = getChildren(attrNameLst, "p:attrName");
  if (attrNames.length === 0) {
    return;
  }
  return getTextContent(attrNames[0]);
}
function parseCommonBehavior(cBhvr) {
  const cTn = getChild(cBhvr, "p:cTn");
  const tgtEl = getChild(cBhvr, "p:tgtEl");
  const attrNameLst = getChild(cBhvr, "p:attrNameLst");
  const target = tgtEl ? parseTargetElement(tgtEl) : undefined;
  const attribute = extractFirstAttributeName(attrNameLst);
  const accumulate = mapAccumulateMode(getAttr(cBhvr, "accumulate"));
  const override = mapOverrideMode(getAttr(cBhvr, "override"));
  const transformType = mapTransformType(getAttr(cBhvr, "xfrmType"));
  return { target, attribute, cTn, accumulate, override, transformType };
}

// packages/@oxen-office/pptx/src/parser/timing-parser/color.ts
function parseColorValue(element) {
  const srgbClr = getChild(element, "a:srgbClr");
  if (srgbClr) {
    return getAttr(srgbClr, "val");
  }
  const schemeClr = getChild(element, "a:schemeClr");
  if (schemeClr) {
    return getAttr(schemeClr, "val");
  }
  const hsl = getChild(element, "p:hsl");
  if (hsl) {
    const h = getAttr(hsl, "h") ?? "0";
    const s = getAttr(hsl, "s") ?? "0";
    const l = getAttr(hsl, "l") ?? "0";
    return `hsl(${h},${s},${l})`;
  }
  const rgb = getChild(element, "p:rgb");
  if (rgb) {
    const r = getAttr(rgb, "r") ?? "0";
    const g = getAttr(rgb, "g") ?? "0";
    const b = getAttr(rgb, "b") ?? "0";
    return `rgb(${r},${g},${b})`;
  }
  return;
}

// packages/@oxen-office/pptx/src/parser/timing-parser/keyframe.ts
function parseAnimateValue(element) {
  const strVal = getChild(element, "p:strVal");
  if (strVal) {
    return getAttr(strVal, "val") ?? "";
  }
  const boolVal = getChild(element, "p:boolVal");
  if (boolVal) {
    return getAttr(boolVal, "val") === "1";
  }
  const intVal = getChild(element, "p:intVal");
  if (intVal) {
    return parseInt(getAttr(intVal, "val") ?? "0", 10);
  }
  const fltVal = getChild(element, "p:fltVal");
  if (fltVal) {
    return parseFloat(getAttr(fltVal, "val") ?? "0");
  }
  const clrVal = getChild(element, "p:clrVal");
  if (clrVal) {
    return parseColorValue(clrVal) ?? "";
  }
  return "";
}
function parseKeyframe(tav) {
  const tm = getAttr(tav, "tm");
  if (tm === undefined) {
    return;
  }
  if (tm === "indefinite") {
    return;
  }
  const time = parseInt(tm, 10) / 1000;
  const valElement = getChild(tav, "p:val");
  const value = valElement ? parseAnimateValue(valElement) : "";
  const formula = getAttr(tav, "fmla");
  return {
    time,
    value,
    formula
  };
}
function parseKeyframes(tavLst) {
  const keyframes = [];
  for (const tav of getChildren(tavLst, "p:tav")) {
    const keyframe = parseKeyframe(tav);
    if (keyframe) {
      keyframes.push(keyframe);
    }
  }
  return keyframes;
}

// packages/@oxen-office/pptx/src/parser/timing-parser/behavior.ts
function parseAnimateBehavior(element) {
  const cBhvr = getChild(element, "p:cBhvr");
  if (!cBhvr) {
    return;
  }
  const { target, attribute, cTn, accumulate, override, transformType } = parseCommonBehavior(cBhvr);
  if (!target) {
    return;
  }
  const base = cTn ? parseCommonTimeNode(cTn) : { id: 0 };
  const tavLst = getChild(element, "p:tavLst");
  const keyframes = tavLst ? parseKeyframes(tavLst) : undefined;
  return {
    type: "animate",
    ...base,
    target,
    attribute: attribute ?? "",
    keyframes,
    from: getAttr(element, "from"),
    to: getAttr(element, "to"),
    by: getAttr(element, "by"),
    calcMode: mapCalcMode(getAttr(element, "calcmode")),
    valueType: mapValueType(getAttr(element, "valueType")),
    additive: mapAdditiveMode(getAttr(cBhvr, "additive")),
    accumulate,
    override,
    transformType
  };
}
function parseSetBehavior(element) {
  const cBhvr = getChild(element, "p:cBhvr");
  if (!cBhvr) {
    return;
  }
  const { target, attribute, cTn, accumulate, override, transformType } = parseCommonBehavior(cBhvr);
  if (!target) {
    return;
  }
  const base = cTn ? parseCommonTimeNode(cTn) : { id: 0 };
  const toElement = getChild(element, "p:to");
  const value = toElement ? parseAnimateValue(toElement) : undefined;
  return {
    type: "set",
    ...base,
    target,
    attribute: attribute ?? "style.visibility",
    value: value ?? "visible",
    accumulate,
    override,
    transformType
  };
}
function parseAnimateEffectBehavior(element) {
  const cBhvr = getChild(element, "p:cBhvr");
  if (!cBhvr) {
    return;
  }
  const { target, cTn, accumulate, override, transformType } = parseCommonBehavior(cBhvr);
  if (!target) {
    return;
  }
  const base = cTn ? parseCommonTimeNode(cTn) : { id: 0 };
  const transition = getAttr(element, "transition");
  const filter = getAttr(element, "filter");
  const progress = getChild(element, "p:progress");
  return {
    type: "animateEffect",
    ...base,
    target,
    transition: transition ?? "in",
    filter: filter ?? "",
    progress: progress ? parseAnimateValue(progress) : undefined,
    accumulate,
    override,
    transformType
  };
}
function parseAnimateMotionBehavior(element) {
  const cBhvr = getChild(element, "p:cBhvr");
  if (!cBhvr) {
    return;
  }
  const { target, cTn, accumulate, override, transformType } = parseCommonBehavior(cBhvr);
  if (!target) {
    return;
  }
  const base = cTn ? parseCommonTimeNode(cTn) : { id: 0 };
  const path = getAttr(element, "path");
  const origin = getAttr(element, "origin");
  const pathEditMode = getAttr(element, "pathEditMode");
  const rotationCenter = parseRotationCenter(getChild(element, "p:rCtr"));
  return {
    type: "animateMotion",
    ...base,
    target,
    path,
    origin,
    pathEditMode,
    rotationCenter,
    accumulate,
    override,
    transformType
  };
}
function parseAnimateRotationBehavior(element) {
  const cBhvr = getChild(element, "p:cBhvr");
  if (!cBhvr) {
    return;
  }
  const { target, cTn, accumulate, override, transformType } = parseCommonBehavior(cBhvr);
  if (!target) {
    return;
  }
  const base = cTn ? parseCommonTimeNode(cTn) : { id: 0 };
  const by = getAttr(element, "by");
  const from = getAttr(element, "from");
  const to = getAttr(element, "to");
  return {
    type: "animateRotation",
    ...base,
    target,
    from: from ? parseInt(from, 10) / 60000 : undefined,
    to: to ? parseInt(to, 10) / 60000 : undefined,
    by: by ? parseInt(by, 10) / 60000 : undefined,
    accumulate,
    override,
    transformType
  };
}
function parseScaleValue(val) {
  if (!val) {
    return;
  }
  return parseInt(val, 10) / 1000;
}
function parsePercentageValue2(value) {
  if (!value) {
    return;
  }
  if (value.endsWith("%")) {
    return parsePositiveFixedPercentage(value);
  }
  return parsePercentage2(value);
}
function parseRotationCenter(element) {
  if (!element) {
    return;
  }
  const x2 = parsePercentageValue2(getAttr(element, "x"));
  const y = parsePercentageValue2(getAttr(element, "y"));
  if (x2 === undefined || y === undefined) {
    return;
  }
  return { x: x2, y };
}
function parseAnimateScaleBehavior(element) {
  const cBhvr = getChild(element, "p:cBhvr");
  if (!cBhvr) {
    return;
  }
  const { target, cTn, accumulate, override, transformType } = parseCommonBehavior(cBhvr);
  if (!target) {
    return;
  }
  const base = cTn ? parseCommonTimeNode(cTn) : { id: 0 };
  const by = getChild(element, "p:by");
  const from = getChild(element, "p:from");
  const to = getChild(element, "p:to");
  return {
    type: "animateScale",
    ...base,
    target,
    fromX: from ? parseScaleValue(getAttr(from, "x")) : undefined,
    fromY: from ? parseScaleValue(getAttr(from, "y")) : undefined,
    toX: to ? parseScaleValue(getAttr(to, "x")) : undefined,
    toY: to ? parseScaleValue(getAttr(to, "y")) : undefined,
    byX: by ? parseScaleValue(getAttr(by, "x")) : undefined,
    byY: by ? parseScaleValue(getAttr(by, "y")) : undefined,
    accumulate,
    override,
    transformType
  };
}
function parseAnimateColorBehavior(element) {
  const cBhvr = getChild(element, "p:cBhvr");
  if (!cBhvr) {
    return;
  }
  const { target, attribute, cTn, accumulate, override, transformType } = parseCommonBehavior(cBhvr);
  if (!target) {
    return;
  }
  const base = cTn ? parseCommonTimeNode(cTn) : { id: 0 };
  const clrSpc = getAttr(element, "clrSpc");
  const direction = getAttr(element, "dir");
  const by = getChild(element, "p:by");
  const from = getChild(element, "p:from");
  const to = getChild(element, "p:to");
  return {
    type: "animateColor",
    ...base,
    target,
    attribute: attribute ?? "",
    colorSpace: clrSpc ?? "rgb",
    direction,
    from: from ? parseColorValue(from) : undefined,
    to: to ? parseColorValue(to) : undefined,
    by: by ? parseColorValue(by) : undefined,
    accumulate,
    override,
    transformType
  };
}
function parseAudioBehavior(element) {
  const cMediaNode = getChild(element, "p:cMediaNode");
  if (!cMediaNode) {
    return;
  }
  const cTn = getChild(cMediaNode, "p:cTn");
  const tgtEl = getChild(cMediaNode, "p:tgtEl");
  const target = tgtEl ? parseTargetElement(tgtEl) : undefined;
  if (!target) {
    return;
  }
  const base = cTn ? parseCommonTimeNode(cTn) : { id: 0 };
  return {
    type: "audio",
    ...base,
    target,
    isNarration: getAttr(element, "isNarration") === "1"
  };
}
function parseVideoBehavior(element) {
  const cMediaNode = getChild(element, "p:cMediaNode");
  if (!cMediaNode) {
    return;
  }
  const cTn = getChild(cMediaNode, "p:cTn");
  const tgtEl = getChild(cMediaNode, "p:tgtEl");
  const target = tgtEl ? parseTargetElement(tgtEl) : undefined;
  if (!target) {
    return;
  }
  const base = cTn ? parseCommonTimeNode(cTn) : { id: 0 };
  return {
    type: "video",
    ...base,
    target,
    fullscreen: getAttr(element, "fullScrn") === "1"
  };
}
function parseCommandBehavior(element) {
  const cBhvr = getChild(element, "p:cBhvr");
  if (!cBhvr) {
    return;
  }
  const { target, cTn, accumulate, override, transformType } = parseCommonBehavior(cBhvr);
  if (!target) {
    return;
  }
  const base = cTn ? parseCommonTimeNode(cTn) : { id: 0 };
  const cmdType = mapCommandType(getAttr(element, "type"));
  const cmd = getAttr(element, "cmd");
  return {
    type: "command",
    ...base,
    target,
    commandType: cmdType ?? "call",
    command: cmd ?? "",
    accumulate,
    override,
    transformType
  };
}

// packages/@oxen-office/pptx/src/parser/timing-parser/time-node.ts
function parseTimeNodeElement(element) {
  switch (element.name) {
    case "p:par":
      return parseParallelTimeNode(element);
    case "p:seq":
      return parseSequenceTimeNode(element);
    case "p:excl":
      return parseExclusiveTimeNode(element);
    case "p:anim":
      return parseAnimateBehavior(element);
    case "p:set":
      return parseSetBehavior(element);
    case "p:animEffect":
      return parseAnimateEffectBehavior(element);
    case "p:animMotion":
      return parseAnimateMotionBehavior(element);
    case "p:animRot":
      return parseAnimateRotationBehavior(element);
    case "p:animScale":
      return parseAnimateScaleBehavior(element);
    case "p:animClr":
      return parseAnimateColorBehavior(element);
    case "p:audio":
      return parseAudioBehavior(element);
    case "p:video":
      return parseVideoBehavior(element);
    case "p:cmd":
      return parseCommandBehavior(element);
    default:
      return;
  }
}
function parseChildTimeNodes(cTn) {
  const childTnLst = getChild(cTn, "p:childTnLst");
  if (!childTnLst) {
    return [];
  }
  const nodes = [];
  for (const child of childTnLst.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    const node = parseTimeNodeElement(child);
    if (node) {
      nodes.push(node);
    }
  }
  return nodes;
}
function parseSubTimeNodes(cTn) {
  const subTnLst = getChild(cTn, "p:subTnLst");
  if (!subTnLst) {
    return [];
  }
  const nodes = [];
  for (const child of subTnLst.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    const node = parseTimeNodeElement(child);
    if (node) {
      nodes.push(node);
    }
  }
  return nodes;
}
function parseParallelTimeNode(element) {
  const cTn = getChild(element, "p:cTn");
  if (!cTn) {
    return;
  }
  const base = parseCommonTimeNode(cTn);
  const children = parseChildTimeNodes(cTn);
  const subTimeNodes = parseSubTimeNodes(cTn);
  return {
    type: "parallel",
    ...base,
    children,
    subTimeNodes: subTimeNodes.length > 0 ? subTimeNodes : undefined
  };
}
function parseSequenceTimeNode(element) {
  const cTn = getChild(element, "p:cTn");
  if (!cTn) {
    return;
  }
  const base = parseCommonTimeNode(cTn);
  const children = parseChildTimeNodes(cTn);
  const subTimeNodes = parseSubTimeNodes(cTn);
  const prevCondLst = getChild(element, "p:prevCondLst");
  const nextCondLst = getChild(element, "p:nextCondLst");
  const prevConditions = prevCondLst ? parseConditionList(prevCondLst) : undefined;
  const nextConditions = nextCondLst ? parseConditionList(nextCondLst) : undefined;
  return {
    type: "sequence",
    ...base,
    children,
    subTimeNodes: subTimeNodes.length > 0 ? subTimeNodes : undefined,
    concurrent: getAttr(element, "concurrent") === "1",
    nextAction: mapNextAction(getAttr(element, "nextAc")),
    prevAction: mapPrevAction(getAttr(element, "prevAc")),
    prevConditions,
    nextConditions
  };
}
function parseExclusiveTimeNode(element) {
  const cTn = getChild(element, "p:cTn");
  if (!cTn) {
    return;
  }
  const base = parseCommonTimeNode(cTn);
  const children = parseChildTimeNodes(cTn);
  const subTimeNodes = parseSubTimeNodes(cTn);
  return {
    type: "exclusive",
    ...base,
    children,
    subTimeNodes: subTimeNodes.length > 0 ? subTimeNodes : undefined
  };
}
function parseRootTimeNode(tnLst) {
  if (!tnLst) {
    return;
  }
  const parElements = getChildren(tnLst, "p:par");
  if (parElements.length === 0) {
    return;
  }
  return parseParallelTimeNode(parElements[0]);
}
function parseTimeNodeList(tnLst) {
  if (!tnLst) {
    return [];
  }
  const nodes = [];
  for (const child of tnLst.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    const node = parseTimeNodeElement(child);
    if (node) {
      nodes.push(node);
    }
  }
  return nodes;
}

// packages/@oxen-office/pptx/src/parser/timing-parser/graphic-build.ts
function parseBuildChartElement(element) {
  if (!element) {
    return;
  }
  const build = mapChartBuildType(getAttr(element, "bld"));
  const animBg = getAttr(element, "animBg");
  if (!build && animBg === undefined) {
    return;
  }
  return {
    build,
    animateBackground: animBg === "1"
  };
}
function parseBuildDgmElement(element) {
  if (!element) {
    return;
  }
  const build = mapDgmBuildType(getAttr(element, "bld"));
  if (!build) {
    return;
  }
  return { build };
}

// packages/@oxen-office/pptx/src/parser/timing-parser/build-list.ts
function parseBuildParagraph(bldP) {
  const spid = parseShapeId(getAttr(bldP, "spid"));
  if (!spid) {
    return;
  }
  const grpId = getAttr(bldP, "grpId");
  const build = getAttr(bldP, "build");
  const animBg = getAttr(bldP, "animBg");
  const rev2 = getAttr(bldP, "rev");
  const advAuto = getAttr(bldP, "advAuto");
  const tmplLst = getChild(bldP, "p:tmplLst");
  return {
    shapeId: spid,
    groupId: grpId ? parseInt(grpId, 10) : undefined,
    buildType: mapParaBuildType(build),
    advanceAfter: parseDuration(advAuto),
    animateBackground: animBg === "1",
    reverse: rev2 === "1",
    templateEffects: tmplLst ? parseTemplateList(tmplLst) : undefined
  };
}
function parseTemplateList(tmplLst) {
  const templates = [];
  for (const tmpl of getChildren(tmplLst, "p:tmpl")) {
    const levelAttr = getAttr(tmpl, "lvl");
    const level = levelAttr ? parseInt(levelAttr, 10) : undefined;
    const tnLst = getChild(tmpl, "p:tnLst");
    if (!tnLst) {
      continue;
    }
    const timeNodes = parseTimeNodeList(tnLst);
    templates.push({ level, timeNodes });
  }
  return templates;
}
function parseGraphicBuildElement(bldGraphic) {
  const bldAsOne = getChild(bldGraphic, "p:bldAsOne");
  if (bldAsOne) {
    return { type: "asOne" };
  }
  const bldSub = getChild(bldGraphic, "p:bldSub");
  if (!bldSub) {
    return;
  }
  const chartBuild = parseBuildChartElement(getChild(bldSub, "a:bldChart"));
  const diagramBuild = parseBuildDgmElement(getChild(bldSub, "a:bldDgm"));
  if (!chartBuild && !diagramBuild) {
    return;
  }
  return {
    type: "sub",
    chartBuild,
    diagramBuild
  };
}
function parseBuildGraphic(bldGraphic) {
  const spid = parseShapeId(getAttr(bldGraphic, "spid"));
  if (!spid) {
    return;
  }
  const grpId = getAttr(bldGraphic, "grpId");
  const graphicBuild = parseGraphicBuildElement(bldGraphic);
  return {
    shapeId: spid,
    groupId: grpId ? parseInt(grpId, 10) : undefined,
    uiExpand: getBoolAttr2(bldGraphic, "uiExpand"),
    graphicBuild
  };
}
function parseBuildOleChart(bldOleChart) {
  const spid = parseShapeId(getAttr(bldOleChart, "spid"));
  if (!spid) {
    return;
  }
  const grpId = getAttr(bldOleChart, "grpId");
  const build = mapOleChartBuildType(getAttr(bldOleChart, "bld"));
  const animBg = getBoolAttr2(bldOleChart, "animBg");
  const oleChartBuild = resolveOleChartBuild(build, animBg);
  return {
    shapeId: spid,
    groupId: grpId ? parseInt(grpId, 10) : undefined,
    uiExpand: getBoolAttr2(bldOleChart, "uiExpand"),
    oleChartBuild
  };
}
function resolveOleChartBuild(build, animateBackground) {
  if (build !== undefined || animateBackground !== undefined) {
    return { build, animateBackground };
  }
  return;
}
function parseBuildList(bldLst) {
  const entries = [];
  for (const bldP of getChildren(bldLst, "p:bldP")) {
    const entry = parseBuildParagraph(bldP);
    if (entry) {
      entries.push(entry);
    }
  }
  for (const bldGraphic of getChildren(bldLst, "p:bldGraphic")) {
    const entry = parseBuildGraphic(bldGraphic);
    if (entry) {
      entries.push(entry);
    }
  }
  for (const bldOleChart of getChildren(bldLst, "p:bldOleChart")) {
    const entry = parseBuildOleChart(bldOleChart);
    if (entry) {
      entries.push(entry);
    }
  }
  return entries;
}

// packages/@oxen-office/pptx/src/parser/timing-parser/parse-timing.ts
function parseTiming(timingElement) {
  if (!timingElement) {
    return;
  }
  const tnLst = getChild(timingElement, "p:tnLst");
  const bldLst = getChild(timingElement, "p:bldLst");
  const rootTimeNode = parseRootTimeNode(tnLst);
  const buildList = bldLst ? parseBuildList(bldLst) : undefined;
  if (!rootTimeNode && !buildList) {
    return;
  }
  return {
    rootTimeNode,
    buildList
  };
}
function findTimingElement(slideContent) {
  for (const child of slideContent.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    const timing = getChild(child, "p:timing");
    if (timing) {
      return timing;
    }
  }
  return;
}
function parseSlideTimingData(slideContent) {
  const timingEl = findTimingElement(slideContent);
  return parseTiming(timingEl);
}
// packages/@oxen-office/pptx/src/parser/slide/transition-parser.ts
function parseSlideTransitionData(content) {
  if (!content) {
    return;
  }
  const sld = getByPath(content, ["p:sld"]);
  if (!sld) {
    return;
  }
  const transitionElement = getTransitionElement(sld);
  return parseTransition(transitionElement);
}

// packages/@oxen-office/pptx/src/app/slide-builder.ts
function createSlide({ data, zip, defaultTextStyle, tableStyles, slideSize, renderOptions }) {
  const timing = parseSlideTimingData(data.content);
  const transition = parseSlideTransitionData(data.content);
  return {
    number: data.number,
    filename: data.filename,
    content: data.content,
    layout: data.layout,
    layoutTables: data.layoutTables,
    master: data.master,
    masterTables: data.masterTables,
    masterTextStyles: data.masterTextStyles,
    theme: data.theme,
    relationships: data.relationships,
    layoutRelationships: data.layoutRelationships,
    masterRelationships: data.masterRelationships,
    themeRelationships: data.themeRelationships,
    diagram: data.diagram,
    diagramRelationships: data.diagramRelationships,
    timing,
    transition,
    themeOverrides: data.themeOverrides,
    zip,
    defaultTextStyle,
    tableStyles,
    slideSize,
    renderOptions: renderOptions ?? DEFAULT_RENDER_OPTIONS
  };
}

// packages/@oxen-office/pptx/src/parser/slide/shape-tree-indexer.ts
function getSlideShapeTree(content) {
  const root = content.children.find((c) => isXmlElement(c));
  if (!root) {
    return;
  }
  const cSld = getChild(root, "p:cSld");
  if (!cSld) {
    return;
  }
  return getChild(cSld, "p:spTree");
}
function indexShapeTreeNodes(content) {
  const result = {
    idTable: {},
    idxTable: new Map,
    typeTable: {}
  };
  if (content === null) {
    return result;
  }
  const spTree = getSlideShapeTree(content);
  if (spTree === undefined) {
    return result;
  }
  const elementTypes = ["p:sp", "p:cxnSp", "p:pic", "p:graphicFrame", "p:grpSp", "mc:AlternateContent"];
  for (const elementType of elementTypes) {
    const elements = getChildren(spTree, elementType);
    for (const element of elements) {
      indexShapeTreeNode(element, result);
    }
  }
  return result;
}
function indexShapeTreeNode(node, tables) {
  let nvSpPr = getChild(node, "p:nvSpPr");
  if (!nvSpPr) {
    nvSpPr = getChild(node, "p:nvPicPr");
  }
  if (!nvSpPr) {
    nvSpPr = getChild(node, "p:nvCxnSpPr");
  }
  if (!nvSpPr) {
    nvSpPr = getChild(node, "p:nvGraphicFramePr");
  }
  if (!nvSpPr) {
    nvSpPr = getChild(node, "p:nvGrpSpPr");
  }
  if (!nvSpPr) {
    return;
  }
  const cNvPr = getChild(nvSpPr, "p:cNvPr");
  const nvPr = getChild(nvSpPr, "p:nvPr");
  const ph = nvPr ? getChild(nvPr, "p:ph") : undefined;
  const id = cNvPr?.attrs.id;
  const idx = ph?.attrs.idx;
  const type = ph?.attrs.type;
  if (id !== undefined) {
    tables.idTable[id] = node;
  }
  if (idx !== undefined) {
    const idxNum = Number(idx);
    if (!Number.isNaN(idxNum)) {
      tables.idxTable.set(idxNum, node);
    }
  }
  if (type !== undefined) {
    tables.typeTable[type] = node;
  }
}

// packages/@oxen-office/pptx/src/parser/slide/diagram-transform.ts
function transformDiagramNamespace(diagram) {
  const serialized = JSON.stringify(diagram);
  const transformed = replaceDspNamespace(serialized);
  const parsed = JSON.parse(transformed);
  if (!isXmlDocument(parsed)) {
    return null;
  }
  return parsed;
}

// packages/@oxen-office/pptx/src/parser/slide/loader.ts
function loadLayoutData(file, relationships) {
  const layoutPath = findLayoutPath(relationships);
  if (layoutPath === undefined) {
    return {
      layout: null,
      layoutTables: indexShapeTreeNodes(null),
      layoutRelationships: createEmptyResourceMap()
    };
  }
  const layout = readXml(file, layoutPath, 16, false, DEFAULT_MARKUP_COMPATIBILITY_OPTIONS);
  return {
    layout,
    layoutTables: indexShapeTreeNodes(layout),
    layoutRelationships: loadRelationships2(file, layoutPath)
  };
}
function loadMasterData(file, layoutRelationships) {
  const masterPath = findMasterPath(layoutRelationships);
  if (masterPath === undefined) {
    return {
      master: null,
      masterTables: indexShapeTreeNodes(null),
      masterTextStyles: undefined,
      masterRelationships: createEmptyResourceMap()
    };
  }
  const master = readXml(file, masterPath, 16, false, DEFAULT_MARKUP_COMPATIBILITY_OPTIONS);
  return {
    master,
    masterTables: indexShapeTreeNodes(master),
    masterTextStyles: getByPath(master, ["p:sldMaster", "p:txStyles"]),
    masterRelationships: loadRelationships2(file, masterPath)
  };
}
function loadThemeData(file, masterRelationships) {
  const themePath = findThemePath(masterRelationships);
  if (themePath === undefined) {
    return {
      theme: null,
      themeRelationships: createEmptyResourceMap(),
      themeOverrides: []
    };
  }
  const theme = readXml(file, themePath, 16, false, DEFAULT_MARKUP_COMPATIBILITY_OPTIONS);
  const themeOverridePaths = masterRelationships.getAllTargetsByType(RELATIONSHIP_TYPES.THEME_OVERRIDE);
  const themeOverrides = themeOverridePaths.map((path) => readXml(file, path, 16, false, DEFAULT_MARKUP_COMPATIBILITY_OPTIONS)).filter((doc) => doc !== null);
  return {
    theme,
    themeRelationships: loadRelationships2(file, themePath),
    themeOverrides
  };
}
function loadDiagramData(file, relationships) {
  const diagramPath = findDiagramDrawingPath(relationships);
  if (diagramPath === undefined) {
    return { diagram: null, diagramRelationships: createEmptyResourceMap() };
  }
  const rawDiagram = readXml(file, diagramPath, 16, false, DEFAULT_MARKUP_COMPATIBILITY_OPTIONS);
  if (rawDiagram === null) {
    return { diagram: null, diagramRelationships: createEmptyResourceMap() };
  }
  const diagram = transformDiagramNamespace(rawDiagram);
  if (diagram === null) {
    return { diagram: null, diagramRelationships: createEmptyResourceMap() };
  }
  return {
    diagram,
    diagramRelationships: loadRelationships2(file, diagramPath)
  };
}

// packages/@oxen-office/pptx/src/app/open-presentation.ts
function parseSlide2({
  file,
  slideInfo,
  appVersion,
  zipAdapter,
  defaultTextStyle,
  tableStyles,
  slideSize,
  renderOptions
}) {
  const content = readXml(file, slideInfo.path, appVersion, true, DEFAULT_MARKUP_COMPATIBILITY_OPTIONS);
  if (content === null) {
    throw new Error(`Failed to read slide: ${slideInfo.path}`);
  }
  const relationships = getRelationships(file, slideInfo.path, DEFAULT_MARKUP_COMPATIBILITY_OPTIONS);
  const layoutData = loadLayoutData(file, relationships);
  const masterData = loadMasterData(file, layoutData.layoutRelationships);
  const themeData = loadThemeData(file, masterData.masterRelationships);
  const diagramData = loadDiagramData(file, relationships);
  const data = {
    number: slideInfo.number,
    filename: slideInfo.filename,
    content,
    layout: layoutData.layout,
    layoutTables: layoutData.layoutTables,
    master: masterData.master,
    masterTables: masterData.masterTables,
    masterTextStyles: masterData.masterTextStyles,
    theme: themeData.theme,
    relationships,
    layoutRelationships: layoutData.layoutRelationships,
    masterRelationships: masterData.masterRelationships,
    themeRelationships: themeData.themeRelationships,
    themeOverrides: themeData.themeOverrides,
    diagram: diagramData.diagram,
    diagramRelationships: diagramData.diagramRelationships
  };
  return createSlide({ data, zip: zipAdapter, defaultTextStyle, tableStyles, slideSize, renderOptions });
}
function buildSlideFileInfoListFromPresentation(file, presentationXml) {
  const sldIdLst = getByPath(presentationXml, ["p:presentation", "p:sldIdLst"]);
  if (!sldIdLst) {
    throw new Error("ppt/presentation.xml is missing p:sldIdLst (required for slide order)");
  }
  const sldIds = getChildren(sldIdLst, "p:sldId");
  if (sldIds.length === 0) {
    throw new Error("ppt/presentation.xml: p:sldIdLst has no p:sldId entries");
  }
  const presentationRels = getRelationships(file, "ppt/presentation.xml", DEFAULT_MARKUP_COMPATIBILITY_OPTIONS);
  return sldIds.map((sldId, index) => {
    const rId = sldId.attrs["r:id"];
    if (!rId) {
      throw new Error("ppt/presentation.xml: p:sldId is missing r:id");
    }
    const target = presentationRels.getTarget(rId);
    if (!target) {
      throw new Error(`ppt/_rels/presentation.xml.rels: missing Target for ${rId}`);
    }
    const type = presentationRels.getType(rId);
    if (type !== RELATIONSHIP_TYPES.SLIDE) {
      throw new Error(`ppt/_rels/presentation.xml.rels: ${rId} is not a slide relationship (Type=${type ?? "undefined"})`);
    }
    return {
      path: target,
      number: index + 1,
      filename: getBasename(target)
    };
  });
}
function openPresentation(file, options) {
  const renderOptions = options?.renderOptions;
  const zipAdapter = createZipAdapter(file);
  if (readXml(file, "[Content_Types].xml", 16, false, DEFAULT_MARKUP_COMPATIBILITY_OPTIONS) === null) {
    throw new Error("Failed to read [Content_Types].xml");
  }
  const appXml = readXml(file, "docProps/app.xml", 16, false, DEFAULT_MARKUP_COMPATIBILITY_OPTIONS);
  const appVersion = parseAppVersion(appXml);
  const presentationXml = readXml(file, "ppt/presentation.xml", 16, false, DEFAULT_MARKUP_COMPATIBILITY_OPTIONS);
  if (presentationXml === null) {
    throw new Error("Failed to read ppt/presentation.xml");
  }
  const size = parseSlideSizeFromXml(presentationXml);
  const defaultTextStyle = parseDefaultTextStyle(presentationXml);
  const slideFiles = buildSlideFileInfoListFromPresentation(file, presentationXml);
  const tableStylesXml = readXml(file, "ppt/tableStyles.xml", 16, false, DEFAULT_MARKUP_COMPATIBILITY_OPTIONS);
  const tableStylesRoot = tableStylesXml ? getByPath(tableStylesXml, ["a:tblStyleLst"]) : undefined;
  const tableStyles = tableStylesRoot ? parseTableStyleList(tableStylesRoot) ?? null : null;
  const thumbnail = file.readBinary("docProps/thumbnail.jpeg");
  const list = (options2) => {
    const offset = options2?.offset ?? 0;
    const limit = options2?.limit ?? slideFiles.length;
    return slideFiles.slice(offset, offset + limit).map((info) => ({
      number: info.number,
      filename: info.filename
    }));
  };
  const getSlide = (slideNumber) => {
    const slideInfo = slideFiles.find((s) => s.number === slideNumber);
    if (slideInfo === undefined) {
      throw new Error(`Slide ${slideNumber} not found`);
    }
    return parseSlide2({ file, slideInfo, appVersion: appVersion ?? 16, zipAdapter, defaultTextStyle, tableStyles, slideSize: size, renderOptions });
  };
  function* slidesGenerator() {
    for (const slideInfo of slideFiles) {
      yield parseSlide2({ file, slideInfo, appVersion: appVersion ?? 16, zipAdapter, defaultTextStyle, tableStyles, slideSize: size, renderOptions });
    }
  }
  return {
    size,
    count: slideFiles.length,
    thumbnail,
    appVersion,
    defaultTextStyle,
    tableStyles,
    list,
    getSlide,
    slides: slidesGenerator
  };
}

// packages/@oxen-office/pptx/src/app/pptx-loader.ts
async function loadPptxBundleFromBuffer(buffer) {
  if (!buffer) {
    throw new Error("buffer is required");
  }
  const zipPackage = await loadZipPackage(buffer);
  return {
    zipPackage,
    presentationFile: zipPackage.asPresentationFile()
  };
}

// packages/@oxen-office/cfb/src/constants.ts
var CFB_HEADER_SIZE = 512;
var CFB_SIGNATURE = new Uint8Array([208, 207, 17, 224, 161, 177, 26, 225]);
var MAXREGSECT = 4294967289;
var ENDOFCHAIN = 4294967294;
var FREESECT = 4294967295;
var NOSTREAM = 4294967295;

// packages/@oxen-office/cfb/src/errors.ts
class CfbFormatError extends Error {
  name = "CfbFormatError";
}

class CfbUnsupportedError extends Error {
  name = "CfbUnsupportedError";
}

// packages/@oxen-office/cfb/src/parser/header.ts
function bytesEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i2 = 0;i2 < a.length; i2++) {
    if (a[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}
function parseCfbHeader(bytes, opts) {
  if (!(bytes instanceof Uint8Array)) {
    throw new CfbFormatError("openCfb: bytes must be a Uint8Array");
  }
  if (bytes.length < CFB_HEADER_SIZE) {
    throw new CfbFormatError(`CFB header is truncated: ${bytes.length} bytes`);
  }
  const signature = bytes.subarray(0, 8);
  if (!bytesEqual(signature, CFB_SIGNATURE)) {
    throw new CfbFormatError("Invalid CFB signature");
  }
  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  const majorVersion = view.getUint16(26, true);
  if (majorVersion !== 3 && majorVersion !== 4) {
    throw new CfbUnsupportedError(`Unsupported CFB major version: ${majorVersion}`);
  }
  const byteOrder = view.getUint16(28, true);
  if (opts.strict && byteOrder !== 65534) {
    throw new CfbFormatError(`Invalid byte order: 0x${byteOrder.toString(16)}`);
  }
  const sectorShift = view.getUint16(30, true);
  const sectorSize = 1 << sectorShift;
  if (majorVersion === 3 && sectorSize !== 512) {
    throw new CfbFormatError(`Invalid sector size for major version 3: ${sectorSize}`);
  }
  if (majorVersion === 4 && sectorSize !== 4096) {
    throw new CfbFormatError(`Invalid sector size for major version 4: ${sectorSize}`);
  }
  const miniSectorShift = view.getUint16(32, true);
  const miniSectorSize = 1 << miniSectorShift;
  if (opts.strict && miniSectorSize !== 64) {
    throw new CfbFormatError(`Invalid mini sector size: ${miniSectorSize}`);
  }
  const numberOfFatSectors = view.getUint32(44, true);
  const firstDirectorySector = view.getUint32(48, true);
  const miniStreamCutoffSize = view.getUint32(56, true);
  const firstMiniFatSector = view.getUint32(60, true);
  const numberOfMiniFatSectors = view.getUint32(64, true);
  const firstDifatSector = view.getUint32(68, true);
  const numberOfDifatSectors = view.getUint32(72, true);
  if (opts.strict && miniStreamCutoffSize !== 4096) {
    throw new CfbFormatError(`Invalid mini stream cutoff size: ${miniStreamCutoffSize}`);
  }
  const difat = [];
  for (let i2 = 0;i2 < 109; i2++) {
    difat.push(view.getUint32(76 + i2 * 4, true));
  }
  return {
    majorVersion,
    sectorSize,
    miniSectorSize,
    miniStreamCutoffSize,
    numberOfFatSectors,
    firstDirectorySector,
    firstMiniFatSector,
    numberOfMiniFatSectors,
    firstDifatSector,
    numberOfDifatSectors,
    difat
  };
}

// packages/@oxen-office/cfb/src/parser/sector.ts
function getSectorCount(bytes, header) {
  const payloadBytes = bytes.length - CFB_HEADER_SIZE;
  if (payloadBytes < 0) {
    return 0;
  }
  return Math.floor(payloadBytes / header.sectorSize);
}
function assertRegSect(sector, sectorCount, where) {
  if (sector === ENDOFCHAIN || sector === FREESECT) {
    throw new CfbFormatError(`${where}: invalid sector value: 0x${sector.toString(16)}`);
  }
  if (sector > MAXREGSECT) {
    throw new CfbFormatError(`${where}: sector is out of REGSECT range: 0x${sector.toString(16)}`);
  }
  if (sector >= sectorCount) {
    throw new CfbFormatError(`${where}: sector is out of file range: ${sector} >= ${sectorCount}`);
  }
}
function readSector(bytes, header, sectorNumber) {
  const sectorCount = getSectorCount(bytes, header);
  assertRegSect(sectorNumber, sectorCount, "readSector");
  const start = (sectorNumber + 1) * header.sectorSize;
  const end = start + header.sectorSize;
  if (end > bytes.length) {
    throw new CfbFormatError(`readSector: sector ${sectorNumber} is truncated`);
  }
  return bytes.subarray(start, end);
}

// packages/@oxen-office/cfb/src/parser/difat.ts
function buildDifat(bytes, header, opts) {
  const fatSectors = [];
  for (const entry of header.difat) {
    if (entry !== FREESECT) {
      fatSectors.push(entry);
    }
  }
  if (header.numberOfDifatSectors === 0) {
    if (opts.strict && fatSectors.length !== header.numberOfFatSectors) {
      throw new CfbFormatError(`DIFAT count mismatch: header lists ${fatSectors.length}, numberOfFatSectors=${header.numberOfFatSectors}`);
    }
    return fatSectors;
  }
  const chainState = { nextDifatSector: header.firstDifatSector };
  const seen = new Set;
  for (let i2 = 0;i2 < header.numberOfDifatSectors; i2++) {
    const nextDifatSector = chainState.nextDifatSector;
    if (nextDifatSector === ENDOFCHAIN) {
      throw new CfbFormatError("DIFAT chain ended early");
    }
    if (seen.has(nextDifatSector)) {
      throw new CfbFormatError("DIFAT chain has a cycle");
    }
    seen.add(nextDifatSector);
    const sector = readSector(bytes, header, nextDifatSector);
    const view = new DataView(sector.buffer, sector.byteOffset, sector.byteLength);
    const entriesPerSector = header.sectorSize / 4;
    for (let j = 0;j < entriesPerSector - 1; j++) {
      const v = view.getUint32(j * 4, true);
      if (v !== FREESECT) {
        fatSectors.push(v);
      }
    }
    chainState.nextDifatSector = view.getUint32((entriesPerSector - 1) * 4, true);
  }
  if (opts.strict && chainState.nextDifatSector !== ENDOFCHAIN) {
    throw new CfbFormatError("DIFAT chain did not end with ENDOFCHAIN");
  }
  if (opts.strict && fatSectors.length !== header.numberOfFatSectors) {
    throw new CfbFormatError(`DIFAT count mismatch: collected ${fatSectors.length}, numberOfFatSectors=${header.numberOfFatSectors}`);
  }
  return fatSectors;
}

// packages/@oxen-office/cfb/src/parser/fat.ts
function buildFat(bytes, header, difat) {
  const entries = [];
  for (const sectorNumber of difat) {
    const sector = readSector(bytes, header, sectorNumber);
    const view = new DataView(sector.buffer, sector.byteOffset, sector.byteLength);
    for (let i2 = 0;i2 < header.sectorSize; i2 += 4) {
      entries.push(view.getUint32(i2, true));
    }
  }
  if (entries.length === 0) {
    throw new CfbFormatError("FAT is empty");
  }
  return new Uint32Array(entries);
}
function fatGet(fat, sectorNumber) {
  const v = fat[sectorNumber];
  return v === undefined ? FREESECT : v;
}

// packages/@oxen-office/cfb/src/parser/chain.ts
function walkFatChain(fat, startSector, opts) {
  const out = [];
  const visited = new Set;
  for (let steps = 0, current = startSector;steps < opts.maxSteps; steps++) {
    if (current === ENDOFCHAIN) {
      return out;
    }
    if (current === FREESECT) {
      throw new CfbFormatError("FAT chain encountered FREESECT");
    }
    if (current > MAXREGSECT) {
      throw new CfbFormatError(`FAT chain encountered reserved value: 0x${current.toString(16)}`);
    }
    if (visited.has(current)) {
      throw new CfbFormatError("FAT chain has a cycle");
    }
    visited.add(current);
    out.push(current);
    current = fatGet(fat, current);
  }
  throw new CfbFormatError("FAT chain exceeded max steps");
}
function walkMiniFatChain(miniFat, startMiniSector, opts) {
  const out = [];
  const visited = new Set;
  for (let steps = 0, current = startMiniSector;steps < opts.maxSteps; steps++) {
    if (current === ENDOFCHAIN) {
      return out;
    }
    if (current === FREESECT) {
      throw new CfbFormatError("MiniFAT chain encountered FREESECT");
    }
    if (current > MAXREGSECT) {
      throw new CfbFormatError(`MiniFAT chain encountered reserved value: 0x${current.toString(16)}`);
    }
    if (visited.has(current)) {
      throw new CfbFormatError("MiniFAT chain has a cycle");
    }
    visited.add(current);
    out.push(current);
    current = miniFat[current] ?? FREESECT;
  }
  throw new CfbFormatError("MiniFAT chain exceeded max steps");
}

// packages/@oxen-office/cfb/src/parser/streams.ts
function assertSafeSize(size, where) {
  if (size < 0n) {
    throw new CfbFormatError(`${where}: negative stream size`);
  }
  if (size > BigInt(Number.MAX_SAFE_INTEGER)) {
    throw new CfbFormatError(`${where}: stream size too large for JS: ${size.toString()}`);
  }
  return Number(size);
}
function requireWarningSink(opts, where) {
  if (opts.strict) {
    throw new Error(`${where}: internal error (warning sink required only in non-strict mode)`);
  }
  if (!opts.onWarning) {
    throw new Error(`${where}: non-strict mode requires onWarning sink`);
  }
  return opts.onWarning;
}
function readFatChainOrFallback(params) {
  const { fat, startSector, requiredSectors, opts } = params;
  try {
    return walkFatChain(fat, startSector, { maxSteps: requiredSectors + 1e4 });
  } catch (err2) {
    if (opts.strict) {
      throw err2;
    }
    const onWarning = requireWarningSink(opts, "readStreamFromFat");
    onWarning({
      code: "FAT_CHAIN_INVALID",
      where: "readStreamFromFat",
      message: `FAT chain walk failed; returning zero-filled stream: ${err2 instanceof Error ? err2.message : String(err2)}`,
      meta: { startSector, required: requiredSectors }
    });
    return [];
  }
}
function readMiniFatChainOrFallback(params) {
  const { miniFat, startMiniSector, requiredSectors, opts } = params;
  try {
    return walkMiniFatChain(miniFat, startMiniSector, { maxSteps: requiredSectors + 1e4 });
  } catch (err2) {
    if (opts.strict) {
      throw err2;
    }
    const onWarning = requireWarningSink(opts, "readStreamFromMiniFat");
    onWarning({
      code: "MINIFAT_CHAIN_INVALID",
      where: "readStreamFromMiniFat",
      message: `MiniFAT chain walk failed; returning zero-filled stream: ${err2 instanceof Error ? err2.message : String(err2)}`,
      meta: { startMiniSector, required: requiredSectors }
    });
    return [];
  }
}
function readStreamFromFat(params) {
  const { bytes, header, fat, startSector, streamSize, opts } = params;
  const size = assertSafeSize(streamSize, "readStreamFromFat");
  if (size === 0) {
    return new Uint8Array;
  }
  if (startSector === ENDOFCHAIN) {
    throw new CfbFormatError("readStreamFromFat: non-empty stream has ENDOFCHAIN as starting sector");
  }
  const requiredSectors = Math.ceil(size / header.sectorSize);
  const out = new Uint8Array(requiredSectors * header.sectorSize);
  const chain = readFatChainOrFallback({ fat, startSector, requiredSectors, opts });
  if (chain.length < requiredSectors) {
    try {
      throw new CfbFormatError(`readStreamFromFat: chain too short: ${chain.length} < ${requiredSectors}`);
    } catch (err2) {
      if (opts.strict) {
        throw err2;
      }
      const onWarning = requireWarningSink(opts, "readStreamFromFat");
      onWarning({
        code: "FAT_CHAIN_TOO_SHORT",
        where: "readStreamFromFat",
        message: `FAT chain too short; zero-filling missing sectors: chain=${chain.length}, required=${requiredSectors}`,
        meta: { chain: chain.length, required: requiredSectors, startSector }
      });
    }
  } else if (chain.length !== requiredSectors) {
    try {
      throw new CfbFormatError(`readStreamFromFat: chain length mismatch: ${chain.length} !== ${requiredSectors}`);
    } catch (err2) {
      if (opts.strict) {
        throw err2;
      }
      const onWarning = requireWarningSink(opts, "readStreamFromFat");
      onWarning({
        code: "FAT_CHAIN_LENGTH_MISMATCH",
        where: "readStreamFromFat",
        message: `FAT chain length mismatch; using first required sectors: chain=${chain.length}, required=${requiredSectors}`,
        meta: { chain: chain.length, required: requiredSectors, startSector }
      });
    }
  }
  for (let i2 = 0;i2 < requiredSectors; i2++) {
    const sectorNumber = chain[i2];
    if (sectorNumber === undefined) {
      break;
    }
    try {
      out.set(readSector(bytes, header, sectorNumber), i2 * header.sectorSize);
    } catch (err2) {
      if (opts.strict) {
        throw err2;
      }
      const onWarning = requireWarningSink(opts, "readStreamFromFat");
      onWarning({
        code: "FAT_SECTOR_READ_FAILED",
        where: "readStreamFromFat",
        message: `Failed to read FAT sector; truncating stream read and zero-filling remainder: sector=${sectorNumber}`,
        meta: { sectorNumber, sectorIndex: i2, startSector }
      });
      break;
    }
  }
  return out.subarray(0, size);
}
function readDirectoryStreamBytes(bytes, header, fat) {
  if (header.firstDirectorySector === ENDOFCHAIN) {
    throw new CfbFormatError("Directory stream missing (firstDirectorySector=ENDOFCHAIN)");
  }
  const chain = walkFatChain(fat, header.firstDirectorySector, { maxSteps: 1e6 });
  if (chain.length === 0) {
    throw new CfbFormatError("Directory stream chain is empty");
  }
  const out = new Uint8Array(chain.length * header.sectorSize);
  for (const [i2, sectorNumber] of chain.entries()) {
    out.set(readSector(bytes, header, sectorNumber), i2 * header.sectorSize);
  }
  return out;
}
function readStreamFromMiniFat(params) {
  const { miniFat, miniStreamBytes, header, startMiniSector, streamSize, opts } = params;
  const size = assertSafeSize(streamSize, "readStreamFromMiniFat");
  if (size === 0) {
    return new Uint8Array;
  }
  const requiredSectors = Math.ceil(size / header.miniSectorSize);
  const out = new Uint8Array(requiredSectors * header.miniSectorSize);
  const chain = readMiniFatChainOrFallback({ miniFat, startMiniSector, requiredSectors, opts });
  if (chain.length < requiredSectors) {
    try {
      throw new CfbFormatError(`readStreamFromMiniFat: chain too short: ${chain.length} < ${requiredSectors}`);
    } catch (err2) {
      if (opts.strict) {
        throw err2;
      }
      const onWarning = requireWarningSink(opts, "readStreamFromMiniFat");
      onWarning({
        code: "MINIFAT_CHAIN_TOO_SHORT",
        where: "readStreamFromMiniFat",
        message: `MiniFAT chain too short; zero-filling missing mini sectors: chain=${chain.length}, required=${requiredSectors}`,
        meta: { chain: chain.length, required: requiredSectors, startMiniSector }
      });
    }
  } else if (chain.length !== requiredSectors) {
    try {
      throw new CfbFormatError(`readStreamFromMiniFat: chain length mismatch: ${chain.length} !== ${requiredSectors}`);
    } catch (err2) {
      if (opts.strict) {
        throw err2;
      }
      const onWarning = requireWarningSink(opts, "readStreamFromMiniFat");
      onWarning({
        code: "MINIFAT_CHAIN_LENGTH_MISMATCH",
        where: "readStreamFromMiniFat",
        message: `MiniFAT chain length mismatch; using first required mini sectors: chain=${chain.length}, required=${requiredSectors}`,
        meta: { chain: chain.length, required: requiredSectors, startMiniSector }
      });
    }
  }
  for (let i2 = 0;i2 < requiredSectors; i2++) {
    const miniSectorNumber = chain[i2];
    if (miniSectorNumber === undefined) {
      break;
    }
    const start = miniSectorNumber * header.miniSectorSize;
    const end = start + header.miniSectorSize;
    if (end > miniStreamBytes.length) {
      try {
        throw new CfbFormatError("readStreamFromMiniFat: mini stream is truncated");
      } catch (err2) {
        if (opts.strict) {
          throw err2;
        }
        const onWarning = requireWarningSink(opts, "readStreamFromMiniFat");
        onWarning({
          code: "MINISTREAM_TRUNCATED",
          where: "readStreamFromMiniFat",
          message: "Mini stream is truncated; truncating read and zero-filling remainder.",
          meta: { miniStreamBytes: miniStreamBytes.length, end, startMiniSector, miniSectorNumber, miniSectorIndex: i2 }
        });
      }
      break;
    }
    out.set(miniStreamBytes.subarray(start, end), i2 * header.miniSectorSize);
  }
  return out.subarray(0, size);
}

// packages/@oxen-office/cfb/src/parser/directory.ts
function parseDirectoryEntryType(v) {
  switch (v) {
    case 0:
      return "unused";
    case 1:
      return "storage";
    case 2:
      return "stream";
    case 5:
      return "root";
    default:
      throw new CfbFormatError(`Unknown directory entry type: 0x${v.toString(16)}`);
  }
}
function parseUtf16leName(bytes, nameLenBytes) {
  if (nameLenBytes < 2) {
    return "";
  }
  if (nameLenBytes > 64) {
    throw new CfbFormatError(`Invalid directory name length: ${nameLenBytes}`);
  }
  const dataBytes = nameLenBytes - 2;
  const nameBytes = bytes.subarray(0, dataBytes);
  const decoder = new TextDecoder("utf-16le");
  return decoder.decode(nameBytes);
}
function parseDirectoryStream(directoryBytes) {
  if (directoryBytes.length % 128 !== 0) {}
  const entries = [];
  const view = new DataView(directoryBytes.buffer, directoryBytes.byteOffset, directoryBytes.byteLength);
  const count = Math.floor(directoryBytes.length / 128);
  for (let i2 = 0;i2 < count; i2++) {
    const base = i2 * 128;
    const nameBytes = directoryBytes.subarray(base, base + 64);
    const nameLenBytes = view.getUint16(base + 64, true);
    const objectType = view.getUint8(base + 66);
    const leftSiblingId = view.getUint32(base + 68, true);
    const rightSiblingId = view.getUint32(base + 72, true);
    const childId = view.getUint32(base + 76, true);
    const startingSector = view.getUint32(base + 116, true);
    const streamSize = view.getBigUint64(base + 120, true);
    const type = parseDirectoryEntryType(objectType);
    const name = parseUtf16leName(nameBytes, nameLenBytes);
    entries.push({
      id: i2,
      name,
      type,
      leftSiblingId,
      rightSiblingId,
      childId,
      startingSector,
      streamSize
    });
  }
  return entries;
}

// packages/@oxen-office/cfb/src/runner.ts
function normalizeName(name) {
  return name.toUpperCase();
}
function assertEntryId(entries, id, where) {
  const entry = entries[id];
  if (!entry) {
    throw new CfbFormatError(`${where}: entry id out of range: ${id}`);
  }
  return entry;
}
function walkRbTreeInOrder(entries, rootId) {
  const out = [];
  const visited = new Set;
  function visit(id) {
    if (id === NOSTREAM) {
      return;
    }
    if (visited.has(id)) {
      throw new CfbFormatError("Directory tree has a cycle");
    }
    visited.add(id);
    const entry = assertEntryId(entries, id, "Directory tree");
    visit(entry.leftSiblingId);
    out.push(id);
    visit(entry.rightSiblingId);
  }
  visit(rootId);
  return out;
}
function buildChildIndex(entries, storageId) {
  const storage = assertEntryId(entries, storageId, "buildChildIndex");
  if (storage.type !== "root" && storage.type !== "storage") {
    throw new CfbFormatError(`buildChildIndex: entry ${storageId} is not a storage/root`);
  }
  if (storage.childId === NOSTREAM) {
    return new Map;
  }
  const childIds = walkRbTreeInOrder(entries, storage.childId);
  const map = new Map;
  for (const childId of childIds) {
    const child = assertEntryId(entries, childId, "buildChildIndex");
    if (child.type !== "storage" && child.type !== "stream") {
      continue;
    }
    const key = normalizeName(child.name);
    if (map.has(key)) {
      throw new CfbFormatError(`Duplicate child name in storage ${storageId}: ${child.name}`);
    }
    map.set(key, childId);
  }
  return map;
}
function createCfbRunner(args) {
  const childIndexByStorageId = new Map;
  function getEntryById(id) {
    return args.directory[id];
  }
  function getChildIndex(storageId) {
    const cached = childIndexByStorageId.get(storageId);
    if (cached) {
      return cached;
    }
    const built = buildChildIndex(args.directory, storageId);
    childIndexByStorageId.set(storageId, built);
    return built;
  }
  function getEntry(path) {
    if (!Array.isArray(path) || path.length === 0) {
      throw new CfbFormatError("getEntry: path must be a non-empty string[]");
    }
    const cursor = { currentId: 0 };
    for (let i2 = 0;i2 < path.length; i2++) {
      const part = path[i2];
      if (!part) {
        throw new CfbFormatError("getEntry: path contains empty segment");
      }
      const index = getChildIndex(cursor.currentId);
      const nextId = index.get(normalizeName(part));
      if (nextId === undefined) {
        throw new CfbFormatError(`Path not found: ${path.join("/")}`);
      }
      const entry = assertEntryId(args.directory, nextId, "getEntry");
      const isLast = i2 === path.length - 1;
      if (!isLast && entry.type !== "storage") {
        throw new CfbFormatError(`Path segment is not a storage: ${part}`);
      }
      cursor.currentId = nextId;
    }
    return assertEntryId(args.directory, cursor.currentId, "getEntry");
  }
  function list(path) {
    const storage = path ? getEntry(path) : assertEntryId(args.directory, 0, "list");
    if (storage.type !== "root" && storage.type !== "storage") {
      throw new CfbFormatError("list: path must refer to a storage/root");
    }
    const index = getChildIndex(storage.id);
    const out = [];
    for (const id of index.values()) {
      const entry = assertEntryId(args.directory, id, "list");
      if (entry.type === "storage" || entry.type === "stream") {
        out.push({ name: entry.name, type: entry.type });
      }
    }
    out.sort((a, b) => a.name.localeCompare(b.name));
    return out;
  }
  function readStreamByEntry(entry) {
    if (entry.type !== "stream") {
      throw new CfbFormatError(`readStream: entry is not a stream: ${entry.name}`);
    }
    const isMini = entry.streamSize < BigInt(args.header.miniStreamCutoffSize);
    if (!isMini) {
      return readStreamFromFat({ bytes: args.bytes, header: args.header, fat: args.fat, startSector: entry.startingSector, streamSize: entry.streamSize, opts: { strict: args.strict, ...args.onWarning ? { onWarning: args.onWarning } : {} } });
    }
    if (!args.miniFat || !args.miniStreamBytes) {
      throw new CfbFormatError(`readStream: mini stream data not available for ${entry.name}`);
    }
    if (entry.startingSector === ENDOFCHAIN && entry.streamSize !== 0n) {
      throw new CfbFormatError("readStream: non-empty mini stream has ENDOFCHAIN as starting sector");
    }
    return readStreamFromMiniFat({ miniFat: args.miniFat, miniStreamBytes: args.miniStreamBytes, header: args.header, startMiniSector: entry.startingSector, streamSize: entry.streamSize, opts: { strict: args.strict, ...args.onWarning ? { onWarning: args.onWarning } : {} } });
  }
  function readStream(path) {
    const entry = getEntry(path);
    return readStreamByEntry(entry);
  }
  function readStreamText(path, enc) {
    const bytes = readStream(path);
    const decoder = new TextDecoder(enc);
    return decoder.decode(bytes);
  }
  const root = assertEntryId(args.directory, 0, "createCfbRunner");
  if (args.strict && root.type !== "root") {
    throw new CfbFormatError("Directory entry 0 must be the root entry");
  }
  return {
    header: args.header,
    directory: args.directory,
    getEntryById,
    getEntry,
    list,
    readStream,
    readStreamText
  };
}

// packages/@oxen-office/cfb/src/warnings.ts
function warnCfbOrThrow(opts, warning, strictError) {
  if (opts.strict) {
    throw strictError;
  }
  if (!opts.onWarning) {
    throw new Error(`non-strict CFB mode requires onWarning sink: ${warning.code} (${warning.where})`);
  }
  opts.onWarning(warning);
}

// packages/@oxen-office/cfb/src/index.ts
function walkFatChainOrEmpty(args) {
  try {
    return walkFatChain(args.fat, args.startSector, { maxSteps: args.expectedSectors + 1e4 });
  } catch (err2) {
    warnCfbOrThrow(args.opts, {
      code: "MINIFAT_CHAIN_INVALID",
      where: args.where,
      message: `MiniFAT chain walk failed; treating MiniFAT as empty: ${err2 instanceof Error ? err2.message : String(err2)}`,
      meta: { firstMiniFatSector: args.startSector, miniFatSectors: args.expectedSectors }
    }, err2 instanceof Error ? err2 : new Error(String(err2)));
    return [];
  }
}
function tryReadSectorOrTruncate(args) {
  try {
    return readSector(args.bytes, args.header, args.sectorNumber);
  } catch (err2) {
    warnCfbOrThrow(args.opts, {
      code: "FAT_SECTOR_READ_FAILED",
      where: args.where,
      message: `Failed to read MiniFAT sector; truncating MiniFAT: sector=${args.sectorNumber}`,
      meta: { sectorNumber: args.sectorNumber, sectorIndex: args.sectorIndex }
    }, err2 instanceof Error ? err2 : new Error(String(err2)));
    return;
  }
}
function openCfb(bytes, opts) {
  const strict = opts?.strict ?? true;
  const onWarning = opts?.onWarning;
  if (!strict && !onWarning) {
    throw new Error("openCfb: non-strict mode requires onWarning sink");
  }
  const header = parseCfbHeader(bytes, { strict });
  const difat = buildDifat(bytes, header, { strict });
  const fat = buildFat(bytes, header, difat);
  const directoryBytes = readDirectoryStreamBytes(bytes, header, fat);
  const directory = parseDirectoryStream(directoryBytes);
  const mini = {};
  if (header.firstMiniFatSector !== ENDOFCHAIN) {
    const miniFatSectors = header.numberOfMiniFatSectors;
    const optsForRead = { strict, ...onWarning ? { onWarning } : {} };
    const chain = walkFatChainOrEmpty({ fat, startSector: header.firstMiniFatSector, expectedSectors: miniFatSectors, opts: optsForRead, where: "openCfb:MiniFAT" });
    if (chain.length < miniFatSectors) {
      warnCfbOrThrow(optsForRead, {
        code: "MINIFAT_CHAIN_TOO_SHORT",
        where: "openCfb:MiniFAT",
        message: `MiniFAT chain too short; truncating: chain=${chain.length}, required=${miniFatSectors}`,
        meta: { chain: chain.length, required: miniFatSectors }
      }, new CfbFormatError(`MiniFAT chain too short: ${chain.length} < ${miniFatSectors}`));
    } else if (chain.length !== miniFatSectors) {
      warnCfbOrThrow(optsForRead, {
        code: "MINIFAT_CHAIN_LENGTH_MISMATCH",
        where: "openCfb:MiniFAT",
        message: `MiniFAT chain length mismatch; using first required sectors: chain=${chain.length}, required=${miniFatSectors}`,
        meta: { chain: chain.length, required: miniFatSectors }
      }, new CfbFormatError(`MiniFAT chain length mismatch: ${chain.length} !== ${miniFatSectors}`));
    }
    const entryCount = miniFatSectors * header.sectorSize / 4;
    const entries = new Uint32Array(entryCount);
    entries.fill(ENDOFCHAIN);
    for (let sectorIndex = 0;sectorIndex < miniFatSectors; sectorIndex++) {
      const sectorNumber = chain[sectorIndex];
      if (sectorNumber === undefined) {
        break;
      }
      const sectorBytes = tryReadSectorOrTruncate({ bytes, header, sectorNumber, sectorIndex, opts: optsForRead, where: "openCfb:MiniFAT" });
      if (!sectorBytes) {
        break;
      }
      const view = new DataView(sectorBytes.buffer, sectorBytes.byteOffset, sectorBytes.byteLength);
      const baseEntry = sectorIndex * header.sectorSize / 4;
      for (let i2 = 0;i2 < header.sectorSize; i2 += 4) {
        const idx = baseEntry + i2 / 4;
        if (idx >= entries.length) {
          break;
        }
        entries[idx] = view.getUint32(i2, true);
      }
    }
    mini.miniFat = entries;
  }
  const root = directory[0];
  if (root && root.type === "root" && root.streamSize > 0n) {
    mini.miniStreamBytes = readStreamFromFat({ bytes, header, fat, startSector: root.startingSector, streamSize: root.streamSize, opts: { strict, ...onWarning ? { onWarning } : {} } });
  }
  return createCfbRunner({ bytes, header, directory, fat, miniFat: mini.miniFat, miniStreamBytes: mini.miniStreamBytes, strict, ...onWarning ? { onWarning } : {} });
}

// packages/@oxen-office/ppt/src/parse-context.ts
function isStrict(ctx) {
  return ctx.mode === "strict";
}
function warnOrThrow(ctx, warning, strictError) {
  if (isStrict(ctx)) {
    throw strictError;
  }
  if (!ctx.warn) {
    throw new Error(`lenient mode requires warn sink: ${warning.code} (${warning.where})`);
  }
  ctx.warn(warning);
}

// packages/@oxen-office/ppt/src/warnings.ts
function createPptWarningCollector() {
  const warnings = [];
  return {
    warn: (warning) => {
      warnings.push(warning);
    },
    warnings
  };
}

// packages/@oxen-office/ppt/src/records/record-types.ts
var RT = {
  DocumentContainer: 1000,
  DocumentAtom: 1001,
  EndDocumentAtom: 1002,
  SlideListWithText: 4080,
  SlidePersistAtom: 1011,
  Environment: 1010,
  SlideContainer: 1006,
  SlideAtom: 1007,
  NotesContainer: 1008,
  NotesAtom: 1009,
  MainMasterContainer: 1016,
  MainMasterAtom: 1017,
  TextHeaderAtom: 3999,
  TextCharsAtom: 4000,
  StyleTextPropAtom: 4001,
  TextRulerAtom: 4002,
  MasterTextPropAtom: 4003,
  TextBookmarkAtom: 4007,
  TextBytesAtom: 4008,
  TextSpecialInfoAtom: 4010,
  InteractiveInfoAtom: 4082,
  InteractiveInfoInstance: 4083,
  TxInteractiveInfoAtom: 4063,
  FontEntityAtom: 4023,
  FontCollection: 2005,
  OfficeArtDggContainer: 61440,
  OfficeArtBStoreContainer: 61441,
  OfficeArtDgContainer: 61442,
  OfficeArtSpgrContainer: 61443,
  OfficeArtSpContainer: 61444,
  OfficeArtFDGG: 61446,
  OfficeArtBStoreEntry: 61447,
  OfficeArtFDG: 61448,
  OfficeArtFSPGR: 61449,
  OfficeArtFSP: 61450,
  OfficeArtFOPT: 61451,
  OfficeArtClientTextbox: 61453,
  OfficeArtChildAnchor: 61455,
  OfficeArtClientAnchor: 61456,
  OfficeArtClientData: 61457,
  OfficeArtSecondaryFOPT: 61729,
  OfficeArtTertiaryFOPT: 61730,
  OfficeArtBlipEMF: 61466,
  OfficeArtBlipWMF: 61467,
  OfficeArtBlipPICT: 61468,
  OfficeArtBlipJPEG1: 61469,
  OfficeArtBlipPNG: 61470,
  OfficeArtBlipDIB: 61471,
  OfficeArtBlipTIFF: 61481,
  OfficeArtBlipJPEG2: 61482,
  CurrentUserAtom: 4086,
  UserEditAtom: 4085,
  PersistDirectoryAtom: 6002,
  ColorSchemeAtom: 2032,
  ExternalHyperlinkContainer: 4055,
  ExternalHyperlinkAtom: 4051,
  ExternalOleLink: 4049,
  ExObjListContainer: 1033,
  ExObjListAtom: 1034,
  CString: 4026,
  PP10ShapeGroup: 5097,
  PPDrawing: 1036,
  HeadersFootersContainer: 4057,
  HeadersFootersAtom: 4058,
  NotesTextViewInfoAtom: 3994,
  ExOleEmbedContainer: 4044,
  ExOleEmbedAtom: 4045,
  ExOleObjAtom: 4035,
  ExternalOleObjectAtom: 4033
};

// packages/@oxen-office/ppt/src/records/record-reader.ts
var RECORD_HEADER_SIZE = 8;
function formatHex(value) {
  return `0x${value.toString(16).padStart(4, "0")}`;
}
function readPptRecord(bytes, offset) {
  if (!Number.isInteger(offset) || offset < 0) {
    throw new Error(`Invalid PPT record offset: ${offset}`);
  }
  if (offset + RECORD_HEADER_SIZE > bytes.length) {
    throw new Error(`Truncated PPT record header at offset ${offset} (need ${RECORD_HEADER_SIZE} bytes, have ${bytes.length - offset})`);
  }
  const view = new DataView(bytes.buffer, bytes.byteOffset + offset, RECORD_HEADER_SIZE);
  const verAndInstance = view.getUint16(0, true);
  const recVer = verAndInstance & 15;
  const recInstance = verAndInstance >> 4 & 4095;
  const recType = view.getUint16(2, true);
  const recLen = view.getUint32(4, true);
  const dataStart = offset + RECORD_HEADER_SIZE;
  const dataEnd = dataStart + recLen;
  if (dataEnd > bytes.length) {
    throw new Error(`Truncated PPT record data for type ${formatHex(recType)} at offset ${offset} (need ${recLen} bytes, have ${bytes.length - dataStart})`);
  }
  return {
    recVer,
    recInstance,
    recType,
    recLen,
    data: bytes.subarray(dataStart, dataEnd),
    offset
  };
}

// packages/@oxen-office/ppt/src/records/container-parser.ts
function parsePptRecordTree(bytes, offset) {
  const record = readPptRecord(bytes, offset);
  if (record.recVer === 15) {
    const children = parseContainerChildren(bytes, offset + RECORD_HEADER_SIZE, offset + RECORD_HEADER_SIZE + record.recLen);
    return { ...record, children };
  }
  return record;
}
function parseContainerChildren(bytes, startOffset, endOffset) {
  const children = [];
  let pos = startOffset;
  while (pos + RECORD_HEADER_SIZE <= endOffset) {
    const child = parsePptRecordTree(bytes, pos);
    children.push(child);
    pos += RECORD_HEADER_SIZE + child.recLen;
  }
  return children;
}

// packages/@oxen-office/ppt/src/records/record-iterator.ts
function findChildByType(children, recType) {
  return children.find((c) => c.recType === recType);
}
function findChildrenByType(children, recType) {
  return children.filter((c) => c.recType === recType);
}

// packages/@oxen-office/ppt/src/records/atoms/slide.ts
function parseSlidePersistAtom(record) {
  if (record.recType !== RT.SlidePersistAtom) {
    throw new Error(`Expected SlidePersistAtom (0x03F3), got 0x${record.recType.toString(16)}`);
  }
  const view = new DataView(record.data.buffer, record.data.byteOffset, record.data.byteLength);
  return {
    persistIdRef: view.getUint32(0, true),
    flags: view.getUint32(4, true),
    numberOfTexts: view.getInt32(8, true),
    slideId: view.getInt32(12, true),
    reserved: view.getUint32(16, true)
  };
}

// packages/@oxen-office/ppt/src/stream/ppt-stream.ts
function parseCurrentUserStream(bytes) {
  const record = readPptRecord(bytes, 0);
  if (record.recType !== RT.CurrentUserAtom) {
    throw new Error(`Expected CurrentUserAtom (0x0FF6), got 0x${record.recType.toString(16)}`);
  }
  const view = new DataView(record.data.buffer, record.data.byteOffset, record.data.byteLength);
  const offsetToCurrentEdit = view.getUint32(8, true);
  return offsetToCurrentEdit;
}
function buildPersistDirectory(docStream, firstUserEditOffset, ctx) {
  const persistDir = new Map;
  let docPersistIdRef = 1;
  let currentOffset = firstUserEditOffset;
  const visited = new Set;
  while (currentOffset !== 0 && !visited.has(currentOffset)) {
    visited.add(currentOffset);
    if (currentOffset + RECORD_HEADER_SIZE > docStream.length) {
      warnOrThrow(ctx, { code: "PPT_PERSIST_OFFSET_INVALID", where: "buildPersistDirectory", message: `UserEditAtom offset ${currentOffset} out of range` }, new Error(`UserEditAtom offset ${currentOffset} out of range`));
      break;
    }
    const userEditRecord = readPptRecord(docStream, currentOffset);
    if (userEditRecord.recType !== RT.UserEditAtom) {
      warnOrThrow(ctx, { code: "PPT_PERSIST_OFFSET_INVALID", where: "buildPersistDirectory", message: `Expected UserEditAtom at offset ${currentOffset}, got 0x${userEditRecord.recType.toString(16)}` }, new Error(`Expected UserEditAtom at offset ${currentOffset}`));
      break;
    }
    const ueView = new DataView(userEditRecord.data.buffer, userEditRecord.data.byteOffset, userEditRecord.data.byteLength);
    const offsetLastEdit = ueView.getUint32(8, true);
    const offsetPersistDir = ueView.getUint32(12, true);
    docPersistIdRef = ueView.getUint32(16, true);
    if (offsetPersistDir + RECORD_HEADER_SIZE <= docStream.length) {
      const pdRecord = readPptRecord(docStream, offsetPersistDir);
      if (pdRecord.recType === RT.PersistDirectoryAtom) {
        parsePersistDirectoryEntries(pdRecord, persistDir);
      }
    }
    currentOffset = offsetLastEdit;
  }
  return { persistDir, docPersistIdRef };
}
function parsePersistDirectoryEntries(record, target) {
  const view = new DataView(record.data.buffer, record.data.byteOffset, record.data.byteLength);
  let offset = 0;
  while (offset + 4 <= record.data.byteLength) {
    const packed = view.getUint32(offset, true);
    offset += 4;
    const startPersistId = packed & 1048575;
    const count = packed >> 20 & 4095;
    for (let i2 = 0;i2 < count && offset + 4 <= record.data.byteLength; i2++) {
      const streamOffset = view.getUint32(offset, true);
      offset += 4;
      target.set(startPersistId + i2, streamOffset);
    }
  }
}
function parsePptDocumentStream(docStream, currentUserStream, ctx) {
  let firstUserEditOffset;
  if (currentUserStream && currentUserStream.length > 0) {
    firstUserEditOffset = parseCurrentUserStream(currentUserStream);
  } else {
    firstUserEditOffset = findLastUserEditAtom(docStream);
  }
  const { persistDir, docPersistIdRef } = buildPersistDirectory(docStream, firstUserEditOffset, ctx);
  const docOffset = persistDir.get(docPersistIdRef);
  if (docOffset === undefined) {
    throw new Error(`DocumentContainer persist ID ${docPersistIdRef} not found in persist directory`);
  }
  const documentRecord = parsePptRecordTree(docStream, docOffset);
  if (documentRecord.recType !== RT.DocumentContainer) {
    throw new Error(`Expected DocumentContainer at offset ${docOffset}, got 0x${documentRecord.recType.toString(16)}`);
  }
  const slideListWithTexts = findChildrenByType(documentRecord.children ?? [], RT.SlideListWithText);
  const slidePersists = [];
  const notesPersists = [];
  for (const slt of slideListWithTexts) {
    const persistAtoms = findChildrenByType(slt.children ?? [], RT.SlidePersistAtom);
    const parsedPersists = persistAtoms.map((a) => parseSlidePersistAtom(a));
    if (slt.recInstance === 0) {
      slidePersists.push(...parsedPersists);
    } else if (slt.recInstance === 2) {
      notesPersists.push(...parsedPersists);
    }
  }
  const slideRecords = [];
  for (const sp of slidePersists) {
    const slideOffset = persistDir.get(sp.persistIdRef);
    if (slideOffset === undefined) {
      warnOrThrow(ctx, { code: "PPT_SLIDE_PARSE_FAILED", where: "parsePptDocumentStream", message: `Slide persist ID ${sp.persistIdRef} not found`, meta: { persistId: sp.persistIdRef } }, new Error(`Slide persist ID ${sp.persistIdRef} not found`));
      continue;
    }
    try {
      const slideRecord = parsePptRecordTree(docStream, slideOffset);
      slideRecords.push(slideRecord);
    } catch (err2) {
      warnOrThrow(ctx, { code: "PPT_SLIDE_PARSE_FAILED", where: "parsePptDocumentStream", message: `Failed to parse slide at offset ${slideOffset}: ${err2 instanceof Error ? err2.message : String(err2)}` }, err2 instanceof Error ? err2 : new Error(String(err2)));
    }
  }
  const noteRecords = [];
  for (const np of notesPersists) {
    const notesOffset = persistDir.get(np.persistIdRef);
    if (notesOffset === undefined)
      continue;
    try {
      const notesRecord = parsePptRecordTree(docStream, notesOffset);
      noteRecords.push(notesRecord);
    } catch {}
  }
  const masterRecords = [];
  for (const [, offset] of persistDir) {
    if (offset + RECORD_HEADER_SIZE > docStream.length)
      continue;
    try {
      const rec = readPptRecord(docStream, offset);
      if (rec.recType === RT.MainMasterContainer) {
        masterRecords.push(parsePptRecordTree(docStream, offset));
      }
    } catch {}
  }
  return {
    documentRecord,
    slideRecords,
    slidePersists,
    persistDirectory: persistDir,
    noteRecords,
    masterRecords
  };
}
function findLastUserEditAtom(docStream) {
  for (let offset = docStream.length - RECORD_HEADER_SIZE;offset >= 0; offset--) {
    try {
      const record = readPptRecord(docStream, offset);
      if (record.recType === RT.UserEditAtom && record.recLen >= 20 && record.recLen <= 32) {
        return offset;
      }
    } catch {}
  }
  throw new Error("Could not find UserEditAtom in PowerPoint Document stream");
}

// packages/@oxen-office/ppt/src/records/atoms/picture.ts
var BLIP_INFO = {
  [RT.OfficeArtBlipJPEG1]: { contentType: "image/jpeg", headerSize1: 17, headerSize2: 33 },
  [RT.OfficeArtBlipJPEG2]: { contentType: "image/jpeg", headerSize1: 17, headerSize2: 33 },
  [RT.OfficeArtBlipPNG]: { contentType: "image/png", headerSize1: 17, headerSize2: 33 },
  [RT.OfficeArtBlipDIB]: { contentType: "image/bmp", headerSize1: 17, headerSize2: 33 },
  [RT.OfficeArtBlipEMF]: { contentType: "image/x-emf", headerSize1: 50, headerSize2: 66 },
  [RT.OfficeArtBlipWMF]: { contentType: "image/x-wmf", headerSize1: 50, headerSize2: 66 },
  [RT.OfficeArtBlipTIFF]: { contentType: "image/tiff", headerSize1: 17, headerSize2: 33 },
  [RT.OfficeArtBlipPICT]: { contentType: "image/pict", headerSize1: 50, headerSize2: 66 }
};
function isBlipRecordType(recType) {
  return recType in BLIP_INFO;
}
function parseBlipRecord(record) {
  const info = BLIP_INFO[record.recType];
  if (!info) {
    throw new Error(`Unknown BLIP record type: 0x${record.recType.toString(16)}`);
  }
  const headerSize = record.recInstance & 1 ? info.headerSize2 : info.headerSize1;
  const dataStart = Math.min(headerSize, record.data.byteLength);
  const data = record.data.subarray(dataStart);
  return {
    contentType: info.contentType,
    data
  };
}

// packages/@oxen-office/ppt/src/stream/pictures-stream.ts
function parsePicturesStream(bytes) {
  const images = [];
  let offset = 0;
  let index = 0;
  while (offset + RECORD_HEADER_SIZE < bytes.length) {
    try {
      const record = readPptRecord(bytes, offset);
      if (isBlipRecordType(record.recType)) {
        const blip = parseBlipRecord(record);
        images.push({
          index,
          contentType: blip.contentType,
          data: blip.data
        });
        index++;
      }
      offset += RECORD_HEADER_SIZE + record.recLen;
    } catch {
      break;
    }
  }
  return images;
}

// packages/@oxen-office/ppt/src/records/atoms/document.ts
var MASTER_UNIT_TO_EMU = 914400 / 576;
function parseDocumentAtom(record) {
  if (record.recType !== RT.DocumentAtom) {
    throw new Error(`Expected DocumentAtom (0x03E9), got 0x${record.recType.toString(16)}`);
  }
  const view = new DataView(record.data.buffer, record.data.byteOffset, record.data.byteLength);
  const slideSizeX = view.getInt32(0, true);
  const slideSizeY = view.getInt32(4, true);
  const notesSizeX = view.getInt32(8, true);
  const notesSizeY = view.getInt32(12, true);
  const serverZoomNumer = view.getInt32(16, true);
  const serverZoomDenom = view.getInt32(20, true);
  const notesMasterPersistIdRef = view.getUint32(24, true);
  const handoutMasterPersistIdRef = view.getUint32(28, true);
  const firstSlideNumber = view.getUint16(32, true);
  const slideSizeType = view.getUint16(34, true);
  return {
    slideSizeX,
    slideSizeY,
    notesSizeX,
    notesSizeY,
    slideSizeXEmu: Math.round(slideSizeX * MASTER_UNIT_TO_EMU),
    slideSizeYEmu: Math.round(slideSizeY * MASTER_UNIT_TO_EMU),
    serverZoom: { numer: serverZoomNumer, denom: serverZoomDenom },
    notesMasterPersistIdRef,
    handoutMasterPersistIdRef,
    firstSlideNumber,
    slideSizeType
  };
}

// packages/@oxen-office/ppt/src/records/atoms/text.ts
function decodeTextCharsAtom(record) {
  if (record.recType !== RT.TextCharsAtom) {
    throw new Error(`Expected TextCharsAtom (0x0FA0), got 0x${record.recType.toString(16)}`);
  }
  return decodeUtf16Le(record.data);
}
function decodeTextBytesAtom(record) {
  if (record.recType !== RT.TextBytesAtom) {
    throw new Error(`Expected TextBytesAtom (0x0FA8), got 0x${record.recType.toString(16)}`);
  }
  const chars = [];
  for (let i2 = 0;i2 < record.data.length; i2++) {
    chars.push(String.fromCharCode(record.data[i2]));
  }
  return chars.join("");
}
function decodeUtf16Le(data) {
  const chars = [];
  for (let i2 = 0;i2 + 1 < data.length; i2 += 2) {
    const code = data[i2] | data[i2 + 1] << 8;
    chars.push(String.fromCharCode(code));
  }
  return chars.join("");
}
function parseStyleTextPropAtom(record, textLength) {
  if (record.recType !== RT.StyleTextPropAtom) {
    throw new Error(`Expected StyleTextPropAtom (0x0FA1), got 0x${record.recType.toString(16)}`);
  }
  const view = new DataView(record.data.buffer, record.data.byteOffset, record.data.byteLength);
  let offset = 0;
  function u162() {
    const v = view.getUint16(offset, true);
    offset += 2;
    return v;
  }
  function s16() {
    const v = view.getInt16(offset, true);
    offset += 2;
    return v;
  }
  function u32() {
    const v = view.getUint32(offset, true);
    offset += 4;
    return v;
  }
  function canRead(n) {
    return offset + n <= record.data.byteLength;
  }
  const paragraphRuns = [];
  let totalParagraphChars = 0;
  while (totalParagraphChars < textLength && canRead(4)) {
    const charCount = u32();
    totalParagraphChars += charCount;
    if (!canRead(2))
      break;
    const indent = u162();
    if (!canRead(4)) {
      paragraphRuns.push({ charCount, indent });
      break;
    }
    const mask = u32();
    const run = { charCount, indent };
    if (mask & 15 && canRead(2))
      run.bulletFlags = u162();
    if (mask & 128 && canRead(4))
      run.bulletColor = u32();
    if (mask & 16 && canRead(2))
      run.bulletChar = u162();
    if (mask & 32 && canRead(2))
      run.bulletFontRef = u162();
    if (mask & 64 && canRead(2))
      run.bulletSize = u162();
    if (mask & 2048 && canRead(2))
      run.alignment = u162();
    if (mask & 4096 && canRead(2))
      run.lineSpacing = s16();
    if (mask & 8192 && canRead(2))
      run.spaceBefore = s16();
    if (mask & 16384 && canRead(2))
      run.spaceAfter = s16();
    if (mask & 256 && canRead(2))
      run.leftMargin = u162();
    if (mask & 1024 && canRead(2)) {
      u162();
    }
    if (mask & 32768 && canRead(2))
      run.defaultTabSize = u162();
    if (mask & 1048576 && canRead(2)) {
      const count = u162();
      const skipBytes = count * 4;
      if (canRead(skipBytes))
        offset += skipBytes;
    }
    if (mask & 65536 && canRead(2)) {
      u162();
    }
    if (mask & 917504 && canRead(2)) {
      u162();
    }
    if (mask & 2097152 && canRead(2)) {
      u162();
    }
    paragraphRuns.push(run);
  }
  const characterRuns = [];
  let totalCharChars = 0;
  while (totalCharChars < textLength && canRead(4)) {
    const charCount = u32();
    totalCharChars += charCount;
    if (!canRead(4)) {
      characterRuns.push({ charCount });
      break;
    }
    const mask = u32();
    const run = { charCount };
    if (mask & 65535 && canRead(2)) {
      const flags = u162();
      run.bold = !!(flags & 1);
      run.italic = !!(flags & 2);
      run.underline = !!(flags & 4);
      run.strikethrough = !!(flags & 512);
    }
    if (mask & 65536 && canRead(2))
      run.fontRef = u162();
    if (mask & 2097152 && canRead(2)) {
      u162();
    }
    if (mask & 4194304 && canRead(2)) {
      u162();
    }
    if (mask & 8388608 && canRead(2)) {
      u162();
    }
    if (mask & 131072 && canRead(2))
      run.fontSize = u162();
    if (mask & 262144 && canRead(4))
      run.color = u32();
    if (mask & 524288 && canRead(2)) {
      u162();
    }
    if (mask & 1048576 && canRead(2)) {
      u162();
    }
    if (mask & 16777216 && canRead(2)) {
      u162();
    }
    if (mask & 33554432 && canRead(2)) {
      u162();
    }
    if (mask & 67108864 && canRead(2)) {
      u162();
    }
    characterRuns.push(run);
  }
  return { paragraphRuns, characterRuns };
}
function parseFontEntityAtom(record) {
  if (record.recType !== RT.FontEntityAtom) {
    throw new Error(`Expected FontEntityAtom (0x0FB7), got 0x${record.recType.toString(16)}`);
  }
  const nameEnd = Math.min(64, record.data.byteLength);
  let name = "";
  for (let i2 = 0;i2 + 1 < nameEnd; i2 += 2) {
    const code = record.data[i2] | record.data[i2 + 1] << 8;
    if (code === 0)
      break;
    name += String.fromCharCode(code);
  }
  const charset = record.data.byteLength > 64 ? record.data[64] : 0;
  const flags = record.data.byteLength > 65 ? record.data[65] : 0;
  const pitchAndFamily = record.data.byteLength > 66 ? record.data[66] : 0;
  return { name, charset, flags, pitchAndFamily };
}

// packages/@oxen-office/ppt/src/records/atoms/color.ts
function parseColorSchemeAtom(record) {
  if (record.recType !== RT.ColorSchemeAtom) {
    throw new Error(`Expected ColorSchemeAtom (0x07F0), got 0x${record.recType.toString(16)}`);
  }
  function readColor(offset) {
    if (offset + 3 > record.data.byteLength)
      return "000000";
    const r = record.data[offset];
    const g = record.data[offset + 1];
    const b = record.data[offset + 2];
    return toHex2(r) + toHex2(g) + toHex2(b);
  }
  return {
    background: readColor(0),
    textAndLines: readColor(4),
    shadows: readColor(8),
    titleText: readColor(12),
    fills: readColor(16),
    accent: readColor(20),
    accentAndHyperlink: readColor(24),
    accentAndFollowedHyperlink: readColor(28)
  };
}
function toHex2(n) {
  return n.toString(16).padStart(2, "0").toUpperCase();
}
var DEFAULT_COLOR_SCHEME = {
  background: "FFFFFF",
  textAndLines: "000000",
  shadows: "808080",
  titleText: "000000",
  fills: "BBE0E3",
  accent: "333399",
  accentAndHyperlink: "0066CC",
  accentAndFollowedHyperlink: "990099"
};
function resolveColor(value, scheme) {
  const flag = value >> 24 & 255;
  const r = value & 255;
  const g = value >> 8 & 255;
  const b = value >> 16 & 255;
  if (flag === 254 || flag === 1) {
    return resolveSchemeColor(r, scheme);
  }
  return toHex2(r) + toHex2(g) + toHex2(b);
}
function resolveSchemeColor(index, scheme) {
  const colors = [
    scheme.background,
    scheme.textAndLines,
    scheme.shadows,
    scheme.titleText,
    scheme.fills,
    scheme.accent,
    scheme.accentAndHyperlink,
    scheme.accentAndFollowedHyperlink
  ];
  return colors[index] ?? "000000";
}

// packages/@oxen-office/ppt/src/extractor/color-resolver.ts
function extractColorScheme(record) {
  const children = record.children ?? [];
  const colorSchemeAtom = findColorSchemeInTree(children);
  if (colorSchemeAtom) {
    return parseColorSchemeAtom(colorSchemeAtom);
  }
  return DEFAULT_COLOR_SCHEME;
}
function findColorSchemeInTree(records) {
  const direct = findChildByType(records, RT.ColorSchemeAtom);
  if (direct)
    return direct;
  for (const rec of records) {
    if (rec.children) {
      const nested = findChildByType(rec.children, RT.ColorSchemeAtom);
      if (nested)
        return nested;
    }
  }
  return;
}

// packages/@oxen-office/ppt/src/records/atoms/shape.ts
function parseOfficeArtFSP(record) {
  if (record.recType !== RT.OfficeArtFSP) {
    throw new Error(`Expected OfficeArtFSP (0xF00A), got 0x${record.recType.toString(16)}`);
  }
  const view = new DataView(record.data.buffer, record.data.byteOffset, record.data.byteLength);
  const shapeId = view.getUint32(0, true);
  const flags = view.getUint32(4, true);
  return {
    shapeId,
    isGroup: !!(flags & 1),
    isChild: !!(flags & 2),
    isPatriarch: !!(flags & 4),
    isDeleted: !!(flags & 8),
    isOleShape: !!(flags & 16),
    hasShapeType: !!(flags & 32),
    hasAnchor: !!(flags & 64),
    isConnector: !!(flags & 128),
    flipH: !!(flags & 16384),
    flipV: !!(flags & 32768)
  };
}
var SHAPE_PROP = {
  ROTATION: 4,
  GROUP_LEFT: 320,
  GROUP_TOP: 321,
  GROUP_RIGHT: 322,
  GROUP_BOTTOM: 323,
  FILL_TYPE: 384,
  FILL_COLOR: 385,
  FILL_OPACITY: 386,
  FILL_BACKGROUND_COLOR: 387,
  FILL_STYLE_BOOL_PROPS: 447,
  LINE_COLOR: 448,
  LINE_OPACITY: 449,
  LINE_WIDTH: 459,
  LINE_DASH_STYLE: 462,
  LINE_STYLE_BOOL_PROPS: 511,
  TEXT_ID: 128,
  TEXT_DIRECTION: 139,
  TEXT_ANCHOR: 135,
  TEXT_WORD_WRAP: 133,
  TEXT_ROTATION: 138,
  GEO_LEFT: 320,
  GEO_TOP: 321,
  GEO_RIGHT: 322,
  GEO_BOTTOM: 323,
  BLIP_ID: 260,
  CROP_FROM_LEFT: 258,
  CROP_FROM_TOP: 259,
  CROP_FROM_RIGHT: 261,
  CROP_FROM_BOTTOM: 262,
  SHAPE_BOOL_PROPS: 959
};
function parseOfficeArtFOPT(record) {
  if (record.recType !== RT.OfficeArtFOPT && record.recType !== RT.OfficeArtSecondaryFOPT && record.recType !== RT.OfficeArtTertiaryFOPT) {
    throw new Error(`Expected OfficeArtFOPT, got 0x${record.recType.toString(16)}`);
  }
  const propertyCount = record.recInstance;
  const view = new DataView(record.data.buffer, record.data.byteOffset, record.data.byteLength);
  const properties = new Map;
  const fixedSize = propertyCount * 6;
  for (let i2 = 0;i2 < propertyCount && i2 * 6 + 5 < record.data.byteLength; i2++) {
    const offset = i2 * 6;
    const idRaw = view.getUint16(offset, true);
    const value = view.getUint32(offset + 2, true);
    const id = idRaw & 16383;
    const isBlip = !!(idRaw & 16384);
    const isComplex = !!(idRaw & 32768);
    properties.set(id, { id, value, isBlip, isComplex });
  }
  let complexOffset = fixedSize;
  for (const [, prop] of properties) {
    if (prop.isComplex && prop.value > 0 && complexOffset + prop.value <= record.data.byteLength) {
      const complexData = record.data.slice(complexOffset, complexOffset + prop.value);
      properties.set(prop.id, { ...prop, complexData });
      complexOffset += prop.value;
    }
  }
  return properties;
}
function getShapeProp(props, id) {
  return props.get(id)?.value;
}
function parseClientAnchor(record) {
  if (record.recType !== RT.OfficeArtClientAnchor) {
    throw new Error(`Expected OfficeArtClientAnchor (0xF010), got 0x${record.recType.toString(16)}`);
  }
  const view = new DataView(record.data.buffer, record.data.byteOffset, record.data.byteLength);
  if (record.recInstance === 1 || record.data.byteLength >= 16) {
    return {
      top: view.getInt32(0, true),
      left: view.getInt32(4, true),
      right: view.getInt32(8, true),
      bottom: view.getInt32(12, true)
    };
  }
  return {
    top: view.getInt16(0, true),
    left: view.getInt16(2, true),
    right: view.getInt16(4, true),
    bottom: view.getInt16(6, true)
  };
}
function parseChildAnchor(record) {
  if (record.recType !== RT.OfficeArtChildAnchor) {
    throw new Error(`Expected OfficeArtChildAnchor (0xF00F), got 0x${record.recType.toString(16)}`);
  }
  const view = new DataView(record.data.buffer, record.data.byteOffset, record.data.byteLength);
  return {
    left: view.getInt32(0, true),
    top: view.getInt32(4, true),
    right: view.getInt32(8, true),
    bottom: view.getInt32(12, true)
  };
}
function msosptToPresetShape(msospt) {
  const mapping = {
    0: "rect",
    1: "rect",
    2: "roundRect",
    3: "ellipse",
    4: "diamond",
    5: "triangle",
    6: "rtTriangle",
    7: "parallelogram",
    8: "trapezoid",
    9: "hexagon",
    10: "octagon",
    11: "plus",
    12: "star5",
    13: "rightArrow",
    14: "mathNotEqual",
    15: "homePlate",
    16: "cube",
    20: "line",
    21: "bentConnector3",
    32: "straightConnector1",
    33: "bentConnector2",
    34: "bentConnector3",
    35: "bentConnector4",
    36: "bentConnector5",
    37: "curvedConnector2",
    38: "curvedConnector3",
    39: "curvedConnector4",
    40: "curvedConnector5",
    61: "rect",
    75: "rect",
    109: "wedgeRoundRectCallout",
    110: "wedgeEllipseCallout",
    183: "sun",
    184: "moon",
    185: "bracketPair",
    186: "bracePair",
    187: "star4",
    188: "doubleWave",
    202: "rect"
  };
  return mapping[msospt] ?? "rect";
}

// packages/@oxen-office/ppt/src/extractor/text-extractor.ts
function extractTextBodies(children, fonts, colorScheme) {
  const bodies = [];
  let i2 = 0;
  while (i2 < children.length) {
    const rec = children[i2];
    if (rec.recType === RT.TextHeaderAtom) {
      const { textBody, consumed } = extractOneTextBody(children, i2, fonts, colorScheme);
      if (textBody) {
        bodies.push(textBody);
      }
      i2 += consumed;
    } else {
      i2++;
    }
  }
  return bodies;
}
function extractOneTextBody(children, startIndex, fonts, colorScheme) {
  let idx = startIndex + 1;
  let rawText;
  let styleRecord;
  while (idx < children.length) {
    const rec = children[idx];
    if (rec.recType === RT.TextCharsAtom) {
      rawText = decodeTextCharsAtom(rec);
      idx++;
    } else if (rec.recType === RT.TextBytesAtom) {
      rawText = decodeTextBytesAtom(rec);
      idx++;
    } else if (rec.recType === RT.StyleTextPropAtom) {
      styleRecord = rec;
      idx++;
    } else if (rec.recType === RT.TextHeaderAtom) {
      break;
    } else {
      idx++;
      if (rec.recType === RT.TextHeaderAtom)
        break;
    }
  }
  if (rawText === undefined) {
    return { textBody: undefined, consumed: idx - startIndex };
  }
  const textLength = rawText.length;
  let paragraphRuns = [];
  let characterRuns = [];
  if (styleRecord) {
    const styleData = parseStyleTextPropAtom(styleRecord, textLength);
    paragraphRuns = styleData.paragraphRuns;
    characterRuns = styleData.characterRuns;
  }
  const paragraphs = buildParagraphs(rawText, paragraphRuns, characterRuns, fonts, colorScheme);
  return {
    textBody: { paragraphs },
    consumed: idx - startIndex
  };
}
function buildParagraphs(rawText, paragraphRuns, characterRuns, fonts, colorScheme) {
  const lines = rawText.split("\r");
  const paragraphs = [];
  let charPos = 0;
  let paraRunIdx = 0;
  let charRunIdx = 0;
  let charRunOffset = 0;
  for (let lineIdx = 0;lineIdx < lines.length; lineIdx++) {
    const lineText = lines[lineIdx];
    const lineLength = lineText.length + (lineIdx < lines.length - 1 ? 1 : 0);
    const paraStyle = paragraphRuns[paraRunIdx];
    const runs = [];
    let linePos = 0;
    while (linePos < lineText.length) {
      const charStyle = characterRuns[charRunIdx];
      const remainingInRun = charStyle ? charStyle.charCount - charRunOffset : lineText.length;
      const charsToTake = Math.min(remainingInRun, lineText.length - linePos);
      if (charsToTake > 0) {
        const text = lineText.substring(linePos, linePos + charsToTake);
        runs.push({
          text,
          properties: buildRunProperties(charStyle, fonts, colorScheme)
        });
      }
      linePos += charsToTake;
      charRunOffset += charsToTake;
      if (charStyle && charRunOffset >= charStyle.charCount) {
        charRunIdx++;
        charRunOffset = 0;
      }
    }
    if (runs.length === 0) {
      runs.push({ text: "", properties: {} });
    }
    const level = deriveLevel(paraStyle);
    const paragraph = {
      runs,
      ...paraStyle?.alignment !== undefined ? { alignment: alignmentToString(paraStyle.alignment) } : {},
      ...level > 0 ? { level } : {},
      ...paraStyle?.bulletFlags !== undefined ? { bullet: buildBullet(paraStyle) } : {},
      ...paraStyle?.lineSpacing !== undefined ? { lineSpacing: paraStyle.lineSpacing } : {},
      ...paraStyle?.spaceBefore !== undefined ? { spaceBefore: paraStyle.spaceBefore } : {},
      ...paraStyle?.spaceAfter !== undefined ? { spaceAfter: paraStyle.spaceAfter } : {}
    };
    paragraphs.push(paragraph);
    charPos += lineLength;
    charRunOffset += lineIdx < lines.length - 1 ? 1 : 0;
    if (characterRuns[charRunIdx] && charRunOffset >= characterRuns[charRunIdx].charCount) {
      charRunIdx++;
      charRunOffset = 0;
    }
    if (paraStyle) {
      paraRunIdx++;
    }
  }
  return paragraphs;
}
function buildRunProperties(charStyle, fonts, colorScheme) {
  if (!charStyle)
    return {};
  return {
    ...charStyle.bold ? { bold: true } : {},
    ...charStyle.italic ? { italic: true } : {},
    ...charStyle.underline ? { underline: true } : {},
    ...charStyle.strikethrough ? { strikethrough: true } : {},
    ...charStyle.fontSize !== undefined ? { fontSize: charStyle.fontSize } : {},
    ...charStyle.fontRef !== undefined && fonts[charStyle.fontRef] ? { fontFamily: fonts[charStyle.fontRef] } : {},
    ...charStyle.color !== undefined ? { color: resolveColor(charStyle.color, colorScheme) } : {}
  };
}
function alignmentToString(alignment) {
  switch (alignment) {
    case 0:
      return "left";
    case 1:
      return "center";
    case 2:
      return "right";
    case 3:
      return "justify";
    default:
      return;
  }
}
function deriveLevel(paraStyle) {
  if (!paraStyle)
    return 0;
  if (paraStyle.indent !== undefined && paraStyle.indent > 0)
    return paraStyle.indent;
  if (paraStyle.leftMargin !== undefined && paraStyle.leftMargin > 0) {
    return Math.min(Math.round(paraStyle.leftMargin / 228600), 8);
  }
  return 0;
}
function buildBullet(paraStyle) {
  if (!paraStyle.bulletFlags)
    return;
  const hasBullet = !!(paraStyle.bulletFlags & 15);
  if (!hasBullet)
    return { type: "none" };
  if (paraStyle.bulletChar !== undefined) {
    return { type: "char", char: String.fromCharCode(paraStyle.bulletChar) };
  }
  return { type: "autoNumber" };
}

// packages/@oxen-office/ppt/src/extractor/hyperlink-extractor.ts
function extractHyperlinkMap(documentRecord) {
  const map = new Map;
  const docChildren = documentRecord.children ?? [];
  const exObjList = findChildByType(docChildren, RT.ExObjListContainer);
  if (!exObjList)
    return map;
  const hyperlinkContainers = findChildrenByType(exObjList.children ?? [], RT.ExternalHyperlinkContainer);
  for (const container of hyperlinkContainers) {
    const children = container.children ?? [];
    const atom = findChildByType(children, RT.ExternalHyperlinkAtom);
    if (!atom || atom.data.byteLength < 4)
      continue;
    const view = new DataView(atom.data.buffer, atom.data.byteOffset, atom.data.byteLength);
    const exHyperlinkId = view.getUint32(0, true);
    const cstrings = findChildrenByType(children, RT.CString);
    for (const cs of cstrings) {
      if (cs.recInstance === 0) {
        const url = decodeUtf16Le2(cs.data);
        if (url.length > 0) {
          map.set(exHyperlinkId, url);
        }
        break;
      }
    }
  }
  return map;
}
function extractTextHyperlinkRanges(textboxChildren) {
  const ranges = [];
  let i2 = 0;
  while (i2 < textboxChildren.length) {
    const rec = textboxChildren[i2];
    if (rec.recType === RT.InteractiveInfoAtom) {
      const instance = rec.children ? findChildByType(rec.children, RT.InteractiveInfoInstance) : undefined;
      let exHyperlinkIdRef;
      if (instance && instance.data.byteLength >= 4) {
        const view = new DataView(instance.data.buffer, instance.data.byteOffset, instance.data.byteLength);
        exHyperlinkIdRef = view.getUint32(4, true);
      } else if (!rec.children && rec.data.byteLength >= 8) {
        const view = new DataView(rec.data.buffer, rec.data.byteOffset, rec.data.byteLength);
        exHyperlinkIdRef = view.getUint32(4, true);
      }
      if (exHyperlinkIdRef !== undefined && exHyperlinkIdRef !== 0) {
        const nextIdx = i2 + 1;
        if (nextIdx < textboxChildren.length && textboxChildren[nextIdx].recType === RT.TxInteractiveInfoAtom) {
          const txRec = textboxChildren[nextIdx];
          if (txRec.data.byteLength >= 8) {
            const txView = new DataView(txRec.data.buffer, txRec.data.byteOffset, txRec.data.byteLength);
            const begin = txView.getUint32(0, true);
            const end = txView.getUint32(4, true);
            ranges.push({ begin, end, exHyperlinkIdRef });
          }
          i2 = nextIdx + 1;
          continue;
        }
      }
    }
    i2++;
  }
  return ranges.sort((a, b) => a.begin - b.begin);
}
function decodeUtf16Le2(data) {
  const chars = [];
  for (let i2 = 0;i2 + 1 < data.length; i2 += 2) {
    const code = data[i2] | data[i2 + 1] << 8;
    if (code === 0)
      break;
    chars.push(String.fromCharCode(code));
  }
  return chars.join("");
}

// packages/@oxen-office/ppt/src/extractor/table-extractor.ts
var MASTER_UNIT_TO_EMU2 = 914400 / 576;
var TABLE_FLAG = 927;
var TABLE_LAYOUT = 928;
function isTableGroup(groupContainer) {
  const children = groupContainer.children ?? [];
  const spContainers = findChildrenByType(children, RT.OfficeArtSpContainer);
  if (spContainers.length === 0)
    return;
  const patriarch = spContainers[0];
  const tertiaryFOPT = findChildByType(patriarch.children ?? [], RT.OfficeArtTertiaryFOPT);
  if (!tertiaryFOPT)
    return;
  const props = parseOfficeArtFOPT(tertiaryFOPT);
  const tableFlag = props.get(TABLE_FLAG);
  if (!tableFlag || tableFlag.value !== 1)
    return;
  return props;
}
function extractTable(groupContainer, tertiaryProps, fonts, colorScheme) {
  const layoutProp = tertiaryProps.get(TABLE_LAYOUT);
  if (!layoutProp?.complexData || layoutProp.complexData.byteLength < 6)
    return;
  const layoutView = new DataView(layoutProp.complexData.buffer, layoutProp.complexData.byteOffset, layoutProp.complexData.byteLength);
  const nRows = layoutView.getUint16(0, true);
  const nCols = layoutView.getUint16(2, true);
  const rowHeightsMaster = [];
  for (let i2 = 0;i2 < nRows && 6 + (i2 + 1) * 4 <= layoutProp.complexData.byteLength; i2++) {
    rowHeightsMaster.push(layoutView.getInt32(6 + i2 * 4, true));
  }
  const children = groupContainer.children ?? [];
  const cells = [];
  for (const child of children) {
    if (child.recType !== RT.OfficeArtSpContainer)
      continue;
    const childChildren = child.children ?? [];
    const fsp = findChildByType(childChildren, RT.OfficeArtFSP);
    if (!fsp)
      continue;
    const flags = parseOfficeArtFSP(fsp);
    if (flags.isPatriarch)
      continue;
    if (fsp.recInstance === 20)
      continue;
    const anchor = findChildByType(childChildren, RT.OfficeArtChildAnchor);
    if (!anchor)
      continue;
    const a = parseChildAnchor(anchor);
    let textBody;
    const clientTextbox = findChildByType(childChildren, RT.OfficeArtClientTextbox);
    if (clientTextbox?.children) {
      const bodies = extractTextBodies(clientTextbox.children, fonts, colorScheme);
      if (bodies.length > 0)
        textBody = bodies[0];
    }
    cells.push({ left: a.left, top: a.top, right: a.right, bottom: a.bottom, textBody });
  }
  if (cells.length === 0)
    return;
  const colBounds = deriveGridLines(cells.map((c) => c.left), cells.map((c) => c.right));
  const rowBounds = deriveGridLines(cells.map((c) => c.top), cells.map((c) => c.bottom));
  if (colBounds.length < 2 || rowBounds.length < 2)
    return;
  const actualNCols = colBounds.length - 1;
  const actualNRows = rowBounds.length - 1;
  const columnWidthsEmu = [];
  for (let c = 0;c < actualNCols; c++) {
    columnWidthsEmu.push(Math.round((colBounds[c + 1] - colBounds[c]) * MASTER_UNIT_TO_EMU2));
  }
  const grid = Array.from({ length: actualNRows }, () => Array.from({ length: actualNCols }, () => {
    return;
  }));
  for (const cell of cells) {
    const col = findGridIndex(colBounds, cell.left);
    const row = findGridIndex(rowBounds, cell.top);
    const colEnd = findGridIndex(colBounds, cell.right);
    const rowEnd = findGridIndex(rowBounds, cell.bottom);
    if (col < 0 || row < 0 || colEnd < 0 || rowEnd < 0)
      continue;
    const colSpan = colEnd - col;
    const rowSpan = rowEnd - row;
    grid[row][col] = {
      text: cell.textBody,
      ...colSpan > 1 ? { colSpan } : {},
      ...rowSpan > 1 ? { rowSpan } : {}
    };
  }
  const rows = [];
  for (let r = 0;r < actualNRows; r++) {
    const heightEmu = Math.round((rowBounds[r + 1] - rowBounds[r]) * MASTER_UNIT_TO_EMU2);
    const rowCells = [];
    for (let c = 0;c < actualNCols; c++) {
      rowCells.push(grid[r][c] ?? { text: undefined });
    }
    rows.push({ heightEmu, cells: rowCells });
  }
  return { columnWidthsEmu, rows };
}
function deriveGridLines(starts, ends) {
  const positions = new Set;
  for (const s of starts)
    positions.add(s);
  for (const e of ends)
    positions.add(e);
  return Array.from(positions).sort((a, b) => a - b);
}
function findGridIndex(gridLines, position) {
  let minDist = Infinity;
  let bestIdx = -1;
  for (let i2 = 0;i2 < gridLines.length; i2++) {
    const dist = Math.abs(gridLines[i2] - position);
    if (dist < minDist) {
      minDist = dist;
      bestIdx = i2;
    }
  }
  return bestIdx;
}

// packages/@oxen-office/ppt/src/extractor/shape-extractor.ts
var MASTER_UNIT_TO_EMU3 = 914400 / 576;
function extractShapes(slideRecord, fonts, colorScheme, hyperlinkMap) {
  const children = slideRecord.children ?? [];
  let dgContainer = findChildByType(children, RT.OfficeArtDgContainer);
  if (!dgContainer) {
    const ppDrawing = findChildByType(children, RT.PPDrawing);
    if (ppDrawing) {
      dgContainer = findChildByType(ppDrawing.children ?? [], RT.OfficeArtDgContainer);
    }
  }
  if (!dgContainer)
    return [];
  const spgrContainer = findChildByType(dgContainer.children ?? [], RT.OfficeArtSpgrContainer);
  if (!spgrContainer)
    return [];
  return extractShapesFromGroup(spgrContainer, fonts, colorScheme, hyperlinkMap);
}
function extractShapesFromGroup(container, fonts, colorScheme, hyperlinkMap) {
  const shapes = [];
  const children = container.children ?? [];
  for (const child of children) {
    if (child.recType === RT.OfficeArtSpContainer) {
      const shape = extractSingleShape(child, fonts, colorScheme, hyperlinkMap);
      if (shape)
        shapes.push(shape);
    } else if (child.recType === RT.OfficeArtSpgrContainer) {
      const tertiaryProps = isTableGroup(child);
      if (tertiaryProps) {
        const table = extractTable(child, tertiaryProps, fonts, colorScheme);
        if (table) {
          const transform = extractGroupTransform(child);
          shapes.push({
            type: "table",
            transform: transform ?? defaultTransform(),
            table
          });
          continue;
        }
      }
      const groupShapes = extractShapesFromGroup(child, fonts, colorScheme, hyperlinkMap);
      if (groupShapes.length > 0) {
        const transform = extractGroupTransform(child);
        shapes.push({
          type: "group",
          transform: transform ?? defaultTransform(),
          children: groupShapes
        });
      }
    }
  }
  return shapes;
}
function extractSingleShape(spContainer, fonts, colorScheme, hyperlinkMap) {
  const children = spContainer.children ?? [];
  const fspRecord = findChildByType(children, RT.OfficeArtFSP);
  if (!fspRecord)
    return;
  const fsp = parseOfficeArtFSP(fspRecord);
  if (fsp.isDeleted || fsp.isPatriarch)
    return;
  const foptRecord = findChildByType(children, RT.OfficeArtFOPT);
  const props = foptRecord ? parseOfficeArtFOPT(foptRecord) : new Map;
  const anchorRecord = findChildByType(children, RT.OfficeArtClientAnchor);
  const childAnchorRecord = findChildByType(children, RT.OfficeArtChildAnchor);
  let transform;
  if (anchorRecord) {
    const anchor = parseClientAnchor(anchorRecord);
    transform = anchorToTransform(anchor.left, anchor.top, anchor.right, anchor.bottom, fsp, props);
  } else if (childAnchorRecord) {
    const anchor = parseChildAnchor(childAnchorRecord);
    transform = childAnchorToTransform(anchor.left, anchor.top, anchor.right, anchor.bottom, fsp, props);
  } else {
    transform = defaultTransform();
  }
  const msospt = fspRecord.recInstance;
  const presetShape = msosptToPresetShape(msospt);
  const fill = extractFill(props, colorScheme);
  const line = extractLine(props, colorScheme);
  const clientTextboxRecord = findChildByType(children, RT.OfficeArtClientTextbox);
  let textBody;
  if (clientTextboxRecord?.children) {
    const bodies = extractTextBodies(clientTextboxRecord.children, fonts, colorScheme);
    if (bodies.length > 0) {
      textBody = bodies[0];
      if (hyperlinkMap && hyperlinkMap.size > 0) {
        const ranges = extractTextHyperlinkRanges(clientTextboxRecord.children);
        if (ranges.length > 0) {
          textBody = applyHyperlinksToTextBody(textBody, ranges, hyperlinkMap);
        }
      }
    }
  }
  let picture;
  const blipId = getShapeProp(props, SHAPE_PROP.BLIP_ID);
  if (blipId !== undefined) {
    picture = {
      pictureIndex: blipId - 1,
      ...extractCrop(props)
    };
  }
  let type = "shape";
  if (picture)
    type = "picture";
  else if (fsp.isConnector || msospt === 20 || msospt >= 32 && msospt <= 40)
    type = "connector";
  return {
    type,
    transform,
    presetShape,
    ...fill ? { fill } : {},
    ...line ? { line } : {},
    ...textBody ? { textBody } : {},
    ...picture ? { picture } : {}
  };
}
function anchorToTransform(left, top, right, bottom, fsp, props) {
  const scale = MASTER_UNIT_TO_EMU3;
  const xEmu = Math.round(left * scale);
  const yEmu = Math.round(top * scale);
  const widthEmu = Math.round((right - left) * scale);
  const heightEmu = Math.round((bottom - top) * scale);
  const rotation = extractRotation(props);
  return {
    xEmu,
    yEmu,
    widthEmu: Math.abs(widthEmu),
    heightEmu: Math.abs(heightEmu),
    rotation,
    flipH: fsp.flipH,
    flipV: fsp.flipV
  };
}
function childAnchorToTransform(left, top, right, bottom, fsp, props) {
  const rotation = extractRotation(props);
  return {
    xEmu: left,
    yEmu: top,
    widthEmu: Math.abs(right - left),
    heightEmu: Math.abs(bottom - top),
    rotation,
    flipH: fsp.flipH,
    flipV: fsp.flipV
  };
}
function extractRotation(props) {
  const raw = getShapeProp(props, SHAPE_PROP.ROTATION);
  if (raw === undefined)
    return 0;
  return (raw >> 16) + (raw & 65535) / 65536;
}
function extractFill(props, colorScheme) {
  const boolProps = getShapeProp(props, SHAPE_PROP.FILL_STYLE_BOOL_PROPS);
  if (boolProps !== undefined) {
    const hasFill = boolProps & 16;
    const useFill = boolProps & 1048576;
    if (useFill && !hasFill) {
      return { type: "none" };
    }
  }
  const fillColor = getShapeProp(props, SHAPE_PROP.FILL_COLOR);
  if (fillColor !== undefined) {
    return { type: "solid", color: resolveColor(fillColor, colorScheme) };
  }
  return;
}
function extractLine(props, colorScheme) {
  const boolProps = getShapeProp(props, SHAPE_PROP.LINE_STYLE_BOOL_PROPS);
  if (boolProps !== undefined) {
    const hasLine = boolProps & 8;
    const useLine = boolProps & 524288;
    if (useLine && !hasLine) {
      return;
    }
  }
  const lineColor = getShapeProp(props, SHAPE_PROP.LINE_COLOR);
  const lineWidth = getShapeProp(props, SHAPE_PROP.LINE_WIDTH);
  const lineDash = getShapeProp(props, SHAPE_PROP.LINE_DASH_STYLE);
  if (lineColor === undefined && lineWidth === undefined)
    return;
  return {
    widthEmu: lineWidth ?? 9525,
    ...lineColor !== undefined ? { color: resolveColor(lineColor, colorScheme) } : {},
    ...lineDash !== undefined ? { dashStyle: dashStyleToString(lineDash) } : {}
  };
}
function dashStyleToString(value) {
  switch (value) {
    case 0:
      return "solid";
    case 1:
      return "dash";
    case 2:
      return "dot";
    case 3:
      return "dashDot";
    case 4:
      return "dashDotDot";
    default:
      return "solid";
  }
}
function extractCrop(props) {
  const cropLeft = getShapeProp(props, SHAPE_PROP.CROP_FROM_LEFT);
  const cropTop = getShapeProp(props, SHAPE_PROP.CROP_FROM_TOP);
  const cropRight = getShapeProp(props, SHAPE_PROP.CROP_FROM_RIGHT);
  const cropBottom = getShapeProp(props, SHAPE_PROP.CROP_FROM_BOTTOM);
  return {
    ...cropLeft ? { cropLeft: fixedPointToFraction(cropLeft) } : {},
    ...cropTop ? { cropTop: fixedPointToFraction(cropTop) } : {},
    ...cropRight ? { cropRight: fixedPointToFraction(cropRight) } : {},
    ...cropBottom ? { cropBottom: fixedPointToFraction(cropBottom) } : {}
  };
}
function fixedPointToFraction(value) {
  return value / 65536;
}
function extractGroupTransform(groupContainer) {
  const children = groupContainer.children ?? [];
  const spContainers = findChildrenByType(children, RT.OfficeArtSpContainer);
  if (spContainers.length === 0)
    return;
  const patriarch = spContainers[0];
  const anchor = findChildByType(patriarch.children ?? [], RT.OfficeArtClientAnchor);
  if (!anchor)
    return;
  const a = parseClientAnchor(anchor);
  const scale = MASTER_UNIT_TO_EMU3;
  return {
    xEmu: Math.round(a.left * scale),
    yEmu: Math.round(a.top * scale),
    widthEmu: Math.round((a.right - a.left) * scale),
    heightEmu: Math.round((a.bottom - a.top) * scale),
    rotation: 0,
    flipH: false,
    flipV: false
  };
}
function defaultTransform() {
  return { xEmu: 0, yEmu: 0, widthEmu: 0, heightEmu: 0, rotation: 0, flipH: false, flipV: false };
}
function applyHyperlinksToTextBody(textBody, ranges, hyperlinkMap) {
  const newParagraphs = [];
  let charPos = 0;
  for (const para of textBody.paragraphs) {
    const newRuns = [];
    for (const run of para.runs) {
      const runStart = charPos;
      const runEnd = charPos + run.text.length;
      const overlapping = ranges.filter((r) => r.begin < runEnd && r.end > runStart);
      if (overlapping.length === 0) {
        newRuns.push(run);
      } else {
        let pos = 0;
        for (const range2 of overlapping) {
          const relStart = Math.max(0, range2.begin - runStart);
          const relEnd = Math.min(run.text.length, range2.end - runStart);
          if (relStart > pos) {
            newRuns.push({ text: run.text.substring(pos, relStart), properties: run.properties });
          }
          const url = hyperlinkMap.get(range2.exHyperlinkIdRef);
          if (url) {
            newRuns.push({
              text: run.text.substring(relStart, relEnd),
              properties: { ...run.properties, hyperlink: url }
            });
          } else {
            newRuns.push({ text: run.text.substring(relStart, relEnd), properties: run.properties });
          }
          pos = relEnd;
        }
        if (pos < run.text.length) {
          newRuns.push({ text: run.text.substring(pos), properties: run.properties });
        }
      }
      charPos += run.text.length;
    }
    newParagraphs.push({ ...para, runs: newRuns });
    charPos += 1;
  }
  return { ...textBody, paragraphs: newParagraphs };
}

// packages/@oxen-office/ppt/src/extractor/index.ts
function extractPptPresentation(parsed, images, ctx) {
  const docChildren = parsed.documentRecord.children ?? [];
  const documentAtomRecord = findChildByType(docChildren, RT.DocumentAtom);
  let slideSize;
  if (documentAtomRecord) {
    const docAtom = parseDocumentAtom(documentAtomRecord);
    slideSize = {
      widthEmu: docAtom.slideSizeXEmu,
      heightEmu: docAtom.slideSizeYEmu
    };
  } else {
    slideSize = { widthEmu: 12192000, heightEmu: 6858000 };
  }
  const fonts = extractFonts(docChildren);
  const masterColorScheme = parsed.masterRecords.length > 0 ? extractColorScheme(parsed.masterRecords[0]) : DEFAULT_COLOR_SCHEME;
  const hyperlinkMap = extractHyperlinkMap(parsed.documentRecord);
  const slides = [];
  for (let i2 = 0;i2 < parsed.slideRecords.length; i2++) {
    const slideRecord = parsed.slideRecords[i2];
    try {
      const slide = extractSlide(slideRecord, fonts, masterColorScheme, hyperlinkMap, parsed.noteRecords[i2]);
      slides.push(slide);
    } catch (err2) {
      warnOrThrow(ctx, { code: "PPT_SLIDE_PARSE_FAILED", where: "extractPptPresentation", message: `Failed to extract slide ${i2}: ${err2 instanceof Error ? err2.message : String(err2)}` }, err2 instanceof Error ? err2 : new Error(String(err2)));
      slides.push({ shapes: [] });
    }
  }
  return { slideSize, slides, images };
}
function extractSlide(slideRecord, fonts, masterColorScheme, hyperlinkMap, notesRecord) {
  const colorScheme = extractColorScheme(slideRecord) ?? masterColorScheme;
  const shapes = extractShapes(slideRecord, fonts, colorScheme, hyperlinkMap);
  let notes;
  if (notesRecord) {
    notes = extractNotesText(notesRecord, fonts, colorScheme);
  }
  return {
    shapes,
    ...notes ? { notes } : {}
  };
}
function extractFonts(docChildren) {
  const fonts = [];
  const envContainer = findChildByType(docChildren, RT.Environment);
  if (!envContainer)
    return fonts;
  const fontCollection = findChildByType(envContainer.children ?? [], RT.FontCollection);
  if (!fontCollection)
    return fonts;
  const fontEntities = findChildrenByType(fontCollection.children ?? [], RT.FontEntityAtom);
  for (const fe of fontEntities) {
    const fontData = parseFontEntityAtom(fe);
    fonts.push(fontData.name);
  }
  return fonts;
}
function extractNotesText(notesRecord, fonts, colorScheme) {
  const shapes = extractShapes(notesRecord, fonts, colorScheme);
  const textParts = [];
  for (const shape of shapes) {
    if (!shape.textBody)
      continue;
    for (const para of shape.textBody.paragraphs) {
      const text2 = para.runs.map((r) => r.text).join("");
      if (text2.length > 0)
        textParts.push(text2);
    }
  }
  const text = textParts.join(`
`);
  return text.length > 0 ? text : undefined;
}

// packages/@oxen-office/ppt/src/converter/template.ts
var APP_XML = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties">
  <AppVersion>16.0</AppVersion>
</Properties>`;
var ROOT_RELS_XML = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="ppt/presentation.xml"/>
  <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>
</Relationships>`;
var MINIMAL_THEME = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="PPT Import Theme">
  <a:themeElements>
    <a:clrScheme name="PPT Import">
      <a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>
      <a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>
      <a:dk2><a:srgbClr val="44546A"/></a:dk2>
      <a:lt2><a:srgbClr val="E7E6E6"/></a:lt2>
      <a:accent1><a:srgbClr val="5B9BD5"/></a:accent1>
      <a:accent2><a:srgbClr val="ED7D31"/></a:accent2>
      <a:accent3><a:srgbClr val="A5A5A5"/></a:accent3>
      <a:accent4><a:srgbClr val="FFC000"/></a:accent4>
      <a:accent5><a:srgbClr val="4472C4"/></a:accent5>
      <a:accent6><a:srgbClr val="70AD47"/></a:accent6>
      <a:hlink><a:srgbClr val="0563C1"/></a:hlink>
      <a:folHlink><a:srgbClr val="954F72"/></a:folHlink>
    </a:clrScheme>
    <a:fontScheme name="PPT Import">
      <a:majorFont><a:latin typeface="Calibri"/></a:majorFont>
      <a:minorFont><a:latin typeface="Calibri"/></a:minorFont>
    </a:fontScheme>
    <a:fmtScheme name="PPT Import">
      <a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill></a:fillStyleLst>
      <a:lnStyleLst><a:ln w="6350"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill></a:ln></a:lnStyleLst>
      <a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle></a:effectStyleLst>
      <a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill></a:bgFillStyleLst>
    </a:fmtScheme>
  </a:themeElements>
</a:theme>`;
var MINIMAL_SLIDE_MASTER = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<p:sldMaster
  xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"
  xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"
  xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <p:cSld>
    <p:spTree>
      <p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr>
      <p:grpSpPr/>
    </p:spTree>
  </p:cSld>
  <p:txStyles>
    <p:titleStyle/>
    <p:bodyStyle/>
  </p:txStyles>
</p:sldMaster>`;
var MINIMAL_SLIDE_LAYOUT = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<p:sldLayout
  xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"
  xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"
  xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
  type="blank">
  <p:cSld>
    <p:spTree>
      <p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr>
      <p:grpSpPr/>
    </p:spTree>
  </p:cSld>
</p:sldLayout>`;

// packages/@oxen-office/ppt/src/converter/presentation-xml.ts
var SLIDE_ID_START = 256;
var SLIDE_MASTER_ID = 2147483648;
var CT_PRESENTATION = "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml";
var CT_SLIDE = "application/vnd.openxmlformats-officedocument.presentationml.slide+xml";
var CT_SLIDE_LAYOUT = "application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml";
var CT_SLIDE_MASTER = "application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml";
var CT_THEME = "application/vnd.openxmlformats-officedocument.theme+xml";
var CT_NOTES = "application/vnd.openxmlformats-officedocument.presentationml.notesSlide+xml";
var CT_CHART = "application/vnd.openxmlformats-officedocument.drawingml.chart+xml";
var RT_SLIDE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide";
var RT_SLIDE_LAYOUT = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout";
var RT_SLIDE_MASTER = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster";
var RT_THEME = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme";
var RT_IMAGE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image";
var RT_HYPERLINK = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink";
var RT_NOTES = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide";
function buildContentTypesXml(slideCount, options) {
  const overrides = [];
  overrides.push(`<Override PartName="/ppt/presentation.xml" ContentType="${CT_PRESENTATION}"/>`);
  overrides.push(`<Override PartName="/ppt/slideLayouts/slideLayout1.xml" ContentType="${CT_SLIDE_LAYOUT}"/>`);
  overrides.push(`<Override PartName="/ppt/slideMasters/slideMaster1.xml" ContentType="${CT_SLIDE_MASTER}"/>`);
  overrides.push(`<Override PartName="/ppt/theme/theme1.xml" ContentType="${CT_THEME}"/>`);
  for (let i2 = 1;i2 <= slideCount; i2++) {
    overrides.push(`<Override PartName="/ppt/slides/slide${i2}.xml" ContentType="${CT_SLIDE}"/>`);
  }
  if (options?.hasNotes) {
    for (let i2 = 0;i2 < options.hasNotes.length; i2++) {
      if (options.hasNotes[i2]) {
        overrides.push(`<Override PartName="/ppt/notesSlides/notesSlide${i2 + 1}.xml" ContentType="${CT_NOTES}"/>`);
      }
    }
  }
  if (options?.hasCharts) {
    for (const chartIdx of options.hasCharts) {
      overrides.push(`<Override PartName="/ppt/charts/chart${chartIdx}.xml" ContentType="${CT_CHART}"/>`);
    }
  }
  const defaultExtensions = [
    `<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>`,
    `<Default Extension="xml" ContentType="application/xml"/>`
  ];
  const imageExts = new Set(options?.imageExtensions ?? []);
  if (imageExts.has("png"))
    defaultExtensions.push(`<Default Extension="png" ContentType="image/png"/>`);
  if (imageExts.has("jpeg") || imageExts.has("jpg"))
    defaultExtensions.push(`<Default Extension="jpeg" ContentType="image/jpeg"/>`);
  if (imageExts.has("emf"))
    defaultExtensions.push(`<Default Extension="emf" ContentType="image/x-emf"/>`);
  if (imageExts.has("wmf"))
    defaultExtensions.push(`<Default Extension="wmf" ContentType="image/x-wmf"/>`);
  if (imageExts.has("bmp"))
    defaultExtensions.push(`<Default Extension="bmp" ContentType="image/bmp"/>`);
  if (imageExts.has("tiff"))
    defaultExtensions.push(`<Default Extension="tiff" ContentType="image/tiff"/>`);
  return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` + `<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">` + defaultExtensions.join("") + overrides.join("") + `</Types>`;
}
function buildPresentationXml(slideCount, slideSize) {
  const sldIds = [];
  for (let i2 = 1;i2 <= slideCount; i2++) {
    const id = SLIDE_ID_START - 1 + i2;
    const rId = `rId${i2 + 1}`;
    sldIds.push(`<p:sldId id="${id}" r:id="${rId}"/>`);
  }
  return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` + `<p:presentation ` + `xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" ` + `xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" ` + `xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">` + `<p:sldMasterIdLst><p:sldMasterId id="${SLIDE_MASTER_ID}" r:id="rId1"/></p:sldMasterIdLst>` + `<p:sldIdLst>${sldIds.join("")}</p:sldIdLst>` + `<p:sldSz cx="${slideSize.widthEmu}" cy="${slideSize.heightEmu}"/>` + `<p:defaultTextStyle><a:defPPr><a:defRPr sz="1800"/></a:defPPr></p:defaultTextStyle>` + `</p:presentation>`;
}
function buildPresentationRelsXml(slideCount) {
  const rels = [];
  rels.push(`<Relationship Id="rId1" Type="${RT_SLIDE_MASTER}" Target="slideMasters/slideMaster1.xml"/>`);
  for (let i2 = 1;i2 <= slideCount; i2++) {
    rels.push(`<Relationship Id="rId${i2 + 1}" Type="${RT_SLIDE}" Target="slides/slide${i2}.xml"/>`);
  }
  return wrapRelationships(rels);
}
function buildSlideRelsXml(extraRels) {
  const rels = [];
  rels.push(`<Relationship Id="rId1" Type="${RT_SLIDE_LAYOUT}" Target="../slideLayouts/slideLayout1.xml"/>`);
  if (extraRels) {
    for (const rel of extraRels) {
      const targetMode = rel.targetMode ? ` TargetMode="${rel.targetMode}"` : "";
      rels.push(`<Relationship Id="${rel.id}" Type="${rel.type}" Target="${rel.target}"${targetMode}/>`);
    }
  }
  return wrapRelationships(rels);
}
function buildLayoutRelsXml() {
  return wrapRelationships([
    `<Relationship Id="rId1" Type="${RT_SLIDE_MASTER}" Target="../slideMasters/slideMaster1.xml"/>`
  ]);
}
function buildMasterRelsXml() {
  return wrapRelationships([
    `<Relationship Id="rId1" Type="${RT_THEME}" Target="../theme/theme1.xml"/>`
  ]);
}
function buildNotesSlideXml(text) {
  const escapedText = escapeXml3(text);
  return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` + `<p:notes xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" ` + `xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" ` + `xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">` + `<p:cSld><p:spTree>` + `<p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr>` + `<p:grpSpPr/>` + `<p:sp><p:nvSpPr><p:cNvPr id="2" name="Notes Placeholder"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr>` + `<p:nvPr><p:ph type="body" idx="1"/></p:nvPr></p:nvSpPr>` + `<p:spPr/>` + `<p:txBody><a:bodyPr/><a:lstStyle/>` + `<a:p><a:r><a:rPr lang="en-US" dirty="0"/><a:t>${escapedText}</a:t></a:r></a:p>` + `</p:txBody></p:sp>` + `</p:spTree></p:cSld></p:notes>`;
}
function buildNotesRelsXml(slideIndex) {
  return wrapRelationships([
    `<Relationship Id="rId1" Type="${RT_SLIDE}" Target="../slides/slide${slideIndex}.xml"/>`
  ]);
}
function wrapRelationships(rels) {
  return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` + `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">` + rels.join("") + `</Relationships>`;
}
function escapeXml3(s) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}

// packages/@oxen-office/ppt/src/converter/text-xml.ts
function buildTextBodyXml(textBody, hyperlinks) {
  const bodyProps = buildBodyProperties(textBody);
  const paragraphs = textBody.paragraphs.map((p) => buildParagraphXml(p, hyperlinks)).join("");
  return `<p:txBody>${bodyProps}<a:lstStyle/>${paragraphs}</p:txBody>`;
}
function buildBodyProperties(textBody) {
  const attrs = [];
  if (textBody.anchor) {
    const anchorMap = { top: "t", middle: "ctr", bottom: "b" };
    attrs.push(`anchor="${anchorMap[textBody.anchor] ?? "t"}"`);
  }
  if (textBody.wordWrap === false) {
    attrs.push(`wrap="none"`);
  }
  if (textBody.rotation) {
    attrs.push(`rot="${Math.round(textBody.rotation * 60000)}"`);
  }
  return `<a:bodyPr${attrs.length > 0 ? " " + attrs.join(" ") : ""}/>`;
}
function buildParagraphXml(paragraph, hyperlinks) {
  const pPr = buildParagraphProperties(paragraph);
  const runs = paragraph.runs.map((r) => buildRunXml(r, hyperlinks)).join("");
  const endParaRPr = `<a:endParaRPr lang="en-US"/>`;
  return `<a:p>${pPr}${runs}${endParaRPr}</a:p>`;
}
function buildParagraphProperties(paragraph) {
  const attrs = [];
  if (paragraph.alignment) {
    const alignMap = { left: "l", center: "ctr", right: "r", justify: "just" };
    attrs.push(`algn="${alignMap[paragraph.alignment] ?? "l"}"`);
  }
  if (paragraph.level !== undefined && paragraph.level > 0) {
    attrs.push(`lvl="${paragraph.level}"`);
  }
  const children = [];
  if (paragraph.bullet) {
    if (paragraph.bullet.type === "none") {
      children.push(`<a:buNone/>`);
    } else if (paragraph.bullet.type === "char" && paragraph.bullet.char) {
      children.push(`<a:buChar char="${escapeXml3(paragraph.bullet.char)}"/>`);
    } else if (paragraph.bullet.type === "autoNumber") {
      children.push(`<a:buAutoNum type="arabicPeriod"/>`);
    }
  }
  if (paragraph.lineSpacing !== undefined) {
    if (paragraph.lineSpacing > 0) {
      children.push(`<a:lnSpc><a:spcPct val="${paragraph.lineSpacing * 1000}"/></a:lnSpc>`);
    }
  }
  if (paragraph.spaceBefore !== undefined) {
    children.push(`<a:spcBef><a:spcPts val="${Math.abs(paragraph.spaceBefore) * 100}"/></a:spcBef>`);
  }
  if (paragraph.spaceAfter !== undefined) {
    children.push(`<a:spcAft><a:spcPts val="${Math.abs(paragraph.spaceAfter) * 100}"/></a:spcAft>`);
  }
  if (attrs.length === 0 && children.length === 0) {
    return `<a:pPr/>`;
  }
  return `<a:pPr${attrs.length > 0 ? " " + attrs.join(" ") : ""}>${children.join("")}</a:pPr>`;
}
function buildRunXml(run, hyperlinks) {
  const rPr = buildRunProperties2(run);
  const text = escapeXml3(run.text);
  if (run.properties.hyperlink && hyperlinks) {
    const rId = hyperlinks.get(run.properties.hyperlink);
    if (rId) {
      return `<a:r>${rPr}<a:t>${text}</a:t></a:r>`;
    }
  }
  return `<a:r>${rPr}<a:t>${text}</a:t></a:r>`;
}
function buildRunProperties2(run) {
  const attrs = [];
  const children = [];
  const p = run.properties;
  attrs.push(`lang="en-US"`);
  if (p.bold)
    attrs.push(`b="1"`);
  if (p.italic)
    attrs.push(`i="1"`);
  if (p.underline)
    attrs.push(`u="sng"`);
  if (p.strikethrough)
    attrs.push(`strike="sngStrike"`);
  if (p.fontSize !== undefined) {
    attrs.push(`sz="${Math.round(p.fontSize * 100)}"`);
  }
  if (p.color) {
    children.push(`<a:solidFill><a:srgbClr val="${p.color}"/></a:solidFill>`);
  }
  if (p.fontFamily) {
    children.push(`<a:latin typeface="${escapeXml3(p.fontFamily)}"/>`);
    children.push(`<a:ea typeface="${escapeXml3(p.fontFamily)}"/>`);
  }
  if (p.hyperlink) {
    children.push(`<a:hlinkClick r:id=""/>`);
  }
  return `<a:rPr ${attrs.join(" ")}>${children.join("")}</a:rPr>`;
}

// packages/@oxen-office/ppt/src/converter/shape-xml.ts
var _shapeIdCounter = 2;
function resetShapeIdCounter() {
  _shapeIdCounter = 2;
}
function nextShapeId() {
  return _shapeIdCounter++;
}
function buildShapeXml(shape, imageRefs, hyperlinks) {
  switch (shape.type) {
    case "picture":
      return buildPictureXml(shape, imageRefs);
    case "group":
      return buildGroupXml(shape, imageRefs, hyperlinks);
    case "connector":
      return buildConnectorXml(shape);
    case "table":
      return buildTableXml(shape);
    default:
      return buildSpShapeXml(shape, hyperlinks);
  }
}
function buildSpShapeXml(shape, hyperlinks) {
  const id = nextShapeId();
  const name = shape.name ?? `Shape ${id}`;
  const nvSpPr = `<p:nvSpPr>` + `<p:cNvPr id="${id}" name="${escapeXml3(name)}"/>` + `<p:cNvSpPr/>` + `<p:nvPr/>` + `</p:nvSpPr>`;
  const spPr = buildShapeProperties(shape);
  const txBody = shape.textBody ? buildTextBodyXml(shape.textBody, hyperlinks) : "";
  return `<p:sp>${nvSpPr}${spPr}${txBody}</p:sp>`;
}
function buildPictureXml(shape, imageRefs) {
  const id = nextShapeId();
  const name = shape.name ?? `Picture ${id}`;
  const rId = shape.picture && imageRefs ? imageRefs.get(shape.picture.pictureIndex) : undefined;
  if (!rId) {
    return buildSpShapeXml({ ...shape, type: "shape" });
  }
  const nvPicPr = `<p:nvPicPr>` + `<p:cNvPr id="${id}" name="${escapeXml3(name)}"/>` + `<p:cNvPicPr><a:picLocks noChangeAspect="1"/></p:cNvPicPr>` + `<p:nvPr/>` + `</p:nvPicPr>`;
  let blipFill = `<p:blipFill><a:blip r:embed="${rId}"/>`;
  if (shape.picture && hasCrop(shape.picture)) {
    const p = shape.picture;
    blipFill += `<a:srcRect l="${pct2(p.cropLeft)}" t="${pct2(p.cropTop)}" r="${pct2(p.cropRight)}" b="${pct2(p.cropBottom)}"/>`;
  }
  blipFill += `<a:stretch><a:fillRect/></a:stretch></p:blipFill>`;
  const spPr = buildTransformXml(shape.transform) + `<a:prstGeom prst="rect"><a:avLst/></a:prstGeom>`;
  return `<p:pic>${nvPicPr}${blipFill}<p:spPr>${spPr}</p:spPr></p:pic>`;
}
function buildGroupXml(shape, imageRefs, hyperlinks) {
  const id = nextShapeId();
  const name = shape.name ?? `Group ${id}`;
  const nvGrpSpPr = `<p:nvGrpSpPr>` + `<p:cNvPr id="${id}" name="${escapeXml3(name)}"/>` + `<p:cNvGrpSpPr/>` + `<p:nvPr/>` + `</p:nvGrpSpPr>`;
  const t = shape.transform;
  const grpSpPr = `<p:grpSpPr>` + `<a:xfrm>` + `<a:off x="${t.xEmu}" y="${t.yEmu}"/>` + `<a:ext cx="${t.widthEmu}" cy="${t.heightEmu}"/>` + `<a:chOff x="${t.xEmu}" y="${t.yEmu}"/>` + `<a:chExt cx="${t.widthEmu}" cy="${t.heightEmu}"/>` + `</a:xfrm></p:grpSpPr>`;
  const childShapes = (shape.children ?? []).map((c) => buildShapeXml(c, imageRefs, hyperlinks)).join("");
  return `<p:grpSp>${nvGrpSpPr}${grpSpPr}${childShapes}</p:grpSp>`;
}
function buildConnectorXml(shape) {
  const id = nextShapeId();
  const name = shape.name ?? `Connector ${id}`;
  const preset = shape.presetShape ?? "straightConnector1";
  const nvCxnSpPr = `<p:nvCxnSpPr>` + `<p:cNvPr id="${id}" name="${escapeXml3(name)}"/>` + `<p:cNvCxnSpPr/>` + `<p:nvPr/>` + `</p:nvCxnSpPr>`;
  const spPr = buildShapeProperties({ ...shape, presetShape: preset });
  return `<p:cxnSp>${nvCxnSpPr}${spPr}</p:cxnSp>`;
}
function buildTableXml(shape) {
  if (!shape.table)
    return buildSpShapeXml({ ...shape, type: "shape" });
  const id = nextShapeId();
  const name = shape.name ?? `Table ${id}`;
  const t = shape.transform;
  const nvGraphicFramePr = `<p:nvGraphicFramePr>` + `<p:cNvPr id="${id}" name="${escapeXml3(name)}"/>` + `<p:cNvGraphicFramePr><a:graphicFrameLocks noGrp="1"/></p:cNvGraphicFramePr>` + `<p:nvPr/>` + `</p:nvGraphicFramePr>`;
  const xfrm = `<p:xfrm><a:off x="${t.xEmu}" y="${t.yEmu}"/><a:ext cx="${t.widthEmu}" cy="${t.heightEmu}"/></p:xfrm>`;
  const tbl = buildTableContentXml(shape.table);
  return `<p:graphicFrame>${nvGraphicFramePr}${xfrm}` + `<a:graphic><a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/table">` + tbl + `</a:graphicData></a:graphic></p:graphicFrame>`;
}
function buildTableContentXml(table) {
  const gridCols = table.columnWidthsEmu.map((w) => `<a:gridCol w="${w}"/>`).join("");
  const rows = table.rows.map((row) => {
    const cells = row.cells.map((cell) => {
      const attrs = [];
      if (cell.colSpan && cell.colSpan > 1)
        attrs.push(`gridSpan="${cell.colSpan}"`);
      if (cell.rowSpan && cell.rowSpan > 1)
        attrs.push(`rowSpan="${cell.rowSpan}"`);
      const txBody = cell.text ? buildTextBodyXml(cell.text) : `<p:txBody><a:bodyPr/><a:lstStyle/><a:p><a:endParaRPr lang="en-US"/></a:p></p:txBody>`;
      const tcPr = cell.fill ? `<a:tcPr>${buildFillXml(cell.fill)}</a:tcPr>` : `<a:tcPr/>`;
      return `<a:tc${attrs.length > 0 ? " " + attrs.join(" ") : ""}>${txBody}${tcPr}</a:tc>`;
    }).join("");
    return `<a:tr h="${row.heightEmu}">${cells}</a:tr>`;
  }).join("");
  return `<a:tbl><a:tblPr/><a:tblGrid>${gridCols}</a:tblGrid>${rows}</a:tbl>`;
}
function buildShapeProperties(shape) {
  const parts = [];
  parts.push(buildTransformXml(shape.transform));
  const preset = shape.presetShape ?? "rect";
  parts.push(`<a:prstGeom prst="${preset}"><a:avLst/></a:prstGeom>`);
  if (shape.fill) {
    parts.push(buildFillXml(shape.fill));
  }
  if (shape.line) {
    parts.push(buildLineXml(shape.line));
  }
  return `<p:spPr>${parts.join("")}</p:spPr>`;
}
function buildTransformXml(t) {
  const attrs = [];
  if (t.rotation && t.rotation !== 0) {
    attrs.push(`rot="${Math.round(t.rotation * 60000)}"`);
  }
  if (t.flipH)
    attrs.push(`flipH="1"`);
  if (t.flipV)
    attrs.push(`flipV="1"`);
  return `<a:xfrm${attrs.length > 0 ? " " + attrs.join(" ") : ""}>` + `<a:off x="${t.xEmu}" y="${t.yEmu}"/>` + `<a:ext cx="${t.widthEmu}" cy="${t.heightEmu}"/>` + `</a:xfrm>`;
}
function buildFillXml(fill) {
  switch (fill.type) {
    case "none":
      return `<a:noFill/>`;
    case "solid":
      return `<a:solidFill><a:srgbClr val="${fill.color}"/></a:solidFill>`;
    case "gradient": {
      const stops = fill.stops.map((s) => `<a:gs pos="${Math.round(s.position * 1e5)}"><a:srgbClr val="${s.color}"/></a:gs>`).join("");
      return `<a:gradFill><a:gsLst>${stops}</a:gsLst>` + `<a:lin ang="${Math.round(fill.angle * 60000)}" scaled="1"/></a:gradFill>`;
    }
  }
}
function buildLineXml(line) {
  const attrs = [];
  attrs.push(`w="${line.widthEmu}"`);
  const children = [];
  if (line.color) {
    children.push(`<a:solidFill><a:srgbClr val="${line.color}"/></a:solidFill>`);
  }
  if (line.dashStyle && line.dashStyle !== "solid") {
    const dashMap = {
      dash: "dash",
      dot: "dot",
      dashDot: "dashDot",
      dashDotDot: "lgDashDotDot"
    };
    children.push(`<a:prstDash val="${dashMap[line.dashStyle] ?? "solid"}"/>`);
  }
  return `<a:ln ${attrs.join(" ")}>${children.join("")}</a:ln>`;
}
function hasCrop(p) {
  return !!(p.cropLeft || p.cropTop || p.cropRight || p.cropBottom);
}
function pct2(value) {
  if (!value)
    return "0";
  return String(Math.round(value * 1e5));
}

// packages/@oxen-office/ppt/src/converter/slide-xml.ts
function buildSlideXml(slide, imageRefs, hyperlinks) {
  resetShapeIdCounter();
  const shapes = slide.shapes.map((s) => buildShapeXml(s, imageRefs, hyperlinks)).join("");
  return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` + `<p:sld ` + `xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" ` + `xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" ` + `xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">` + `<p:cSld><p:spTree>` + `<p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr>` + `<p:grpSpPr/>` + shapes + `</p:spTree></p:cSld>` + `</p:sld>`;
}

// packages/@oxen-office/ppt/src/converter/image-embed.ts
function contentTypeToExtension(contentType) {
  const mapping = {
    "image/jpeg": "jpeg",
    "image/png": "png",
    "image/bmp": "bmp",
    "image/x-emf": "emf",
    "image/x-wmf": "wmf",
    "image/tiff": "tiff",
    "image/pict": "pict"
  };
  return mapping[contentType] ?? "png";
}
function embedSlideImages(pkg, images, usedImageIndices, slideIndex, startRId) {
  const imageMap = new Map;
  const extensions = new Set;
  let rIdCounter = startRId;
  for (const idx of usedImageIndices) {
    const image = images.find((img) => img.index === idx);
    if (!image)
      continue;
    const ext = contentTypeToExtension(image.contentType);
    extensions.add(ext);
    const mediaPath = `ppt/media/image${slideIndex}_${idx}.${ext}`;
    const rId = `rId${rIdCounter++}`;
    const buf = new Uint8Array(image.data.byteLength);
    buf.set(image.data);
    pkg.writeBinary(mediaPath, buf.buffer);
    imageMap.set(idx, { rId, mediaPath });
  }
  return { imageMap, extensions: Array.from(extensions) };
}
function buildImageRelationships(imageMap) {
  const rels = [];
  for (const [, { rId, mediaPath }] of imageMap) {
    rels.push({
      id: rId,
      type: RT_IMAGE,
      target: `../${mediaPath.replace("ppt/", "")}`
    });
  }
  return rels;
}
function collectUsedImageIndices(shapes) {
  const indices = new Set;
  function walk(shape) {
    if (shape.picture) {
      indices.add(shape.picture.pictureIndex);
    }
    if (shape.children) {
      for (const child of shape.children) {
        walk(child);
      }
    }
  }
  for (const shape of shapes) {
    walk(shape);
  }
  return indices;
}

// packages/@oxen-office/ppt/src/converter/index.ts
function convertPptToPptx(ppt, _ctx) {
  const pkg = createEmptyZipPackage();
  const slideCount = ppt.slides.length;
  pkg.writeText("_rels/.rels", ROOT_RELS_XML);
  pkg.writeText("docProps/app.xml", APP_XML);
  pkg.writeText("ppt/theme/theme1.xml", MINIMAL_THEME);
  pkg.writeText("ppt/slideMasters/slideMaster1.xml", MINIMAL_SLIDE_MASTER);
  pkg.writeText("ppt/slideMasters/_rels/slideMaster1.xml.rels", buildMasterRelsXml());
  pkg.writeText("ppt/slideLayouts/slideLayout1.xml", MINIMAL_SLIDE_LAYOUT);
  pkg.writeText("ppt/slideLayouts/_rels/slideLayout1.xml.rels", buildLayoutRelsXml());
  const hasNotes = [];
  const allImageExtensions = new Set;
  for (let i2 = 0;i2 < slideCount; i2++) {
    const slide = ppt.slides[i2];
    const slideIdx = i2 + 1;
    const usedIndices = collectUsedImageIndices(slide.shapes);
    const embedResult = embedSlideImages(pkg, ppt.images, usedIndices, slideIdx, 2);
    for (const ext of embedResult.extensions) {
      allImageExtensions.add(ext);
    }
    const imageRefs = new Map;
    for (const [idx, { rId }] of embedResult.imageMap) {
      imageRefs.set(idx, rId);
    }
    const hyperlinkRels = [];
    const hyperlinkMap = new Map;
    collectHyperlinks(slide, hyperlinkMap, hyperlinkRels, embedResult.imageMap.size + 2);
    const extraRels = [
      ...buildImageRelationships(embedResult.imageMap),
      ...hyperlinkRels
    ];
    const slideHasNotes = !!slide.notes;
    hasNotes.push(slideHasNotes);
    if (slideHasNotes) {
      const notesRId = `rId${extraRels.length + 2}`;
      extraRels.push({
        id: notesRId,
        type: RT_NOTES,
        target: `../notesSlides/notesSlide${slideIdx}.xml`
      });
      pkg.writeText(`ppt/notesSlides/notesSlide${slideIdx}.xml`, buildNotesSlideXml(slide.notes));
      pkg.writeText(`ppt/notesSlides/_rels/notesSlide${slideIdx}.xml.rels`, buildNotesRelsXml(slideIdx));
    }
    const slideXml = buildSlideXml(slide, imageRefs, hyperlinkMap);
    pkg.writeText(`ppt/slides/slide${slideIdx}.xml`, slideXml);
    pkg.writeText(`ppt/slides/_rels/slide${slideIdx}.xml.rels`, buildSlideRelsXml(extraRels));
  }
  pkg.writeText("ppt/presentation.xml", buildPresentationXml(slideCount, ppt.slideSize));
  pkg.writeText("ppt/_rels/presentation.xml.rels", buildPresentationRelsXml(slideCount));
  pkg.writeText("[Content_Types].xml", buildContentTypesXml(slideCount, {
    hasNotes,
    imageExtensions: Array.from(allImageExtensions)
  }));
  return { pkg };
}
function collectHyperlinks(slide, hyperlinkMap, rels, startRId) {
  let rIdCounter = startRId;
  function walkShape(shape) {
    if (shape.textBody) {
      for (const para of shape.textBody.paragraphs) {
        for (const run of para.runs) {
          if (run.properties.hyperlink && !hyperlinkMap.has(run.properties.hyperlink)) {
            const rId = `rId${rIdCounter++}`;
            hyperlinkMap.set(run.properties.hyperlink, rId);
            rels.push({
              id: rId,
              type: RT_HYPERLINK,
              target: run.properties.hyperlink,
              targetMode: "External"
            });
          }
        }
      }
    }
    if (shape.children) {
      for (const child of shape.children) {
        walkShape(child);
      }
    }
  }
  for (const shape of slide.shapes) {
    walkShape(shape);
  }
}

// packages/@oxen-office/ppt/src/parser.ts
function createCfbWarningSink(warn) {
  if (!warn)
    return;
  return (warning) => {
    const base = { where: `CFB:${warning.where}`, message: warning.message, ...warning.meta ? { meta: warning.meta } : {} };
    const codeMapping = {
      FAT_CHAIN_INVALID: "CFB_FAT_CHAIN_INVALID",
      FAT_CHAIN_TOO_SHORT: "CFB_FAT_CHAIN_TOO_SHORT",
      FAT_CHAIN_LENGTH_MISMATCH: "CFB_FAT_CHAIN_LENGTH_MISMATCH",
      FAT_SECTOR_READ_FAILED: "CFB_FAT_SECTOR_READ_FAILED",
      MINIFAT_CHAIN_INVALID: "CFB_MINIFAT_CHAIN_INVALID",
      MINIFAT_CHAIN_TOO_SHORT: "CFB_MINIFAT_CHAIN_TOO_SHORT",
      MINIFAT_CHAIN_LENGTH_MISMATCH: "CFB_MINIFAT_CHAIN_LENGTH_MISMATCH",
      MINISTREAM_TRUNCATED: "CFB_MINISTREAM_TRUNCATED"
    };
    const code = codeMapping[warning.code];
    if (code)
      warn({ code, ...base });
  };
}
function createContext(options) {
  return { mode: options?.mode ?? "strict", ...options?.onWarning ? { warn: options.onWarning } : {} };
}
function readStreamSafe(cfb, path) {
  try {
    return cfb.readStream(path);
  } catch {
    return;
  }
}
function parsePptFromBytes(bytes, ctx) {
  const cfbWarningSink = createCfbWarningSink(ctx.warn);
  const strict = isStrict(ctx);
  const cfb = openCfb(bytes, { strict, ...cfbWarningSink ? { onWarning: cfbWarningSink } : {} });
  const docStream = readStreamSafe(cfb, ["PowerPoint Document"]);
  if (!docStream) {
    throw new Error("PowerPoint Document stream not found in CFB container");
  }
  const currentUserStream = readStreamSafe(cfb, ["Current User"]);
  const picturesStream = readStreamSafe(cfb, ["Pictures"]);
  const parsed = parsePptDocumentStream(docStream, currentUserStream, ctx);
  const images = picturesStream ? parsePicturesStream(picturesStream) : [];
  const presentation = extractPptPresentation(parsed, images, ctx);
  const { pkg } = convertPptToPptx(presentation, ctx);
  return { presentation, pkg };
}
function parsePptWithReport(bytes, options) {
  if (!(bytes instanceof Uint8Array)) {
    throw new Error("parsePptWithReport: bytes must be a Uint8Array");
  }
  const collector = createPptWarningCollector();
  const ctx = createContext({ ...options?.mode ? { mode: options.mode } : {}, onWarning: collector.warn });
  const { presentation, pkg } = parsePptFromBytes(bytes, ctx);
  return { presentation, pkg, warnings: collector.warnings };
}
// packages/@oxen-converters/ppt-to-pptx/src/index.ts
function convert(input, options) {
  options?.onProgress?.({ current: 0, total: 1, phase: "converting" });
  const result = parsePptWithReport(input, { mode: "lenient" });
  options?.onProgress?.({ current: 1, total: 1, phase: "done" });
  return {
    data: result.pkg,
    warnings: result.warnings.map((w) => ({
      code: w.code,
      message: w.message,
      where: w.where,
      ...w.meta ? { meta: w.meta } : {}
    }))
  };
}

// packages/@oxen-cli/pptx-cli/src/commands/loader.ts
async function loadPresentationBundle(filePath) {
  const buffer = await fs.readFile(filePath);
  if (extname(filePath).toLowerCase() === ".ppt") {
    const { data } = convert(new Uint8Array(buffer));
    const pptxBuffer = await data.toArrayBuffer();
    return loadPptxBundleFromBuffer(pptxBuffer);
  }
  return loadPptxBundleFromBuffer(buffer);
}
// packages/@oxen-cli/cli-core/src/result.ts
function success(data) {
  return { success: true, data };
}
function error(code, message) {
  return { success: false, error: { code, message } };
}
// packages/@oxen-cli/cli-core/src/json-output.ts
function formatJson(result) {
  return JSON.stringify(result, null, 2);
}
// packages/@oxen-cli/cli-core/src/output-handler.ts
function output(result, mode, prettyFormatter, mermaidFormatter) {
  if (mode === "json") {
    console.log(formatJson(result));
  } else {
    const formatter = mode === "mermaid" && mermaidFormatter ? mermaidFormatter : prettyFormatter;
    if (result.success) {
      console.log(formatter(result.data));
    } else {
      console.error(`Error [${result.error.code}]: ${result.error.message}`);
    }
  }
  if (!result.success) {
    process.exitCode = 1;
  }
}
// packages/@oxen-cli/pptx-cli/src/commands/info.ts
async function runInfo(filePath) {
  try {
    const { presentationFile } = await loadPresentationBundle(filePath);
    const presentation = openPresentation(presentationFile);
    const widthEmu = Math.round(presentation.size.width * EMU_PER_PIXEL);
    const heightEmu = Math.round(presentation.size.height * EMU_PER_PIXEL);
    return success({
      slideCount: presentation.count,
      slideSize: {
        width: presentation.size.width,
        height: presentation.size.height,
        widthEmu,
        heightEmu
      },
      appVersion: presentation.appVersion
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse PPTX: ${err2.message}`);
  }
}

// packages/@oxen-office/pptx/src/domain/text-utils.ts
function extractTextFromBody(textBody) {
  return textBody.paragraphs.map(extractTextFromParagraph).join(`
`);
}
function extractTextFromParagraph(paragraph) {
  return paragraph.runs.map(extractTextFromRun).join("");
}
function extractTextFromRun(run) {
  switch (run.type) {
    case "text":
      return run.text;
    case "break":
      return `
`;
    case "field":
      return run.text;
  }
}
function extractTextFromShape(shape) {
  if (shape.type === "sp" && shape.textBody) {
    return extractTextFromBody(shape.textBody);
  }
  if (shape.type === "grpSp") {
    return shape.children.map(extractTextFromShape).filter(Boolean).join(`
`);
  }
  return "";
}

// packages/@oxen-cli/pptx-cli/src/commands/utils.ts
function parseRangePart(part, maxSlide, result) {
  if (part.includes("-")) {
    const [startStr, endStr] = part.split("-").map((s) => s.trim());
    const start = parseInt(startStr, 10);
    const end = parseInt(endStr, 10);
    if (Number.isNaN(start) || Number.isNaN(end)) {
      return;
    }
    for (let i2 = Math.max(1, start);i2 <= Math.min(maxSlide, end); i2++) {
      if (!result.includes(i2)) {
        result.push(i2);
      }
    }
  } else {
    const num = parseInt(part, 10);
    if (!Number.isNaN(num) && num >= 1 && num <= maxSlide && !result.includes(num)) {
      result.push(num);
    }
  }
}
function parseSlideRange(range2, maxSlide) {
  const result = [];
  const parts = range2.split(",").map((s) => s.trim());
  for (const part of parts) {
    parseRangePart(part, maxSlide, result);
  }
  return result.sort((a, b) => a - b);
}
function getSlideNumbers(slidesOption, count) {
  if (slidesOption) {
    return parseSlideRange(slidesOption, count);
  }
  return Array.from({ length: count }, (_, i2) => i2 + 1);
}
function hasShapeOfType(shapes, check) {
  for (const shape of shapes) {
    if (check(shape)) {
      return true;
    }
    if (shape.type === "grpSp" && hasShapeOfType(shape.children, check)) {
      return true;
    }
  }
  return false;
}
function collectShapes(shapes, collector) {
  const results = [];
  for (const shape of shapes) {
    const result = collector(shape);
    if (result !== undefined) {
      results.push(result);
    }
    if (shape.type === "grpSp") {
      results.push(...collectShapes(shape.children, collector));
    }
  }
  return results;
}

// packages/@oxen-cli/pptx-cli/src/commands/list.ts
function findTitleInShape(shape) {
  if (shape.type !== "sp") {
    return null;
  }
  const phType = shape.placeholder?.type;
  if (phType !== "title" && phType !== "ctrTitle") {
    return null;
  }
  const text = extractTextFromShape(shape).trim();
  return text || null;
}
function findTitle(shapes) {
  for (const shape of shapes) {
    const title = findTitleInShape(shape);
    if (title) {
      return title;
    }
  }
  return null;
}
function countShapesRecursive(shapes, initial) {
  return shapes.reduce((acc, shape) => {
    const childCount = shape.type === "grpSp" ? countShapesRecursive(shape.children, 0) : 0;
    return acc + 1 + childCount;
  }, initial);
}
function countShapes(shapes) {
  return countShapesRecursive(shapes, 0);
}
function hasTable(shapes) {
  return hasShapeOfType(shapes, (s) => s.type === "graphicFrame" && s.content.type === "table");
}
function hasChart(shapes) {
  return hasShapeOfType(shapes, (s) => s.type === "graphicFrame" && s.content.type === "chart");
}
function hasImage(shapes) {
  return hasShapeOfType(shapes, (s) => s.type === "pic");
}
async function runList(filePath) {
  try {
    const { presentationFile } = await loadPresentationBundle(filePath);
    const presentation = openPresentation(presentationFile);
    const items = [];
    for (const apiSlide of presentation.slides()) {
      const domainSlide = parseSlide(apiSlide.content);
      const shapes = domainSlide?.shapes ?? [];
      items.push({
        number: apiSlide.number,
        filename: apiSlide.filename,
        title: findTitle(shapes),
        shapeCount: countShapes(shapes),
        hasTable: hasTable(shapes),
        hasChart: hasChart(shapes),
        hasImage: hasImage(shapes),
        transitionType: domainSlide?.transition?.type
      });
    }
    return success({ slides: items });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse PPTX: ${err2.message}`);
  }
}

// packages/@oxen-cli/pptx-cli/src/serializers/shape-serializer.ts
function serializeBounds(transform) {
  if (!transform) {
    return;
  }
  return {
    x: transform.x,
    y: transform.y,
    width: transform.width,
    height: transform.height
  };
}
function serializePlaceholder(placeholder) {
  if (!placeholder) {
    return;
  }
  return {
    type: placeholder.type,
    idx: placeholder.idx
  };
}
function serializeRunProperties(props) {
  if (!props) {
    return;
  }
  const result = {};
  if (props.bold !== undefined) {
    result.bold = props.bold;
  }
  if (props.italic !== undefined) {
    result.italic = props.italic;
  }
  if (props.fontSize !== undefined) {
    result.fontSize = props.fontSize;
  }
  if (props.fontFamily !== undefined) {
    result.fontFamily = props.fontFamily;
  }
  return Object.keys(result).length > 0 ? result : undefined;
}
function serializeRun(run) {
  const text = run.type === "text" ? run.text : run.type === "field" ? run.text : "";
  return {
    type: run.type,
    text,
    properties: serializeRunProperties(run.properties)
  };
}
function serializeParagraphProperties(props) {
  const result = {};
  if (props.level !== undefined) {
    result.level = props.level;
  }
  if (props.alignment !== undefined) {
    result.alignment = props.alignment;
  }
  if (props.bulletStyle?.bullet?.type !== undefined && props.bulletStyle.bullet.type !== "none") {
    result.bulletType = props.bulletStyle.bullet.type;
  }
  return Object.keys(result).length > 0 ? result : undefined;
}
function serializeParagraph(paragraph) {
  return {
    text: extractTextFromParagraph(paragraph),
    runs: paragraph.runs.map(serializeRun),
    properties: serializeParagraphProperties(paragraph.properties)
  };
}
function serializeMedia(media) {
  if (!media) {
    return;
  }
  return {
    audioFile: media.audioFile,
    quickTimeFile: media.quickTimeFile,
    videoFile: media.videoFile,
    wavAudioFile: media.wavAudioFile
  };
}
function serializeGeometry(geometry) {
  if (!geometry) {
    return;
  }
  if (geometry.type === "preset") {
    const preset = geometry;
    return {
      kind: "preset",
      preset: preset.preset,
      adjustValues: preset.adjustValues.length > 0 ? preset.adjustValues : undefined
    };
  }
  const custom = geometry;
  return {
    kind: "custom",
    pathCount: custom.paths.length,
    adjustValues: custom.adjustValues && custom.adjustValues.length > 0 ? custom.adjustValues : undefined
  };
}
function getColorValue(color) {
  if (!color) {
    return;
  }
  if (color.spec.type === "srgb" && color.spec.value) {
    return color.spec.value;
  }
  if (color.spec.type === "scheme" && color.spec.value) {
    return `scheme:${color.spec.value}`;
  }
  return;
}
function serializeBlipColor(color) {
  return getColorValue(color);
}
function serializeBlipEffects(effects) {
  if (!effects) {
    return;
  }
  const result = {};
  if (effects.alphaBiLevel) {
    result.alphaBiLevel = { threshold: effects.alphaBiLevel.threshold };
  }
  if (effects.alphaCeiling) {
    result.alphaCeiling = true;
  }
  if (effects.alphaFloor) {
    result.alphaFloor = true;
  }
  if (effects.alphaInv) {
    result.alphaInv = true;
  }
  if (effects.alphaMod) {
    result.alphaMod = true;
  }
  if (effects.alphaModFix) {
    result.alphaModFix = effects.alphaModFix.amount;
  }
  if (effects.alphaRepl) {
    result.alphaRepl = { alpha: effects.alphaRepl.alpha };
  }
  if (effects.biLevel) {
    result.biLevel = { threshold: effects.biLevel.threshold };
  }
  if (effects.blur) {
    result.blur = {
      radius: effects.blur.radius,
      grow: effects.blur.grow || undefined
    };
  }
  if (effects.colorChange) {
    const from = serializeBlipColor(effects.colorChange.from);
    const to = serializeBlipColor(effects.colorChange.to);
    if (from && to) {
      result.colorChange = {
        from,
        to,
        useAlpha: effects.colorChange.useAlpha || undefined
      };
    }
  }
  if (effects.colorReplace) {
    const color = serializeBlipColor(effects.colorReplace.color);
    if (color) {
      result.colorReplace = { color };
    }
  }
  if (effects.duotone) {
    const c1 = serializeBlipColor(effects.duotone.colors[0]);
    const c2 = serializeBlipColor(effects.duotone.colors[1]);
    if (c1 && c2) {
      result.duotone = { colors: [c1, c2] };
    }
  }
  if (effects.grayscale) {
    result.grayscale = true;
  }
  if (effects.hsl) {
    result.hsl = {
      hue: effects.hsl.hue,
      saturation: effects.hsl.saturation,
      luminance: effects.hsl.luminance
    };
  }
  if (effects.luminance) {
    result.luminance = {
      brightness: effects.luminance.brightness,
      contrast: effects.luminance.contrast
    };
  }
  if (effects.tint) {
    result.tint = {
      hue: effects.tint.hue,
      amount: effects.tint.amount
    };
  }
  return Object.keys(result).length > 0 ? result : undefined;
}
function serializeFill(fill) {
  if (!fill) {
    return;
  }
  switch (fill.type) {
    case "solidFill":
      return { type: "solid", color: getColorValue(fill.color) };
    case "gradientFill":
      return { type: "gradient" };
    case "patternFill":
      return { type: "pattern" };
    case "blipFill":
      return { type: "blip", resourceId: fill.resourceId };
    case "groupFill":
      return { type: "group" };
    case "noFill":
      return { type: "none" };
    default:
      return { type: "unknown" };
  }
}
function serializeLine(line) {
  if (!line) {
    return;
  }
  const result = {};
  if (line.width !== undefined) {
    result.width = line.width;
  }
  if (line.fill?.type === "solidFill") {
    const colorValue = getColorValue(line.fill.color);
    if (colorValue) {
      result.color = colorValue;
    }
  }
  if (line.dash !== undefined && typeof line.dash === "string") {
    result.dashStyle = line.dash;
  }
  if (line.compound !== undefined && line.compound !== "sng") {
    result.compound = line.compound;
  }
  return Object.keys(result).length > 0 ? result : undefined;
}
function serializeStyle(style) {
  if (!style) {
    return;
  }
  const result = {};
  if (style.lineReference?.index !== undefined) {
    result.lineRef = style.lineReference.index;
  }
  if (style.fillReference?.index !== undefined) {
    result.fillRef = style.fillReference.index;
  }
  if (style.effectReference?.index !== undefined) {
    result.effectRef = style.effectReference.index;
  }
  if (style.fontReference?.index !== undefined) {
    result.fontRef = style.fontReference.index;
  }
  return Object.keys(result).length > 0 ? result : undefined;
}
function serializeEffects(effects) {
  if (!effects) {
    return;
  }
  const result = {};
  if (effects.shadow) {
    result.shadow = {
      type: effects.shadow.type,
      color: getColorValue(effects.shadow.color),
      blur: effects.shadow.blurRadius,
      distance: effects.shadow.distance,
      direction: effects.shadow.direction
    };
  }
  if (effects.glow) {
    result.glow = {
      color: getColorValue(effects.glow.color),
      radius: effects.glow.radius
    };
  }
  if (effects.softEdge) {
    result.softEdge = {
      radius: effects.softEdge.radius
    };
  }
  return Object.keys(result).length > 0 ? result : undefined;
}
function serializeShape3d(shape3d) {
  if (!shape3d) {
    return;
  }
  const result = {};
  if (shape3d.bevelTop) {
    result.bevelTop = {
      preset: shape3d.bevelTop.preset,
      width: shape3d.bevelTop.width,
      height: shape3d.bevelTop.height
    };
  }
  if (shape3d.bevelBottom) {
    result.bevelBottom = {
      preset: shape3d.bevelBottom.preset,
      width: shape3d.bevelBottom.width,
      height: shape3d.bevelBottom.height
    };
  }
  if (shape3d.preset) {
    result.material = shape3d.preset;
  }
  if (shape3d.extrusionHeight !== undefined && shape3d.extrusionHeight > 0) {
    result.extrusionHeight = shape3d.extrusionHeight;
  }
  return Object.keys(result).length > 0 ? result : undefined;
}
function serializeTableCell(cell) {
  const text = cell.textBody ? extractTextFromBody(cell.textBody) : "";
  const result = { text };
  if (cell.properties.rowSpan && cell.properties.rowSpan > 1) {
    result.rowSpan = cell.properties.rowSpan;
  }
  if (cell.properties.colSpan && cell.properties.colSpan > 1) {
    result.colSpan = cell.properties.colSpan;
  }
  return result;
}
function serializeTableRow(row) {
  return {
    height: row.height,
    cells: row.cells.map(serializeTableCell)
  };
}
function serializeTable(tableRef) {
  const table = tableRef.table;
  return {
    rows: table.rows.length,
    cols: table.grid.columns.length,
    data: table.rows.map(serializeTableRow),
    styleId: table.properties.tableStyleId
  };
}
function serializeChart(chartRef, ctx) {
  const result = {
    resourceId: chartRef.resourceId
  };
  if (ctx?.resolveChart) {
    const chart = ctx.resolveChart(chartRef.resourceId);
    if (chart) {
      const title = chart.title?.textBody?.paragraphs.flatMap((p) => p.runs.map((r) => ("text" in r ? r.text : "") ?? "")).join("") || undefined;
      const chartSeries = chart.plotArea.charts[0];
      if (chartSeries) {
        result.title = title;
        result.chartType = chartSeries.type;
        const series = [];
        const seriesItems = "series" in chartSeries ? chartSeries.series : [];
        for (const s of seriesItems) {
          const item = s;
          const numPoints = item.values?.numRef?.cache?.points ?? item.values?.numLit?.points;
          const values = numPoints?.slice().sort((a, b) => a.idx - b.idx).map((p) => p.value) ?? [];
          const strPoints = item.categories?.strRef?.cache?.points ?? item.categories?.strLit?.points;
          const numCatPoints = item.categories?.numRef?.cache?.points ?? item.categories?.numLit?.points;
          const cats = strPoints?.slice().sort((a, b) => a.idx - b.idx).map((p) => p.value) ?? numCatPoints?.slice().sort((a, b) => a.idx - b.idx).map((p) => String(p.value));
          series.push({
            name: item.tx?.value,
            values,
            categories: cats
          });
        }
        result.series = series;
      }
    }
  }
  return result;
}
function serializeDiagram(diagramRef, frame, ctx) {
  const base = {
    dataResourceId: diagramRef.dataResourceId,
    layoutResourceId: diagramRef.layoutResourceId,
    styleResourceId: diagramRef.styleResourceId,
    colorResourceId: diagramRef.colorResourceId
  };
  if (ctx?.resolveDiagramShapes) {
    const shapes = ctx.resolveDiagramShapes(diagramRef);
    if (shapes && shapes.length > 0) {
      const diagramShapes = [];
      for (const s of shapes) {
        if (s.type === "sp" || s.type === "pic") {
          const sp = s;
          const t = sp.properties?.transform;
          if (t) {
            const text = sp.textBody ? sp.textBody.paragraphs.map((p) => extractTextFromParagraph(p)).filter(Boolean).join(`
`) : undefined;
            diagramShapes.push({
              bounds: { x: t.x, y: t.y, width: t.width, height: t.height },
              text: text || undefined
            });
          }
        }
      }
      base.shapes = diagramShapes;
      if (frame?.transform) {
        base.width = frame.transform.width;
        base.height = frame.transform.height;
      }
    }
  }
  return base;
}
function serializeGraphicContent(content, frame, ctx) {
  switch (content.type) {
    case "table":
      return { type: "table", table: serializeTable(content.data) };
    case "chart":
      return { type: "chart", chart: serializeChart(content.data, ctx) };
    case "diagram":
      return { type: "diagram", diagram: serializeDiagram(content.data, frame, ctx) };
    case "oleObject":
      return { type: "oleObject", progId: content.data.progId };
    case "unknown":
      return { type: "unknown", uri: content.uri };
  }
}
function serializeShapeProperties(props) {
  return {
    geometry: serializeGeometry(props.geometry),
    fill: serializeFill(props.fill),
    line: serializeLine(props.line),
    effects: serializeEffects(props.effects),
    shape3d: serializeShape3d(props.shape3d)
  };
}
function serializeShape(shape, ctx) {
  switch (shape.type) {
    case "sp": {
      const text = extractTextFromShape(shape);
      const { geometry, fill, line, effects, shape3d } = serializeShapeProperties(shape.properties);
      const transform = shape.properties.transform;
      return {
        id: shape.nonVisual.id,
        name: shape.nonVisual.name,
        type: shape.type,
        placeholder: serializePlaceholder(shape.placeholder),
        bounds: serializeBounds(transform),
        rotation: transform?.rotation !== 0 ? transform?.rotation : undefined,
        flipH: transform?.flipH || undefined,
        flipV: transform?.flipV || undefined,
        text: text || undefined,
        paragraphs: shape.textBody?.paragraphs.map(serializeParagraph),
        geometry,
        fill,
        line,
        effects,
        shape3d,
        style: serializeStyle(shape.style)
      };
    }
    case "pic": {
      const { fill, line } = serializeShapeProperties(shape.properties);
      const transform = shape.properties.transform;
      return {
        id: shape.nonVisual.id,
        name: shape.nonVisual.name,
        type: shape.type,
        bounds: serializeBounds(transform),
        rotation: transform?.rotation !== 0 ? transform?.rotation : undefined,
        flipH: transform?.flipH || undefined,
        flipV: transform?.flipV || undefined,
        resourceId: shape.blipFill.resourceId,
        blipEffects: serializeBlipEffects(shape.blipFill.blipEffects),
        mediaType: shape.mediaType,
        media: serializeMedia(shape.media),
        fill,
        line,
        style: serializeStyle(shape.style)
      };
    }
    case "grpSp": {
      return {
        id: shape.nonVisual.id,
        name: shape.nonVisual.name,
        type: shape.type,
        children: shape.children.map((c) => serializeShape(c, ctx))
      };
    }
    case "cxnSp": {
      const { geometry, fill, line } = serializeShapeProperties(shape.properties);
      const transform = shape.properties.transform;
      return {
        id: shape.nonVisual.id,
        name: shape.nonVisual.name,
        type: shape.type,
        bounds: serializeBounds(transform),
        rotation: transform?.rotation !== 0 ? transform?.rotation : undefined,
        geometry,
        fill,
        line,
        style: serializeStyle(shape.style),
        connection: {
          startShapeId: shape.nonVisual.startConnection?.shapeId,
          endShapeId: shape.nonVisual.endConnection?.shapeId
        }
      };
    }
    case "graphicFrame": {
      return {
        id: shape.nonVisual.id,
        name: shape.nonVisual.name,
        type: shape.type,
        bounds: serializeBounds(shape.transform),
        rotation: shape.transform?.rotation !== 0 ? shape.transform?.rotation : undefined,
        content: serializeGraphicContent(shape.content, { transform: shape.transform ?? undefined }, ctx)
      };
    }
    case "contentPart": {
      return {
        id: "contentPart",
        name: "contentPart",
        type: shape.type
      };
    }
  }
}

// packages/@oxen-office/chart/src/domain/summary.ts
function isObject2(value) {
  return typeof value === "object" && value !== null;
}
function pointsToDenseArray(points) {
  const sorted = [...points].sort((a, b) => a.idx - b.idx);
  return sorted.map((p) => p.value);
}
function serializeDataReference(ref) {
  if (ref.strLit?.points) {
    return {
      values: pointsToDenseArray(ref.strLit.points)
    };
  }
  if (ref.strRef?.cache?.points) {
    return {
      formula: ref.strRef.formula,
      values: pointsToDenseArray(ref.strRef.cache.points)
    };
  }
  if (ref.numLit?.points) {
    return {
      values: pointsToDenseArray(ref.numLit.points)
    };
  }
  if (ref.numRef?.cache?.points) {
    return {
      formula: ref.numRef.formula,
      values: pointsToDenseArray(ref.numRef.cache.points)
    };
  }
  return;
}
function isSeriesItemLike(value) {
  if (!isObject2(value)) {
    return false;
  }
  return "categories" in value && "values" in value;
}
function summarizeChart(chart) {
  const plotCharts = chart.plotArea.charts;
  const series = plotCharts.map((s) => {
    const items = s.series.filter(isSeriesItemLike).map((item) => ({
      name: item.tx?.value,
      categories: serializeDataReference(item.categories),
      values: serializeDataReference(item.values)
    }));
    return {
      type: s.type,
      items
    };
  });
  return {
    types: plotCharts.map((s) => s.type),
    series
  };
}

// packages/@oxen-cli/pptx-cli/src/serializers/chart-resolver.ts
function getSlidePaths(slideFilename) {
  const slidePath = `ppt/slides/${slideFilename}.xml`;
  const relsPath = `ppt/slides/_rels/${slideFilename}.xml.rels`;
  return { slidePath, relsPath };
}
function resolveChartsForSlide(options) {
  const { slidePath, relsPath } = getSlidePaths(options.slideFilename);
  const relsXml = options.zipPackage.readText(relsPath);
  if (!relsXml) {
    return options.chartResourceIds.map((resourceId) => ({
      resourceId,
      error: `Could not read slide relationships: ${relsPath}`
    }));
  }
  const relsDoc = parseXml(relsXml);
  const rels = listRelationships(relsDoc);
  const relById = new Map(rels.map((r) => [r.id, r]));
  return options.chartResourceIds.map((resourceId) => {
    const rel = relById.get(resourceId);
    if (!rel) {
      return { resourceId, error: `Missing relationship: ${resourceId}` };
    }
    const partPath = resolveRelationshipTargetPath(slidePath, rel.target);
    const chartXml = options.zipPackage.readText(partPath);
    if (!chartXml) {
      return { resourceId, partPath, error: `Could not read chart part: ${partPath}` };
    }
    const chartDoc = parseXml(chartXml);
    const chart = parseChart(chartDoc);
    if (!chart) {
      return { resourceId, partPath, error: `Failed to parse chart: ${partPath}` };
    }
    return {
      resourceId,
      partPath,
      chart: summarizeChart(chart)
    };
  });
}

// packages/@oxen-cli/pptx-cli/src/commands/show.ts
function resolveChartsIfAny(options) {
  if (options.chartResourceIds.length === 0) {
    return;
  }
  return resolveChartsForSlide(options);
}
function collectChartResourceIds(shapes) {
  const ids = new Set;
  const visit = (shape) => {
    if (shape.type === "graphicFrame" && shape.content.type === "chart") {
      ids.add(shape.content.data.resourceId);
    }
    if (shape.type === "grpSp") {
      for (const child of shape.children) {
        visit(child);
      }
    }
  };
  for (const shape of shapes) {
    visit(shape);
  }
  return [...ids];
}
async function runShow(filePath, slideNumber) {
  try {
    const { zipPackage, presentationFile } = await loadPresentationBundle(filePath);
    const presentation = openPresentation(presentationFile);
    if (slideNumber < 1 || slideNumber > presentation.count) {
      return error("SLIDE_NOT_FOUND", `Slide ${slideNumber} not found. Valid range: 1-${presentation.count}`);
    }
    const apiSlide = presentation.getSlide(slideNumber);
    const zipFile = createZipAdapter(presentationFile);
    const renderContext = createRenderContext({ apiSlide, zip: zipFile, slideSize: presentation.size });
    const parseCtx = createParseContext(renderContext.slideRenderContext);
    const domainSlide = parseSlide(apiSlide.content, parseCtx);
    if (!domainSlide) {
      return error("PARSE_ERROR", `Failed to parse slide ${slideNumber}`);
    }
    const chartResourceIds = collectChartResourceIds(domainSlide.shapes);
    const charts = resolveChartsIfAny({
      zipPackage,
      slideFilename: apiSlide.filename,
      chartResourceIds
    });
    return success({
      number: apiSlide.number,
      filename: apiSlide.filename,
      transition: domainSlide.transition,
      shapes: domainSlide.shapes.map((s) => serializeShape(s)),
      charts
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse PPTX: ${err2.message}`);
  }
}

// packages/@oxen-cli/pptx-cli/src/commands/extract.ts
function collectAllText(shapes) {
  const texts = [];
  for (const shape of shapes) {
    const text = extractTextFromShape(shape).trim();
    if (text) {
      texts.push(text);
    }
    if (shape.type === "grpSp") {
      texts.push(...collectAllText(shape.children));
    }
  }
  return texts;
}
async function runExtract(filePath, options) {
  try {
    const { presentationFile } = await loadPresentationBundle(filePath);
    const presentation = openPresentation(presentationFile);
    const slideNumbers = getSlideNumbers(options.slides, presentation.count);
    const items = [];
    for (const slideNumber of slideNumbers) {
      const apiSlide = presentation.getSlide(slideNumber);
      const domainSlide = parseSlide(apiSlide.content);
      const shapes = domainSlide?.shapes ?? [];
      const texts = collectAllText(shapes);
      items.push({
        number: slideNumber,
        text: texts.join(`
`)
      });
    }
    return success({ slides: items });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse PPTX: ${err2.message}`);
  }
}

// packages/@oxen-cli/pptx-cli/src/commands/theme.ts
async function runTheme(filePath) {
  try {
    const { presentationFile } = await loadPresentationBundle(filePath);
    const presentation = openPresentation(presentationFile);
    const slide = presentation.getSlide(1);
    const theme = parseTheme(slide.theme, slide.themeOverrides);
    return success({
      fontScheme: {
        majorFont: {
          latin: theme.fontScheme.majorFont.latin,
          eastAsian: theme.fontScheme.majorFont.eastAsian,
          complexScript: theme.fontScheme.majorFont.complexScript
        },
        minorFont: {
          latin: theme.fontScheme.minorFont.latin,
          eastAsian: theme.fontScheme.minorFont.eastAsian,
          complexScript: theme.fontScheme.minorFont.complexScript
        }
      },
      colorScheme: theme.colorScheme,
      formatScheme: {
        lineStyleCount: theme.formatScheme.lineStyles.length,
        fillStyleCount: theme.formatScheme.fillStyles.length,
        effectStyleCount: theme.formatScheme.effectStyles.length,
        bgFillStyleCount: theme.formatScheme.bgFillStyles.length
      },
      customColors: theme.customColors.map((c) => ({
        name: c.name,
        color: c.color,
        type: c.type
      })),
      extraColorSchemeCount: theme.extraColorSchemes.length,
      hasObjectDefaults: {
        line: theme.objectDefaults.lineDefault !== undefined,
        shape: theme.objectDefaults.shapeDefault !== undefined,
        text: theme.objectDefaults.textDefault !== undefined
      }
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse PPTX: ${err2.message}`);
  }
}

// packages/@oxen-cli/pptx-cli/src/commands/build.ts
import * as fs3 from "fs/promises";
import * as path4 from "path";

// packages/@oxen-builder/pptx/src/builders/file-utils.ts
import * as fs2 from "fs/promises";
import * as path from "path";
var IMAGE_EXT_MAP = {
  ".png": "image/png",
  ".jpg": "image/jpeg",
  ".jpeg": "image/jpeg",
  ".gif": "image/gif",
  ".svg": "image/svg+xml"
};
function detectImageMimeType(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  const mimeType = IMAGE_EXT_MAP[ext];
  if (!mimeType) {
    throw new Error(`Unsupported image extension: "${ext}" (supported: ${Object.keys(IMAGE_EXT_MAP).join(", ")})`);
  }
  return mimeType;
}
async function readFileToArrayBuffer(filePath) {
  const buffer = await fs2.readFile(filePath);
  const arrayBuffer = new ArrayBuffer(buffer.length);
  new Uint8Array(arrayBuffer).set(buffer);
  return arrayBuffer;
}
function uint8ArrayToArrayBuffer(data) {
  const arrayBuffer = new ArrayBuffer(data.byteLength);
  new Uint8Array(arrayBuffer).set(data);
  return arrayBuffer;
}

// packages/@oxen-builder/pptx/src/builders/rels-utils.ts
function getSlideRelsPath(slidePath) {
  return slidePath.replace(/\/([^/]+)\.xml$/, "/_rels/$1.xml.rels");
}

// packages/@oxen-builder/pptx/src/builders/id-generator.ts
function generateShapeId(existingIds) {
  const maxId = existingIds.reduce((max2, id) => {
    const num = parseInt(id, 10);
    return Number.isNaN(num) ? max2 : Math.max(max2, num);
  }, 0);
  return String(maxId + 1);
}

// packages/@oxen-builder/pptx/src/builders/xml-utils.ts
function setChildren(element, children) {
  return { ...element, children };
}

// packages/@oxen-builder/pptx/src/builders/presets.ts
var PRESET_MAP = {
  rectangle: "rect",
  ellipse: "ellipse",
  triangle: "triangle",
  rtTriangle: "rtTriangle",
  diamond: "diamond",
  pentagon: "pentagon",
  hexagon: "hexagon",
  heptagon: "heptagon",
  octagon: "octagon",
  decagon: "decagon",
  dodecagon: "dodecagon",
  parallelogram: "parallelogram",
  trapezoid: "trapezoid",
  teardrop: "teardrop",
  halfFrame: "halfFrame",
  corner: "corner",
  diagStripe: "diagStripe",
  chord: "chord",
  funnel: "funnel",
  gear6: "gear6",
  gear9: "gear9",
  pie: "pie",
  pieWedge: "pieWedge",
  blockArc: "blockArc",
  roundRect: "roundRect",
  round1Rect: "round1Rect",
  round2SameRect: "round2SameRect",
  round2DiagRect: "round2DiagRect",
  snip1Rect: "snip1Rect",
  snip2SameRect: "snip2SameRect",
  snip2DiagRect: "snip2DiagRect",
  snipRoundRect: "snipRoundRect",
  rightArrow: "rightArrow",
  leftArrow: "leftArrow",
  upArrow: "upArrow",
  downArrow: "downArrow",
  leftRightArrow: "leftRightArrow",
  upDownArrow: "upDownArrow",
  bentArrow: "bentArrow",
  uturnArrow: "uturnArrow",
  chevron: "chevron",
  notchedRightArrow: "notchedRightArrow",
  stripedRightArrow: "stripedRightArrow",
  quadArrow: "quadArrow",
  quadArrowCallout: "quadArrowCallout",
  leftRightUpArrow: "leftRightUpArrow",
  leftUpArrow: "leftUpArrow",
  bentUpArrow: "bentUpArrow",
  curvedLeftArrow: "curvedLeftArrow",
  curvedRightArrow: "curvedRightArrow",
  curvedUpArrow: "curvedUpArrow",
  curvedDownArrow: "curvedDownArrow",
  circularArrow: "circularArrow",
  swooshArrow: "swooshArrow",
  leftCircularArrow: "leftCircularArrow",
  leftRightCircularArrow: "leftRightCircularArrow",
  leftArrowCallout: "leftArrowCallout",
  rightArrowCallout: "rightArrowCallout",
  upArrowCallout: "upArrowCallout",
  downArrowCallout: "downArrowCallout",
  leftRightArrowCallout: "leftRightArrowCallout",
  upDownArrowCallout: "upDownArrowCallout",
  star4: "star4",
  star5: "star5",
  star6: "star6",
  star7: "star7",
  star8: "star8",
  star10: "star10",
  star12: "star12",
  star16: "star16",
  star24: "star24",
  star32: "star32",
  ribbon: "ribbon",
  ribbon2: "ribbon2",
  ellipseRibbon: "ellipseRibbon",
  ellipseRibbon2: "ellipseRibbon2",
  verticalScroll: "verticalScroll",
  horizontalScroll: "horizontalScroll",
  wave: "wave",
  doubleWave: "doubleWave",
  irregularSeal1: "irregularSeal1",
  irregularSeal2: "irregularSeal2",
  wedgeRectCallout: "wedgeRectCallout",
  wedgeRoundRectCallout: "wedgeRoundRectCallout",
  wedgeEllipseCallout: "wedgeEllipseCallout",
  cloudCallout: "cloudCallout",
  borderCallout1: "borderCallout1",
  borderCallout2: "borderCallout2",
  borderCallout3: "borderCallout3",
  accentCallout1: "accentCallout1",
  accentCallout2: "accentCallout2",
  accentCallout3: "accentCallout3",
  accentBorderCallout1: "accentBorderCallout1",
  accentBorderCallout2: "accentBorderCallout2",
  accentBorderCallout3: "accentBorderCallout3",
  callout1: "callout1",
  callout2: "callout2",
  callout3: "callout3",
  flowChartProcess: "flowChartProcess",
  flowChartDecision: "flowChartDecision",
  flowChartTerminator: "flowChartTerminator",
  flowChartDocument: "flowChartDocument",
  flowChartData: "flowChartInputOutput",
  flowChartConnector: "flowChartConnector",
  flowChartAlternateProcess: "flowChartAlternateProcess",
  flowChartSort: "flowChartSort",
  flowChartExtract: "flowChartExtract",
  flowChartMerge: "flowChartMerge",
  flowChartOnlineStorage: "flowChartOnlineStorage",
  flowChartMagneticTape: "flowChartMagneticTape",
  flowChartMagneticDisk: "flowChartMagneticDisk",
  flowChartMagneticDrum: "flowChartMagneticDrum",
  flowChartDisplay: "flowChartDisplay",
  flowChartDelay: "flowChartDelay",
  flowChartPreparation: "flowChartPreparation",
  flowChartManualInput: "flowChartManualInput",
  flowChartManualOperation: "flowChartManualOperation",
  flowChartPunchedCard: "flowChartPunchedCard",
  flowChartPunchedTape: "flowChartPunchedTape",
  flowChartSummingJunction: "flowChartSummingJunction",
  flowChartOr: "flowChartOr",
  flowChartCollate: "flowChartCollate",
  flowChartInternalStorage: "flowChartInternalStorage",
  flowChartMultidocument: "flowChartMultidocument",
  flowChartOffpageConnector: "flowChartOffpageConnector",
  flowChartPredefinedProcess: "flowChartPredefinedProcess",
  mathPlus: "mathPlus",
  mathMinus: "mathMinus",
  mathMultiply: "mathMultiply",
  mathDivide: "mathDivide",
  mathEqual: "mathEqual",
  mathNotEqual: "mathNotEqual",
  leftBrace: "leftBrace",
  rightBrace: "rightBrace",
  leftBracket: "leftBracket",
  rightBracket: "rightBracket",
  bracePair: "bracePair",
  bracketPair: "bracketPair",
  actionButtonBackPrevious: "actionButtonBackPrevious",
  actionButtonBeginning: "actionButtonBeginning",
  actionButtonBlank: "actionButtonBlank",
  actionButtonDocument: "actionButtonDocument",
  actionButtonEnd: "actionButtonEnd",
  actionButtonForwardNext: "actionButtonForwardNext",
  actionButtonHelp: "actionButtonHelp",
  actionButtonHome: "actionButtonHome",
  actionButtonInformation: "actionButtonInformation",
  actionButtonMovie: "actionButtonMovie",
  actionButtonReturn: "actionButtonReturn",
  actionButtonSound: "actionButtonSound",
  heart: "heart",
  lightning: "lightningBolt",
  lightningBolt: "lightningBolt",
  sun: "sun",
  moon: "moon",
  cloud: "cloud",
  arc: "arc",
  donut: "donut",
  frame: "frame",
  cube: "cube",
  can: "can",
  foldedCorner: "foldedCorner",
  smileyFace: "smileyFace",
  noSmoking: "noSmoking",
  plus: "mathPlus",
  cross: "plus",
  homePlate: "homePlate",
  plaque: "plaque",
  bevel: "bevel",
  rect: "rect",
  line: "line",
  bentConnector2: "bentConnector2",
  bentConnector3: "bentConnector3",
  bentConnector4: "bentConnector4",
  bentConnector5: "bentConnector5",
  curvedConnector2: "curvedConnector2",
  curvedConnector3: "curvedConnector3",
  curvedConnector4: "curvedConnector4",
  curvedConnector5: "curvedConnector5",
  straightConnector1: "straightConnector1",
  flowChartInputOutput: "flowChartInputOutput",
  plaqueTabs: "plaqueTabs",
  squareTabs: "squareTabs",
  cornerTabs: "cornerTabs"
};

// packages/@oxen-builder/drawing-ml/src/types.ts
function isThemeColor(color) {
  return typeof color === "object" && "theme" in color;
}

// packages/@oxen-builder/drawing-ml/src/fill/solid-fill.ts
function stripHash(hex) {
  return hex.startsWith("#") ? hex.slice(1) : hex;
}
function buildColor(colorSpec) {
  if (typeof colorSpec === "string") {
    return { spec: { type: "srgb", value: stripHash(colorSpec) } };
  }
  const transform = {
    ...colorSpec.lumMod !== undefined && { lumMod: colorSpec.lumMod * 1000 },
    ...colorSpec.lumOff !== undefined && { lumOff: colorSpec.lumOff * 1000 },
    ...colorSpec.tint !== undefined && { tint: colorSpec.tint * 1000 },
    ...colorSpec.shade !== undefined && { shade: colorSpec.shade * 1000 }
  };
  return {
    spec: { type: "scheme", value: colorSpec.theme },
    transform: Object.keys(transform).length > 0 ? transform : undefined
  };
}
function buildSolidFill(hexColor) {
  return {
    type: "solidFill",
    color: { spec: { type: "srgb", value: stripHash(hexColor) } }
  };
}
function buildSolidFillFromSpec(colorSpec) {
  return {
    type: "solidFill",
    color: buildColor(colorSpec)
  };
}
function buildThemeFill(spec) {
  const themeColorSpec = {
    theme: spec.theme,
    lumMod: spec.lumMod,
    lumOff: spec.lumOff,
    tint: spec.tint,
    shade: spec.shade
  };
  return buildSolidFillFromSpec(themeColorSpec);
}

// packages/@oxen-builder/drawing-ml/src/fill/gradient-fill.ts
function buildGradientFill(spec) {
  const stops = spec.stops.map((stop) => ({
    position: stop.position * 1000,
    color: buildColor(stop.color)
  }));
  if (spec.gradientType === "linear") {
    return {
      type: "gradientFill",
      stops,
      linear: {
        angle: spec.angle ?? 0,
        scaled: false
      },
      rotWithShape: true
    };
  }
  if (spec.gradientType === "radial") {
    return {
      type: "gradientFill",
      stops,
      path: {
        path: "circle"
      },
      rotWithShape: true
    };
  }
  return {
    type: "gradientFill",
    stops,
    path: {
      path: "rect"
    },
    rotWithShape: true
  };
}

// packages/@oxen-builder/drawing-ml/src/fill/pattern-fill.ts
function buildPatternFill(spec) {
  return {
    type: "patternFill",
    preset: spec.preset,
    foregroundColor: buildColor(spec.fgColor),
    backgroundColor: buildColor(spec.bgColor)
  };
}
// packages/@oxen-builder/drawing-ml/src/fill/index.ts
function buildFill(fillSpec) {
  if (typeof fillSpec === "string") {
    return buildSolidFill(fillSpec);
  }
  switch (fillSpec.type) {
    case "solid": {
      const solidSpec = fillSpec;
      if (isThemeColor(solidSpec.color)) {
        return buildSolidFillFromSpec(solidSpec.color);
      }
      return buildSolidFill(solidSpec.color);
    }
    case "gradient":
      return buildGradientFill(fillSpec);
    case "pattern":
      return buildPatternFill(fillSpec);
    case "theme":
      return buildThemeFill(fillSpec);
    default:
      return;
  }
}

// packages/@oxen-builder/pptx/src/builders/blip-effects-builder.ts
function buildBlipEffectsFromSpec(spec) {
  const effects = {};
  if (spec.alphaBiLevel) {
    effects.alphaBiLevel = {
      threshold: spec.alphaBiLevel.threshold * 1000
    };
  }
  if (spec.alphaCeiling) {
    effects.alphaCeiling = true;
  }
  if (spec.alphaFloor) {
    effects.alphaFloor = true;
  }
  if (spec.alphaInv) {
    effects.alphaInv = true;
  }
  if (spec.alphaMod) {
    effects.alphaMod = true;
  }
  if (spec.alphaRepl) {
    effects.alphaRepl = {
      alpha: spec.alphaRepl.alpha * 1000
    };
  }
  if (spec.biLevel) {
    effects.biLevel = {
      threshold: spec.biLevel.threshold * 1000
    };
  }
  if (spec.blur) {
    effects.blur = {
      radius: spec.blur.radius,
      grow: false
    };
  }
  if (spec.colorChange) {
    effects.colorChange = {
      from: buildColor(spec.colorChange.from),
      to: buildColor(spec.colorChange.to),
      useAlpha: spec.colorChange.useAlpha ?? false
    };
  }
  if (spec.colorReplace) {
    effects.colorReplace = {
      color: buildColor(spec.colorReplace.color)
    };
  }
  if (spec.duotone) {
    effects.duotone = {
      colors: [buildColor(spec.duotone.colors[0]), buildColor(spec.duotone.colors[1])]
    };
  }
  if (spec.grayscale) {
    effects.grayscale = true;
  }
  if (spec.hsl) {
    effects.hsl = {
      hue: spec.hsl.hue,
      saturation: spec.hsl.saturation * 1000,
      luminance: spec.hsl.luminance * 1000
    };
  }
  if (spec.luminance) {
    effects.luminance = {
      brightness: spec.luminance.brightness * 1000,
      contrast: spec.luminance.contrast * 1000
    };
  }
  if (spec.tint) {
    effects.tint = {
      hue: spec.tint.hue,
      amount: spec.tint.amount * 1000
    };
  }
  if (spec.alphaModFix !== undefined) {
    effects.alphaModFix = {
      amount: spec.alphaModFix * 1000
    };
  }
  return effects;
}

// packages/@oxen-builder/pptx/src/builders/custom-geometry-builder.ts
function requireNumber(name, value) {
  if (value === undefined || Number.isNaN(value)) {
    throw new Error(`customGeometry: ${name} is required`);
  }
  return value;
}
function buildPathCommand(spec) {
  switch (spec.type) {
    case "moveTo":
      return {
        type: "moveTo",
        point: { x: requireNumber("moveTo.x", spec.x), y: requireNumber("moveTo.y", spec.y) }
      };
    case "lineTo":
      return {
        type: "lineTo",
        point: { x: requireNumber("lineTo.x", spec.x), y: requireNumber("lineTo.y", spec.y) }
      };
    case "arcTo":
      return {
        type: "arcTo",
        widthRadius: requireNumber("arcTo.widthRadius", spec.widthRadius),
        heightRadius: requireNumber("arcTo.heightRadius", spec.heightRadius),
        startAngle: requireNumber("arcTo.startAngle", spec.startAngle),
        swingAngle: requireNumber("arcTo.swingAngle", spec.swingAngle)
      };
    case "quadBezierTo":
      return {
        type: "quadBezierTo",
        control: {
          x: requireNumber("quadBezierTo.control.x", spec.control?.x),
          y: requireNumber("quadBezierTo.control.y", spec.control?.y)
        },
        end: {
          x: requireNumber("quadBezierTo.end.x", spec.end?.x),
          y: requireNumber("quadBezierTo.end.y", spec.end?.y)
        }
      };
    case "cubicBezierTo":
      return {
        type: "cubicBezierTo",
        control1: {
          x: requireNumber("cubicBezierTo.control1.x", spec.control1?.x),
          y: requireNumber("cubicBezierTo.control1.y", spec.control1?.y)
        },
        control2: {
          x: requireNumber("cubicBezierTo.control2.x", spec.control2?.x),
          y: requireNumber("cubicBezierTo.control2.y", spec.control2?.y)
        },
        end: {
          x: requireNumber("cubicBezierTo.end.x", spec.end?.x),
          y: requireNumber("cubicBezierTo.end.y", spec.end?.y)
        }
      };
    case "close":
      return { type: "close" };
  }
}
function buildGeometryPath(spec) {
  if (!spec.commands || spec.commands.length === 0) {
    throw new Error("customGeometry: path.commands is required");
  }
  return {
    width: requireNumber("path.width", spec.width),
    height: requireNumber("path.height", spec.height),
    fill: spec.fill,
    stroke: spec.stroke,
    extrusionOk: spec.extrusionOk,
    commands: spec.commands.map(buildPathCommand)
  };
}
function buildCustomGeometryFromSpec(spec) {
  if (!spec) {
    throw new Error("customGeometry is required");
  }
  if (!spec.paths || spec.paths.length === 0) {
    throw new Error("customGeometry.paths is required");
  }
  return {
    type: "custom",
    paths: spec.paths.map(buildGeometryPath)
  };
}

// packages/@oxen-builder/pptx/src/builders/media-embed-builder.ts
var VIDEO_EXT_MAP = {
  mp4: "video/mp4",
  webm: "video/webm",
  mov: "video/quicktime"
};
var AUDIO_EXT_MAP = {
  mp3: "audio/mpeg",
  wav: "audio/wav",
  m4a: "audio/mp4",
  ogg: "audio/ogg"
};
function detectEmbeddedMediaType(spec) {
  if (spec.mimeType) {
    return spec.mimeType;
  }
  const ext = spec.path?.split(".").pop()?.toLowerCase() ?? "";
  if (spec.type === "video") {
    const mimeType = VIDEO_EXT_MAP[ext];
    if (mimeType) {
      return mimeType;
    }
    throw new Error(`Unsupported video extension: .${ext} (supported: ${Object.keys(VIDEO_EXT_MAP).map((e) => `.${e}`).join(", ")})`);
  }
  if (spec.type === "audio") {
    const mimeType = AUDIO_EXT_MAP[ext];
    if (mimeType) {
      return mimeType;
    }
    throw new Error(`Unsupported audio extension: .${ext} (supported: ${Object.keys(AUDIO_EXT_MAP).map((e) => `.${e}`).join(", ")})`);
  }
  throw new Error(`Unsupported media type: ${spec.type}`);
}
function buildMediaReferenceFromSpec(spec, rId, contentType) {
  if (!spec) {
    throw new Error("media spec is required");
  }
  if (!spec.type) {
    throw new Error("media.type is required");
  }
  if (!spec.path && !spec.data) {
    throw new Error("media.path or media.data is required");
  }
  if (!rId) {
    throw new Error("media rId is required");
  }
  if (spec.type === "video") {
    return {
      mediaType: "video",
      media: { videoFile: { link: rId, contentType } }
    };
  }
  return {
    mediaType: "audio",
    media: { audioFile: { link: rId, contentType } }
  };
}

// packages/@oxen-builder/pptx/src/builders/background-builder.ts
import * as path2 from "path";

// packages/@oxen-builder/pptx/src/patcher/core/xml-mutator.ts
function setAttribute(element, name, value) {
  return {
    ...element,
    attrs: {
      ...element.attrs,
      [name]: value
    }
  };
}
function removeAttribute(element, name) {
  const { [name]: _, ...rest } = element.attrs;
  return {
    ...element,
    attrs: rest
  };
}
function insertChildAt(parent, child, index) {
  const children = [...parent.children];
  children.splice(index, 0, child);
  return {
    ...parent,
    children
  };
}
function removeChildren(parent, predicate) {
  return {
    ...parent,
    children: parent.children.filter((child, i2) => !predicate(child, i2))
  };
}
function replaceChildAt(parent, index, newChild) {
  return {
    ...parent,
    children: parent.children.map((child, i2) => i2 === index ? newChild : child)
  };
}
function replaceChild(parent, predicate, newChild) {
  const index = parent.children.findIndex(predicate);
  if (index === -1) {
    return parent;
  }
  return replaceChildAt(parent, index, newChild);
}
function replaceChildByName(parent, name, newChild) {
  return replaceChild(parent, (child) => isXmlElement(child) && child.name === name, newChild);
}
function setChildren2(parent, children) {
  return {
    ...parent,
    children
  };
}
function updateChildByName(parent, name, updater) {
  return {
    ...parent,
    children: parent.children.map((child) => {
      if (isXmlElement(child) && child.name === name) {
        return updater(child);
      }
      return child;
    })
  };
}
function updateAtPath(root, path2, updater) {
  if (path2.length === 0) {
    return updater(root);
  }
  const [first, ...rest] = path2;
  const firstIndex = root.children.findIndex((child) => isXmlElement(child) && child.name === first);
  const newChildren = root.children.map((child, index) => {
    if (index !== firstIndex) {
      return child;
    }
    return updateAtPath(child, rest, updater);
  });
  return {
    ...root,
    children: newChildren
  };
}
function updateDocumentRoot(doc, updater) {
  const rootIndex = doc.children.findIndex(isXmlElement);
  if (rootIndex === -1) {
    return doc;
  }
  const root = doc.children[rootIndex];
  const updatedRoot = updater(root);
  return {
    ...doc,
    children: doc.children.map((child, i2) => i2 === rootIndex ? updatedRoot : child)
  };
}
function getDocumentRoot(doc) {
  const root = doc.children.find(isXmlElement);
  return root ?? null;
}

// packages/@oxen-builder/core/src/ooxml-units.ts
function ooxmlBool(value) {
  return value ? "1" : "0";
}
function ooxmlAngleUnits(degrees) {
  return String(Math.round(degrees * 60000));
}
function ooxmlPercent100k(percent) {
  return String(Math.round(percent / 100 * 1e5));
}
function ooxmlPercent1000(percent) {
  return String(Math.round(percent * 1000));
}
var EMU_PER_PIXEL2 = 9525;
function ooxmlEmu(pixels) {
  return String(Math.round(pixels * EMU_PER_PIXEL2));
}
// packages/@oxen-builder/pptx/src/patcher/serializer/color.ts
function serializeColor(color) {
  const children = serializeColorTransform(color.transform);
  switch (color.spec.type) {
    case "srgb":
      return createElement("a:srgbClr", { val: color.spec.value.toUpperCase() }, children);
    case "scheme":
      return createElement("a:schemeClr", { val: color.spec.value }, children);
    case "system": {
      const attrs = { val: color.spec.value };
      if (color.spec.lastColor) {
        attrs.lastClr = color.spec.lastColor.toUpperCase();
      }
      return createElement("a:sysClr", attrs, children);
    }
    case "preset":
      return createElement("a:prstClr", { val: color.spec.value }, children);
    case "hsl":
      return createElement("a:hslClr", {
        hue: ooxmlAngleUnits(color.spec.hue),
        sat: ooxmlPercent100k(color.spec.saturation),
        lum: ooxmlPercent100k(color.spec.luminance)
      }, children);
    case "scrgb":
      return createElement("a:scrgbClr", {
        r: ooxmlPercent100k(color.spec.red),
        g: ooxmlPercent100k(color.spec.green),
        b: ooxmlPercent100k(color.spec.blue)
      }, children);
  }
}
function serializeColorTransform(transform) {
  if (!transform) {
    return [];
  }
  const children = [];
  if (transform.alpha !== undefined) {
    children.push(createElement("a:alpha", { val: ooxmlPercent100k(transform.alpha) }));
  }
  if (transform.alphaMod !== undefined) {
    children.push(createElement("a:alphaMod", { val: ooxmlPercent100k(transform.alphaMod) }));
  }
  if (transform.alphaOff !== undefined) {
    children.push(createElement("a:alphaOff", { val: ooxmlPercent100k(transform.alphaOff) }));
  }
  if (transform.hue !== undefined) {
    children.push(createElement("a:hue", { val: ooxmlAngleUnits(transform.hue) }));
  }
  if (transform.hueMod !== undefined) {
    children.push(createElement("a:hueMod", { val: ooxmlPercent100k(transform.hueMod) }));
  }
  if (transform.hueOff !== undefined) {
    children.push(createElement("a:hueOff", { val: ooxmlAngleUnits(transform.hueOff) }));
  }
  if (transform.sat !== undefined) {
    children.push(createElement("a:sat", { val: ooxmlPercent100k(transform.sat) }));
  }
  if (transform.satMod !== undefined) {
    children.push(createElement("a:satMod", { val: ooxmlPercent100k(transform.satMod) }));
  }
  if (transform.satOff !== undefined) {
    children.push(createElement("a:satOff", { val: ooxmlPercent100k(transform.satOff) }));
  }
  if (transform.lum !== undefined) {
    children.push(createElement("a:lum", { val: ooxmlPercent100k(transform.lum) }));
  }
  if (transform.lumMod !== undefined) {
    children.push(createElement("a:lumMod", { val: ooxmlPercent100k(transform.lumMod) }));
  }
  if (transform.lumOff !== undefined) {
    children.push(createElement("a:lumOff", { val: ooxmlPercent100k(transform.lumOff) }));
  }
  if (transform.gamma) {
    children.push(createElement("a:gamma"));
  }
  if (transform.invGamma) {
    children.push(createElement("a:invGamma"));
  }
  if (transform.green !== undefined) {
    children.push(createElement("a:green", { val: ooxmlPercent100k(transform.green) }));
  }
  if (transform.greenMod !== undefined) {
    children.push(createElement("a:greenMod", { val: ooxmlPercent100k(transform.greenMod) }));
  }
  if (transform.greenOff !== undefined) {
    children.push(createElement("a:greenOff", { val: ooxmlPercent100k(transform.greenOff) }));
  }
  if (transform.redMod !== undefined) {
    children.push(createElement("a:redMod", { val: ooxmlPercent100k(transform.redMod) }));
  }
  if (transform.redOff !== undefined) {
    children.push(createElement("a:redOff", { val: ooxmlPercent100k(transform.redOff) }));
  }
  if (transform.blueMod !== undefined) {
    children.push(createElement("a:blueMod", { val: ooxmlPercent100k(transform.blueMod) }));
  }
  if (transform.blueOff !== undefined) {
    children.push(createElement("a:blueOff", { val: ooxmlPercent100k(transform.blueOff) }));
  }
  if (transform.shade !== undefined) {
    children.push(createElement("a:shade", { val: ooxmlPercent100k(transform.shade) }));
  }
  if (transform.tint !== undefined) {
    children.push(createElement("a:tint", { val: ooxmlPercent100k(transform.tint) }));
  }
  if (transform.comp) {
    children.push(createElement("a:comp"));
  }
  if (transform.inv) {
    children.push(createElement("a:inv"));
  }
  if (transform.gray) {
    children.push(createElement("a:gray"));
  }
  return children;
}

// packages/@oxen-builder/pptx/src/patcher/serializer/fill.ts
function serializeFill2(fill) {
  switch (fill.type) {
    case "noFill":
      return createElement("a:noFill");
    case "solidFill":
      return createElement("a:solidFill", {}, [serializeColor(fill.color)]);
    case "gradientFill":
      return serializeGradientFill(fill);
    case "patternFill":
      return serializePatternFill(fill);
    case "blipFill":
      return serializeBlipFill(fill);
    case "groupFill":
      return createElement("a:grpFill");
  }
}
function serializeGradientFill(gradient) {
  const attrs = {
    rotWithShape: ooxmlBool(gradient.rotWithShape)
  };
  const children = [
    createElement("a:gsLst", {}, gradient.stops.map(serializeGradientStop))
  ];
  if (gradient.linear) {
    children.push(createElement("a:lin", {
      ang: ooxmlAngleUnits(gradient.linear.angle),
      scaled: ooxmlBool(gradient.linear.scaled)
    }));
  }
  if (gradient.path) {
    const pathChildren = [];
    if (gradient.path.fillToRect) {
      pathChildren.push(createElement("a:fillToRect", {
        l: ooxmlPercent100k(gradient.path.fillToRect.left),
        t: ooxmlPercent100k(gradient.path.fillToRect.top),
        r: ooxmlPercent100k(gradient.path.fillToRect.right),
        b: ooxmlPercent100k(gradient.path.fillToRect.bottom)
      }));
    }
    children.push(createElement("a:path", { path: gradient.path.path }, pathChildren));
  }
  if (gradient.tileRect) {
    children.push(createElement("a:tileRect", {
      l: ooxmlPercent100k(gradient.tileRect.left),
      t: ooxmlPercent100k(gradient.tileRect.top),
      r: ooxmlPercent100k(gradient.tileRect.right),
      b: ooxmlPercent100k(gradient.tileRect.bottom)
    }));
  }
  return createElement("a:gradFill", attrs, children);
}
function serializeGradientStop(stop) {
  return createElement("a:gs", { pos: ooxmlPercent100k(stop.position) }, [serializeColor(stop.color)]);
}
function serializePatternFill(pattern) {
  return createElement("a:pattFill", { prst: pattern.preset }, [
    createElement("a:fgClr", {}, [serializeColor(pattern.foregroundColor)]),
    createElement("a:bgClr", {}, [serializeColor(pattern.backgroundColor)])
  ]);
}
function serializeBlipFill(blip) {
  if (blip.resourceId.startsWith("data:")) {
    throw new Error("serializeBlipFill: data: resourceId requires Phase 7 media embedding");
  }
  const attrs = {
    rotWithShape: ooxmlBool(blip.rotWithShape)
  };
  if (blip.dpi !== undefined) {
    attrs.dpi = String(blip.dpi);
  }
  const blipAttrs = {};
  if (blip.relationshipType === "link") {
    blipAttrs["r:link"] = blip.resourceId;
  } else {
    blipAttrs["r:embed"] = blip.resourceId;
  }
  if (blip.compressionState) {
    blipAttrs.cstate = blip.compressionState;
  }
  const blipChildren = blip.blipEffects ? serializeBlipEffects2(blip.blipEffects) : [];
  const children = [createElement("a:blip", blipAttrs, blipChildren)];
  if (blip.sourceRect) {
    children.push(createElement("a:srcRect", {
      l: ooxmlPercent100k(blip.sourceRect.left),
      t: ooxmlPercent100k(blip.sourceRect.top),
      r: ooxmlPercent100k(blip.sourceRect.right),
      b: ooxmlPercent100k(blip.sourceRect.bottom)
    }));
  }
  if (blip.stretch) {
    children.push(serializeStretchFill(blip.stretch));
  }
  if (blip.tile) {
    children.push(serializeTileFill(blip.tile));
  }
  return createElement("a:blipFill", attrs, children);
}
function serializeStretchFill(stretch) {
  if (!stretch.fillRect) {
    return createElement("a:stretch");
  }
  return createElement("a:stretch", {}, [
    createElement("a:fillRect", {
      l: ooxmlPercent100k(stretch.fillRect.left),
      t: ooxmlPercent100k(stretch.fillRect.top),
      r: ooxmlPercent100k(stretch.fillRect.right),
      b: ooxmlPercent100k(stretch.fillRect.bottom)
    })
  ]);
}
function serializeTileFill(tile) {
  return createElement("a:tile", {
    tx: ooxmlEmu(tile.tx),
    ty: ooxmlEmu(tile.ty),
    sx: ooxmlPercent100k(tile.sx),
    sy: ooxmlPercent100k(tile.sy),
    flip: tile.flip,
    algn: tile.alignment
  });
}
function serializeBlipEffects2(effects) {
  const children = [];
  if (effects.alphaBiLevel) {
    children.push(createElement("a:alphaBiLevel", { thresh: ooxmlPercent100k(effects.alphaBiLevel.threshold) }));
  }
  if (effects.alphaCeiling) {
    children.push(createElement("a:alphaCeiling"));
  }
  if (effects.alphaFloor) {
    children.push(createElement("a:alphaFloor"));
  }
  if (effects.alphaInv) {
    children.push(createElement("a:alphaInv"));
  }
  if (effects.alphaMod) {
    children.push(createElement("a:alphaMod"));
  }
  if (effects.alphaModFix) {
    children.push(createElement("a:alphaModFix", { amt: ooxmlPercent100k(effects.alphaModFix.amount) }));
  }
  if (effects.alphaRepl) {
    children.push(createElement("a:alphaRepl", { a: ooxmlPercent100k(effects.alphaRepl.alpha) }));
  }
  if (effects.biLevel) {
    children.push(createElement("a:biLevel", { thresh: ooxmlPercent100k(effects.biLevel.threshold) }));
  }
  if (effects.blur) {
    children.push(createElement("a:blur", {
      rad: ooxmlEmu(effects.blur.radius),
      grow: ooxmlBool(effects.blur.grow)
    }));
  }
  if (effects.colorChange) {
    children.push(createElement("a:clrChange", { useA: ooxmlBool(effects.colorChange.useAlpha) }, [
      createElement("a:clrFrom", {}, [serializeColor(effects.colorChange.from)]),
      createElement("a:clrTo", {}, [serializeColor(effects.colorChange.to)])
    ]));
  }
  if (effects.colorReplace) {
    children.push(createElement("a:clrRepl", {}, [serializeColor(effects.colorReplace.color)]));
  }
  if (effects.duotone) {
    children.push(createElement("a:duotone", {}, [
      serializeColor(effects.duotone.colors[0]),
      serializeColor(effects.duotone.colors[1])
    ]));
  }
  if (effects.grayscale) {
    children.push(createElement("a:grayscl"));
  }
  if (effects.hsl) {
    children.push(createElement("a:hsl", {
      hue: ooxmlAngleUnits(effects.hsl.hue),
      sat: ooxmlPercent100k(effects.hsl.saturation),
      lum: ooxmlPercent100k(effects.hsl.luminance)
    }));
  }
  if (effects.luminance) {
    children.push(createElement("a:lum", {
      bright: ooxmlPercent100k(effects.luminance.brightness),
      contrast: ooxmlPercent100k(effects.luminance.contrast)
    }));
  }
  if (effects.tint) {
    children.push(createElement("a:tint", {
      hue: ooxmlAngleUnits(effects.tint.hue),
      amt: ooxmlPercent100k(effects.tint.amount)
    }));
  }
  return children;
}

// packages/@oxen-builder/pptx/src/patcher/resources/content-types-manager.ts
function addContentType(contentTypesXml, extension, contentType) {
  if (!extension) {
    throw new Error("addContentType: extension is required");
  }
  if (!contentType) {
    throw new Error("addContentType: contentType is required");
  }
  const root = getDocumentRoot(contentTypesXml);
  if (!root || root.name !== "Types") {
    throw new Error("addContentType: invalid [Content_Types].xml (missing Types root)");
  }
  const normalizedExt = extension.replace(/^\./, "").toLowerCase();
  const existing = findDefault(root, normalizedExt);
  if (existing) {
    const existingType = existing.attrs.ContentType;
    if (existingType && existingType !== contentType) {
      throw new Error(`addContentType: extension "${normalizedExt}" already exists with ContentType "${existingType}"`);
    }
    return contentTypesXml;
  }
  const newDefault = createElement("Default", {
    Extension: normalizedExt,
    ContentType: contentType
  });
  return updateDocumentRoot(contentTypesXml, (typesEl) => {
    if (typesEl.name !== "Types") {
      return typesEl;
    }
    const firstOverrideIndex = typesEl.children.findIndex((child) => isXmlElement(child) && child.name === "Override");
    const insertIndex = firstOverrideIndex === -1 ? typesEl.children.length : firstOverrideIndex;
    const children = [...typesEl.children];
    children.splice(insertIndex, 0, newDefault);
    return { ...typesEl, children };
  });
}
function addOverride(contentTypesXml, partName, contentType) {
  if (!partName) {
    throw new Error("addOverride: partName is required");
  }
  if (!contentType) {
    throw new Error("addOverride: contentType is required");
  }
  const root = getDocumentRoot(contentTypesXml);
  if (!root || root.name !== "Types") {
    throw new Error("addOverride: invalid [Content_Types].xml (missing Types root)");
  }
  const normalizedPartName = partName.startsWith("/") ? partName : `/${partName}`;
  const existing = findOverride(root, normalizedPartName);
  if (existing) {
    const existingType = existing.attrs.ContentType;
    if (existingType && existingType !== contentType) {
      throw new Error(`addOverride: part "${normalizedPartName}" already exists with ContentType "${existingType}"`);
    }
    return contentTypesXml;
  }
  const overrideEl = createElement("Override", {
    PartName: normalizedPartName,
    ContentType: contentType
  });
  return updateDocumentRoot(contentTypesXml, (typesEl) => {
    if (typesEl.name !== "Types") {
      return typesEl;
    }
    return { ...typesEl, children: [...typesEl.children, overrideEl] };
  });
}
function findDefault(typesEl, extension) {
  return typesEl.children.find((child) => isXmlElement(child) && child.name === "Default" && child.attrs.Extension?.toLowerCase() === extension.toLowerCase());
}
function findOverride(typesEl, partName) {
  return typesEl.children.find((child) => isXmlElement(child) && child.name === "Override" && child.attrs.PartName === partName);
}

// packages/@oxen-builder/pptx/src/patcher/parts/relationships.ts
var RELATIONSHIPS_XMLNS = "http://schemas.openxmlformats.org/package/2006/relationships";
function createRelationshipsDocument(relationships = []) {
  const children = relationships.map((relationship) => {
    const attrs = {
      Id: relationship.id,
      Type: relationship.type,
      Target: relationship.target
    };
    if (relationship.targetMode) {
      attrs.TargetMode = relationship.targetMode;
    }
    return createElement("Relationship", attrs);
  });
  return {
    children: [createElement("Relationships", { xmlns: RELATIONSHIPS_XMLNS }, children)]
  };
}

// packages/@oxen-builder/pptx/src/patcher/resources/relationship-manager.ts
function generateRelationshipId(existingIds) {
  const used = new Set;
  for (const id of existingIds) {
    const match = /^rId(\d+)$/.exec(id);
    if (!match) {
      continue;
    }
    used.add(Number(match[1]));
  }
  let next = 1;
  while (used.has(next)) {
    next += 1;
  }
  return `rId${next}`;
}
function addRelationship(relsXml, target, type) {
  if (!target) {
    throw new Error("addRelationship: target is required");
  }
  const existing = listRelationships(relsXml).find((rel) => rel.type === type && rel.target === target);
  if (existing) {
    return { updatedXml: relsXml, rId: existing.id };
  }
  const root = getDocumentRoot(relsXml);
  if (!root || root.name !== "Relationships") {
    throw new Error("addRelationship: invalid .rels document (missing Relationships root)");
  }
  const existingIds = listRelationships(relsXml).map((rel) => rel.id);
  const rId = generateRelationshipId(existingIds);
  const relationshipAttrs = {
    Id: rId,
    Type: type,
    Target: target
  };
  const targetMode = inferTargetMode(type, target);
  if (targetMode) {
    relationshipAttrs.TargetMode = targetMode;
  }
  const relationshipEl = createElement("Relationship", relationshipAttrs);
  const updated = updateDocumentRoot(relsXml, (rootEl) => {
    if (rootEl.name !== "Relationships") {
      return rootEl;
    }
    const nextAttrs = { ...rootEl.attrs };
    if (nextAttrs.xmlns === undefined) {
      nextAttrs.xmlns = RELATIONSHIPS_XMLNS;
    }
    return {
      ...rootEl,
      attrs: nextAttrs,
      children: [...rootEl.children, relationshipEl]
    };
  });
  return { updatedXml: updated, rId };
}
function ensureRelationshipsDocument(relsXml) {
  if (relsXml === null) {
    return createRelationshipsDocument();
  }
  const root = getDocumentRoot(relsXml);
  if (!root || root.name !== "Relationships") {
    return createRelationshipsDocument();
  }
  return relsXml;
}
function inferTargetMode(type, target) {
  if (type !== "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink") {
    return;
  }
  if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(target)) {
    return "External";
  }
  return;
}

// packages/@oxen-builder/pptx/src/patcher/resources/media-manager.ts
var IMAGE_REL = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image";
var VIDEO_REL = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/video";
var AUDIO_REL = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/audio";
function addMedia({ pkg, mediaData, mediaType, referringPart }) {
  if (!mediaData) {
    throw new Error("addMedia: mediaData is required");
  }
  if (!mediaType) {
    throw new Error("addMedia: mediaType is required");
  }
  if (!referringPart) {
    throw new Error("addMedia: referringPart is required");
  }
  const { extension, relationshipType, prefix } = inferMediaInfo(mediaType);
  const existingPath = findExistingMediaByBytes(pkg, extension, mediaData);
  const mediaPath = existingPath ?? generateMediaPath(pkg, prefix, extension);
  if (!existingPath) {
    pkg.writeBinary(mediaPath, mediaData);
  }
  updateContentTypesForMedia(pkg, extension, mediaType);
  const rId = addMediaRelationship({ pkg, referringPart, mediaPath, relationshipType });
  return { path: mediaPath, rId };
}
function updateContentTypesForMedia(pkg, extension, mediaType) {
  const contentTypesText = pkg.readText("[Content_Types].xml");
  if (contentTypesText === null) {
    throw new Error("addMedia: missing [Content_Types].xml");
  }
  const contentTypesXml = parseXml(contentTypesText);
  const updated = addContentType(contentTypesXml, extension, mediaType);
  pkg.writeText("[Content_Types].xml", serializeXml(updated));
}
function addMediaRelationship({ pkg, referringPart, mediaPath, relationshipType }) {
  const relsPath = getRelationshipPath2(referringPart);
  const relsXml = (() => {
    const existing = pkg.readText(relsPath);
    if (existing === null) {
      return ensureRelationshipsDocument(null);
    }
    return ensureRelationshipsDocument(parseXml(existing));
  })();
  const target = buildRelationshipTarget(referringPart, mediaPath);
  const { updatedXml, rId } = addRelationship(relsXml, target, relationshipType);
  pkg.writeText(relsPath, serializeXml(updatedXml));
  return rId;
}
function inferMediaInfo(mediaType) {
  switch (mediaType) {
    case "image/png":
      return { extension: "png", relationshipType: IMAGE_REL, prefix: "image" };
    case "image/jpeg":
      return { extension: "jpeg", relationshipType: IMAGE_REL, prefix: "image" };
    case "image/gif":
      return { extension: "gif", relationshipType: IMAGE_REL, prefix: "image" };
    case "image/svg+xml":
      return { extension: "svg", relationshipType: IMAGE_REL, prefix: "image" };
    case "video/mp4":
      return { extension: "mp4", relationshipType: VIDEO_REL, prefix: "video" };
    case "video/webm":
      return { extension: "webm", relationshipType: VIDEO_REL, prefix: "video" };
    case "video/quicktime":
      return { extension: "mov", relationshipType: VIDEO_REL, prefix: "video" };
    case "audio/mpeg":
      return { extension: "mp3", relationshipType: AUDIO_REL, prefix: "audio" };
    case "audio/wav":
      return { extension: "wav", relationshipType: AUDIO_REL, prefix: "audio" };
    case "audio/mp4":
      return { extension: "m4a", relationshipType: AUDIO_REL, prefix: "audio" };
    case "audio/ogg":
      return { extension: "ogg", relationshipType: AUDIO_REL, prefix: "audio" };
  }
}
function findExistingMediaByBytes(pkg, extension, mediaData) {
  const candidates = pkg.listFiles().filter((path2) => path2.startsWith("ppt/media/") && path2.toLowerCase().endsWith(`.${extension}`)).sort();
  for (const path2 of candidates) {
    const existing = pkg.readBinary(path2);
    if (existing && buffersEqual(existing, mediaData)) {
      return path2;
    }
  }
  return null;
}
function buffersEqual(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  const ua = new Uint8Array(a);
  const ub = new Uint8Array(b);
  for (let i2 = 0;i2 < ua.length; i2 += 1) {
    if (ua[i2] !== ub[i2]) {
      return false;
    }
  }
  return true;
}
function generateMediaPath(pkg, prefix, extension) {
  const existing = new Set(pkg.listFiles().filter((p) => p.startsWith("ppt/media/")));
  let next = 1;
  while (existing.has(`ppt/media/${prefix}${next}.${extension}`)) {
    next += 1;
  }
  return `ppt/media/${prefix}${next}.${extension}`;
}
function buildRelationshipTarget(sourcePart, targetPart) {
  const sourceDir = getDirectory(sourcePart);
  const sourceSegments = sourceDir.split("/").filter((s) => s.length > 0);
  const targetSegments = targetPart.split("/").filter((s) => s.length > 0);
  let common = 0;
  while (common < sourceSegments.length && common < targetSegments.length && sourceSegments[common] === targetSegments[common]) {
    common += 1;
  }
  const up = sourceSegments.length - common;
  const relSegments = [];
  for (let i2 = 0;i2 < up; i2 += 1) {
    relSegments.push("..");
  }
  relSegments.push(...targetSegments.slice(common));
  return relSegments.join("/");
}
function getDirectory(path2) {
  const lastSlash = path2.lastIndexOf("/");
  if (lastSlash === -1) {
    return "";
  }
  return path2.slice(0, lastSlash);
}
function serializeXml(doc) {
  return serializeDocument(doc, { declaration: true, standalone: true });
}

// packages/@oxen-builder/pptx/src/builders/background-builder.ts
function buildBackgroundFill(spec) {
  if (typeof spec === "string") {
    return {
      type: "solidFill",
      color: { spec: { type: "srgb", value: spec } }
    };
  }
  switch (spec.type) {
    case "solid":
      return {
        type: "solidFill",
        color: { spec: { type: "srgb", value: spec.color } }
      };
    case "gradient":
      return buildGradientFill2(spec);
    default:
      throw new Error(`Unknown background fill type: ${spec.type}`);
  }
}
function buildGradientFill2(spec) {
  const stops = spec.stops.map((stop) => ({
    position: stop.position * 1000,
    color: buildColor(stop.color)
  }));
  return {
    type: "gradientFill",
    stops,
    linear: {
      angle: spec.angle ?? 0,
      scaled: false
    },
    rotWithShape: false
  };
}
function buildBackgroundElement(fill) {
  const fillXml = serializeFill2(fill);
  const bgPr = createElement("p:bgPr", {}, [fillXml]);
  return createElement("p:bg", {}, [bgPr]);
}
function buildFillMode(mode) {
  if (mode === "tile") {
    return createElement("a:tile", {
      tx: "0",
      ty: "0",
      sx: "100000",
      sy: "100000",
      flip: "none",
      algn: "tl"
    });
  }
  return createElement("a:stretch", {}, [createElement("a:fillRect")]);
}
function buildBlipFillBackground(rId, mode = "stretch") {
  const blipElement = createElement("a:blip", { "r:embed": rId });
  const fillMode = buildFillMode(mode);
  const blipFill = createElement("a:blipFill", { rotWithShape: "0" }, [
    blipElement,
    fillMode
  ]);
  const bgPr = createElement("p:bgPr", {}, [blipFill]);
  return createElement("p:bg", {}, [bgPr]);
}
function withoutBackground(children) {
  return children.filter((c) => !(isXmlElement(c) && c.name === "p:bg"));
}
function applyBackground(slideDoc, spec) {
  const fill = buildBackgroundFill(spec);
  const bgElement = buildBackgroundElement(fill);
  return updateDocumentRoot(slideDoc, (root) => {
    const cSld = getChild(root, "p:cSld");
    if (!cSld) {
      return root;
    }
    const existingBg = getChild(cSld, "p:bg");
    const filteredChildren = existingBg ? withoutBackground(cSld.children) : cSld.children;
    const newCsld = {
      ...cSld,
      children: [bgElement, ...filteredChildren]
    };
    return replaceChildByName(root, "p:cSld", newCsld);
  });
}
async function applyImageBackground(slideDoc, spec, ctx) {
  let arrayBuffer;
  let mimeType;
  if (spec.data) {
    arrayBuffer = uint8ArrayToArrayBuffer(spec.data);
    mimeType = spec.mimeType ?? "image/png";
  } else if (spec.path) {
    const imagePath = path2.resolve(ctx.specDir, spec.path);
    mimeType = detectImageMimeType(imagePath);
    arrayBuffer = await readFileToArrayBuffer(imagePath);
  } else {
    throw new Error("BackgroundImageSpec requires either 'path' or 'data'");
  }
  const { rId } = addMedia({
    pkg: ctx.zipPackage,
    mediaData: arrayBuffer,
    mediaType: mimeType,
    referringPart: ctx.slidePath
  });
  const bgElement = buildBlipFillBackground(rId, spec.mode ?? "stretch");
  return updateDocumentRoot(slideDoc, (root) => {
    const cSld = getChild(root, "p:cSld");
    if (!cSld) {
      return root;
    }
    const existingBg = getChild(cSld, "p:bg");
    const filteredChildren = existingBg ? withoutBackground(cSld.children) : cSld.children;
    const newCsld = {
      ...cSld,
      children: [bgElement, ...filteredChildren]
    };
    return replaceChildByName(root, "p:cSld", newCsld);
  });
}
function isImageBackground(spec) {
  return typeof spec === "object" && spec.type === "image";
}
// packages/@oxen-builder/pptx/src/builders/registry.ts
import * as path3 from "path";
// packages/@oxen-builder/pptx/src/patcher/serializer/line.ts
function serializeLine2(line) {
  const attrs = {
    w: ooxmlEmu(line.width),
    cap: serializeLineCap(line.cap),
    cmpd: line.compound,
    algn: line.alignment
  };
  const children = [
    serializeFill2(line.fill),
    serializeDash(line.dash)
  ];
  if (line.headEnd) {
    children.push(serializeLineEnd("a:headEnd", line.headEnd));
  }
  if (line.tailEnd) {
    children.push(serializeLineEnd("a:tailEnd", line.tailEnd));
  }
  children.push(serializeLineJoin(line));
  return createElement("a:ln", attrs, children);
}
function serializeLineCap(cap) {
  switch (cap) {
    case "flat":
      return "flat";
    case "round":
      return "rnd";
    case "square":
      return "sq";
  }
}
function serializeDash(dash) {
  if (typeof dash === "string") {
    return createElement("a:prstDash", { val: dash });
  }
  return createElement("a:custDash", {}, dash.dashes.map((d) => createElement("a:ds", {
    d: ooxmlPercent100k(d.dashLength),
    sp: ooxmlPercent100k(d.spaceLength)
  })));
}
function serializeLineEnd(name, end) {
  return createElement(name, {
    type: end.type,
    w: end.width,
    len: end.length
  });
}
function serializeLineJoin(line) {
  switch (line.join) {
    case "bevel":
      return createElement("a:bevel");
    case "round":
      return createElement("a:round");
    case "miter": {
      const attrs = {};
      if (line.miterLimit !== undefined) {
        attrs.lim = String(Math.round(line.miterLimit / 100 * 1e5));
      }
      return createElement("a:miter", attrs);
    }
  }
}
// packages/@oxen-builder/pptx/src/patcher/serializer/effects.ts
function serializeEffects2(effects) {
  const children = [];
  if (effects.shadow) {
    children.push(serializeShadow(effects.shadow));
  }
  if (effects.glow) {
    children.push(serializeGlow(effects.glow));
  }
  if (effects.reflection) {
    children.push(serializeReflection(effects.reflection));
  }
  if (effects.softEdge) {
    children.push(serializeSoftEdge(effects.softEdge));
  }
  if (effects.alphaBiLevel) {
    children.push(serializeAlphaBiLevel(effects.alphaBiLevel));
  }
  if (effects.alphaCeiling) {
    children.push(serializeAlphaCeiling(effects.alphaCeiling));
  }
  if (effects.alphaFloor) {
    children.push(serializeAlphaFloor(effects.alphaFloor));
  }
  if (effects.alphaInv) {
    children.push(serializeAlphaInv(effects.alphaInv));
  }
  if (effects.alphaMod) {
    children.push(serializeAlphaMod(effects.alphaMod));
  }
  if (effects.alphaModFix) {
    children.push(serializeAlphaModFix(effects.alphaModFix));
  }
  if (effects.alphaOutset) {
    children.push(serializeAlphaOutset(effects.alphaOutset));
  }
  if (effects.alphaRepl) {
    children.push(serializeAlphaRepl(effects.alphaRepl));
  }
  if (effects.biLevel) {
    children.push(serializeBiLevel(effects.biLevel));
  }
  if (effects.blend) {
    children.push(serializeBlend(effects.blend));
  }
  if (effects.colorChange) {
    children.push(serializeColorChange(effects.colorChange));
  }
  if (effects.colorReplace) {
    children.push(serializeColorReplace(effects.colorReplace));
  }
  if (effects.duotone) {
    children.push(serializeDuotone(effects.duotone));
  }
  if (effects.fillOverlay) {
    children.push(serializeFillOverlay(effects.fillOverlay));
  }
  if (effects.grayscale) {
    children.push(serializeGrayscale(effects.grayscale));
  }
  if (effects.presetShadow) {
    children.push(serializePresetShadow(effects.presetShadow));
  }
  if (effects.relativeOffset) {
    children.push(serializeRelativeOffset(effects.relativeOffset));
  }
  if (children.length === 0) {
    return null;
  }
  const containerName = effects.containerKind === "effectDag" ? "a:effectDag" : "a:effectLst";
  return createElement(containerName, {}, children);
}
function serializeShadow(shadow) {
  const name = shadow.type === "outer" ? "a:outerShdw" : "a:innerShdw";
  const attrs = {
    blurRad: ooxmlEmu(shadow.blurRadius),
    dist: ooxmlEmu(shadow.distance),
    dir: ooxmlAngleUnits(shadow.direction)
  };
  if (shadow.type === "outer") {
    if (shadow.scaleX !== undefined) {
      attrs.sx = ooxmlPercent100k(shadow.scaleX);
    }
    if (shadow.scaleY !== undefined) {
      attrs.sy = ooxmlPercent100k(shadow.scaleY);
    }
    if (shadow.skewX !== undefined) {
      attrs.kx = ooxmlAngleUnits(shadow.skewX);
    }
    if (shadow.skewY !== undefined) {
      attrs.ky = ooxmlAngleUnits(shadow.skewY);
    }
    if (shadow.alignment !== undefined) {
      attrs.algn = shadow.alignment;
    }
    if (shadow.rotateWithShape !== undefined) {
      attrs.rotWithShape = ooxmlBool(shadow.rotateWithShape);
    }
  }
  return createElement(name, attrs, [serializeColor(shadow.color)]);
}
function serializeGlow(glow) {
  return createElement("a:glow", { rad: ooxmlEmu(glow.radius) }, [serializeColor(glow.color)]);
}
function serializeReflection(reflection) {
  const attrs = {
    blurRad: ooxmlEmu(reflection.blurRadius),
    stA: ooxmlPercent100k(reflection.startOpacity),
    stPos: ooxmlPercent100k(reflection.startPosition),
    endA: ooxmlPercent100k(reflection.endOpacity),
    endPos: ooxmlPercent100k(reflection.endPosition),
    dist: ooxmlEmu(reflection.distance),
    dir: ooxmlAngleUnits(reflection.direction),
    fadeDir: ooxmlAngleUnits(reflection.fadeDirection),
    sx: ooxmlPercent100k(reflection.scaleX),
    sy: ooxmlPercent100k(reflection.scaleY)
  };
  if (reflection.skewX !== undefined) {
    attrs.kx = ooxmlAngleUnits(reflection.skewX);
  }
  if (reflection.skewY !== undefined) {
    attrs.ky = ooxmlAngleUnits(reflection.skewY);
  }
  if (reflection.alignment !== undefined) {
    attrs.algn = reflection.alignment;
  }
  if (reflection.rotateWithShape !== undefined) {
    attrs.rotWithShape = ooxmlBool(reflection.rotateWithShape);
  }
  return createElement("a:reflection", attrs);
}
function serializeSoftEdge(softEdge) {
  return createElement("a:softEdge", { rad: ooxmlEmu(softEdge.radius) });
}
function serializeAlphaBiLevel(effect) {
  return createElement("a:alphaBiLevel", { thresh: ooxmlPercent100k(effect.threshold) });
}
function serializeAlphaCeiling(effect) {
  return createElement("a:alphaCeiling");
}
function serializeAlphaFloor(effect) {
  return createElement("a:alphaFloor");
}
function serializeAlphaInv(effect) {
  return createElement("a:alphaInv");
}
function serializeAlphaMod(effect) {
  return createElement("a:alphaMod", {}, [serializeEffectContainer(effect.container, effect)]);
}
function serializeAlphaModFix(effect) {
  return createElement("a:alphaModFix", { amt: ooxmlPercent1000(effect.amount) });
}
function serializeAlphaOutset(effect) {
  return createElement("a:alphaOutset", { rad: ooxmlEmu(effect.radius) });
}
function serializeAlphaRepl(effect) {
  return createElement("a:alphaRepl", { a: ooxmlPercent100k(effect.alpha) });
}
function serializeBiLevel(effect) {
  return createElement("a:biLevel", { thresh: ooxmlPercent100k(effect.threshold) });
}
function serializeBlend(effect) {
  return createElement("a:blend", { blend: effect.blend }, [serializeEffectContainer(effect.container, effect)]);
}
function serializeColorChange(effect) {
  return createElement("a:clrChange", { useA: ooxmlBool(effect.useAlpha) }, [
    createElement("a:clrFrom", {}, [serializeColor(effect.from)]),
    createElement("a:clrTo", {}, [serializeColor(effect.to)])
  ]);
}
function serializeColorReplace(effect) {
  return createElement("a:clrRepl", {}, [serializeColor(effect.color)]);
}
function serializeDuotone(effect) {
  return createElement("a:duotone", {}, [
    serializeColor(effect.colors[0]),
    serializeColor(effect.colors[1])
  ]);
}
function serializeFillOverlay(effect) {
  const fillChild = effect.fill ? serializeFill2(effect.fill) : serializeFillOverlayChild(effect);
  return createElement("a:fillOverlay", { blend: effect.blend }, [fillChild]);
}
function serializeGrayscale(effect) {
  return createElement("a:grayscl");
}
function serializePresetShadow(effect) {
  return createElement("a:prstShdw", {
    prst: effect.preset,
    dir: ooxmlAngleUnits(effect.direction),
    dist: ooxmlEmu(effect.distance)
  }, [serializeColor(effect.color)]);
}
function serializeRelativeOffset(effect) {
  return createElement("a:relOff", {
    tx: ooxmlPercent1000(effect.offsetX),
    ty: ooxmlPercent1000(effect.offsetY)
  });
}
function serializeEffectContainer(container, fallback) {
  const attrs = {};
  const type = container?.type ?? fallback.containerType;
  const name = container?.name ?? fallback.name;
  if (type) {
    attrs.type = type;
  }
  if (name) {
    attrs.name = name;
  }
  return createElement("a:cont", attrs);
}
function serializeFillOverlayChild(effect) {
  switch (effect.fillType) {
    case "solidFill":
      return createElement("a:solidFill");
    case "gradFill":
      return createElement("a:gradFill");
    case "blipFill":
      return createElement("a:blipFill");
    case "pattFill":
      return createElement("a:pattFill");
    case "grpFill":
      return createElement("a:grpFill");
  }
}
// packages/@oxen-builder/pptx/src/patcher/serializer/transform.ts
var ANGLE_UNITS_PER_DEGREE2 = 60000;
function pixelsToEmuString(valuePx) {
  return String(Math.round(valuePx * EMU_PER_PIXEL));
}
function degreesToAngleUnitsString(valueDeg) {
  return String(Math.round(valueDeg * ANGLE_UNITS_PER_DEGREE2));
}
function buildOffElement(transform) {
  return createElement("a:off", {
    x: pixelsToEmuString(Number(transform.x)),
    y: pixelsToEmuString(Number(transform.y))
  });
}
function buildExtElement(transform) {
  return createElement("a:ext", {
    cx: pixelsToEmuString(Number(transform.width)),
    cy: pixelsToEmuString(Number(transform.height))
  });
}
function buildTransformAttrs(transform) {
  const attrs = {};
  if (Number(transform.rotation) !== 0) {
    attrs.rot = degreesToAngleUnitsString(Number(transform.rotation));
  }
  if (transform.flipH) {
    attrs.flipH = "1";
  }
  if (transform.flipV) {
    attrs.flipV = "1";
  }
  return attrs;
}
function serializeTransform(transform) {
  return createElement("a:xfrm", buildTransformAttrs(transform), [
    buildOffElement(transform),
    buildExtElement(transform)
  ]);
}
function patchTransformElement(existingXfrm, transform) {
  const attrs = { ...existingXfrm.attrs };
  if (Number(transform.rotation) !== 0) {
    attrs.rot = degreesToAngleUnitsString(Number(transform.rotation));
  } else {
    delete attrs.rot;
  }
  if (transform.flipH) {
    attrs.flipH = "1";
  }
  if (transform.flipV) {
    attrs.flipV = "1";
  }
  const preservedChildren = existingXfrm.children.filter((child) => {
    if (!isXmlElement(child)) {
      return true;
    }
    return child.name !== "a:off" && child.name !== "a:ext";
  });
  return createElement(existingXfrm.name, attrs, [
    buildOffElement(transform),
    buildExtElement(transform),
    ...preservedChildren
  ]);
}

// packages/@oxen-builder/pptx/src/patcher/serializer/three-d.ts
function serializeBevel(name, bevel) {
  const attrs = {
    w: ooxmlEmu(bevel.width),
    h: ooxmlEmu(bevel.height),
    prst: bevel.preset
  };
  return createElement(name, attrs);
}
function serializeShape3d2(shape3d) {
  const children = [];
  const attrs = {};
  if (shape3d.extrusionHeight !== undefined && shape3d.extrusionHeight > 0) {
    attrs.extrusionH = ooxmlEmu(shape3d.extrusionHeight);
  }
  if (shape3d.z !== undefined && shape3d.z > 0) {
    attrs.z = ooxmlEmu(shape3d.z);
  }
  if (shape3d.contourWidth !== undefined && shape3d.contourWidth > 0) {
    attrs.contourW = ooxmlEmu(shape3d.contourWidth);
  }
  if (shape3d.preset) {
    attrs.prstMaterial = shape3d.preset;
  }
  if (shape3d.bevelTop) {
    children.push(serializeBevel("a:bevelT", shape3d.bevelTop));
  }
  if (shape3d.bevelBottom) {
    children.push(serializeBevel("a:bevelB", shape3d.bevelBottom));
  }
  if (Object.keys(attrs).length === 0 && children.length === 0) {
    return null;
  }
  return createElement("a:sp3d", attrs, children);
}
// packages/@oxen-builder/pptx/src/patcher/serializer/text-properties.ts
var PT_PER_INCH = 72;
var PX_PER_INCH = 96;
function ooxmlCentipoints(points) {
  return String(Math.round(points * 100));
}
function ooxmlTextPointUnqualified(pixels) {
  return String(Math.round(pixels * (PT_PER_INCH / PX_PER_INCH) * 100));
}
function serializeLineSpacing(spacing, elementName) {
  switch (spacing.type) {
    case "percent":
      return createElement(elementName, {}, [
        createElement("a:spcPct", { val: ooxmlPercent1000(spacing.value) })
      ]);
    case "points":
      return createElement(elementName, {}, [
        createElement("a:spcPts", { val: ooxmlCentipoints(spacing.value) })
      ]);
  }
}
function serializeTabStops(tabs) {
  return createElement("a:tabLst", {}, tabs.map((tab) => createElement("a:tab", {
    pos: ooxmlEmu(tab.position),
    algn: serializeTabStopAlignment(tab.alignment)
  })));
}
function serializeTabStopAlignment(alignment) {
  switch (alignment) {
    case "left":
      return "l";
    case "center":
      return "ctr";
    case "right":
      return "r";
    case "decimal":
      return "dec";
  }
}
function serializeParagraphAlignment(alignment) {
  switch (alignment) {
    case "left":
      return "l";
    case "center":
      return "ctr";
    case "right":
      return "r";
    case "justify":
      return "just";
    case "justifyLow":
      return "justLow";
    case "distributed":
      return "dist";
    case "thaiDistributed":
      return "thaiDist";
  }
}
function serializeFontAlignment(alignment) {
  switch (alignment) {
    case "auto":
      return "auto";
    case "top":
      return "t";
    case "center":
      return "ctr";
    case "base":
      return "base";
    case "bottom":
      return "b";
  }
}
function serializeBodyAnchor(anchor) {
  switch (anchor) {
    case "top":
      return "t";
    case "center":
      return "ctr";
    case "bottom":
      return "b";
  }
}
function serializeHyperlinkSound(sound) {
  const attrs = { "r:embed": sound.embed };
  if (sound.name) {
    attrs.name = sound.name;
  }
  return createElement("a:snd", attrs);
}
function serializeHyperlink(hlink) {
  const attrs = { "r:id": hlink.id };
  if (hlink.tooltip !== undefined) {
    attrs.tooltip = hlink.tooltip;
  }
  if (hlink.action !== undefined) {
    attrs.action = hlink.action;
  }
  const children = [];
  if (hlink.sound) {
    children.push(serializeHyperlinkSound(hlink.sound));
  }
  return createElement("a:hlinkClick", attrs, children);
}
function serializeHyperlinkMouseOver(hlink) {
  const attrs = {};
  if (hlink.id !== undefined) {
    attrs["r:id"] = hlink.id;
  }
  if (hlink.tooltip !== undefined) {
    attrs.tooltip = hlink.tooltip;
  }
  if (hlink.action !== undefined) {
    attrs.action = hlink.action;
  }
  if (hlink.highlightClick !== undefined) {
    attrs.highlightClick = ooxmlBool(hlink.highlightClick);
  }
  if (hlink.endSound !== undefined) {
    attrs.endSnd = ooxmlBool(hlink.endSound);
  }
  const children = [];
  if (hlink.sound) {
    children.push(serializeHyperlinkSound(hlink.sound));
  }
  return createElement("a:hlinkMouseOver", attrs, children);
}
function serializeBullet(bullet) {
  switch (bullet.type) {
    case "none":
      return createElement("a:buNone");
    case "auto": {
      const attrs = { type: bullet.scheme };
      if (bullet.startAt !== undefined) {
        attrs.startAt = String(bullet.startAt);
      }
      return createElement("a:buAutoNum", attrs);
    }
    case "char":
      return createElement("a:buChar", { char: bullet.char });
    case "blip":
      return createElement("a:buBlip", {}, [
        createElement("a:blip", { "r:embed": bullet.resourceId })
      ]);
  }
}
function serializeBulletStyle(style) {
  const elements = [];
  elements.push(serializeBullet(style.bullet));
  if (style.colorFollowText) {
    elements.push(createElement("a:buClrTx"));
  } else if (style.color) {
    elements.push(createElement("a:buClr", {}, [serializeColor(style.color)]));
  }
  if (style.sizeFollowText) {
    elements.push(createElement("a:buSzTx"));
  } else if (style.sizePercent !== undefined) {
    elements.push(createElement("a:buSzPct", { val: ooxmlPercent1000(style.sizePercent) }));
  } else if (style.sizePoints !== undefined) {
    elements.push(createElement("a:buSzPts", { val: ooxmlCentipoints(style.sizePoints) }));
  }
  if (style.fontFollowText) {
    elements.push(createElement("a:buFontTx"));
  } else if (style.font !== undefined) {
    elements.push(createElement("a:buFont", { typeface: style.font }));
  }
  return elements;
}
function renameElement(element, name) {
  return { ...element, name };
}
function serializeRunPropertiesElement(props, elementName) {
  const attrs = {};
  if (props.language !== undefined) {
    attrs.lang = props.language;
  }
  if (props.altLanguage !== undefined) {
    attrs.altLang = props.altLanguage;
  }
  if (props.bookmark !== undefined) {
    attrs.bmk = props.bookmark;
  }
  if (props.fontSize !== undefined) {
    attrs.sz = ooxmlCentipoints(props.fontSize);
  }
  if (props.bold !== undefined) {
    attrs.b = ooxmlBool(props.bold);
  }
  if (props.italic !== undefined) {
    attrs.i = ooxmlBool(props.italic);
  }
  if (props.underline !== undefined) {
    attrs.u = props.underline;
  }
  if (props.strike !== undefined) {
    attrs.strike = props.strike;
  }
  if (props.caps !== undefined) {
    attrs.cap = props.caps;
  }
  if (props.baseline !== undefined) {
    attrs.baseline = String(Math.round(props.baseline));
  }
  if (props.spacing !== undefined) {
    attrs.spc = ooxmlTextPointUnqualified(props.spacing);
  }
  if (props.kerning !== undefined) {
    attrs.kern = ooxmlCentipoints(props.kerning);
  }
  if (props.noProof !== undefined) {
    attrs.noProof = ooxmlBool(props.noProof);
  }
  if (props.dirty !== undefined) {
    attrs.dirty = ooxmlBool(props.dirty);
  }
  if (props.smartTagClean !== undefined) {
    attrs.smtClean = ooxmlBool(props.smartTagClean);
  }
  if (props.error !== undefined) {
    attrs.err = ooxmlBool(props.error);
  }
  if (props.kumimoji !== undefined) {
    attrs.kumimoji = ooxmlBool(props.kumimoji);
  }
  if (props.normalizeHeights !== undefined) {
    attrs.normalizeH = ooxmlBool(props.normalizeHeights);
  }
  if (props.smartTagId !== undefined) {
    attrs.smtId = String(Math.round(props.smartTagId));
  }
  if (props.outline !== undefined) {
    attrs.outline = ooxmlBool(props.outline);
  }
  if (props.shadow !== undefined) {
    attrs.shadow = ooxmlBool(props.shadow);
  }
  if (props.emboss !== undefined) {
    attrs.emboss = ooxmlBool(props.emboss);
  }
  const children = [];
  if (props.fill !== undefined) {
    children.push(serializeFill2(props.fill));
  } else if (props.color !== undefined) {
    children.push(createElement("a:solidFill", {}, [serializeColor(props.color)]));
  }
  if (props.highlightColor !== undefined) {
    children.push(createElement("a:highlight", {}, [serializeColor(props.highlightColor)]));
  }
  if (props.underlineLineFollowText === true) {
    children.push(createElement("a:uLnTx"));
  }
  if (props.underlineFillFollowText === true) {
    children.push(createElement("a:uFillTx"));
  }
  if (props.underlineLine !== undefined) {
    children.push(renameElement(serializeLine2(props.underlineLine), "a:uLn"));
  }
  if (props.underlineFill !== undefined) {
    children.push(createElement("a:uFill", {}, [serializeFill2(props.underlineFill)]));
  }
  if (props.underlineColor !== undefined && props.underlineLine === undefined) {
    children.push(createElement("a:uLn", {}, [createElement("a:solidFill", {}, [serializeColor(props.underlineColor)])]));
  }
  if (props.textOutline !== undefined) {
    children.push(serializeLine2(props.textOutline));
  }
  if (props.effects !== undefined) {
    const effectEl = serializeEffects2(props.effects);
    if (effectEl) {
      children.push(effectEl);
    }
  }
  if (props.fontFamily !== undefined) {
    const attrs2 = { typeface: props.fontFamily };
    if (props.fontFamilyPitchFamily !== undefined) {
      attrs2.pitchFamily = String(props.fontFamilyPitchFamily);
    }
    children.push(createElement("a:latin", attrs2));
  }
  if (props.fontFamilyEastAsian !== undefined) {
    const attrs2 = { typeface: props.fontFamilyEastAsian };
    if (props.fontFamilyEastAsianPitchFamily !== undefined) {
      attrs2.pitchFamily = String(props.fontFamilyEastAsianPitchFamily);
    }
    children.push(createElement("a:ea", attrs2));
  }
  if (props.fontFamilyComplexScript !== undefined) {
    const attrs2 = { typeface: props.fontFamilyComplexScript };
    if (props.fontFamilyComplexScriptPitchFamily !== undefined) {
      attrs2.pitchFamily = String(props.fontFamilyComplexScriptPitchFamily);
    }
    children.push(createElement("a:cs", attrs2));
  }
  if (props.fontFamilySymbol !== undefined) {
    const attrs2 = { typeface: props.fontFamilySymbol };
    if (props.fontFamilySymbolPitchFamily !== undefined) {
      attrs2.pitchFamily = String(props.fontFamilySymbolPitchFamily);
    }
    children.push(createElement("a:sym", attrs2));
  }
  if (props.hyperlink) {
    children.push(serializeHyperlink(props.hyperlink));
  }
  if (props.hyperlinkMouseOver) {
    children.push(serializeHyperlinkMouseOver(props.hyperlinkMouseOver));
  }
  if (props.rtl === true) {
    children.push(createElement("a:rtl"));
  }
  return createElement(elementName, attrs, children);
}
function serializeRunProperties2(props) {
  return serializeRunPropertiesElement(props, "a:rPr");
}
function serializeBodyProperties(props) {
  if (props.textWarp !== undefined) {
    throw new Error("a:bodyPr serialization does not support textWarp yet");
  }
  if (props.scene3d !== undefined || props.shape3d !== undefined) {
    throw new Error("a:bodyPr serialization does not support 3D text properties yet");
  }
  const attrs = {};
  if (props.rotation !== undefined) {
    attrs.rot = ooxmlAngleUnits(props.rotation);
  }
  if (props.verticalType !== undefined) {
    attrs.vert = props.verticalType;
  }
  if (props.wrapping !== undefined) {
    attrs.wrap = props.wrapping;
  }
  if (props.anchor !== undefined) {
    attrs.anchor = serializeBodyAnchor(props.anchor);
  }
  if (props.anchorCenter !== undefined) {
    attrs.anchorCtr = ooxmlBool(props.anchorCenter);
  }
  if (props.overflow !== undefined) {
    attrs.horzOverflow = props.overflow;
  }
  if (props.verticalOverflow !== undefined) {
    attrs.vertOverflow = props.verticalOverflow;
  }
  if (props.insets) {
    attrs.lIns = ooxmlEmu(props.insets.left);
    attrs.tIns = ooxmlEmu(props.insets.top);
    attrs.rIns = ooxmlEmu(props.insets.right);
    attrs.bIns = ooxmlEmu(props.insets.bottom);
  }
  if (props.columns !== undefined) {
    attrs.numCol = String(Math.round(props.columns));
  }
  if (props.columnSpacing !== undefined) {
    attrs.spcCol = ooxmlEmu(props.columnSpacing);
  }
  if (props.upright !== undefined) {
    attrs.upright = ooxmlBool(props.upright);
  }
  if (props.compatibleLineSpacing !== undefined) {
    attrs.compatLnSpc = ooxmlBool(props.compatibleLineSpacing);
  }
  if (props.rtlColumns !== undefined) {
    attrs.rtlCol = ooxmlBool(props.rtlColumns);
  }
  if (props.spaceFirstLastPara !== undefined) {
    attrs.spcFirstLastPara = ooxmlBool(props.spaceFirstLastPara);
  }
  if (props.forceAntiAlias !== undefined) {
    attrs.forceAA = ooxmlBool(props.forceAntiAlias);
  }
  if (props.fromWordArt !== undefined) {
    attrs.fromWordArt = ooxmlBool(props.fromWordArt);
  }
  const children = [];
  if (props.autoFit) {
    switch (props.autoFit.type) {
      case "none":
        break;
      case "shape":
        children.push(createElement("a:spAutoFit"));
        break;
      case "normal": {
        const autoFitAttrs = {};
        if (props.autoFit.fontScale !== undefined) {
          autoFitAttrs.fontScale = ooxmlPercent1000(props.autoFit.fontScale);
        }
        if (props.autoFit.lineSpaceReduction !== undefined) {
          autoFitAttrs.lnSpcReduction = ooxmlPercent1000(props.autoFit.lineSpaceReduction);
        }
        children.push(createElement("a:normAutofit", autoFitAttrs));
        break;
      }
    }
  }
  return createElement("a:bodyPr", attrs, children);
}
function serializeParagraphProperties2(props) {
  const attrs = {};
  if (props.level !== undefined) {
    attrs.lvl = String(Math.round(props.level));
  }
  if (props.alignment !== undefined) {
    attrs.algn = serializeParagraphAlignment(props.alignment);
  }
  if (props.defaultTabSize !== undefined) {
    attrs.defTabSz = ooxmlEmu(props.defaultTabSize);
  }
  if (props.marginLeft !== undefined) {
    attrs.marL = ooxmlEmu(props.marginLeft);
  }
  if (props.marginRight !== undefined) {
    attrs.marR = ooxmlEmu(props.marginRight);
  }
  if (props.indent !== undefined) {
    attrs.indent = ooxmlEmu(props.indent);
  }
  if (props.rtl !== undefined) {
    attrs.rtl = ooxmlBool(props.rtl);
  }
  if (props.fontAlignment !== undefined) {
    attrs.fontAlgn = serializeFontAlignment(props.fontAlignment);
  }
  if (props.eaLineBreak !== undefined) {
    attrs.eaLnBrk = ooxmlBool(props.eaLineBreak);
  }
  if (props.latinLineBreak !== undefined) {
    attrs.latinLnBrk = ooxmlBool(props.latinLineBreak);
  }
  if (props.hangingPunctuation !== undefined) {
    attrs.hangingPunct = ooxmlBool(props.hangingPunctuation);
  }
  const children = [];
  if (props.lineSpacing) {
    children.push(serializeLineSpacing(props.lineSpacing, "a:lnSpc"));
  }
  if (props.spaceBefore) {
    children.push(serializeLineSpacing(props.spaceBefore, "a:spcBef"));
  }
  if (props.spaceAfter) {
    children.push(serializeLineSpacing(props.spaceAfter, "a:spcAft"));
  }
  if (props.bulletStyle) {
    children.push(...serializeBulletStyle(props.bulletStyle));
  }
  if (props.tabStops && props.tabStops.length > 0) {
    children.push(serializeTabStops(props.tabStops));
  }
  if (props.defaultRunProperties) {
    children.push(serializeRunPropertiesElement(props.defaultRunProperties, "a:defRPr"));
  }
  return createElement("a:pPr", attrs, children);
}
function serializeEndParaRunProperties(props) {
  return serializeRunPropertiesElement(props, "a:endParaRPr");
}
function serializeText2(text) {
  const needsPreserve = /(^\s|\s$|\s{2,}|\t)/.test(text);
  const attrs = needsPreserve ? { "xml:space": "preserve" } : {};
  return createElement("a:t", attrs, [createText(text)]);
}

// packages/@oxen-builder/pptx/src/patcher/serializer/paragraph.ts
function serializeTextRun(run) {
  const children = [];
  if (run.properties) {
    children.push(serializeRunProperties2(run.properties));
  }
  children.push(serializeText2(run.text));
  return createElement("a:r", {}, children);
}
function serializeLineBreak(lineBreak) {
  const children = [];
  if (lineBreak.properties) {
    children.push(serializeRunProperties2(lineBreak.properties));
  }
  return createElement("a:br", {}, children);
}
function serializeTextField(field) {
  const children = [];
  if (field.properties) {
    children.push(serializeRunProperties2(field.properties));
  }
  children.push(serializeText2(field.text));
  return createElement("a:fld", { id: field.id, type: field.fieldType }, children);
}
function serializeRun2(run) {
  switch (run.type) {
    case "text":
      return serializeTextRun(run);
    case "break":
      return serializeLineBreak(run);
    case "field":
      return serializeTextField(run);
  }
}
function serializeParagraph2(paragraph) {
  const children = [];
  if (Object.keys(paragraph.properties).length > 0) {
    children.push(serializeParagraphProperties2(paragraph.properties));
  }
  for (const run of paragraph.runs) {
    children.push(serializeRun2(run));
  }
  if (paragraph.endProperties) {
    children.push(serializeEndParaRunProperties(paragraph.endProperties));
  }
  return createElement("a:p", {}, children);
}

// packages/@oxen-builder/pptx/src/patcher/serializer/text.ts
function createEmptyParagraph() {
  return createElement("a:p");
}
function serializeTextBody(textBody) {
  const paragraphs = [];
  if (textBody.paragraphs.length > 0) {
    paragraphs.push(...textBody.paragraphs.map(serializeParagraph2));
  } else {
    paragraphs.push(createEmptyParagraph());
  }
  return createElement("p:txBody", {}, [
    serializeBodyProperties(textBody.bodyProperties),
    createElement("a:lstStyle"),
    ...paragraphs
  ]);
}
function serializeDrawingTextBody(textBody) {
  const paragraphs = [];
  if (textBody.paragraphs.length > 0) {
    paragraphs.push(...textBody.paragraphs.map(serializeParagraph2));
  } else {
    paragraphs.push(createEmptyParagraph());
  }
  return createElement("a:txBody", {}, [
    serializeBodyProperties(textBody.bodyProperties),
    createElement("a:lstStyle"),
    ...paragraphs
  ]);
}
function patchTextBodyElement(existingTxBody, textBody) {
  const existingBodyPr = existingTxBody.children.find((c) => isXmlElement(c) && c.name === "a:bodyPr");
  const existingLstStyle = existingTxBody.children.find((c) => isXmlElement(c) && c.name === "a:lstStyle");
  const otherChildren = existingTxBody.children.filter((c) => {
    if (!isXmlElement(c)) {
      return true;
    }
    return c.name !== "a:bodyPr" && c.name !== "a:lstStyle" && c.name !== "a:p";
  });
  const paragraphs = [];
  if (textBody.paragraphs.length > 0) {
    paragraphs.push(...textBody.paragraphs.map(serializeParagraph2));
  } else {
    paragraphs.push(createEmptyParagraph());
  }
  return createElement(existingTxBody.name, { ...existingTxBody.attrs }, [
    existingBodyPr ?? serializeBodyProperties(textBody.bodyProperties),
    existingLstStyle ?? createElement("a:lstStyle"),
    ...paragraphs,
    ...otherChildren
  ]);
}
// packages/@oxen-builder/pptx/src/patcher/serializer/table.ts
function serializeTableProperties(props) {
  const attrs = {};
  if (props.rtl !== undefined) {
    attrs.rtl = ooxmlBool(props.rtl);
  }
  if (props.firstRow !== undefined) {
    attrs.firstRow = ooxmlBool(props.firstRow);
  }
  if (props.firstCol !== undefined) {
    attrs.firstCol = ooxmlBool(props.firstCol);
  }
  if (props.lastRow !== undefined) {
    attrs.lastRow = ooxmlBool(props.lastRow);
  }
  if (props.lastCol !== undefined) {
    attrs.lastCol = ooxmlBool(props.lastCol);
  }
  if (props.bandRow !== undefined) {
    attrs.bandRow = ooxmlBool(props.bandRow);
  }
  if (props.bandCol !== undefined) {
    attrs.bandCol = ooxmlBool(props.bandCol);
  }
  const children = [];
  if (props.fill) {
    children.push(serializeFill2(props.fill));
  }
  if (props.effects) {
    const eff = serializeEffects2(props.effects);
    if (eff) {
      children.push(eff);
    }
  }
  if (props.tableStyleId) {
    children.push(createElement("a:tableStyleId", {}, [{ type: "text", value: props.tableStyleId }]));
  }
  return createElement("a:tblPr", attrs, children);
}
function serializeCellAnchor(anchor) {
  if (!anchor) {
    return;
  }
  if (anchor === "top") {
    return "t";
  }
  if (anchor === "center") {
    return "ctr";
  }
  return "b";
}
function serializeCellBorders(borders) {
  const out = [];
  const withName = (name, line) => {
    const base = serializeLine2(line);
    return createElement(name, base.attrs, base.children);
  };
  if (borders.left) {
    out.push(withName("a:lnL", borders.left));
  }
  if (borders.right) {
    out.push(withName("a:lnR", borders.right));
  }
  if (borders.top) {
    out.push(withName("a:lnT", borders.top));
  }
  if (borders.bottom) {
    out.push(withName("a:lnB", borders.bottom));
  }
  if (borders.tlToBr) {
    out.push(withName("a:lnTlToBr", borders.tlToBr));
  }
  if (borders.blToTr) {
    out.push(withName("a:lnBlToTr", borders.blToTr));
  }
  return out;
}
function serializeTableCellProperties(props) {
  const attrs = {};
  if (props.margins) {
    attrs.marL = ooxmlEmu(props.margins.left);
    attrs.marR = ooxmlEmu(props.margins.right);
    attrs.marT = ooxmlEmu(props.margins.top);
    attrs.marB = ooxmlEmu(props.margins.bottom);
  }
  const anchor = serializeCellAnchor(props.anchor);
  if (anchor) {
    attrs.anchor = anchor;
  }
  if (props.anchorCenter !== undefined) {
    attrs.anchorCtr = ooxmlBool(props.anchorCenter);
  }
  if (props.horzOverflow) {
    attrs.horzOverflow = props.horzOverflow;
  }
  if (props.verticalType) {
    attrs.vert = props.verticalType;
  }
  if (props.rowSpan !== undefined) {
    attrs.rowSpan = String(props.rowSpan);
  }
  if (props.colSpan !== undefined) {
    attrs.gridSpan = String(props.colSpan);
  }
  if (props.horizontalMerge) {
    attrs.hMerge = "1";
  }
  if (props.verticalMerge) {
    attrs.vMerge = "1";
  }
  const children = [];
  if (props.borders) {
    children.push(...serializeCellBorders(props.borders));
  }
  if (props.fill) {
    children.push(serializeFill2(props.fill));
  }
  return createElement("a:tcPr", attrs, children);
}
function createEmptyTxBody() {
  return createElement("a:txBody", {}, [
    createElement("a:bodyPr"),
    createElement("a:lstStyle"),
    createElement("a:p")
  ]);
}
function serializeTableCell2(cell) {
  const attrs = {};
  if (cell.id) {
    attrs.id = cell.id;
  }
  const txBody = cell.textBody ? serializeDrawingTextBody(cell.textBody) : createEmptyTxBody();
  const tcPr = serializeTableCellProperties(cell.properties);
  return createElement("a:tc", attrs, [txBody, tcPr]);
}
function serializeDrawingTable(table) {
  const tblGrid = createElement("a:tblGrid", {}, table.grid.columns.map((c) => createElement("a:gridCol", { w: ooxmlEmu(c.width) })));
  const rows = table.rows.map((r) => createElement("a:tr", { h: ooxmlEmu(r.height) }, r.cells.map(serializeTableCell2)));
  return createElement("a:tbl", {}, [
    serializeTableProperties(table.properties),
    tblGrid,
    ...rows
  ]);
}
// packages/@oxen-builder/pptx/src/patcher/serializer/transition.ts
function booleanAttr(value) {
  return value ? "1" : "0";
}
function durationToSpeed(durationMs) {
  if (durationMs >= 1500) {
    return "slow";
  }
  if (durationMs >= 750) {
    return "med";
  }
  return "fast";
}
var DIRECTION_EIGHT_TYPES = ["wipe", "push", "cover", "pull", "strips"];
var ORIENTATION_TYPES = ["blinds", "checker", "comb", "randomBar"];
var SPOKES_TYPES = ["wheel"];
var IN_OUT_TYPES = ["split", "zoom"];
function serializeTransitionTypeElement(transition) {
  const { type, direction, orientation, spokes, inOutDirection } = transition;
  const attrs = {};
  const usesDir8 = DIRECTION_EIGHT_TYPES.includes(type);
  const usesOrientation = ORIENTATION_TYPES.includes(type);
  const usesSpokes = SPOKES_TYPES.includes(type);
  const usesInOut = IN_OUT_TYPES.includes(type);
  if (direction !== undefined && !usesDir8) {
    throw new Error(`serializeTransitionTypeElement: direction is not supported for transition type "${type}"`);
  }
  if (orientation !== undefined && !usesOrientation) {
    throw new Error(`serializeTransitionTypeElement: orientation is not supported for transition type "${type}"`);
  }
  if (spokes !== undefined && !usesSpokes) {
    throw new Error(`serializeTransitionTypeElement: spokes is not supported for transition type "${type}"`);
  }
  if (inOutDirection !== undefined && !usesInOut) {
    throw new Error(`serializeTransitionTypeElement: inOutDirection is not supported for transition type "${type}"`);
  }
  if (usesDir8 && direction !== undefined) {
    attrs.dir = direction;
  }
  if (usesOrientation && orientation !== undefined) {
    attrs.dir = orientation;
  }
  if (usesSpokes && spokes !== undefined) {
    attrs.spkCnt = `${spokes}`;
  }
  if (usesInOut && inOutDirection !== undefined) {
    attrs.dir = inOutDirection;
  }
  return createElement(`p:${type}`, attrs);
}
function serializeSlideTransition(transition) {
  if (transition.type === "none") {
    return null;
  }
  const attrs = {};
  if (transition.duration !== undefined) {
    attrs.spd = durationToSpeed(transition.duration);
  }
  if (transition.advanceOnClick !== undefined) {
    attrs.advClick = booleanAttr(transition.advanceOnClick);
  }
  if (transition.advanceAfter !== undefined) {
    attrs.advTm = `${transition.advanceAfter}`;
  }
  const typeEl = serializeTransitionTypeElement(transition);
  return createElement("p:transition", attrs, [typeEl]);
}
// packages/@oxen-builder/pptx/src/patcher/serializer/animation.ts
function boolAttr(value) {
  return value ? "1" : "0";
}
function timeValue(time) {
  return time === "indefinite" ? "indefinite" : String(time);
}
function serializeShapeTarget(target) {
  const children = [];
  if (target.textElement) {
    if (target.textElement.type === "paragraph") {
      children.push(createElement("p:txEl", {}, [
        createElement("p:pRg", {
          st: String(target.textElement.start),
          end: String(target.textElement.end)
        })
      ]));
    } else {
      children.push(createElement("p:txEl", {}, [
        createElement("p:charRg", {
          st: String(target.textElement.start),
          end: String(target.textElement.end)
        })
      ]));
    }
  }
  if (target.targetBackground) {
    children.push(createElement("p:bg"));
  }
  return createElement("p:spTgt", { spid: String(target.shapeId) }, children);
}
function serializeTarget(target) {
  switch (target.type) {
    case "shape":
      return createElement("p:tgtEl", {}, [serializeShapeTarget(target)]);
    case "slide":
      return createElement("p:tgtEl", {}, [createElement("p:sldTgt")]);
    case "sound":
      return createElement("p:tgtEl", {}, [
        createElement("p:sndTgt", { "r:embed": target.resourceId, name: target.name ?? "" })
      ]);
    case "ink":
      return createElement("p:tgtEl", {}, [createElement("p:inkTgt", { spid: String(target.shapeId) })]);
  }
}
function serializeCondition(cond) {
  const attrs = {};
  if (cond.delay !== undefined) {
    attrs.delay = timeValue(cond.delay);
  }
  if (cond.event !== undefined) {
    attrs.evt = cond.event;
  }
  const children = [];
  if (cond.target) {
    children.push(serializeTarget(cond.target));
  }
  if (cond.timeNodeRef !== undefined) {
    children.push(createElement("p:tn", { val: String(cond.timeNodeRef) }));
  }
  if (cond.runtimeNode !== undefined) {
    children.push(createElement("p:rtn", { val: cond.runtimeNode }));
  }
  return createElement("p:cond", attrs, children);
}
function serializeConditionList(conditions, wrapper) {
  return createElement(wrapper, {}, conditions.map(serializeCondition));
}
function serializeKeyframe(kf) {
  const attrs = {
    tm: kf.time === "indefinite" ? "indefinite" : String(kf.time)
  };
  if (kf.formula) {
    attrs.fmla = kf.formula;
  }
  const valEl = createElement("p:val", {}, [
    createElement("p:strVal", { val: String(kf.value) })
  ]);
  return createElement("p:tav", attrs, [valEl]);
}
function serializePreset(preset, attrs) {
  attrs.presetID = String(preset.id);
  attrs.presetClass = preset.class;
  if (preset.subtype !== undefined) {
    attrs.presetSubtype = String(preset.subtype);
  }
}
function serializeCommonTimeNode(node) {
  const attrs = {
    id: String(node.id)
  };
  if (node.duration !== undefined) {
    attrs.dur = timeValue(node.duration);
  }
  if (node.fill !== undefined) {
    attrs.fill = node.fill;
  }
  if (node.restart !== undefined) {
    attrs.restart = node.restart;
  }
  if (node.nodeType !== undefined) {
    attrs.nodeType = node.nodeType;
  }
  if (node.preset !== undefined) {
    serializePreset(node.preset, attrs);
  }
  if (node.acceleration !== undefined) {
    attrs.accel = String(node.acceleration * 1000);
  }
  if (node.deceleration !== undefined) {
    attrs.decel = String(node.deceleration * 1000);
  }
  if (node.autoReverse !== undefined) {
    attrs.autoRev = boolAttr(node.autoReverse);
  }
  if (node.repeatCount !== undefined) {
    attrs.repeatCount = node.repeatCount === "indefinite" ? "indefinite" : String(node.repeatCount);
  }
  if (node.speed !== undefined) {
    attrs.spd = String(node.speed * 1000);
  }
  const children = [];
  if (node.startConditions && node.startConditions.length > 0) {
    children.push(serializeConditionList(node.startConditions, "p:stCondLst"));
  }
  if (node.endConditions && node.endConditions.length > 0) {
    children.push(serializeConditionList(node.endConditions, "p:endCondLst"));
  }
  if ("children" in node && node.children.length > 0) {
    children.push(createElement("p:childTnLst", {}, node.children.map(serializeTimeNode)));
  }
  return createElement("p:cTn", attrs, children);
}
function serializeCommonBehavior(node) {
  const attrs = {};
  if ("attribute" in node && node.attribute) {
    attrs.attrName = node.attribute;
  }
  if ("additive" in node && node.additive !== undefined) {
    attrs.additive = node.additive;
  }
  if (node.accumulate !== undefined) {
    attrs.accumulate = node.accumulate;
  }
  if (node.transformType !== undefined) {
    attrs.xfrmType = node.transformType;
  }
  const children = [serializeCommonTimeNode(node)];
  children.push(serializeTarget(node.target));
  if ("attribute" in node && node.attribute) {
    children.push(createElement("p:attrNameLst", {}, [
      createElement("p:attrName", {}, [{ type: "text", value: node.attribute }])
    ]));
  }
  return createElement("p:cBhvr", attrs, children);
}
function serializeAnimateBehavior(node) {
  const attrs = {};
  if (node.calcMode !== undefined) {
    attrs.calcmode = node.calcMode;
  }
  if (node.valueType !== undefined) {
    attrs.valueType = node.valueType;
  }
  const children = [serializeCommonBehavior(node)];
  if (node.keyframes && node.keyframes.length > 0) {
    children.push(createElement("p:tavLst", {}, node.keyframes.map(serializeKeyframe)));
  }
  return createElement("p:anim", attrs, children);
}
function serializeSetBehavior(node) {
  const children = [serializeCommonBehavior(node)];
  children.push(createElement("p:to", {}, [
    createElement("p:strVal", { val: String(node.value) })
  ]));
  return createElement("p:set", {}, children);
}
function serializeAnimateEffectBehavior(node) {
  const attrs = {
    transition: node.transition,
    filter: node.filter
  };
  const children = [serializeCommonBehavior(node)];
  return createElement("p:animEffect", attrs, children);
}
function serializeAnimateMotionBehavior(node) {
  const attrs = {};
  if (node.origin !== undefined) {
    attrs.origin = node.origin;
  }
  if (node.path !== undefined) {
    attrs.path = node.path;
  }
  if (node.pathEditMode !== undefined) {
    attrs.pathEditMode = node.pathEditMode;
  }
  const children = [serializeCommonBehavior(node)];
  if (node.from !== undefined) {
    children.push(createElement("p:from", { x: String(node.from.x), y: String(node.from.y) }));
  }
  if (node.to !== undefined) {
    children.push(createElement("p:to", { x: String(node.to.x), y: String(node.to.y) }));
  }
  if (node.by !== undefined) {
    children.push(createElement("p:by", { x: String(node.by.x), y: String(node.by.y) }));
  }
  if (node.rotationCenter !== undefined) {
    children.push(createElement("p:rCtr", { x: String(node.rotationCenter.x), y: String(node.rotationCenter.y) }));
  }
  return createElement("p:animMotion", attrs, children);
}
function serializeAnimateColorBehavior(node) {
  const attrs = {};
  if (node.colorSpace !== undefined) {
    attrs.clrSpc = node.colorSpace;
  }
  if (node.direction !== undefined) {
    attrs.dir = node.direction;
  }
  const children = [serializeCommonBehavior(node)];
  if (node.from !== undefined) {
    children.push(createElement("p:from", {}, [createElement("a:srgbClr", { val: node.from })]));
  }
  if (node.to !== undefined) {
    children.push(createElement("p:to", {}, [createElement("a:srgbClr", { val: node.to })]));
  }
  if (node.by !== undefined) {
    children.push(createElement("p:by", {}, [createElement("a:srgbClr", { val: node.by })]));
  }
  return createElement("p:animClr", attrs, children);
}
function serializeAnimateScaleBehavior(node) {
  const children = [serializeCommonBehavior(node)];
  if (node.fromX !== undefined && node.fromY !== undefined) {
    children.push(createElement("p:from", { x: String(node.fromX * 1000), y: String(node.fromY * 1000) }));
  }
  if (node.toX !== undefined && node.toY !== undefined) {
    children.push(createElement("p:to", { x: String(node.toX * 1000), y: String(node.toY * 1000) }));
  }
  if (node.byX !== undefined && node.byY !== undefined) {
    children.push(createElement("p:by", { x: String(node.byX * 1000), y: String(node.byY * 1000) }));
  }
  return createElement("p:animScale", {}, children);
}
function serializeAnimateRotationBehavior(node) {
  const attrs = {};
  if (node.from !== undefined) {
    attrs.from = String(node.from * 60000);
  }
  if (node.to !== undefined) {
    attrs.to = String(node.to * 60000);
  }
  if (node.by !== undefined) {
    attrs.by = String(node.by * 60000);
  }
  const children = [serializeCommonBehavior(node)];
  return createElement("p:animRot", attrs, children);
}
function serializeTimeNode(node) {
  switch (node.type) {
    case "parallel":
      return serializeParallelNode(node);
    case "sequence":
      return serializeSequenceNode(node);
    case "exclusive":
      return createElement("p:excl", {}, [serializeCommonTimeNode(node)]);
    case "animate":
      return serializeAnimateBehavior(node);
    case "set":
      return serializeSetBehavior(node);
    case "animateEffect":
      return serializeAnimateEffectBehavior(node);
    case "animateMotion":
      return serializeAnimateMotionBehavior(node);
    case "animateColor":
      return serializeAnimateColorBehavior(node);
    case "animateScale":
      return serializeAnimateScaleBehavior(node);
    case "animateRotation":
      return serializeAnimateRotationBehavior(node);
    case "audio":
      return createElement("p:audio", {}, [serializeCommonTimeNode(node), serializeTarget(node.target)]);
    case "video":
      return createElement("p:video", { fullScrn: node.fullscreen ? "1" : "0" }, [
        serializeCommonTimeNode(node),
        serializeTarget(node.target)
      ]);
    case "command":
      return createElement("p:cmd", { type: node.commandType, cmd: node.command }, [
        serializeCommonTimeNode(node),
        serializeTarget(node.target)
      ]);
  }
}
function serializeParallelNode(node) {
  return createElement("p:par", {}, [serializeCommonTimeNode(node)]);
}
function serializeSequenceNode(node) {
  const attrs = {};
  if (node.concurrent !== undefined) {
    attrs.concurrent = boolAttr(node.concurrent);
  }
  if (node.nextAction !== undefined) {
    attrs.nextAc = node.nextAction;
  }
  if (node.prevAction !== undefined) {
    attrs.prevAc = node.prevAction;
  }
  const children = [serializeCommonTimeNode(node)];
  if (node.prevConditions && node.prevConditions.length > 0) {
    children.push(serializeConditionList(node.prevConditions, "p:prevCondLst"));
  }
  if (node.nextConditions && node.nextConditions.length > 0) {
    children.push(serializeConditionList(node.nextConditions, "p:nextCondLst"));
  }
  return createElement("p:seq", attrs, children);
}
function serializeBuildEntry(entry) {
  const attrs = {
    spid: String(entry.shapeId)
  };
  if (entry.groupId !== undefined) {
    attrs.grpId = String(entry.groupId);
  }
  if (entry.buildType !== undefined) {
    attrs.build = entry.buildType;
  }
  if (entry.animateBackground !== undefined) {
    attrs.animBg = boolAttr(entry.animateBackground);
  }
  if (entry.reverse !== undefined) {
    attrs.rev = boolAttr(entry.reverse);
  }
  if (entry.advanceAfter !== undefined) {
    attrs.advAuto = timeValue(entry.advanceAfter);
  }
  if (entry.uiExpand !== undefined) {
    attrs.uiExpand = boolAttr(entry.uiExpand);
  }
  return createElement("p:bldP", attrs);
}
function serializeTiming(timing) {
  if (!timing.rootTimeNode && !timing.buildList) {
    return null;
  }
  const children = [];
  if (timing.rootTimeNode) {
    children.push(createElement("p:tnLst", {}, [serializeTimeNode(timing.rootTimeNode)]));
  }
  if (timing.buildList && timing.buildList.length > 0) {
    children.push(createElement("p:bldLst", {}, timing.buildList.map(serializeBuildEntry)));
  }
  return createElement("p:timing", {}, children);
}

// packages/@oxen-builder/pptx/src/patcher/serializer/comment.ts
var P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main";
function serializeCommentPosition(position) {
  return createElement("p:pos", {
    x: String(Math.round(position.x * 914400)),
    y: String(Math.round(position.y * 914400))
  });
}
function serializeComment(comment) {
  const attrs = {};
  if (comment.authorId !== undefined) {
    attrs.authorId = String(comment.authorId);
  }
  if (comment.dateTime !== undefined) {
    attrs.dt = comment.dateTime;
  }
  if (comment.idx !== undefined) {
    attrs.idx = String(comment.idx);
  }
  const children = [];
  if (comment.position) {
    children.push(serializeCommentPosition(comment.position));
  }
  if (comment.text) {
    children.push(createElement("p:text", {}, [{ type: "text", value: comment.text }]));
  }
  return createElement("p:cm", attrs, children);
}
function serializeCommentList(commentList) {
  return createElement("p:cmLst", { "xmlns:p": P_NS }, commentList.comments.map(serializeComment));
}
function createCommentListDocument(comments) {
  return {
    children: [serializeCommentList({ comments })]
  };
}
function serializeCommentAuthor(author) {
  const attrs = {
    id: String(author.id)
  };
  if (author.name !== undefined) {
    attrs.name = author.name;
  }
  if (author.initials !== undefined) {
    attrs.initials = author.initials;
  }
  if (author.lastIdx !== undefined) {
    attrs.lastIdx = String(author.lastIdx);
  }
  if (author.colorIndex !== undefined) {
    attrs.clrIdx = String(author.colorIndex);
  }
  return createElement("p:cmAuthor", attrs);
}
function serializeCommentAuthorList(authorList) {
  return createElement("p:cmAuthorLst", { "xmlns:p": P_NS }, authorList.authors.map(serializeCommentAuthor));
}
function createCommentAuthorListDocument(authors) {
  return {
    children: [serializeCommentAuthorList({ authors })]
  };
}

// packages/@oxen-builder/pptx/src/patcher/slide/shape-tree-patcher.ts
function addShapeToTree(spTree, shapeXml, afterId) {
  const shapeStartIndex = getShapesStartIndex(spTree);
  const insertIndex = (() => {
    if (!afterId) {
      return spTree.children.length;
    }
    const index = findDirectChildShapeIndexById(spTree, afterId);
    if (index === -1) {
      return spTree.children.length;
    }
    return index + 1;
  })();
  return insertChildAt(spTree, shapeXml, Math.max(shapeStartIndex, insertIndex));
}
function getShapesStartIndex(container) {
  const first = container.children[0];
  const second = container.children[1];
  if (first && second && isXmlElement(first) && isXmlElement(second) && first.name === "p:nvGrpSpPr" && second.name === "p:grpSpPr") {
    return 2;
  }
  return 0;
}
function findDirectChildShapeIndexById(container, shapeId) {
  for (let i2 = 0;i2 < container.children.length; i2++) {
    const child = container.children[i2];
    if (!isXmlElement(child)) {
      continue;
    }
    if (!isDirectShapeElement(child)) {
      continue;
    }
    if (getNonVisualId(child) === shapeId) {
      return i2;
    }
  }
  return -1;
}
function isDirectShapeElement(el) {
  return ["p:sp", "p:pic", "p:grpSp", "p:cxnSp", "p:graphicFrame"].includes(el.name);
}
function getNonVisualId(shapeEl) {
  const nvPrNames = [
    "p:nvSpPr",
    "p:nvPicPr",
    "p:nvGrpSpPr",
    "p:nvCxnSpPr",
    "p:nvGraphicFramePr"
  ];
  for (const nvPrName of nvPrNames) {
    const nvPr = shapeEl.children.find((c) => isXmlElement(c) && c.name === nvPrName);
    if (!nvPr) {
      continue;
    }
    const cNvPr = nvPr.children.find((c) => isXmlElement(c) && c.name === "p:cNvPr");
    if (cNvPr?.attrs.id) {
      return cNvPr.attrs.id;
    }
    break;
  }
  return;
}

// packages/@oxen-builder/pptx/src/patcher/shape/shape-serializer.ts
function serializeShape2(shape) {
  switch (shape.type) {
    case "sp":
      return serializeSpShape(shape);
    case "grpSp":
      return serializeGroupShape(shape);
    case "pic":
      return serializePicture(shape);
    case "cxnSp":
      return serializeConnectionShape(shape);
    case "graphicFrame":
      return serializeGraphicFrame(shape);
    case "contentPart":
      throw new Error("serializeShape: contentPart is not supported");
  }
}
function serializeGroupShape(group) {
  const nvGrpSpPr = createElement("p:nvGrpSpPr", {}, [
    serializeCNvPr(group.nonVisual),
    serializeCNvGrpSpPr(group.nonVisual.groupLocks),
    createElement("p:nvPr")
  ]);
  const grpSpPrChildren = [serializeGroupTransformOrDefault(group.properties.transform)];
  if (group.properties.fill) {
    grpSpPrChildren.push(serializeFill2(group.properties.fill));
  }
  const effects = group.properties.effects ? serializeEffects2(group.properties.effects) : null;
  if (effects) {
    grpSpPrChildren.push(effects);
  }
  const grpSpPr = createElement("p:grpSpPr", {}, grpSpPrChildren);
  const children = group.children.map(serializeShape2);
  return createElement("p:grpSp", {}, [nvGrpSpPr, grpSpPr, ...children]);
}
function serializePicture(picture) {
  const nvPicPr = createElement("p:nvPicPr", {}, [
    serializeCNvPr(picture.nonVisual),
    serializeCNvPicPr(picture.nonVisual.preferRelativeResize, picture.nonVisual.pictureLocks),
    serializePictureNvPr(picture)
  ]);
  const blipFill = serializePictureBlipFill(picture.blipFill);
  const spPr = createElement("p:spPr", {}, [
    serializeTransformOrDefault(picture.properties.transform),
    createElement("a:prstGeom", { prst: "rect" }, [createElement("a:avLst")]),
    ...serializeShapeStyleElements(picture.properties)
  ]);
  const children = [nvPicPr, blipFill, spPr];
  const style = picture.style ? serializeShapeStyle(picture.style) : null;
  if (style) {
    children.push(style);
  }
  return createElement("p:pic", {}, children);
}
function serializePictureNvPr(picture) {
  const children = [];
  if (picture.mediaType === "video") {
    const video = picture.media?.videoFile;
    if (video?.link) {
      const attrs = { "r:link": video.link };
      if (video.contentType) {
        attrs.contentType = video.contentType;
      }
      children.push(createElement("a:videoFile", attrs));
    }
    const qt = picture.media?.quickTimeFile;
    if (qt?.link) {
      children.push(createElement("a:quickTimeFile", { "r:link": qt.link }));
    }
  }
  if (picture.mediaType === "audio") {
    const audio = picture.media?.audioFile;
    if (audio?.link) {
      const attrs = { "r:link": audio.link };
      if (audio.contentType) {
        attrs.contentType = audio.contentType;
      }
      children.push(createElement("a:audioFile", attrs));
    }
    const wav = picture.media?.wavAudioFile;
    if (wav?.embed) {
      const attrs = { "r:embed": wav.embed };
      if (wav.name) {
        attrs.name = wav.name;
      }
      children.push(createElement("a:wavAudioFile", attrs));
    }
  }
  return createElement("p:nvPr", {}, children);
}
function serializeConnectionShape(conn) {
  const cNvCxnSpPrChildren = [];
  if (conn.nonVisual.startConnection) {
    cNvCxnSpPrChildren.push(serializeConnectionTarget("a:stCxn", conn.nonVisual.startConnection));
  }
  if (conn.nonVisual.endConnection) {
    cNvCxnSpPrChildren.push(serializeConnectionTarget("a:endCxn", conn.nonVisual.endConnection));
  }
  const nvCxnSpPr = createElement("p:nvCxnSpPr", {}, [
    serializeCNvPr(conn.nonVisual),
    createElement("p:cNvCxnSpPr", {}, cNvCxnSpPrChildren),
    createElement("p:nvPr")
  ]);
  const geometryElement = serializeConnectionGeometryOrDefault(conn.properties.geometry);
  const spPr = createElement("p:spPr", {}, [
    serializeTransformOrDefault(conn.properties.transform),
    geometryElement,
    ...serializeShapeStyleElements(conn.properties)
  ]);
  const children = [nvCxnSpPr, spPr];
  const style = conn.style ? serializeShapeStyle(conn.style) : null;
  if (style) {
    children.push(style);
  }
  return createElement("p:cxnSp", {}, children);
}
function serializeConnectionGeometryOrDefault(geometry) {
  if (geometry) {
    return serializeGeometry2(geometry);
  }
  return createElement("a:prstGeom", { prst: "line" }, [createElement("a:avLst")]);
}
function serializeSpShape(shape) {
  const nvSpPr = createElement("p:nvSpPr", {}, [
    serializeCNvPr(shape.nonVisual),
    serializeCNvSpPr(shape.nonVisual.textBox, shape.nonVisual.shapeLocks),
    serializeNvPr(shape.placeholder)
  ]);
  const spPrChildren = [];
  if (shape.properties.transform) {
    spPrChildren.push(serializeTransform(shape.properties.transform));
  }
  if (shape.properties.geometry) {
    spPrChildren.push(serializeGeometry2(shape.properties.geometry));
  } else {
    spPrChildren.push(createElement("a:prstGeom", { prst: "rect" }, [createElement("a:avLst")]));
  }
  spPrChildren.push(...serializeShapeStyleElements(shape.properties));
  const spPr = createElement("p:spPr", {}, spPrChildren);
  const children = [nvSpPr, spPr];
  const style = shape.style ? serializeShapeStyle(shape.style) : null;
  if (style) {
    children.push(style);
  }
  if (shape.textBody) {
    children.push(serializeTextBody(shape.textBody));
  }
  return createElement("p:sp", {}, children);
}
function serializeCNvPr(nonVisual) {
  const attrs = {
    id: nonVisual.id,
    name: nonVisual.name
  };
  if (nonVisual.description) {
    attrs.descr = nonVisual.description;
  }
  if (nonVisual.title) {
    attrs.title = nonVisual.title;
  }
  if (nonVisual.hidden !== undefined) {
    attrs.hidden = nonVisual.hidden ? "1" : "0";
  }
  const children = [];
  const hlinkClick = serializeNonVisualHyperlink("a:hlinkClick", nonVisual.hyperlink);
  if (hlinkClick) {
    children.push(hlinkClick);
  }
  const hlinkHover = serializeNonVisualHyperlink("a:hlinkHover", nonVisual.hyperlinkHover);
  if (hlinkHover) {
    children.push(hlinkHover);
  }
  return createElement("p:cNvPr", attrs, children);
}
function serializeNonVisualHyperlink(name, hyperlink) {
  if (!hyperlink) {
    return null;
  }
  const attrs = { "r:id": hyperlink.id };
  if (hyperlink.tooltip !== undefined) {
    attrs.tooltip = hyperlink.tooltip;
  }
  if (hyperlink.action !== undefined) {
    attrs.action = hyperlink.action;
  }
  const children = [];
  if (hyperlink.sound) {
    const soundAttrs = { "r:embed": hyperlink.sound.embed };
    if (hyperlink.sound.name) {
      soundAttrs.name = hyperlink.sound.name;
    }
    children.push(createElement("a:snd", soundAttrs));
  }
  return createElement(name, attrs, children);
}
function serializeCNvSpPr(textBox, shapeLocks) {
  const attrs = {};
  if (textBox !== undefined) {
    attrs.txBox = ooxmlBool(textBox);
  }
  const children = [];
  const locks = serializeLocksElement("a:spLocks", shapeLocks);
  if (locks) {
    children.push(locks);
  }
  return createElement("p:cNvSpPr", attrs, children);
}
function serializeCNvGrpSpPr(groupLocks) {
  const children = [];
  const locks = serializeLocksElement("a:grpSpLocks", groupLocks);
  if (locks) {
    children.push(locks);
  }
  return createElement("p:cNvGrpSpPr", {}, children);
}
function serializeCNvPicPr(preferRelativeResize, pictureLocks) {
  const attrs = {};
  if (preferRelativeResize !== undefined) {
    attrs.preferRelativeResize = ooxmlBool(preferRelativeResize);
  }
  const children = [];
  const locks = serializeLocksElement("a:picLocks", pictureLocks);
  if (locks) {
    children.push(locks);
  }
  return createElement("p:cNvPicPr", attrs, children);
}
function serializeLocksElement(name, locks) {
  if (!locks) {
    return null;
  }
  const attrs = {};
  for (const [key, value] of Object.entries(locks)) {
    if (value === undefined) {
      continue;
    }
    attrs[key] = ooxmlBool(value);
  }
  if (Object.keys(attrs).length === 0) {
    return null;
  }
  return createElement(name, attrs);
}
function serializePictureBlipFill(blipFill) {
  if (!blipFill.resourceId) {
    throw new Error("serializePictureBlipFill: blipFill.resourceId is required");
  }
  if (blipFill.resourceId.startsWith("data:")) {
    throw new Error("serializePictureBlipFill: data: resourceId requires Phase 7 media embedding");
  }
  const attrs = {};
  if (blipFill.rotateWithShape !== undefined) {
    attrs.rotWithShape = ooxmlBool(blipFill.rotateWithShape);
  }
  if (blipFill.dpi !== undefined) {
    attrs.dpi = String(blipFill.dpi);
  }
  const blipAttrs = { "r:embed": blipFill.resourceId };
  if (blipFill.compressionState) {
    blipAttrs.cstate = blipFill.compressionState;
  }
  const blipChildren = blipFill.blipEffects ? serializeBlipEffects2(blipFill.blipEffects) : [];
  const children = [createElement("a:blip", blipAttrs, blipChildren)];
  if (blipFill.sourceRect) {
    children.push(createElement("a:srcRect", {
      l: ooxmlPercent100k(blipFill.sourceRect.left),
      t: ooxmlPercent100k(blipFill.sourceRect.top),
      r: ooxmlPercent100k(blipFill.sourceRect.right),
      b: ooxmlPercent100k(blipFill.sourceRect.bottom)
    }));
  }
  if (blipFill.tile) {
    children.push(createElement("a:tile", {
      tx: ooxmlEmu(blipFill.tile.tx),
      ty: ooxmlEmu(blipFill.tile.ty),
      sx: ooxmlPercent100k(blipFill.tile.sx),
      sy: ooxmlPercent100k(blipFill.tile.sy),
      flip: blipFill.tile.flip,
      algn: blipFill.tile.alignment
    }));
  } else if (blipFill.stretch) {
    children.push(createElement("a:stretch", {}, [createElement("a:fillRect")]));
  } else {
    throw new Error("serializePictureBlipFill: blipFill requires tile or stretch");
  }
  return createElement("p:blipFill", attrs, children);
}
function serializeShapeStyleElements(properties) {
  const children = [];
  if (properties.fill) {
    children.push(serializeFill2(properties.fill));
  }
  if (properties.line) {
    children.push(serializeLine2(properties.line));
  }
  const effects = properties.effects ? serializeEffects2(properties.effects) : null;
  if (effects) {
    children.push(effects);
  }
  const sp3d = properties.shape3d ? serializeShape3d2(properties.shape3d) : null;
  if (sp3d) {
    children.push(sp3d);
  }
  return children;
}
function serializeShapeStyle(style) {
  const children = [];
  const lnRef = style.lineReference ? serializeStyleReference("a:lnRef", style.lineReference) : null;
  if (lnRef) {
    children.push(lnRef);
  }
  const fillRef = style.fillReference ? serializeStyleReference("a:fillRef", style.fillReference) : null;
  if (fillRef) {
    children.push(fillRef);
  }
  const effectRef = style.effectReference ? serializeStyleReference("a:effectRef", style.effectReference) : null;
  if (effectRef) {
    children.push(effectRef);
  }
  const fontRef = style.fontReference ? serializeFontReference(style.fontReference) : null;
  if (fontRef) {
    children.push(fontRef);
  }
  if (children.length === 0) {
    return null;
  }
  return createElement("p:style", {}, children);
}
function serializeStyleReference(name, ref) {
  const attrs = { idx: String(ref.index) };
  const children = [];
  if (ref.color) {
    if (ref.color.type !== "solidFill") {
      throw new Error(`serializeShapeStyle: only solidFill is supported for ${name} color`);
    }
    children.push(serializeColor(ref.color.color));
  }
  return createElement(name, attrs, children);
}
function serializeFontReference(ref) {
  const attrs = { idx: String(ref.index) };
  const children = [];
  if (ref.color) {
    if (ref.color.type !== "solidFill") {
      throw new Error("serializeShapeStyle: only solidFill is supported for a:fontRef color");
    }
    children.push(serializeColor(ref.color.color));
  }
  return createElement("a:fontRef", attrs, children);
}
function serializeNvPr(placeholder) {
  const children = [];
  if (placeholder) {
    const attrs = {};
    if (placeholder.type) {
      attrs.type = placeholder.type;
    }
    if (placeholder.idx !== undefined) {
      attrs.idx = String(placeholder.idx);
    }
    if (placeholder.size) {
      attrs.sz = placeholder.size;
    }
    if (placeholder.hasCustomPrompt !== undefined) {
      attrs.hasCustomPrompt = placeholder.hasCustomPrompt ? "1" : "0";
    }
    children.push(createElement("p:ph", attrs));
  }
  return createElement("p:nvPr", {}, children);
}
function serializeGroupTransform(transform) {
  const attrs = {};
  if (Number(transform.rotation) !== 0) {
    attrs.rot = ooxmlAngleUnits(transform.rotation);
  }
  if (transform.flipH) {
    attrs.flipH = "1";
  }
  if (transform.flipV) {
    attrs.flipV = "1";
  }
  return createElement("a:xfrm", attrs, [
    createElement("a:off", { x: ooxmlEmu(transform.x), y: ooxmlEmu(transform.y) }),
    createElement("a:ext", { cx: ooxmlEmu(transform.width), cy: ooxmlEmu(transform.height) }),
    createElement("a:chOff", { x: ooxmlEmu(transform.childOffsetX), y: ooxmlEmu(transform.childOffsetY) }),
    createElement("a:chExt", { cx: ooxmlEmu(transform.childExtentWidth), cy: ooxmlEmu(transform.childExtentHeight) })
  ]);
}
function serializeGeometry2(geometry) {
  switch (geometry.type) {
    case "preset":
      return serializePresetGeometry(geometry);
    case "custom":
      return serializeCustomGeometry(geometry);
  }
}
function serializePresetGeometry(geometry) {
  const avLstChildren = geometry.adjustValues.map((v) => createElement("a:gd", { name: v.name, fmla: `val ${v.value}` }));
  return createElement("a:prstGeom", { prst: geometry.preset }, [
    createElement("a:avLst", {}, avLstChildren)
  ]);
}
function serializeCustomGeometry(geometry) {
  const avLst = createElement("a:avLst", {}, (geometry.adjustValues ?? []).map((v) => createElement("a:gd", { name: v.name, fmla: `val ${v.value}` })));
  const gdLst = createElement("a:gdLst", {}, (geometry.guides ?? []).map((g) => createElement("a:gd", { name: g.name, fmla: g.formula })));
  const ahLst = createElement("a:ahLst", {}, []);
  const cxnLst = createElement("a:cxnLst", {}, (geometry.connectionSites ?? []).map((site) => createElement("a:cxn", { ang: ooxmlAngleUnits(site.angle) }, [
    createElement("a:pos", {
      x: ooxmlEmu(site.position.x),
      y: ooxmlEmu(site.position.y)
    })
  ])));
  let rect;
  if (geometry.textRect) {
    rect = createElement("a:rect", {
      l: geometry.textRect.left,
      t: geometry.textRect.top,
      r: geometry.textRect.right,
      b: geometry.textRect.bottom
    });
  }
  const pathLst = createElement("a:pathLst", {}, geometry.paths.map(serializeGeometryPath));
  const children = [avLst, gdLst, ahLst, cxnLst];
  if (rect) {
    children.push(rect);
  }
  children.push(pathLst);
  return createElement("a:custGeom", {}, children);
}
function serializeTransformOrDefault(transform) {
  if (transform) {
    return serializeTransform(transform);
  }
  return createElement("a:xfrm", {}, [
    createElement("a:off", { x: "0", y: "0" }),
    createElement("a:ext", { cx: "0", cy: "0" })
  ]);
}
function serializeGroupTransformOrDefault(transform) {
  if (transform) {
    return serializeGroupTransform(transform);
  }
  return createElement("a:xfrm", {}, [
    createElement("a:off", { x: "0", y: "0" }),
    createElement("a:ext", { cx: "0", cy: "0" }),
    createElement("a:chOff", { x: "0", y: "0" }),
    createElement("a:chExt", { cx: "0", cy: "0" })
  ]);
}
function serializeGeometryPath(path3) {
  const attrs = {
    w: ooxmlEmu(path3.width),
    h: ooxmlEmu(path3.height),
    fill: path3.fill,
    stroke: path3.stroke ? "1" : "0",
    extrusionOk: path3.extrusionOk ? "1" : "0"
  };
  return createElement("a:path", attrs, path3.commands.map(serializePathCommand));
}
function serializePathCommand(command) {
  switch (command.type) {
    case "moveTo":
      return createElement("a:moveTo", {}, [
        createElement("a:pt", { x: ooxmlEmu(command.point.x), y: ooxmlEmu(command.point.y) })
      ]);
    case "lineTo":
      return createElement("a:lnTo", {}, [
        createElement("a:pt", { x: ooxmlEmu(command.point.x), y: ooxmlEmu(command.point.y) })
      ]);
    case "arcTo":
      return createElement("a:arcTo", {
        wR: ooxmlEmu(command.widthRadius),
        hR: ooxmlEmu(command.heightRadius),
        stAng: ooxmlAngleUnits(command.startAngle),
        swAng: ooxmlAngleUnits(command.swingAngle)
      });
    case "quadBezierTo":
      return createElement("a:quadBezTo", {}, [
        createElement("a:pt", { x: ooxmlEmu(command.control.x), y: ooxmlEmu(command.control.y) }),
        createElement("a:pt", { x: ooxmlEmu(command.end.x), y: ooxmlEmu(command.end.y) })
      ]);
    case "cubicBezierTo":
      return createElement("a:cubicBezTo", {}, [
        createElement("a:pt", { x: ooxmlEmu(command.control1.x), y: ooxmlEmu(command.control1.y) }),
        createElement("a:pt", { x: ooxmlEmu(command.control2.x), y: ooxmlEmu(command.control2.y) }),
        createElement("a:pt", { x: ooxmlEmu(command.end.x), y: ooxmlEmu(command.end.y) })
      ]);
    case "close":
      return createElement("a:close");
  }
}
function serializeConnectionTarget(name, target) {
  return createElement(name, { id: target.shapeId, idx: String(target.siteIndex) });
}
function serializeGraphicFrame(frame) {
  const nvGraphicFramePr = createElement("p:nvGraphicFramePr", {}, [
    serializeGraphicFrameCNvPr(frame.nonVisual),
    createElement("p:cNvGraphicFramePr", {}, frame.nonVisual.graphicFrameLocks ? [serializeGraphicFrameLocks(frame.nonVisual.graphicFrameLocks)] : []),
    createElement("p:nvPr")
  ]);
  const xfrm = serializeGraphicFrameTransform(frame.transform);
  const graphic = createElement("a:graphic", {
    xmlns: "http://schemas.openxmlformats.org/drawingml/2006/main"
  }, [
    (() => {
      switch (frame.content.type) {
        case "oleObject":
          return serializeOleObjectGraphicData(frame.content.data);
        case "table":
          return serializeTableGraphicData(frame.content.data.table);
        default:
          throw new Error(`serializeGraphicFrame: content type '${frame.content.type}' is not supported for serialization.`);
      }
    })()
  ]);
  return createElement("p:graphicFrame", {}, [nvGraphicFramePr, xfrm, graphic]);
}
function serializeGraphicFrameCNvPr(nonVisual) {
  const attrs = {
    id: nonVisual.id,
    name: nonVisual.name
  };
  if (nonVisual.description) {
    attrs.descr = nonVisual.description;
  }
  if (nonVisual.title) {
    attrs.title = nonVisual.title;
  }
  if (nonVisual.hidden !== undefined) {
    attrs.hidden = nonVisual.hidden ? "1" : "0";
  }
  return createElement("p:cNvPr", attrs);
}
function serializeGraphicFrameLocks(locks) {
  const attrs = {};
  if (locks.noGrp !== undefined) {
    attrs.noGrp = ooxmlBool(locks.noGrp);
  }
  if (locks.noDrilldown !== undefined) {
    attrs.noDrilldown = ooxmlBool(locks.noDrilldown);
  }
  if (locks.noSelect !== undefined) {
    attrs.noSelect = ooxmlBool(locks.noSelect);
  }
  if (locks.noChangeAspect !== undefined) {
    attrs.noChangeAspect = ooxmlBool(locks.noChangeAspect);
  }
  if (locks.noMove !== undefined) {
    attrs.noMove = ooxmlBool(locks.noMove);
  }
  if (locks.noResize !== undefined) {
    attrs.noResize = ooxmlBool(locks.noResize);
  }
  return createElement("a:graphicFrameLocks", attrs);
}
function serializeGraphicFrameTransform(transform) {
  const attrs = {};
  if (transform.rotation && Number(transform.rotation) !== 0) {
    attrs.rot = ooxmlAngleUnits(transform.rotation);
  }
  if (transform.flipH) {
    attrs.flipH = "1";
  }
  if (transform.flipV) {
    attrs.flipV = "1";
  }
  return createElement("p:xfrm", attrs, [
    createElement("a:off", { x: ooxmlEmu(transform.x), y: ooxmlEmu(transform.y) }),
    createElement("a:ext", { cx: ooxmlEmu(transform.width), cy: ooxmlEmu(transform.height) })
  ]);
}
function serializeOleObjectGraphicData(oleRef) {
  if (!oleRef.resourceId) {
    throw new Error("serializeOleObjectGraphicData: resourceId is required");
  }
  if (!oleRef.progId) {
    throw new Error("serializeOleObjectGraphicData: progId is required");
  }
  const oleObjAttrs = {
    "r:id": oleRef.resourceId,
    progId: oleRef.progId
  };
  if (oleRef.name) {
    oleObjAttrs.name = oleRef.name;
  }
  if (oleRef.showAsIcon !== undefined) {
    oleObjAttrs.showAsIcon = ooxmlBool(oleRef.showAsIcon);
  }
  if (oleRef.imgW !== undefined) {
    oleObjAttrs.imgW = String(oleRef.imgW);
  }
  if (oleRef.imgH !== undefined) {
    oleObjAttrs.imgH = String(oleRef.imgH);
  }
  const oleObjChildren = [createElement("p:embed")];
  const oleObj = createElement("p:oleObj", oleObjAttrs, oleObjChildren);
  return createElement("a:graphicData", {
    uri: "http://schemas.openxmlformats.org/presentationml/2006/ole"
  }, [oleObj]);
}
function serializeTableGraphicData(table) {
  return createElement("a:graphicData", {
    uri: "http://schemas.openxmlformats.org/drawingml/2006/table"
  }, [
    serializeDrawingTable(table)
  ]);
}
// packages/@oxen-builder/pptx/src/patcher/theme/color-scheme-patcher.ts
function schemeChildName(name) {
  return `a:${name}`;
}
function upsertChildBeforeExtLst(parent, childName, newChild) {
  const existingIndex = parent.children.findIndex((c) => isXmlElement(c) && c.name === childName);
  if (existingIndex !== -1) {
    return {
      ...parent,
      children: parent.children.map((c, i2) => i2 === existingIndex ? newChild : c)
    };
  }
  const extLstIndex = parent.children.findIndex((c) => isXmlElement(c) && c.name === "a:extLst");
  const insertIndex = extLstIndex === -1 ? parent.children.length : extLstIndex;
  const nextChildren = [...parent.children];
  nextChildren.splice(insertIndex, 0, newChild);
  return { ...parent, children: nextChildren };
}
function patchSchemeColor(colorScheme, name, color) {
  if (!colorScheme) {
    throw new Error("patchSchemeColor requires colorScheme.");
  }
  if (!name) {
    throw new Error("patchSchemeColor requires name.");
  }
  if (!color) {
    throw new Error("patchSchemeColor requires color.");
  }
  if (color.spec.type !== "srgb" && color.spec.type !== "system") {
    throw new Error(`patchSchemeColor only supports srgb/system, got: ${color.spec.type}`);
  }
  const entryName = schemeChildName(name);
  const existingEntry = colorScheme.children.find((c) => isXmlElement(c) && c.name === entryName);
  const updatedEntry = (() => {
    if (!existingEntry) {
      return createElement(entryName, {}, [serializeColor(color)]);
    }
    const preserved = existingEntry.children.filter((c) => {
      if (!isXmlElement(c)) {
        return true;
      }
      return c.name === "a:extLst";
    });
    return createElement(existingEntry.name, { ...existingEntry.attrs }, [
      serializeColor(color),
      ...preserved
    ]);
  })();
  return upsertChildBeforeExtLst(colorScheme, entryName, updatedEntry);
}

// packages/@oxen-builder/pptx/src/patcher/theme/font-scheme-patcher.ts
function upsertTypeface(fontElement, childName, typeface) {
  if (typeface === undefined) {
    return fontElement;
  }
  const existingIndex = fontElement.children.findIndex((c) => isXmlElement(c) && c.name === childName);
  const updatedChild = (() => {
    if (existingIndex === -1) {
      return createElement(childName, { typeface }, []);
    }
    const existingChild = fontElement.children[existingIndex];
    return {
      ...existingChild,
      attrs: {
        ...existingChild.attrs,
        typeface
      }
    };
  })();
  if (existingIndex !== -1) {
    return {
      ...fontElement,
      children: fontElement.children.map((c, i2) => i2 === existingIndex ? updatedChild : c)
    };
  }
  const extLstIndex = fontElement.children.findIndex((c) => isXmlElement(c) && c.name === "a:extLst");
  const insertIndex = extLstIndex === -1 ? fontElement.children.length : extLstIndex;
  const nextChildren = [...fontElement.children];
  nextChildren.splice(insertIndex, 0, updatedChild);
  return { ...fontElement, children: nextChildren };
}
function patchFont(fontScheme, fontName, fontFamily) {
  const existing = getChild(fontScheme, fontName) ?? createElement(fontName, {}, []);
  const withLatin = upsertTypeface(existing, "a:latin", fontFamily.latin);
  const withEa = upsertTypeface(withLatin, "a:ea", fontFamily.eastAsian);
  const withCs = upsertTypeface(withEa, "a:cs", fontFamily.complexScript);
  const existingIndex = fontScheme.children.findIndex((c) => isXmlElement(c) && c.name === fontName);
  if (existingIndex !== -1) {
    return {
      ...fontScheme,
      children: fontScheme.children.map((c, i2) => i2 === existingIndex ? withCs : c)
    };
  }
  const extLstIndex = fontScheme.children.findIndex((c) => isXmlElement(c) && c.name === "a:extLst");
  const insertIndex = extLstIndex === -1 ? fontScheme.children.length : extLstIndex;
  const nextChildren = [...fontScheme.children];
  nextChildren.splice(insertIndex, 0, withCs);
  return { ...fontScheme, children: nextChildren };
}
function patchMajorFont(fontScheme, fontFamily) {
  if (!fontScheme) {
    throw new Error("patchMajorFont requires fontScheme.");
  }
  if (!fontFamily) {
    throw new Error("patchMajorFont requires fontFamily.");
  }
  return patchFont(fontScheme, "a:majorFont", fontFamily);
}
function patchMinorFont(fontScheme, fontFamily) {
  if (!fontScheme) {
    throw new Error("patchMinorFont requires fontScheme.");
  }
  if (!fontFamily) {
    throw new Error("patchMinorFont requires fontFamily.");
  }
  return patchFont(fontScheme, "a:minorFont", fontFamily);
}

// packages/@oxen-builder/pptx/src/patcher/theme/theme-patcher.ts
function requireThemeElements(root) {
  const themeElements = getChild(root, "a:themeElements");
  if (!themeElements) {
    throw new Error("patchTheme: missing a:themeElements element.");
  }
  return themeElements;
}
function upsertChildBeforeExtLst2(parent, childName, newChild) {
  const existingIndex = parent.children.findIndex((c) => isXmlElement(c) && c.name === childName);
  if (existingIndex !== -1) {
    return {
      ...parent,
      children: parent.children.map((c, i2) => i2 === existingIndex ? newChild : c)
    };
  }
  const extLstIndex = parent.children.findIndex((c) => isXmlElement(c) && c.name === "a:extLst");
  const insertIndex = extLstIndex === -1 ? parent.children.length : extLstIndex;
  const nextChildren = [...parent.children];
  nextChildren.splice(insertIndex, 0, newChild);
  return { ...parent, children: nextChildren };
}
function patchFormatSchemeElement(fmtScheme, scheme) {
  const buildStyleList = (name, entries) => {
    const existing = getChild(fmtScheme, name);
    if (!existing) {
      return createElement(name, {}, entries);
    }
    const preserved = existing.children.filter((c) => !isXmlElement(c) || c.name === "a:extLst");
    return {
      ...existing,
      children: [...entries, ...preserved]
    };
  };
  const withFill = upsertChildBeforeExtLst2(fmtScheme, "a:fillStyleLst", buildStyleList("a:fillStyleLst", scheme.fillStyles));
  const withLine = upsertChildBeforeExtLst2(withFill, "a:lnStyleLst", buildStyleList("a:lnStyleLst", scheme.lineStyles));
  const withEffect = upsertChildBeforeExtLst2(withLine, "a:effectStyleLst", buildStyleList("a:effectStyleLst", scheme.effectStyles));
  return upsertChildBeforeExtLst2(withEffect, "a:bgFillStyleLst", buildStyleList("a:bgFillStyleLst", scheme.bgFillStyles));
}
function applyColorScheme(themeElements, scheme) {
  const clrScheme = getChild(themeElements, "a:clrScheme");
  if (!clrScheme) {
    throw new Error("patchTheme: missing a:clrScheme.");
  }
  const entries = Object.entries(scheme);
  const updatedClrScheme = entries.reduce((current, [name, color]) => {
    if (!color) {
      return current;
    }
    return patchSchemeColor(current, name, color);
  }, clrScheme);
  return replaceChildByName(themeElements, "a:clrScheme", updatedClrScheme);
}
function applyFontScheme(themeElements, scheme) {
  const fontScheme = getChild(themeElements, "a:fontScheme");
  if (!fontScheme) {
    throw new Error("patchTheme: missing a:fontScheme.");
  }
  const withMajor = patchMajorFont(fontScheme, scheme.majorFont);
  const updated = patchMinorFont(withMajor, scheme.minorFont);
  return replaceChildByName(themeElements, "a:fontScheme", updated);
}
function applyFormatScheme(themeElements, scheme) {
  const fmtScheme = getChild(themeElements, "a:fmtScheme");
  if (!fmtScheme) {
    throw new Error("patchTheme: missing a:fmtScheme.");
  }
  const updated = patchFormatSchemeElement(fmtScheme, scheme);
  return replaceChildByName(themeElements, "a:fmtScheme", updated);
}
function patchTheme(themeXml, changes) {
  if (!themeXml) {
    throw new Error("patchTheme requires themeXml.");
  }
  if (!changes) {
    throw new Error("patchTheme requires changes.");
  }
  return changes.reduce((current, change) => {
    return updateDocumentRoot(current, (root) => {
      if (root.name !== "a:theme") {
        throw new Error(`patchTheme: unexpected root element: ${root.name}`);
      }
      const themeElements = requireThemeElements(root);
      const updatedThemeElements = (() => {
        switch (change.type) {
          case "colorScheme":
            return applyColorScheme(themeElements, change.scheme);
          case "fontScheme":
            return applyFontScheme(themeElements, change.scheme);
          case "formatScheme":
            return applyFormatScheme(themeElements, change.scheme);
        }
      })();
      return replaceChildByName(root, "a:themeElements", updatedThemeElements);
    });
  }, themeXml);
}
// packages/@oxen-builder/pptx/src/patcher/table/table-patcher.ts
function requireChild(parent, name, context) {
  const child = getChild(parent, name);
  if (!child) {
    throw new Error(`${context}: missing required child: ${name}`);
  }
  return child;
}
function requireTable(tableElement) {
  if (tableElement.name !== "a:tbl") {
    throw new Error(`patchTable: expected a:tbl, got ${tableElement.name}`);
  }
}
function createEmptyTxBody2() {
  return createElement("a:txBody", {}, [
    createElement("a:bodyPr"),
    createElement("a:lstStyle"),
    createElement("a:p")
  ]);
}
function serializeCellProperties(props) {
  const attrs = {};
  if (props.rowSpan !== undefined) {
    attrs.rowSpan = String(props.rowSpan);
  }
  if (props.colSpan !== undefined) {
    attrs.gridSpan = String(props.colSpan);
  }
  if (props.horizontalMerge) {
    attrs.hMerge = "1";
  }
  if (props.verticalMerge) {
    attrs.vMerge = "1";
  }
  return createElement("a:tcPr", attrs);
}
function serializeTableCell3(cell) {
  const attrs = {};
  if (cell.id) {
    attrs.id = cell.id;
  }
  const txBody = cell.textBody ? serializeDrawingTextBody(cell.textBody) : createEmptyTxBody2();
  const tcPr = serializeCellProperties(cell.properties);
  return createElement("a:tc", attrs, [txBody, tcPr]);
}
function serializeTableRow2(row) {
  return createElement("a:tr", { h: ooxmlEmu(row.height) }, row.cells.map(serializeTableCell3));
}
function patchTableCell(cell, content) {
  if (cell.name !== "a:tc") {
    throw new Error(`patchTableCell: expected a:tc, got ${cell.name}`);
  }
  const txBody = getChild(cell, "a:txBody");
  if (txBody) {
    return replaceChildByName(cell, "a:txBody", patchTextBodyElement(txBody, content));
  }
  const tcPr = getChild(cell, "a:tcPr");
  const newTxBody = serializeDrawingTextBody(content);
  if (!tcPr) {
    return setChildren2(cell, [newTxBody, ...cell.children]);
  }
  const tcPrIndex = cell.children.findIndex((c) => isXmlElement(c) && c.name === "a:tcPr");
  if (tcPrIndex < 0) {
    return setChildren2(cell, [newTxBody, ...cell.children]);
  }
  const nextChildren = [...cell.children];
  nextChildren.splice(tcPrIndex, 0, newTxBody);
  return setChildren2(cell, nextChildren);
}
function getTableRows(table) {
  return getChildren(table, "a:tr");
}
function getTableGrid(table) {
  return requireChild(table, "a:tblGrid", "patchTable");
}
function getTableGridCols(tblGrid) {
  return getChildren(tblGrid, "a:gridCol");
}
function getRowCells(row) {
  return getChildren(row, "a:tc");
}
function replaceCellAt(row, colIndex, newCell) {
  if (colIndex < 0) {
    throw new Error(`replaceCellAt: colIndex out of range: ${colIndex}`);
  }
  const cells = getChildren(row, "a:tc");
  if (colIndex >= cells.length) {
    throw new Error(`replaceCellAt: colIndex out of range: ${colIndex}`);
  }
  let current = -1;
  const nextChildren = row.children.map((child) => {
    if (!isXmlElement(child) || child.name !== "a:tc") {
      return child;
    }
    current += 1;
    return current === colIndex ? newCell : child;
  });
  return setChildren2(row, nextChildren);
}
function insertCellAt(row, position, newCell) {
  if (position < 0) {
    throw new Error(`insertCellAt: position out of range: ${position}`);
  }
  const nextChildren = [];
  let cellIdx = 0;
  let inserted = false;
  for (const child of row.children) {
    if (isXmlElement(child) && child.name === "a:tc" && cellIdx === position) {
      nextChildren.push(newCell);
      inserted = true;
    }
    nextChildren.push(child);
    if (isXmlElement(child) && child.name === "a:tc") {
      cellIdx += 1;
    }
  }
  if (!inserted) {
    if (position !== cellIdx) {
      throw new Error(`insertCellAt: position out of range: ${position}`);
    }
    nextChildren.push(newCell);
  }
  return setChildren2(row, nextChildren);
}
function removeCellAt(row, colIndex) {
  if (colIndex < 0) {
    throw new Error(`removeCellAt: colIndex out of range: ${colIndex}`);
  }
  const cells = getChildren(row, "a:tc");
  if (colIndex >= cells.length) {
    throw new Error(`removeCellAt: colIndex out of range: ${colIndex}`);
  }
  let current = -1;
  const nextChildren = row.children.filter((child) => {
    if (!isXmlElement(child) || child.name !== "a:tc") {
      return true;
    }
    current += 1;
    return current !== colIndex;
  });
  return setChildren2(row, nextChildren);
}
function replaceRowAt(table, rowIndex, newRow) {
  const rows = getTableRows(table);
  if (rowIndex < 0 || rowIndex >= rows.length) {
    throw new Error(`patchTable: rowIndex out of range: ${rowIndex}`);
  }
  let currentRowIndex = -1;
  const nextChildren = table.children.map((child) => {
    if (!isXmlElement(child) || child.name !== "a:tr") {
      return child;
    }
    currentRowIndex += 1;
    return currentRowIndex === rowIndex ? newRow : child;
  });
  return setChildren2(table, nextChildren);
}
function insertRowAt(table, newRow, position) {
  const rows = getTableRows(table);
  if (position < 0 || position > rows.length) {
    throw new Error(`patchTable: addRow position out of range: ${position}`);
  }
  const children = [...table.children];
  const rawFirstRowIndex = children.findIndex((c) => isXmlElement(c) && c.name === "a:tr");
  const firstRowIndex = rawFirstRowIndex < 0 ? children.length : rawFirstRowIndex;
  children.splice(firstRowIndex + position, 0, newRow);
  return setChildren2(table, children);
}
function addTableRow(table, row, position) {
  requireTable(table);
  const gridCols = getTableGridCols(getTableGrid(table));
  if (row.cells.length !== gridCols.length) {
    throw new Error(`addTableRow: row.cells length (${row.cells.length}) must match column count (${gridCols.length})`);
  }
  const newRow = serializeTableRow2(row);
  const insertAt = position ?? getTableRows(table).length;
  return insertRowAt(table, newRow, insertAt);
}
function addTableColumn(table, column, position) {
  requireTable(table);
  const tblGrid = getTableGrid(table);
  const gridCols = getTableGridCols(tblGrid);
  const insertAt = position ?? gridCols.length;
  if (insertAt < 0 || insertAt > gridCols.length) {
    throw new Error(`addTableColumn: position out of range: ${insertAt}`);
  }
  const newGridCol = createElement("a:gridCol", { w: ooxmlEmu(column.width) });
  const nextGridChildren = [...tblGrid.children];
  nextGridChildren.splice(insertAt, 0, newGridCol);
  const nextTblGrid = setChildren2(tblGrid, nextGridChildren);
  const newCell = createElement("a:tc", {}, [createEmptyTxBody2(), createElement("a:tcPr")]);
  const nextChildren = table.children.map((child) => {
    if (!isXmlElement(child)) {
      return child;
    }
    if (child.name === "a:tblGrid") {
      return nextTblGrid;
    }
    if (child.name === "a:tr") {
      return insertCellAt(child, insertAt, newCell);
    }
    return child;
  });
  return setChildren2(table, nextChildren);
}
function removeRow(table, rowIndex) {
  requireTable(table);
  const rows = getTableRows(table);
  if (rowIndex < 0 || rowIndex >= rows.length) {
    throw new Error(`removeRow: rowIndex out of range: ${rowIndex}`);
  }
  let currentRowIndex = -1;
  const nextChildren = table.children.filter((child) => {
    if (!isXmlElement(child) || child.name !== "a:tr") {
      return true;
    }
    currentRowIndex += 1;
    return currentRowIndex !== rowIndex;
  });
  return setChildren2(table, nextChildren);
}
function removeColumn(table, colIndex) {
  requireTable(table);
  const tblGrid = getTableGrid(table);
  const gridCols = getTableGridCols(tblGrid);
  if (colIndex < 0 || colIndex >= gridCols.length) {
    throw new Error(`removeColumn: colIndex out of range: ${colIndex}`);
  }
  const nextGrid = setChildren2(tblGrid, tblGrid.children.filter((_, idx) => idx !== colIndex));
  const nextChildren = table.children.map((child) => {
    if (!isXmlElement(child)) {
      return child;
    }
    if (child.name === "a:tblGrid") {
      return nextGrid;
    }
    if (child.name === "a:tr") {
      return removeCellAt(child, colIndex);
    }
    return child;
  });
  return setChildren2(table, nextChildren);
}
function ensureTcPr(cell) {
  const tcPr = getChild(cell, "a:tcPr");
  if (tcPr) {
    return cell;
  }
  return setChildren2(cell, [...cell.children, createElement("a:tcPr")]);
}
function patchMergeCell(cell, attrs) {
  const withTcPr = ensureTcPr(cell);
  const tcPr = requireChild(withTcPr, "a:tcPr", "patchMergeCell");
  const updated = Object.entries(attrs).reduce((current, [k, v]) => {
    if (v === undefined) {
      return removeAttribute(current, k);
    }
    return setAttribute(current, k, v);
  }, tcPr);
  return replaceChildByName(withTcPr, "a:tcPr", updated);
}
function applyMergeRange({
  table,
  startRow,
  startCol,
  rowSpan,
  colSpan
}) {
  const rows = getTableRows(table);
  if (rowSpan < 1 || colSpan < 1) {
    throw new Error("merge: rowSpan and colSpan must be >= 1");
  }
  if (startRow < 0 || startCol < 0) {
    throw new Error("merge: startRow/startCol must be >= 0");
  }
  if (startRow + rowSpan > rows.length) {
    throw new Error("merge: row range out of bounds");
  }
  const firstRowCells = getRowCells(rows[startRow]);
  if (startCol + colSpan > firstRowCells.length) {
    throw new Error("merge: column range out of bounds");
  }
  const processRow = (currentTable, r) => {
    const rowIndex = startRow + r;
    const rowEl = rows[rowIndex];
    const rowChildren = [];
    let cellIdx = 0;
    for (const child of rowEl.children) {
      if (isXmlElement(child) && child.name === "a:tc") {
        const rr = rowIndex - startRow;
        const cc = cellIdx - startCol;
        const inRange = rr >= 0 && rr < rowSpan && cc >= 0 && cc < colSpan;
        if (!inRange) {
          rowChildren.push(child);
          cellIdx += 1;
          continue;
        }
        const isTopLeft = rr === 0 && cc === 0;
        const isContinuationCol = cc > 0 && colSpan > 1;
        const isContinuationRow = rr > 0 && rowSpan > 1;
        rowChildren.push(patchMergeCell(child, {
          gridSpan: isTopLeft && colSpan > 1 ? String(colSpan) : undefined,
          rowSpan: isTopLeft && rowSpan > 1 ? String(rowSpan) : undefined,
          hMerge: !isTopLeft && isContinuationCol ? "1" : undefined,
          vMerge: !isTopLeft && isContinuationRow ? "1" : undefined
        }));
        cellIdx += 1;
        continue;
      }
      rowChildren.push(child);
    }
    return replaceRowAt(currentTable, rowIndex, setChildren2(rowEl, rowChildren));
  };
  const rowIndices = Array.from({ length: rowSpan }, (_, i2) => i2);
  return rowIndices.reduce(processRow, table);
}
function applySplitRange({
  table,
  startRow,
  startCol,
  rowSpan,
  colSpan
}) {
  const rows = getTableRows(table);
  if (rowSpan < 1 || colSpan < 1) {
    throw new Error("split: rowSpan and colSpan must be >= 1");
  }
  if (startRow < 0 || startCol < 0) {
    throw new Error("split: startRow/startCol must be >= 0");
  }
  if (startRow + rowSpan > rows.length) {
    throw new Error("split: row range out of bounds");
  }
  const firstRowCells = getRowCells(rows[startRow]);
  if (startCol + colSpan > firstRowCells.length) {
    throw new Error("split: column range out of bounds");
  }
  const processRow = (currentTable, r) => {
    const rowIndex = startRow + r;
    const rowEl = rows[rowIndex];
    const cells = getRowCells(rowEl);
    const rowChildren = [];
    let cellIdx = 0;
    for (const child of rowEl.children) {
      if (isXmlElement(child) && child.name === "a:tc") {
        const originalCell = cells[cellIdx];
        const rr = rowIndex - startRow;
        const cc = cellIdx - startCol;
        const inRange = rr >= 0 && rr < rowSpan && cc >= 0 && cc < colSpan;
        if (inRange) {
          rowChildren.push(patchMergeCell(originalCell, {
            gridSpan: undefined,
            rowSpan: undefined,
            hMerge: undefined,
            vMerge: undefined
          }));
        } else {
          rowChildren.push(originalCell);
        }
        cellIdx += 1;
        continue;
      }
      rowChildren.push(child);
    }
    return replaceRowAt(currentTable, rowIndex, setChildren2(rowEl, rowChildren));
  };
  const rowIndices = Array.from({ length: rowSpan }, (_, i2) => i2);
  return rowIndices.reduce(processRow, table);
}
function patchTable(tableElement, changes) {
  requireTable(tableElement);
  let next = tableElement;
  for (const change of changes) {
    switch (change.type) {
      case "cell": {
        const rows = getTableRows(next);
        const rowEl = rows[change.row];
        if (!rowEl) {
          throw new Error(`patchTable: row out of range: ${change.row}`);
        }
        const cells = getRowCells(rowEl);
        const cellEl = cells[change.col];
        if (!cellEl) {
          throw new Error(`patchTable: col out of range: ${change.col}`);
        }
        const patchedCell = patchTableCell(cellEl, change.content);
        next = replaceRowAt(next, change.row, replaceCellAt(rowEl, change.col, patchedCell));
        break;
      }
      case "addRow":
        next = addTableRow(next, change.row, change.position);
        break;
      case "removeRow":
        next = removeRow(next, change.rowIndex);
        break;
      case "addColumn":
        next = addTableColumn(next, change.column, change.position);
        break;
      case "removeColumn":
        next = removeColumn(next, change.colIndex);
        break;
      case "merge":
        next = applyMergeRange({ table: next, startRow: change.startRow, startCol: change.startCol, rowSpan: change.rowSpan, colSpan: change.colSpan });
        break;
      case "split":
        next = applySplitRange({ table: next, startRow: change.startRow, startCol: change.startCol, rowSpan: change.rowSpan, colSpan: change.colSpan });
        break;
      default:
        ((_) => _)(change);
    }
  }
  return next;
}
// packages/@oxen-builder/pptx/src/patcher/table/table-style-patcher.ts
function requireTable2(tableElement) {
  if (tableElement.name !== "a:tbl") {
    throw new Error(`patchTableStyleId: expected a:tbl, got ${tableElement.name}`);
  }
}
function ensureTblPr(table) {
  const tblPr = getChild(table, "a:tblPr");
  if (tblPr) {
    return table;
  }
  const nextChildren = [createElement("a:tblPr"), ...table.children];
  return setChildren2(table, nextChildren);
}
function patchTableStyleId(tableElement, styleId) {
  requireTable2(tableElement);
  const withTblPr = ensureTblPr(tableElement);
  const tblPr = getChild(withTblPr, "a:tblPr");
  if (!tblPr) {
    throw new Error("patchTableStyleId: missing a:tblPr after ensure");
  }
  if (!styleId) {
    const cleaned = removeChildren(tblPr, (child) => isXmlElement(child) && child.name === "a:tableStyleId");
    return replaceChildByName(withTblPr, "a:tblPr", cleaned);
  }
  const tableStyleId = createElement("a:tableStyleId", {}, [createText(styleId)]);
  if (getChild(tblPr, "a:tableStyleId")) {
    const nextTblPr2 = replaceChildByName(tblPr, "a:tableStyleId", tableStyleId);
    return replaceChildByName(withTblPr, "a:tblPr", nextTblPr2);
  }
  const nextTblPr = setChildren2(tblPr, [...tblPr.children, tableStyleId]);
  return replaceChildByName(withTblPr, "a:tblPr", nextTblPr);
}
// packages/@oxen-builder/pptx/src/patcher/diagram/diagram-patcher.ts
function requireDataModelRoot(dataXml) {
  const root = getByPath(dataXml, ["dgm:dataModel"]);
  if (!root) {
    throw new Error("DiagramPatcher: missing dgm:dataModel root");
  }
  return root;
}
function createDiagramText(text) {
  return createElement("dgm:t", {}, [
    createElement("a:bodyPr"),
    createElement("a:lstStyle"),
    createElement("a:p", {}, [createElement("a:r", {}, [createElement("a:t", {}, [createText(text)])])])
  ]);
}
function hasPoint(ptLst, nodeId) {
  return getChildren(ptLst, "dgm:pt").some((pt2) => pt2.attrs.modelId === nodeId);
}
function patchPointText(pt2, text) {
  const t = getChild(pt2, "dgm:t");
  const nextT = createDiagramText(text);
  if (t) {
    return setChildren2(pt2, pt2.children.map((c) => isXmlElement(c) && c.name === "dgm:t" ? nextT : c));
  }
  return setChildren2(pt2, [...pt2.children, nextT]);
}
function addConnection({ cxnLst, srcId, destId, connectionType }) {
  const existing = getChildren(cxnLst, "dgm:cxn").some((cxn2) => cxn2.attrs.srcId === srcId && cxn2.attrs.destId === destId && cxn2.attrs.type === connectionType);
  if (existing) {
    return cxnLst;
  }
  const cxn = createElement("dgm:cxn", { srcId, destId, type: connectionType });
  return setChildren2(cxnLst, [...cxnLst.children, cxn]);
}
function removeConnectionsForNode(cxnLst, nodeId) {
  const next = cxnLst.children.filter((c) => {
    if (!isXmlElement(c) || c.name !== "dgm:cxn") {
      return true;
    }
    return c.attrs.srcId !== nodeId && c.attrs.destId !== nodeId;
  });
  return setChildren2(cxnLst, next);
}
function patchDiagramNodeText(dataXml, nodeId, text) {
  if (!nodeId) {
    throw new Error("patchDiagramNodeText: nodeId is required");
  }
  if (text === undefined) {
    throw new Error("patchDiagramNodeText: text is required");
  }
  return updateDocumentRoot(dataXml, (root) => {
    const dataModel = root.name === "dgm:dataModel" ? root : requireDataModelRoot(dataXml);
    const ptLst = getChild(dataModel, "dgm:ptLst");
    if (!ptLst) {
      throw new Error("patchDiagramNodeText: missing dgm:ptLst");
    }
    const pts = getChildren(ptLst, "dgm:pt");
    const idx = pts.findIndex((pt2) => pt2.attrs.modelId === nodeId);
    if (idx < 0) {
      throw new Error(`patchDiagramNodeText: node not found: ${nodeId}`);
    }
    let ptIndex = -1;
    const nextPtLstChildren = ptLst.children.map((c) => {
      if (!isXmlElement(c) || c.name !== "dgm:pt") {
        return c;
      }
      ptIndex += 1;
      return ptIndex === idx ? patchPointText(c, text) : c;
    });
    const nextPtLst = setChildren2(ptLst, nextPtLstChildren);
    return setChildren2(dataModel, dataModel.children.map((c) => isXmlElement(c) && c.name === "dgm:ptLst" ? nextPtLst : c));
  });
}
function addDiagramNode({ dataXml, parentId, nodeId, text }) {
  if (!parentId) {
    throw new Error("addNode: parentId is required");
  }
  if (!nodeId) {
    throw new Error("addNode: nodeId is required");
  }
  return updateDocumentRoot(dataXml, (root) => {
    const dataModel = root.name === "dgm:dataModel" ? root : requireDataModelRoot(dataXml);
    const ptLst = getChild(dataModel, "dgm:ptLst");
    if (!ptLst) {
      throw new Error("addNode: missing dgm:ptLst");
    }
    const cxnLst = getChild(dataModel, "dgm:cxnLst") ?? createElement("dgm:cxnLst");
    if (hasPoint(ptLst, nodeId)) {
      throw new Error(`addNode: nodeId already exists: ${nodeId}`);
    }
    if (!hasPoint(ptLst, parentId)) {
      throw new Error(`addNode: parentId not found: ${parentId}`);
    }
    const pt2 = createElement("dgm:pt", { modelId: nodeId, type: "node" }, [createDiagramText(text)]);
    const nextPtLst = setChildren2(ptLst, [...ptLst.children, pt2]);
    const nextCxnLst = addConnection({ cxnLst, srcId: parentId, destId: nodeId, connectionType: "parOf" });
    const nextChildren = dataModel.children.map((c) => {
      if (!isXmlElement(c)) {
        return c;
      }
      if (c.name === "dgm:ptLst") {
        return nextPtLst;
      }
      if (c.name === "dgm:cxnLst") {
        return nextCxnLst;
      }
      return c;
    });
    if (!getChild(dataModel, "dgm:cxnLst")) {
      nextChildren.push(nextCxnLst);
    }
    return setChildren2(dataModel, nextChildren);
  });
}
function removeDiagramNode(dataXml, nodeId) {
  if (!nodeId) {
    throw new Error("removeNode: nodeId is required");
  }
  return updateDocumentRoot(dataXml, (root) => {
    const dataModel = root.name === "dgm:dataModel" ? root : requireDataModelRoot(dataXml);
    const ptLst = getChild(dataModel, "dgm:ptLst");
    if (!ptLst) {
      throw new Error("removeNode: missing dgm:ptLst");
    }
    const pts = getChildren(ptLst, "dgm:pt");
    const exists = pts.some((pt2) => pt2.attrs.modelId === nodeId);
    if (!exists) {
      throw new Error(`removeNode: node not found: ${nodeId}`);
    }
    const nextPtLst = setChildren2(ptLst, ptLst.children.filter((c) => !(isXmlElement(c) && c.name === "dgm:pt" && c.attrs.modelId === nodeId)));
    const cxnLst = getChild(dataModel, "dgm:cxnLst");
    const nextCxnLst = cxnLst ? removeConnectionsForNode(cxnLst, nodeId) : undefined;
    return setChildren2(dataModel, dataModel.children.map((c) => {
      if (!isXmlElement(c)) {
        return c;
      }
      if (c.name === "dgm:ptLst") {
        return nextPtLst;
      }
      if (c.name === "dgm:cxnLst" && nextCxnLst) {
        return nextCxnLst;
      }
      return c;
    }));
  });
}
function setDiagramConnection({ dataXml, srcId, destId, connectionType }) {
  if (!srcId || !destId) {
    throw new Error("setConnection: srcId and destId are required");
  }
  if (!connectionType) {
    throw new Error("setConnection: connectionType is required");
  }
  return updateDocumentRoot(dataXml, (root) => {
    const dataModel = root.name === "dgm:dataModel" ? root : requireDataModelRoot(dataXml);
    const ptLst = getChild(dataModel, "dgm:ptLst");
    if (!ptLst) {
      throw new Error("setConnection: missing dgm:ptLst");
    }
    if (!hasPoint(ptLst, srcId) || !hasPoint(ptLst, destId)) {
      throw new Error("setConnection: srcId/destId must exist in dgm:ptLst");
    }
    const cxnLst = getChild(dataModel, "dgm:cxnLst") ?? createElement("dgm:cxnLst");
    const nextCxnLst = addConnection({ cxnLst, srcId, destId, connectionType });
    const hasCxnLst = getChild(dataModel, "dgm:cxnLst") !== undefined;
    if (hasCxnLst) {
      const nextChildren2 = dataModel.children.map((c) => isXmlElement(c) && c.name === "dgm:cxnLst" ? nextCxnLst : c);
      return setChildren2(dataModel, nextChildren2);
    }
    const nextChildren = [...dataModel.children, nextCxnLst];
    return setChildren2(dataModel, nextChildren);
  });
}
function patchDiagram(diagramFiles, changes) {
  let nextData = diagramFiles.data;
  for (const change of changes) {
    switch (change.type) {
      case "nodeText":
        nextData = patchDiagramNodeText(nextData, change.nodeId, change.text);
        break;
      case "addNode":
        nextData = addDiagramNode({ dataXml: nextData, parentId: change.parentId, nodeId: change.nodeId, text: change.text });
        break;
      case "removeNode":
        nextData = removeDiagramNode(nextData, change.nodeId);
        break;
      case "setConnection":
        nextData = setDiagramConnection({ dataXml: nextData, srcId: change.srcId, destId: change.destId, connectionType: change.connectionType });
        break;
      default:
        ((_) => _)(change);
    }
  }
  return {
    ...diagramFiles,
    data: nextData
  };
}
// packages/@oxen-builder/chart/src/patcher/core/xml-mutator.ts
function replaceChildAt2(parent, index, newChild) {
  return {
    ...parent,
    children: parent.children.map((child, i2) => i2 === index ? newChild : child)
  };
}
function replaceChild2(parent, predicate, newChild) {
  const index = parent.children.findIndex(predicate);
  if (index === -1) {
    return parent;
  }
  return replaceChildAt2(parent, index, newChild);
}
function replaceChildByName2(parent, name, newChild) {
  return replaceChild2(parent, (child) => isXmlElement(child) && child.name === name, newChild);
}
function setChildren3(parent, children) {
  return {
    ...parent,
    children
  };
}
function findElements2(root, predicate) {
  const results = [];
  if (predicate(root)) {
    results.push(root);
  }
  for (const child of root.children) {
    if (isXmlElement(child)) {
      results.push(...findElements2(child, predicate));
    }
  }
  return results;
}
function updateDocumentRoot2(doc, updater) {
  const rootIndex = doc.children.findIndex(isXmlElement);
  if (rootIndex === -1) {
    return doc;
  }
  const root = doc.children[rootIndex];
  const updatedRoot = updater(root);
  return {
    ...doc,
    children: doc.children.map((child, i2) => i2 === rootIndex ? updatedRoot : child)
  };
}

// packages/@oxen-builder/chart/src/patcher/chart-data-patcher.ts
function cloneNode(node) {
  if (!isXmlElement(node)) {
    return { ...node };
  }
  return createElement(node.name, { ...node.attrs }, node.children.map(cloneNode));
}
function requireChild2(parent, name, context) {
  const child = getChild(parent, name);
  if (!child) {
    throw new Error(`${context}: missing required child: ${name}`);
  }
  return child;
}
function requireChartRoot(chartXml) {
  const chartSpace = getByPath(chartXml, ["c:chartSpace"]);
  if (!chartSpace) {
    throw new Error("patchChartData: missing c:chartSpace root");
  }
  return chartSpace;
}
function getPlotArea(chartSpace) {
  const chart = requireChild2(chartSpace, "c:chart", "patchChartData");
  return requireChild2(chart, "c:plotArea", "patchChartData");
}
function getSeriesContainers(plotArea) {
  return plotArea.children.filter((c) => {
    if (!isXmlElement(c)) {
      return false;
    }
    return getChild(c, "c:ser") !== undefined;
  });
}
function patchPlotAreaSeriesContainers(plotArea, containers, data) {
  const patchedContainers = new Map;
  for (const container of containers) {
    patchedContainers.set(container.name, patchContainerSeries(container, data));
  }
  const nextChildren = plotArea.children.map((child) => {
    if (!isXmlElement(child)) {
      return child;
    }
    const patched = patchedContainers.get(child.name);
    return patched ?? child;
  });
  return setChildren3(plotArea, nextChildren);
}
function setOrAddSimpleValChild(parent, name, val) {
  const existing = getChild(parent, name);
  if (existing) {
    return replaceChildByName2(parent, name, createElement(name, { ...existing.attrs, val }));
  }
  return setChildren3(parent, [...parent.children, createElement(name, { val })]);
}
function serializePtList(ptName, values) {
  return values.map((value, idx) => createElement(ptName, { idx: String(idx) }, [createElement("c:v", {}, [createText(value)])]));
}
function patchCache(cache, values) {
  const preserved = cache.children.filter((c) => {
    if (!isXmlElement(c)) {
      return true;
    }
    return c.name !== "c:ptCount" && c.name !== "c:pt";
  });
  return createElement(cache.name, { ...cache.attrs }, [
    createElement("c:ptCount", { val: String(values.length) }),
    ...serializePtList("c:pt", values),
    ...preserved
  ]);
}
function patchCategoryElement(cat, categories) {
  const strRef = getChild(cat, "c:strRef");
  if (strRef) {
    const strCache = getChild(strRef, "c:strCache");
    if (!strCache) {
      throw new Error("patchChartData: c:strRef without c:strCache is not supported");
    }
    const nextStrRef = replaceChildByName2(strRef, "c:strCache", patchCache(strCache, categories));
    return replaceChildByName2(cat, "c:strRef", nextStrRef);
  }
  const strLit = getChild(cat, "c:strLit");
  if (strLit) {
    return replaceChildByName2(cat, "c:strLit", patchCache(strLit, categories));
  }
  return createElement(cat.name, { ...cat.attrs }, [
    createElement("c:strLit", {}, [
      createElement("c:ptCount", { val: String(categories.length) }),
      ...serializePtList("c:pt", categories)
    ])
  ]);
}
function patchValuesElement(val, values) {
  const strValues = values.map((v) => String(v));
  const numRef = getChild(val, "c:numRef");
  if (numRef) {
    const numCache = getChild(numRef, "c:numCache");
    if (!numCache) {
      throw new Error("patchChartData: c:numRef without c:numCache is not supported");
    }
    const nextNumRef = replaceChildByName2(numRef, "c:numCache", patchCache(numCache, strValues));
    return replaceChildByName2(val, "c:numRef", nextNumRef);
  }
  const numLit = getChild(val, "c:numLit");
  if (numLit) {
    return replaceChildByName2(val, "c:numLit", patchCache(numLit, strValues));
  }
  return createElement(val.name, { ...val.attrs }, [
    createElement("c:numLit", {}, [
      createElement("c:ptCount", { val: String(values.length) }),
      ...serializePtList("c:pt", strValues)
    ])
  ]);
}
function patchSeriesName(tx, seriesName) {
  const v = getChild(tx, "c:v");
  if (v) {
    return replaceChildByName2(tx, "c:v", createElement("c:v", {}, [createText(seriesName)]));
  }
  const strRef = getChild(tx, "c:strRef");
  if (strRef) {
    const strCache = getChild(strRef, "c:strCache");
    if (strCache) {
      const nextStrRef = replaceChildByName2(strRef, "c:strCache", patchCache(strCache, [seriesName]));
      return replaceChildByName2(tx, "c:strRef", nextStrRef);
    }
  }
  return createElement(tx.name, { ...tx.attrs }, [createElement("c:v", {}, [createText(seriesName)])]);
}
function patchOrCreateChildWithUpdater(options) {
  const existing = getChild(options.parent, options.name);
  if (!existing) {
    return setChildren3(options.parent, [...options.parent.children, options.create()]);
  }
  return replaceChildByName2(options.parent, options.name, options.updater(existing));
}
function patchSeriesData(seriesElement, series) {
  if (seriesElement.name !== "c:ser") {
    throw new Error(`patchSeriesData: expected c:ser, got ${seriesElement.name}`);
  }
  let next = seriesElement;
  if (getChild(next, "c:idx")) {
    next = setOrAddSimpleValChild(next, "c:idx", getChild(next, "c:idx")?.attrs.val ?? "0");
  }
  if (getChild(next, "c:order")) {
    next = setOrAddSimpleValChild(next, "c:order", getChild(next, "c:order")?.attrs.val ?? "0");
  }
  next = patchOrCreateChildWithUpdater({
    parent: next,
    name: "c:tx",
    updater: (tx) => patchSeriesName(tx, series.name),
    create: () => createElement("c:tx", {}, [createElement("c:v", {}, [createText(series.name)])])
  });
  next = patchOrCreateChildWithUpdater({
    parent: next,
    name: "c:val",
    updater: (val) => patchValuesElement(val, series.values),
    create: () => createElement("c:val", {}, [
      createElement("c:numLit", {}, [
        createElement("c:ptCount", { val: String(series.values.length) }),
        ...serializePtList("c:pt", series.values.map(String))
      ])
    ])
  });
  return next;
}
function setSeriesIndex(ser, index) {
  let next = ser;
  next = setOrAddSimpleValChild(next, "c:idx", String(index));
  next = setOrAddSimpleValChild(next, "c:order", String(index));
  return next;
}
function ensureSeriesCount(seriesContainer, desiredCount) {
  const existingSeries = getChildren(seriesContainer, "c:ser");
  if (existingSeries.length >= desiredCount) {
    return seriesContainer;
  }
  if (existingSeries.length === 0) {
    throw new Error("patchChartData: cannot add series when chart has no existing c:ser template");
  }
  const template = existingSeries[0];
  const additional = [];
  for (let i2 = existingSeries.length;i2 < desiredCount; i2 += 1) {
    additional.push(setSeriesIndex(cloneNode(template), i2));
  }
  const nextChildren = [...seriesContainer.children, ...additional];
  return setChildren3(seriesContainer, nextChildren);
}
function patchContainerSeries(container, data) {
  const next = ensureSeriesCount(container, data.series.length);
  const seriesElements = getChildren(next, "c:ser");
  const patchedSeries = seriesElements.map((ser, idx) => {
    const s = data.series[idx];
    if (!s) {
      return ser;
    }
    const withIndex = setSeriesIndex(ser, idx);
    return patchSeriesData(withIndex, s);
  });
  let seriesIndex = 0;
  const nextChildren = next.children.map((child) => {
    if (!isXmlElement(child) || child.name !== "c:ser") {
      return child;
    }
    const replacement = patchedSeries[seriesIndex];
    seriesIndex += 1;
    return replacement ?? child;
  });
  return setChildren3(next, nextChildren);
}
function patchPlotAreaSeriesCategories(plotArea, categories) {
  const patchSeries = (ser) => {
    const cat = getChild(ser, "c:cat");
    if (!cat) {
      return ser;
    }
    return replaceChildByName2(ser, "c:cat", patchCategoryElement(cat, categories));
  };
  const patchAny = (node) => {
    if (!isXmlElement(node)) {
      return node;
    }
    const nextChildren = node.children.map(patchAny);
    const nextEl = createElement(node.name, { ...node.attrs }, nextChildren);
    if (node.name !== "c:ser") {
      return nextEl;
    }
    return patchSeries(nextEl);
  };
  return patchAny(plotArea);
}
function patchAllSeriesCategories(chartSpace, categories) {
  const plotArea = getPlotArea(chartSpace);
  const seriesElements = findElements2(plotArea, (el) => el.name === "c:ser");
  if (seriesElements.length === 0) {
    return chartSpace;
  }
  const patchedPlotArea = patchPlotAreaSeriesCategories(plotArea, categories);
  const chart = requireChild2(chartSpace, "c:chart", "patchChartData");
  const nextChart = replaceChildByName2(chart, "c:plotArea", patchedPlotArea);
  return replaceChildByName2(chartSpace, "c:chart", nextChart);
}
function validateChartData(data) {
  if (!Array.isArray(data.categories)) {
    throw new Error("patchChartData: data.categories must be an array");
  }
  if (!Array.isArray(data.series)) {
    throw new Error("patchChartData: data.series must be an array");
  }
  for (const [idx, s] of data.series.entries()) {
    if (!s) {
      throw new Error(`patchChartData: series[${idx}] is missing`);
    }
    if (s.values.length !== data.categories.length) {
      throw new Error(`patchChartData: series[${idx}].values length (${s.values.length}) must match categories length (${data.categories.length})`);
    }
  }
}
function patchChartData(chartXml, data) {
  validateChartData(data);
  return updateDocumentRoot2(chartXml, (root) => {
    if (root.name !== "c:chartSpace") {
      throw new Error(`patchChartData: expected c:chartSpace root, got ${root.name}`);
    }
    const plotArea = getPlotArea(root);
    const containers = getSeriesContainers(plotArea);
    if (containers.length === 0) {
      throw new Error("patchChartData: no series container found under c:plotArea");
    }
    const patchedPlotArea = patchPlotAreaSeriesContainers(plotArea, containers, data);
    const chart = requireChild2(root, "c:chart", "patchChartData");
    const nextChart = replaceChildByName2(chart, "c:plotArea", patchedPlotArea);
    const withSeries = replaceChildByName2(root, "c:chart", nextChart);
    return patchAllSeriesCategories(withSeries, data.categories);
  });
}
function patchChartTitle(chartXml, title) {
  if (!title) {
    throw new Error("patchChartTitle: title is required");
  }
  return updateDocumentRoot2(chartXml, (root) => {
    const chartSpace = root.name === "c:chartSpace" ? root : requireChartRoot(chartXml);
    const chart = requireChild2(chartSpace, "c:chart", "patchChartTitle");
    const titleEl = createElement("c:title", {}, [
      createElement("c:tx", {}, [
        createElement("c:rich", {}, [
          createElement("a:bodyPr"),
          createElement("a:lstStyle"),
          createElement("a:p", {}, [createElement("a:r", {}, [createElement("a:t", {}, [createText(title)])])])
        ])
      ]),
      createElement("c:layout"),
      createElement("c:overlay", { val: "0" })
    ]);
    if (getChild(chart, "c:title")) {
      const nextChart2 = replaceChildByName2(chart, "c:title", titleEl);
      return replaceChildByName2(chartSpace, "c:chart", nextChart2);
    }
    const nextChart = setChildren3(chart, [...chart.children, titleEl]);
    return replaceChildByName2(chartSpace, "c:chart", nextChart);
  });
}
function patchChartStyle(chartXml, styleId) {
  if (!Number.isFinite(styleId)) {
    throw new Error("patchChartStyle: styleId must be a finite number");
  }
  return updateDocumentRoot2(chartXml, (root) => {
    const chartSpace = root.name === "c:chartSpace" ? root : requireChartRoot(chartXml);
    const styleEl = getChild(chartSpace, "c:style");
    if (styleEl) {
      return replaceChildByName2(chartSpace, "c:style", createElement("c:style", { ...styleEl.attrs, val: String(styleId) }));
    }
    return setChildren3(chartSpace, [...chartSpace.children, createElement("c:style", { val: String(styleId) })]);
  });
}
// packages/@oxen-office/xlsx/src/domain/types.ts
var rowIdx = (v) => v;
var colIdx = (v) => v;
var styleId = (v) => v;
var fontId = (v) => v;
var fillId = (v) => v;
var borderId = (v) => v;
var numFmtId = (v) => v;

// packages/@oxen-builder/pptx/src/patcher/chart/chart-patcher.ts
function requireChild3(parent, name, context) {
  const child = getChild(parent, name);
  if (!child) {
    throw new Error(`${context}: missing required child: ${name}`);
  }
  return child;
}
function patchGraphicFrameTitle(graphicFrame, title) {
  const nv = requireChild3(graphicFrame, "p:nvGraphicFramePr", "patchChartElement");
  const cNvPr = requireChild3(nv, "p:cNvPr", "patchChartElement");
  const nextCNvPr = { ...cNvPr, attrs: { ...cNvPr.attrs, name: title } };
  return updateChildByName(graphicFrame, "p:nvGraphicFramePr", (nvEl) => replaceChildByName(nvEl, "p:cNvPr", nextCNvPr));
}
function patchChartElement(graphicFrame, changes) {
  if (graphicFrame.name !== "p:graphicFrame") {
    throw new Error(`patchChartElement: expected p:graphicFrame, got ${graphicFrame.name}`);
  }
  let next = graphicFrame;
  for (const change of changes) {
    switch (change.type) {
      case "title":
        next = patchGraphicFrameTitle(next, change.value);
        break;
      case "data":
      case "style":
        break;
      default:
        ((_) => _)(change);
    }
  }
  return next;
}
function patchChartTransform(graphicFrame, transform) {
  if (graphicFrame.name !== "p:graphicFrame") {
    throw new Error(`patchChartTransform: expected p:graphicFrame, got ${graphicFrame.name}`);
  }
  const xfrm = getChild(graphicFrame, "p:xfrm");
  if (!xfrm || !isXmlElement(xfrm)) {
    throw new Error("patchChartTransform: missing p:xfrm");
  }
  const patched = patchTransformElement(xfrm, transform);
  return replaceChildByName(graphicFrame, "p:xfrm", patched);
}
function patchChart(target, changes) {
  const nextFrame = patchChartElement(target.graphicFrame, changes);
  let nextChartXml = target.chartXml;
  for (const change of changes) {
    switch (change.type) {
      case "title":
        nextChartXml = patchChartTitle(nextChartXml, change.value);
        break;
      case "data":
        nextChartXml = patchChartData(nextChartXml, change.data);
        break;
      case "style":
        nextChartXml = patchChartStyle(nextChartXml, change.style.styleId);
        break;
      default:
        ((_) => _)(change);
    }
  }
  return { graphicFrame: nextFrame, chartXml: nextChartXml };
}
// packages/@oxen-builder/pptx/src/patcher/animation/animation-patcher.ts
var ENTRANCE_PRESET_IDS = {
  appear: 1,
  fly: 2,
  blinds: 3,
  box: 4,
  checkerboard: 5,
  circle: 6,
  crawl: 7,
  diamond: 8,
  dissolve: 9,
  fade: 10,
  flash: 11,
  peek: 12,
  plus: 13,
  randomBars: 14,
  splits: 15,
  strips: 16,
  wedge: 17,
  wheel: 18,
  wipe: 19,
  zoom: 20,
  float: 21,
  grow: 22,
  bounce: 23,
  swivel: 24,
  fadeZoom: 53
};
var EMPHASIS_PRESET_IDS = {
  pulse: 1,
  colorPulse: 2,
  teeter: 3,
  spin: 4,
  grow: 5,
  shrink: 6,
  transparency: 7,
  boldFlash: 8,
  blink: 9,
  wave: 10
};
var EXIT_PRESET_IDS = {
  disappear: 1,
  fly: 2,
  blinds: 3,
  box: 4,
  checkerboard: 5,
  circle: 6,
  crawl: 7,
  diamond: 8,
  dissolve: 9,
  fade: 10,
  flash: 11,
  peek: 12,
  plus: 13,
  randomBars: 14,
  splits: 15,
  strips: 16,
  wedge: 17,
  wheel: 18,
  wipe: 19,
  zoom: 20
};
var DIRECTION_SUBTYPES = {
  left: 1,
  right: 2,
  top: 3,
  bottom: 4,
  topLeft: 5,
  topRight: 6,
  bottomLeft: 7,
  bottomRight: 8,
  in: 16,
  out: 32
};
function getPresetId(effectClass, effect) {
  switch (effectClass) {
    case "entrance":
      return ENTRANCE_PRESET_IDS[effect] ?? 1;
    case "exit":
      return EXIT_PRESET_IDS[effect] ?? 1;
    case "emphasis":
      return EMPHASIS_PRESET_IDS[effect] ?? 1;
    default:
      return 1;
  }
}
var timeNodeIdCounter = 1;
function nextTimeNodeId() {
  return timeNodeIdCounter++;
}
function resetTimeNodeIdCounter() {
  timeNodeIdCounter = 1;
}
function buildShapeTarget(shapeId) {
  return {
    type: "shape",
    shapeId
  };
}
function buildEffectBehavior(spec) {
  const target = buildShapeTarget(spec.shapeId);
  const duration = spec.duration ?? 500;
  const presetId = getPresetId(spec.class, spec.effect);
  const subtype = spec.direction ? DIRECTION_SUBTYPES[spec.direction] : undefined;
  const id = nextTimeNodeId();
  let filter = "fade";
  if (spec.effect === "wipe")
    filter = "wipe(right)";
  else if (spec.effect === "blinds")
    filter = "blinds(horizontal)";
  else if (spec.effect === "fly")
    filter = "slide(fromBottom)";
  else if (spec.effect === "zoom")
    filter = "zoom";
  else if (spec.effect === "wheel")
    filter = "wheel(1)";
  else if (spec.effect === "randomBars")
    filter = "randombar(horizontal)";
  const transition = spec.class === "exit" ? "out" : "in";
  const effectNode = {
    type: "animateEffect",
    id,
    duration,
    fill: "hold",
    target,
    transition,
    filter,
    preset: {
      id: presetId,
      class: spec.class,
      subtype
    },
    autoReverse: spec.autoReverse,
    repeatCount: spec.repeat
  };
  return effectNode;
}
function buildVisibilitySet(shapeId, visible) {
  return {
    type: "set",
    id: nextTimeNodeId(),
    duration: 1,
    fill: "hold",
    target: buildShapeTarget(shapeId),
    attribute: "style.visibility",
    value: visible ? "visible" : "hidden"
  };
}
function buildEffectContainer(spec) {
  const effectNode = buildEffectBehavior(spec);
  const containerId = nextTimeNodeId();
  const children = [];
  if (spec.class === "entrance") {
    children.push(buildVisibilitySet(spec.shapeId, true));
  }
  children.push(effectNode);
  if (spec.class === "exit") {
    children.push(buildVisibilitySet(spec.shapeId, false));
  }
  const delayValue = spec.delay ?? 0;
  const startConditions = spec.trigger === "afterPrevious" ? [{ event: "onEnd", delay: delayValue }] : spec.trigger === "withPrevious" ? [{ delay: delayValue }] : [{ event: "onClick", delay: delayValue }];
  return {
    type: "parallel",
    id: containerId,
    fill: "hold",
    children,
    startConditions,
    nodeType: spec.trigger === "onClick" ? "clickEffect" : spec.trigger === "withPrevious" ? "withEffect" : "afterEffect"
  };
}
function buildTimingTree(animations) {
  resetTimeNodeIdCounter();
  if (animations.length === 0) {
    return {};
  }
  const clickGroups = [];
  let currentGroup = [];
  for (const anim of animations) {
    const container = buildEffectContainer(anim);
    if (anim.trigger === "onClick" || anim.trigger === undefined) {
      if (currentGroup.length > 0) {
        clickGroups.push(currentGroup);
      }
      currentGroup = [container];
    } else {
      currentGroup.push(container);
    }
  }
  if (currentGroup.length > 0) {
    clickGroups.push(currentGroup);
  }
  const sequenceChildren = clickGroups.map((group, index) => {
    if (group.length === 1) {
      return group[0];
    }
    return {
      type: "parallel",
      id: nextTimeNodeId(),
      fill: "hold",
      children: group,
      nodeType: index === 0 ? "clickEffect" : "afterEffect"
    };
  });
  const mainSeq = {
    type: "sequence",
    id: nextTimeNodeId(),
    duration: "indefinite",
    nodeType: "mainSeq",
    children: sequenceChildren,
    concurrent: false,
    nextAction: "seek",
    prevAction: "skip"
  };
  const root = {
    type: "parallel",
    id: nextTimeNodeId(),
    duration: "indefinite",
    nodeType: "tmRoot",
    children: [mainSeq]
  };
  return {
    rootTimeNode: root
  };
}
function addAnimationsToSlide(slideDoc, animations) {
  if (animations.length === 0) {
    return slideDoc;
  }
  const timing = buildTimingTree(animations);
  const timingEl = serializeTiming(timing);
  if (!timingEl) {
    return slideDoc;
  }
  const timingElWithNs = {
    ...timingEl,
    attrs: {
      ...timingEl.attrs,
      "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main"
    }
  };
  const newChildren = slideDoc.children.map((child) => {
    if (!isXmlElement(child) || child.name !== "p:sld") {
      return child;
    }
    const filteredChildren = child.children.filter((c) => !isXmlElement(c) || c.name !== "p:timing");
    return {
      ...child,
      children: [...filteredChildren, timingElWithNs]
    };
  });
  return {
    ...slideDoc,
    children: newChildren
  };
}
// packages/@oxen-builder/pptx/src/patcher/comment/comment-patcher.ts
var COMMENT_CONTENT_TYPE = "application/vnd.openxmlformats-officedocument.presentationml.comments+xml";
var COMMENT_AUTHORS_CONTENT_TYPE = "application/vnd.openxmlformats-officedocument.presentationml.commentAuthors+xml";
var COMMENT_REL_TYPE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments";
var COMMENT_AUTHORS_REL_TYPE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/commentAuthors";
function getSlideRelsPath2(slidePath) {
  return slidePath.replace(/\/([^/]+)\.xml$/, "/_rels/$1.xml.rels");
}
function getNextCommentIndex(pkg, slidePath) {
  const slideNum = slidePath.match(/slide(\d+)\.xml$/)?.[1] ?? "1";
  const commentsPath = `ppt/comments/comment${slideNum}.xml`;
  const commentsXml = pkg.readText(commentsPath);
  if (!commentsXml) {
    return 1;
  }
  const doc = parseXml(commentsXml);
  const root = doc.children.find(isXmlElement);
  if (!root) {
    return 1;
  }
  const comments = getChildren(root, "p:cm");
  let maxIdx = 0;
  for (const cm of comments) {
    const idx = parseInt(cm.attrs.idx ?? "0", 10);
    if (idx > maxIdx) {
      maxIdx = idx;
    }
  }
  return maxIdx + 1;
}
function ensureCommentAuthors(pkg) {
  const authorsPath = "ppt/commentAuthors.xml";
  const authorsXml = pkg.readText(authorsPath);
  if (authorsXml) {
    const doc = parseXml(authorsXml);
    const root = doc.children.find(isXmlElement);
    if (root) {
      const list = parseCommentAuthorList(root);
      return { authors: [...list.authors], doc };
    }
  }
  return { authors: [], doc: createCommentAuthorListDocument([]) };
}
function findOrCreateAuthor(authors, name, initials) {
  const existing = authors.find((a) => a.name === name);
  if (existing) {
    return existing;
  }
  const maxId = authors.reduce((max2, a) => Math.max(max2, a.id), -1);
  const newAuthor = {
    id: maxId + 1,
    name,
    initials: initials ?? name.slice(0, 2).toUpperCase(),
    lastIdx: 0,
    colorIndex: (maxId + 1) % 8
  };
  authors.push(newAuthor);
  return newAuthor;
}
function addCommentToSlide(pkg, slidePath, spec) {
  const slideNum = slidePath.match(/slide(\d+)\.xml$/)?.[1] ?? "1";
  const commentsPath = `ppt/comments/comment${slideNum}.xml`;
  const { authors, doc: authorsDoc } = ensureCommentAuthors(pkg);
  const author = findOrCreateAuthor(authors, spec.authorName, spec.authorInitials);
  let comments = [];
  const commentsXml = pkg.readText(commentsPath);
  if (commentsXml) {
    const doc = parseXml(commentsXml);
    const root = doc.children.find(isXmlElement);
    if (root) {
      const list = parseCommentList(root);
      comments = [...list.comments];
    }
  }
  const position = spec.x !== undefined && spec.y !== undefined ? { x: spec.x, y: spec.y } : undefined;
  const newComment = {
    authorId: author.id,
    dateTime: new Date().toISOString(),
    idx: getNextCommentIndex(pkg, slidePath),
    position,
    text: spec.text
  };
  comments.push(newComment);
  const updatedAuthors = authors.map((a) => a.id === author.id ? { ...a, lastIdx: Math.max(a.lastIdx ?? 0, newComment.idx ?? 0) } : a);
  const authorsXmlOut = serializeDocument(createCommentAuthorListDocument(updatedAuthors), {
    declaration: true,
    standalone: true
  });
  pkg.writeText("ppt/commentAuthors.xml", authorsXmlOut);
  const commentsXmlOut = serializeDocument(createCommentListDocument(comments), {
    declaration: true,
    standalone: true
  });
  pkg.writeText(commentsPath, commentsXmlOut);
  const contentTypesPath = "[Content_Types].xml";
  const contentTypesXml = pkg.readText(contentTypesPath);
  if (contentTypesXml) {
    let ctDoc = parseXml(contentTypesXml);
    ctDoc = addOverride(ctDoc, `/${commentsPath}`, COMMENT_CONTENT_TYPE);
    ctDoc = addOverride(ctDoc, "/ppt/commentAuthors.xml", COMMENT_AUTHORS_CONTENT_TYPE);
    pkg.writeText(contentTypesPath, serializeDocument(ctDoc, { declaration: true, standalone: true }));
  }
  const relsPath = getSlideRelsPath2(slidePath);
  const relsXml = pkg.readText(relsPath);
  const relsDoc = ensureRelationshipsDocument(relsXml ? parseXml(relsXml) : null);
  const { updatedXml: newRelsDoc } = addRelationship(relsDoc, `../comments/comment${slideNum}.xml`, COMMENT_REL_TYPE);
  pkg.writeText(relsPath, serializeDocument(newRelsDoc, { declaration: true, standalone: true }));
  const presRelsPath = "ppt/_rels/presentation.xml.rels";
  const presRelsXml = pkg.readText(presRelsPath);
  const presRelsDoc = ensureRelationshipsDocument(presRelsXml ? parseXml(presRelsXml) : null);
  const { updatedXml: newPresRelsDoc } = addRelationship(presRelsDoc, "commentAuthors.xml", COMMENT_AUTHORS_REL_TYPE);
  pkg.writeText(presRelsPath, serializeDocument(newPresRelsDoc, { declaration: true, standalone: true }));
}
// packages/@oxen-builder/pptx/src/patcher/notes/notes-patcher.ts
var NOTES_CONTENT_TYPE = "application/vnd.openxmlformats-officedocument.presentationml.notesSlide+xml";
var NOTES_REL_TYPE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide";
var P_NS2 = "http://schemas.openxmlformats.org/presentationml/2006/main";
var A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
var R_NS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships";
function getSlideRelsPath3(slidePath) {
  return slidePath.replace(/\/([^/]+)\.xml$/, "/_rels/$1.xml.rels");
}
function getNotesPath(slidePath) {
  const slideNum = slidePath.match(/slide(\d+)\.xml$/)?.[1] ?? "1";
  return `ppt/notesSlides/notesSlide${slideNum}.xml`;
}
function createNotesSlideDocument(slideRId, text) {
  const textBody = createElement("p:txBody", {}, [
    createElement("a:bodyPr"),
    createElement("a:lstStyle"),
    createElement("a:p", {}, [
      createElement("a:r", {}, [
        createElement("a:rPr", { lang: "en-US" }),
        createElement("a:t", {}, [{ type: "text", value: text }])
      ]),
      createElement("a:endParaRPr", { lang: "en-US" })
    ])
  ]);
  const notesBodyShape = createElement("p:sp", {}, [
    createElement("p:nvSpPr", {}, [
      createElement("p:cNvPr", { id: "2", name: "Notes Placeholder 2" }),
      createElement("p:cNvSpPr", {}, [
        createElement("a:spLocks", { noGrp: "1" })
      ]),
      createElement("p:nvPr", {}, [
        createElement("p:ph", { type: "body", idx: "1" })
      ])
    ]),
    createElement("p:spPr"),
    textBody
  ]);
  const slideImageShape = createElement("p:sp", {}, [
    createElement("p:nvSpPr", {}, [
      createElement("p:cNvPr", { id: "3", name: "Slide Image Placeholder 3" }),
      createElement("p:cNvSpPr", {}, [
        createElement("a:spLocks", { noGrp: "1", noRot: "1", noChangeAspect: "1" })
      ]),
      createElement("p:nvPr", {}, [
        createElement("p:ph", { type: "sldImg" })
      ])
    ]),
    createElement("p:spPr")
  ]);
  const spTree = createElement("p:spTree", {}, [
    createElement("p:nvGrpSpPr", {}, [
      createElement("p:cNvPr", { id: "1", name: "" }),
      createElement("p:cNvGrpSpPr"),
      createElement("p:nvPr")
    ]),
    createElement("p:grpSpPr", {}, [
      createElement("a:xfrm", {}, [
        createElement("a:off", { x: "0", y: "0" }),
        createElement("a:ext", { cx: "0", cy: "0" }),
        createElement("a:chOff", { x: "0", y: "0" }),
        createElement("a:chExt", { cx: "0", cy: "0" })
      ])
    ]),
    slideImageShape,
    notesBodyShape
  ]);
  const cSld = createElement("p:cSld", {}, [spTree]);
  const notes = createElement("p:notes", {
    "xmlns:a": A_NS,
    "xmlns:r": R_NS,
    "xmlns:p": P_NS2
  }, [cSld]);
  return { children: [notes] };
}
function findNotesBodyPlaceholder(notesDoc) {
  const spTree = getByPath(notesDoc, ["p:notes", "p:cSld", "p:spTree"]);
  if (!spTree)
    return null;
  const shapes = getChildren(spTree, "p:sp");
  for (const sp of shapes) {
    const nvSpPr = getChild(sp, "p:nvSpPr");
    if (!nvSpPr)
      continue;
    const nvPr = getChild(nvSpPr, "p:nvPr");
    if (!nvPr)
      continue;
    const ph = getChild(nvPr, "p:ph");
    if (!ph)
      continue;
    const phType = ph.attrs.type;
    if (phType === "body" || phType === undefined) {
      return sp;
    }
  }
  return null;
}
function updateNotesText(notesDoc, text) {
  const placeholder = findNotesBodyPlaceholder(notesDoc);
  if (!placeholder) {
    return notesDoc;
  }
  const newTextBody = createElement("p:txBody", {}, [
    createElement("a:bodyPr"),
    createElement("a:lstStyle"),
    createElement("a:p", {}, [
      createElement("a:r", {}, [
        createElement("a:rPr", { lang: "en-US" }),
        createElement("a:t", {}, [{ type: "text", value: text }])
      ]),
      createElement("a:endParaRPr", { lang: "en-US" })
    ])
  ]);
  const newChildren = placeholder.children.map((child) => {
    if (isXmlElement(child) && child.name === "p:txBody") {
      return newTextBody;
    }
    return child;
  });
  const newPlaceholder = setChildren2(placeholder, newChildren);
  const spTree = getByPath(notesDoc, ["p:notes", "p:cSld", "p:spTree"]);
  if (!spTree)
    return notesDoc;
  const newSpTreeChildren = spTree.children.map((child) => {
    if (child === placeholder) {
      return newPlaceholder;
    }
    return child;
  });
  const newSpTree = setChildren2(spTree, newSpTreeChildren);
  const cSld = getByPath(notesDoc, ["p:notes", "p:cSld"]);
  if (!cSld)
    return notesDoc;
  const newCsldChildren = cSld.children.map((child) => {
    if (isXmlElement(child) && child.name === "p:spTree") {
      return newSpTree;
    }
    return child;
  });
  const newCsld = setChildren2(cSld, newCsldChildren);
  const notes = getByPath(notesDoc, ["p:notes"]);
  if (!notes)
    return notesDoc;
  const newNotesChildren = notes.children.map((child) => {
    if (isXmlElement(child) && child.name === "p:cSld") {
      return newCsld;
    }
    return child;
  });
  const newNotes = setChildren2(notes, newNotesChildren);
  return {
    children: notesDoc.children.map((child) => {
      if (isXmlElement(child) && child.name === "p:notes") {
        return newNotes;
      }
      return child;
    })
  };
}
function setSlideNotes(pkg, slidePath, spec) {
  const notesPath = getNotesPath(slidePath);
  const notesXml = pkg.readText(notesPath);
  if (notesXml) {
    const notesDoc = parseXml(notesXml);
    const updatedDoc = updateNotesText(notesDoc, spec.text);
    const updatedXml = serializeDocument(updatedDoc, { declaration: true, standalone: true });
    pkg.writeText(notesPath, updatedXml);
  } else {
    const slideRelsPath = getSlideRelsPath3(slidePath);
    const slideRelsXml = pkg.readText(slideRelsPath);
    const slideFilename = slidePath.split("/").pop();
    const slideRId = "rId1";
    const notesDoc = createNotesSlideDocument(slideRId, spec.text);
    const notesXmlOut = serializeDocument(notesDoc, { declaration: true, standalone: true });
    pkg.writeText(notesPath, notesXmlOut);
    const contentTypesPath = "[Content_Types].xml";
    const contentTypesXml = pkg.readText(contentTypesPath);
    if (contentTypesXml) {
      const ctDoc = parseXml(contentTypesXml);
      const updatedCtDoc = addOverride(ctDoc, `/${notesPath}`, NOTES_CONTENT_TYPE);
      pkg.writeText(contentTypesPath, serializeDocument(updatedCtDoc, { declaration: true, standalone: true }));
    }
    const relsDoc = ensureRelationshipsDocument(slideRelsXml ? parseXml(slideRelsXml) : null);
    const notesFilename = notesPath.split("/").pop();
    const { updatedXml: newRelsDoc } = addRelationship(relsDoc, `../notesSlides/${notesFilename}`, NOTES_REL_TYPE);
    pkg.writeText(slideRelsPath, serializeDocument(newRelsDoc, { declaration: true, standalone: true }));
    const notesRelsPath = notesPath.replace(/\/([^/]+)\.xml$/, "/_rels/$1.xml.rels");
    const slideNum = slidePath.match(/slide(\d+)\.xml$/)?.[1] ?? "1";
    const notesRelsDoc = {
      children: [
        createElement("Relationships", { xmlns: "http://schemas.openxmlformats.org/package/2006/relationships" }, [
          createElement("Relationship", {
            Id: "rId1",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide",
            Target: `../slides/slide${slideNum}.xml`
          })
        ])
      ]
    };
    pkg.writeText(notesRelsPath, serializeDocument(notesRelsDoc, { declaration: true, standalone: true }));
  }
}
// packages/@oxen-builder/pptx/src/builders/table-update-builder.ts
function textRunSpecToTextRun(spec) {
  const properties = {
    ...spec.bold !== undefined && { bold: spec.bold },
    ...spec.italic !== undefined && { italic: spec.italic },
    ...spec.fontSize !== undefined && { fontSize: spec.fontSize },
    ...spec.fontFamily !== undefined && { fontFamily: spec.fontFamily },
    ...spec.color !== undefined && { color: { spec: { type: "srgb", value: spec.color } } }
  };
  return {
    type: "text",
    text: spec.text,
    properties
  };
}
function paragraphSpecToParagraph(spec) {
  const props = {
    ...spec.alignment && { alignment: spec.alignment }
  };
  return {
    runs: spec.runs.map(textRunSpecToTextRun),
    properties: props
  };
}
function contentToTextBody(content) {
  if (typeof content === "string") {
    return {
      bodyProperties: {},
      paragraphs: [
        {
          runs: [{ type: "text", text: content, properties: {} }],
          properties: {}
        }
      ]
    };
  }
  return {
    bodyProperties: {},
    paragraphs: content.paragraphs.map(paragraphSpecToParagraph)
  };
}
function cellSpecToTableCell(content) {
  return {
    properties: {},
    textBody: contentToTextBody(content)
  };
}
function rowSpecToTableRow(spec, colCount) {
  const cells = [];
  for (let i2 = 0;i2 < colCount; i2++) {
    const content = spec.cells[i2];
    if (content !== undefined) {
      cells.push(cellSpecToTableCell(content));
    } else {
      cells.push({ properties: {} });
    }
  }
  return {
    height: spec.height,
    cells
  };
}
function colSpecToTableColumn(spec) {
  return {
    width: spec.width
  };
}
function findGraphicFrameById(spTree, shapeId) {
  const children = spTree.children.filter(isXmlElement);
  for (const child of children) {
    if (child.name !== "p:graphicFrame") {
      continue;
    }
    const nvGraphicFramePr = getChildren(child, "p:nvGraphicFramePr")[0];
    if (!nvGraphicFramePr) {
      continue;
    }
    const cNvPr = getChildren(nvGraphicFramePr, "p:cNvPr")[0];
    if (!cNvPr) {
      continue;
    }
    if (cNvPr.attrs.id === shapeId) {
      return child;
    }
  }
  return null;
}
function getTableFromGraphicFrame(graphicFrame) {
  const graphic = getChildren(graphicFrame, "a:graphic")[0];
  if (!graphic) {
    return null;
  }
  const graphicData = getChildren(graphic, "a:graphicData")[0];
  if (!graphicData) {
    return null;
  }
  return getChildren(graphicData, "a:tbl")[0] ?? null;
}
function getColumnCount(table) {
  const tblGrid = getChildren(table, "a:tblGrid")[0];
  if (!tblGrid) {
    return 0;
  }
  return getChildren(tblGrid, "a:gridCol").length;
}
function replaceTableInGraphicFrame(graphicFrame, newTable) {
  const graphic = getChildren(graphicFrame, "a:graphic")[0];
  if (!graphic) {
    return graphicFrame;
  }
  const graphicData = getChildren(graphic, "a:graphicData")[0];
  if (!graphicData) {
    return graphicFrame;
  }
  const newGraphicDataChildren = graphicData.children.map((c) => {
    if (isXmlElement(c) && c.name === "a:tbl") {
      return newTable;
    }
    return c;
  });
  const newGraphicData = setChildren(graphicData, newGraphicDataChildren);
  const newGraphicChildren = graphic.children.map((c) => {
    if (isXmlElement(c) && c.name === "a:graphicData") {
      return newGraphicData;
    }
    return c;
  });
  const newGraphic = setChildren(graphic, newGraphicChildren);
  const newGraphicFrameChildren = graphicFrame.children.map((c) => {
    if (isXmlElement(c) && c.name === "a:graphic") {
      return newGraphic;
    }
    return c;
  });
  return setChildren(graphicFrame, newGraphicFrameChildren);
}
function getGraphicFrameId(frame) {
  const nvGraphicFramePr = getChildren(frame, "p:nvGraphicFramePr")[0];
  if (!nvGraphicFramePr) {
    return null;
  }
  const cNvPr = getChildren(nvGraphicFramePr, "p:cNvPr")[0];
  if (!cNvPr) {
    return null;
  }
  return cNvPr.attrs.id ?? null;
}
function replaceGraphicFrameInSpTree(spTree, shapeId, newFrame) {
  const newChildren = spTree.children.map((c) => {
    if (!isXmlElement(c) || c.name !== "p:graphicFrame") {
      return c;
    }
    const frameId = getGraphicFrameId(c);
    if (frameId === shapeId) {
      return newFrame;
    }
    return c;
  });
  return setChildren(spTree, newChildren);
}
function buildTableChanges(spec, colCount) {
  const cellChanges = (spec.updateCells ?? []).map((cellUpdate) => ({
    type: "cell",
    row: cellUpdate.row,
    col: cellUpdate.col,
    content: contentToTextBody(cellUpdate.content)
  }));
  const addRowChanges = (spec.addRows ?? []).map((rowSpec) => ({
    type: "addRow",
    row: rowSpecToTableRow(rowSpec, colCount),
    position: rowSpec.position
  }));
  const removeRowChanges = [...spec.removeRows ?? []].sort((a, b) => b - a).map((rowIndex) => ({ type: "removeRow", rowIndex }));
  const addColChanges = (spec.addColumns ?? []).map((colSpec) => ({
    type: "addColumn",
    column: colSpecToTableColumn(colSpec),
    position: colSpec.position
  }));
  const removeColChanges = [...spec.removeColumns ?? []].sort((a, b) => b - a).map((colIndex) => ({ type: "removeColumn", colIndex }));
  return [...cellChanges, ...addRowChanges, ...removeRowChanges, ...addColChanges, ...removeColChanges];
}
function applyTablePatch(table, changes, styleId2) {
  const patched = changes.length > 0 ? patchTable(table, changes) : table;
  return styleId2 !== undefined ? patchTableStyleId(patched, styleId2) : patched;
}
function processTableUpdate(acc, spec) {
  const graphicFrame = findGraphicFrameById(acc.spTree, spec.shapeId);
  if (!graphicFrame) {
    return acc;
  }
  const table = getTableFromGraphicFrame(graphicFrame);
  if (!table) {
    return acc;
  }
  const colCount = getColumnCount(table);
  const changes = buildTableChanges(spec, colCount);
  const updatedTable = applyTablePatch(table, changes, spec.styleId);
  const updatedFrame = replaceTableInGraphicFrame(graphicFrame, updatedTable);
  const newSpTree = replaceGraphicFrameInSpTree(acc.spTree, spec.shapeId, updatedFrame);
  return { spTree: newSpTree, updated: acc.updated + 1 };
}
function applyTableUpdates(slideDoc, updates) {
  if (updates.length === 0) {
    return { doc: slideDoc, updated: 0 };
  }
  const spTree = getByPath(slideDoc, ["p:sld", "p:cSld", "p:spTree"]);
  if (!spTree) {
    return { doc: slideDoc, updated: 0 };
  }
  const { spTree: currentSpTree, updated } = updates.reduce(processTableUpdate, { spTree, updated: 0 });
  const cSld = getByPath(slideDoc, ["p:sld", "p:cSld"]);
  if (!cSld) {
    return { doc: slideDoc, updated };
  }
  const newCsldChildren = cSld.children.map((c) => {
    if (isXmlElement(c) && c.name === "p:spTree") {
      return currentSpTree;
    }
    return c;
  });
  const newCsld = setChildren(cSld, newCsldChildren);
  const sld = getByPath(slideDoc, ["p:sld"]);
  if (!sld) {
    return { doc: slideDoc, updated };
  }
  const newSldChildren = sld.children.map((c) => {
    if (isXmlElement(c) && c.name === "p:cSld") {
      return newCsld;
    }
    return c;
  });
  const newSld = setChildren(sld, newSldChildren);
  return {
    doc: {
      children: slideDoc.children.map((c) => {
        if (isXmlElement(c) && c.name === "p:sld") {
          return newSld;
        }
        return c;
      })
    },
    updated
  };
}

// packages/@oxen-builder/drawing-ml/src/line/line-properties.ts
var LINE_END_TYPE_MAP = {
  none: "none",
  triangle: "triangle",
  stealth: "stealth",
  diamond: "diamond",
  oval: "oval",
  arrow: "arrow"
};
var LINE_END_SIZE_MAP = {
  sm: "sm",
  med: "med",
  lg: "lg"
};
var COMPOUND_MAP = {
  sng: "sng",
  dbl: "dbl",
  thickThin: "thickThin",
  thinThick: "thinThick",
  tri: "tri"
};
function buildLineEnd(spec) {
  return {
    type: LINE_END_TYPE_MAP[spec.type] ?? "none",
    width: LINE_END_SIZE_MAP[spec.width ?? "med"] ?? "med",
    length: LINE_END_SIZE_MAP[spec.length ?? "med"] ?? "med"
  };
}
function buildLine(lineColor, lineWidth, options) {
  const compound = options?.compound ? COMPOUND_MAP[options.compound] : "sng";
  return {
    width: lineWidth,
    cap: options?.cap ?? "flat",
    compound,
    alignment: "ctr",
    fill: { type: "solidFill", color: { spec: { type: "srgb", value: lineColor.startsWith("#") ? lineColor.slice(1) : lineColor } } },
    dash: options?.dash ?? "solid",
    join: options?.join ?? "round",
    headEnd: options?.headEnd ? buildLineEnd(options.headEnd) : undefined,
    tailEnd: options?.tailEnd ? buildLineEnd(options.tailEnd) : undefined
  };
}
// packages/@oxen-builder/drawing-ml/src/effect/effects.ts
function buildReflection(spec) {
  return {
    blurRadius: spec.blurRadius ?? 0,
    startOpacity: (spec.startOpacity ?? 100) * 1000,
    startPosition: 0,
    endOpacity: (spec.endOpacity ?? 0) * 1000,
    endPosition: 1e5,
    distance: spec.distance ?? 0,
    direction: spec.direction ?? 0,
    fadeDirection: spec.fadeDirection ?? 90,
    scaleX: (spec.scaleX ?? 100) * 1000,
    scaleY: (spec.scaleY ?? -100) * 1000
  };
}
function buildEffects(spec) {
  const effects = {};
  if (spec.shadow) {
    effects.shadow = {
      type: "outer",
      color: { spec: { type: "srgb", value: spec.shadow.color } },
      blurRadius: spec.shadow.blur ?? 4,
      distance: spec.shadow.distance ?? 3,
      direction: spec.shadow.direction ?? 45
    };
  }
  if (spec.glow) {
    effects.glow = {
      color: { spec: { type: "srgb", value: spec.glow.color } },
      radius: spec.glow.radius
    };
  }
  if (spec.softEdge) {
    effects.softEdge = {
      radius: spec.softEdge.radius
    };
  }
  if (spec.reflection) {
    effects.reflection = buildReflection(spec.reflection);
  }
  return effects;
}

// packages/@oxen-builder/drawing-ml/src/text/text-body.ts
var UNDERLINE_MAP = {
  none: "none",
  single: "sng",
  double: "dbl",
  heavy: "heavy",
  dotted: "dotted",
  dashed: "dash",
  wavy: "wavy"
};
var STRIKE_MAP = {
  none: "noStrike",
  single: "sngStrike",
  double: "dblStrike"
};
var VERTICAL_POSITION_MAP = {
  normal: 0,
  superscript: 30,
  subscript: -25
};
function buildHyperlink(spec) {
  return {
    id: spec.url,
    tooltip: spec.tooltip
  };
}
function buildRunProperties3(spec) {
  if (spec.bold !== undefined || spec.italic !== undefined || spec.underline !== undefined || spec.strikethrough !== undefined || spec.caps !== undefined || spec.verticalPosition !== undefined || spec.letterSpacing !== undefined || spec.fontSize !== undefined || spec.fontFamily !== undefined || spec.color !== undefined || spec.outline !== undefined || spec.effects !== undefined || spec.hyperlink !== undefined) {
    const properties = {};
    if (spec.bold !== undefined) {
      properties.bold = spec.bold;
    }
    if (spec.italic !== undefined) {
      properties.italic = spec.italic;
    }
    if (spec.underline && spec.underline !== "none") {
      properties.underline = UNDERLINE_MAP[spec.underline] ?? spec.underline;
    }
    if (spec.strikethrough && spec.strikethrough !== "noStrike") {
      properties.strike = STRIKE_MAP[spec.strikethrough];
    }
    if (spec.caps && spec.caps !== "none") {
      properties.caps = spec.caps;
    }
    if (spec.verticalPosition && spec.verticalPosition !== "normal") {
      properties.baseline = VERTICAL_POSITION_MAP[spec.verticalPosition];
    }
    if (spec.letterSpacing !== undefined) {
      properties.spacing = spec.letterSpacing;
    }
    if (spec.fontSize !== undefined) {
      properties.fontSize = spec.fontSize;
    }
    if (spec.fontFamily !== undefined) {
      properties.fontFamily = spec.fontFamily;
    }
    if (spec.color !== undefined) {
      properties.solidFill = buildSolidFill(spec.color);
    }
    if (spec.outline !== undefined) {
      properties.textOutline = buildLine(spec.outline.color, spec.outline.width ?? 1);
    }
    if (spec.effects !== undefined) {
      properties.effects = buildEffects(spec.effects);
    }
    if (spec.hyperlink !== undefined) {
      properties.hyperlink = buildHyperlink(spec.hyperlink);
    }
    return properties;
  }
  return;
}
function buildTextRun(spec) {
  const properties = buildRunProperties3(spec);
  return {
    type: "text",
    text: spec.text,
    properties
  };
}
function buildParagraph(spec) {
  const runs = spec.runs.map(buildTextRun);
  const properties = {};
  if (spec.level !== undefined) {
    properties.level = spec.level;
  }
  if (spec.alignment !== undefined) {
    properties.alignment = spec.alignment;
  }
  if (spec.bullet !== undefined && spec.bullet.type !== "none") {
    if (spec.bullet.type === "char") {
      properties.bulletStyle = {
        bullet: { type: "char", char: spec.bullet.char ?? "\u2022" },
        colorFollowText: true,
        sizeFollowText: true,
        fontFollowText: true
      };
    } else if (spec.bullet.type === "autoNum") {
      properties.bulletStyle = {
        bullet: { type: "auto", scheme: spec.bullet.autoNumType ?? "arabicPeriod" },
        colorFollowText: true,
        sizeFollowText: true,
        fontFollowText: true
      };
    }
  }
  if (spec.lineSpacing !== undefined) {
    if (spec.lineSpacing.type === "percent") {
      properties.lineSpacing = {
        type: "percent",
        value: spec.lineSpacing.value * 1000
      };
    } else {
      properties.lineSpacing = {
        type: "points",
        value: spec.lineSpacing.value * 100
      };
    }
  }
  if (spec.spaceBefore !== undefined) {
    properties.spaceBefore = spec.spaceBefore * 100;
  }
  if (spec.spaceAfter !== undefined) {
    properties.spaceAfter = spec.spaceAfter * 100;
  }
  if (spec.indent !== undefined) {
    properties.indent = spec.indent;
  }
  if (spec.marginLeft !== undefined) {
    properties.marginLeft = spec.marginLeft;
  }
  return { properties, runs };
}
function isRichText(text) {
  return Array.isArray(text);
}
function buildBodyProperties2(spec) {
  if (!spec) {
    return {};
  }
  const props = {};
  if (spec.anchor !== undefined) {
    props.anchor = spec.anchor;
  }
  if (spec.verticalType !== undefined) {
    props.verticalType = spec.verticalType;
  }
  if (spec.wrapping !== undefined) {
    props.wrapping = spec.wrapping;
  }
  if (spec.anchorCenter !== undefined) {
    props.anchorCenter = spec.anchorCenter;
  }
  if (spec.insetLeft !== undefined || spec.insetTop !== undefined || spec.insetRight !== undefined || spec.insetBottom !== undefined) {
    props.insets = {
      left: spec.insetLeft ?? 0,
      top: spec.insetTop ?? 0,
      right: spec.insetRight ?? 0,
      bottom: spec.insetBottom ?? 0
    };
  }
  return props;
}
function buildTextBody(text, bodyPropertiesSpec) {
  const bodyProperties = buildBodyProperties2(bodyPropertiesSpec);
  if (isRichText(text)) {
    return {
      bodyProperties,
      paragraphs: text.map(buildParagraph)
    };
  }
  return {
    bodyProperties,
    paragraphs: [{ properties: {}, runs: [{ type: "text", text }] }]
  };
}
function collectHyperlinks2(text) {
  const hyperlinks = [];
  if (!isRichText(text)) {
    return hyperlinks;
  }
  for (const paragraph of text) {
    for (const run of paragraph.runs) {
      if (run.hyperlink) {
        hyperlinks.push({
          url: run.hyperlink.url,
          tooltip: run.hyperlink.tooltip
        });
      }
    }
  }
  return hyperlinks;
}
// packages/@oxen-builder/drawing-ml/src/effect/shape-3d.ts
function buildBevel(spec) {
  return {
    preset: spec.preset ?? "circle",
    width: spec.width ?? 8,
    height: spec.height ?? 8
  };
}
function buildShape3d(spec) {
  const shape3d = {};
  if (spec.bevelTop) {
    shape3d.bevelTop = buildBevel(spec.bevelTop);
  }
  if (spec.bevelBottom) {
    shape3d.bevelBottom = buildBevel(spec.bevelBottom);
  }
  if (spec.material) {
    shape3d.preset = spec.material;
  }
  if (spec.extrusionHeight !== undefined) {
    shape3d.extrusionHeight = spec.extrusionHeight;
  }
  return shape3d;
}
// packages/@oxen-builder/pptx/src/builders/registry.ts
function buildLineFromShapeSpec(spec) {
  if (!spec.lineColor) {
    return;
  }
  return buildLine(spec.lineColor, spec.lineWidth ?? 1, {
    dash: spec.lineDash,
    cap: spec.lineCap,
    join: spec.lineJoin,
    compound: spec.lineCompound,
    headEnd: spec.lineHeadEnd,
    tailEnd: spec.lineTailEnd
  });
}
function buildConnectorConnection(shapeId, siteIndex, defaultSiteIndex) {
  if (!shapeId) {
    return;
  }
  return { shapeId, siteIndex: siteIndex ?? defaultSiteIndex };
}
function buildSpShape(spec, id) {
  const preset = PRESET_MAP[spec.type];
  if (!preset) {
    throw new Error(`Unknown shape type: "${spec.type}". Use a valid PresetShapeType.`);
  }
  return {
    type: "sp",
    nonVisual: { id, name: `Shape ${id}` },
    placeholder: spec.placeholder ? { type: spec.placeholder.type, idx: spec.placeholder.idx } : undefined,
    properties: {
      transform: {
        x: spec.x,
        y: spec.y,
        width: spec.width,
        height: spec.height,
        rotation: spec.rotation ?? 0,
        flipH: spec.flipH ?? false,
        flipV: spec.flipV ?? false
      },
      geometry: spec.customGeometry ? buildCustomGeometryFromSpec(spec.customGeometry) : { type: "preset", preset, adjustValues: [] },
      fill: spec.fill ? buildFill(spec.fill) : undefined,
      line: buildLineFromShapeSpec(spec),
      effects: spec.effects ? buildEffects(spec.effects) : undefined,
      shape3d: spec.shape3d ? buildShape3d(spec.shape3d) : undefined
    },
    textBody: spec.text ? buildTextBody(spec.text, spec.textBody) : undefined
  };
}
function registerHyperlinks(text, ctx) {
  const urlToRid = new Map;
  if (!text) {
    return urlToRid;
  }
  const hyperlinks = collectHyperlinks2(text);
  if (hyperlinks.length === 0) {
    return urlToRid;
  }
  const relsPath = getSlideRelsPath(ctx.slidePath);
  const relsXml = ctx.zipPackage.readText(relsPath);
  const initialRelsDoc = ensureRelationshipsDocument(relsXml ? parseXml(relsXml) : null);
  const { doc: finalRelsDoc, map: urlToRidMap } = hyperlinks.reduce((acc, hlink) => {
    if (acc.map.has(hlink.url)) {
      return acc;
    }
    const { updatedXml, rId } = addRelationship(acc.doc, hlink.url, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink");
    const newMap = new Map(acc.map);
    newMap.set(hlink.url, rId);
    return { doc: updatedXml, map: newMap };
  }, { doc: initialRelsDoc, map: urlToRid });
  const updatedRelsXml = serializeDocument(finalRelsDoc, { declaration: true, standalone: true });
  ctx.zipPackage.writeText(relsPath, updatedRelsXml);
  return urlToRidMap;
}
function replaceHyperlinkUrls(element, urlToRid) {
  if (urlToRid.size === 0) {
    return element;
  }
  if (element.name === "a:hlinkClick" && element.attrs["r:id"]) {
    const url = element.attrs["r:id"];
    const rId = urlToRid.get(url);
    if (rId) {
      return {
        ...element,
        attrs: { ...element.attrs, "r:id": rId }
      };
    }
  }
  const children = element.children.map((child) => {
    if (isXmlElement(child)) {
      return replaceHyperlinkUrls(child, urlToRid);
    }
    return child;
  });
  return { ...element, children };
}
function buildShapeXml2(spec, id, urlToRid) {
  const baseXml = serializeShape2(buildSpShape(spec, id));
  return urlToRid.size > 0 ? replaceHyperlinkUrls(baseXml, urlToRid) : baseXml;
}
var shapeBuilder = (spec, id, ctx) => {
  const urlToRid = registerHyperlinks(spec.text, ctx);
  const xml = buildShapeXml2(spec, id, urlToRid);
  return { xml };
};
function buildPicShape({
  spec,
  id,
  resourceId,
  media
}) {
  return {
    type: "pic",
    nonVisual: { id, name: `Picture ${id}` },
    blipFill: {
      resourceId,
      stretch: true,
      blipEffects: spec.effects ? buildBlipEffectsFromSpec(spec.effects) : undefined
    },
    properties: {
      transform: {
        x: spec.x,
        y: spec.y,
        width: spec.width,
        height: spec.height,
        rotation: spec.rotation ?? 0,
        flipH: spec.flipH ?? false,
        flipV: spec.flipV ?? false
      }
    },
    mediaType: media?.mediaType,
    media: media?.media
  };
}
async function buildEmbeddedMedia(spec, ctx) {
  if (!spec.media) {
    return;
  }
  let mediaArrayBuffer;
  if (spec.media.data) {
    mediaArrayBuffer = uint8ArrayToArrayBuffer(spec.media.data);
  } else if (spec.media.path) {
    const mediaPath = path3.resolve(ctx.specDir, spec.media.path);
    mediaArrayBuffer = await readFileToArrayBuffer(mediaPath);
  } else {
    throw new Error("MediaEmbedSpec requires either 'path' or 'data'");
  }
  const mediaType = detectEmbeddedMediaType(spec.media);
  const { rId: mediaRId } = addMedia({
    pkg: ctx.zipPackage,
    mediaData: mediaArrayBuffer,
    mediaType,
    referringPart: ctx.slidePath
  });
  return buildMediaReferenceFromSpec(spec.media, mediaRId, mediaType);
}
var imageBuilder = async (spec, id, ctx) => {
  let arrayBuffer;
  let mimeType;
  if (spec.data) {
    arrayBuffer = uint8ArrayToArrayBuffer(spec.data);
    mimeType = spec.mimeType ?? "image/png";
  } else if (spec.path) {
    const imagePath = path3.resolve(ctx.specDir, spec.path);
    mimeType = detectImageMimeType(imagePath);
    arrayBuffer = await readFileToArrayBuffer(imagePath);
  } else {
    throw new Error("ImageSpec requires either 'path' or 'data'");
  }
  const { rId } = addMedia({
    pkg: ctx.zipPackage,
    mediaData: arrayBuffer,
    mediaType: mimeType,
    referringPart: ctx.slidePath
  });
  const media = await buildEmbeddedMedia(spec, ctx);
  return { xml: serializeShape2(buildPicShape({ spec, id, resourceId: rId, media })) };
};
function buildCxnShape(spec, id) {
  const preset = spec.preset ?? "straightConnector1";
  return {
    type: "cxnSp",
    nonVisual: {
      id,
      name: `Connector ${id}`,
      startConnection: buildConnectorConnection(spec.startShapeId, spec.startSiteIndex, 1),
      endConnection: buildConnectorConnection(spec.endShapeId, spec.endSiteIndex, 3)
    },
    properties: {
      transform: {
        x: spec.x,
        y: spec.y,
        width: spec.width,
        height: spec.height,
        rotation: spec.rotation ?? 0,
        flipH: spec.flipH ?? false,
        flipV: spec.flipV ?? false
      },
      geometry: { type: "preset", preset, adjustValues: [] },
      line: spec.lineColor ? buildLine(spec.lineColor, spec.lineWidth ?? 2) : buildLine("000000", 2)
    }
  };
}
var connectorBuilder = (spec, id) => ({
  xml: serializeShape2(buildCxnShape(spec, id))
});
function isGroupSpec(spec) {
  return spec.type === "group" && "children" in spec;
}
function buildGroupChild(spec, existingIds) {
  const newId = generateShapeId(existingIds);
  existingIds.push(newId);
  if (isGroupSpec(spec)) {
    return buildGrpShape(spec, newId, existingIds);
  }
  return buildSpShape(spec, newId);
}
function buildGrpShape(spec, id, existingIds) {
  const children = spec.children.map((childSpec) => buildGroupChild(childSpec, existingIds));
  const transform = {
    x: spec.x,
    y: spec.y,
    width: spec.width,
    height: spec.height,
    rotation: spec.rotation ?? 0,
    flipH: spec.flipH ?? false,
    flipV: spec.flipV ?? false,
    childOffsetX: 0,
    childOffsetY: 0,
    childExtentWidth: spec.width,
    childExtentHeight: spec.height
  };
  return {
    type: "grpSp",
    nonVisual: { id, name: `Group ${id}` },
    properties: {
      transform,
      fill: spec.fill ? buildFill(spec.fill) : undefined
    },
    children
  };
}
var groupBuilder = (spec, id, ctx) => ({
  xml: serializeShape2(buildGrpShape(spec, id, ctx.existingIds))
});
function mapVerticalAlignment(va) {
  if (va === "middle") {
    return "center";
  }
  return va;
}
function buildCellBorder(color, width) {
  return buildLine(color, width);
}
function buildCellBorders(color, width) {
  const border = buildCellBorder(color, width);
  return {
    left: border,
    right: border,
    top: border,
    bottom: border
  };
}
function buildCellMargins(cellSpec) {
  const hasMargin = cellSpec.marginLeft !== undefined || cellSpec.marginRight !== undefined || cellSpec.marginTop !== undefined || cellSpec.marginBottom !== undefined;
  if (!hasMargin) {
    return;
  }
  return {
    left: cellSpec.marginLeft ?? 0,
    right: cellSpec.marginRight ?? 0,
    top: cellSpec.marginTop ?? 0,
    bottom: cellSpec.marginBottom ?? 0
  };
}
function buildCellProperties(cellSpec) {
  const margins = buildCellMargins(cellSpec);
  return {
    ...cellSpec.fill !== undefined && {
      fill: { type: "solidFill", color: { spec: { type: "srgb", value: cellSpec.fill } } }
    },
    ...cellSpec.borderColor !== undefined && {
      borders: buildCellBorders(cellSpec.borderColor, cellSpec.borderWidth ?? 1)
    },
    ...cellSpec.verticalAlignment !== undefined && {
      anchor: mapVerticalAlignment(cellSpec.verticalAlignment)
    },
    ...margins !== undefined && { margins },
    ...cellSpec.gridSpan !== undefined && cellSpec.gridSpan > 1 && { colSpan: cellSpec.gridSpan },
    ...cellSpec.rowSpan !== undefined && cellSpec.rowSpan > 1 && { rowSpan: cellSpec.rowSpan }
  };
}
function buildCellTextBody(cellSpec) {
  if (cellSpec.content) {
    return contentToTextBody(cellSpec.content);
  }
  if (cellSpec.text !== undefined) {
    return contentToTextBody(cellSpec.text);
  }
  throw new Error("TableCellSpec requires either 'text' or 'content'");
}
function buildTableCell(cellSpec) {
  return {
    properties: buildCellProperties(cellSpec),
    textBody: buildCellTextBody(cellSpec)
  };
}
function collectMergeFlags(rows) {
  const hMerge = new Set;
  const vMerge = new Set;
  for (let r = 0;r < rows.length; r++) {
    const row = rows[r];
    for (let c = 0;c < row.length; c++) {
      const cell = row[c];
      if (cell.gridSpan !== undefined && cell.gridSpan > 1) {
        for (let i2 = 1;i2 < cell.gridSpan && c + i2 < row.length; i2++) {
          hMerge.add(`${r},${c + i2}`);
        }
      }
      if (cell.rowSpan !== undefined && cell.rowSpan > 1) {
        for (let i2 = 1;i2 < cell.rowSpan && r + i2 < rows.length; i2++) {
          vMerge.add(`${r + i2},${c}`);
        }
      }
    }
  }
  return { hMerge, vMerge };
}
function buildTableRow({ rowCells, rowHeight, rowIndex, mergeFlags }) {
  const cells = rowCells.map((cellSpec, colIndex) => {
    const key = `${rowIndex},${colIndex}`;
    const isHMerge = mergeFlags.hMerge.has(key);
    const isVMerge = mergeFlags.vMerge.has(key);
    if (isHMerge || isVMerge) {
      return {
        properties: {
          ...isHMerge && { horizontalMerge: true },
          ...isVMerge && { verticalMerge: true }
        }
      };
    }
    return buildTableCell(cellSpec);
  });
  return { height: rowHeight, cells };
}
function buildTable(spec) {
  const colCount = spec.rows[0]?.length ?? 0;
  const rowCount = spec.rows.length;
  const colWidth = colCount > 0 ? spec.width / colCount : spec.width;
  const rowHeight = rowCount > 0 ? spec.height / rowCount : spec.height;
  const mergeFlags = collectMergeFlags(spec.rows);
  return {
    properties: {},
    grid: {
      columns: Array.from({ length: colCount }, () => ({ width: colWidth }))
    },
    rows: spec.rows.map((row, rowIndex) => buildTableRow({ rowCells: row, rowHeight, rowIndex, mergeFlags }))
  };
}
function buildTableGraphicFrame(spec, id) {
  const table = buildTable(spec);
  return {
    type: "graphicFrame",
    nonVisual: { id, name: `Table ${id}` },
    transform: {
      x: spec.x,
      y: spec.y,
      width: spec.width,
      height: spec.height,
      rotation: 0,
      flipH: false,
      flipV: false
    },
    content: {
      type: "table",
      data: { table }
    }
  };
}
var tableBuilder = (spec, id) => ({
  xml: serializeGraphicFrame(buildTableGraphicFrame(spec, id))
});
function addElementsSync({
  slideDoc,
  specs,
  existingIds,
  ctx,
  builder
}) {
  return specs.reduce((acc, spec) => {
    const newId = generateShapeId(existingIds);
    existingIds.push(newId);
    const { xml } = builder(spec, newId, ctx);
    const doc = updateDocumentRoot(acc.doc, (root) => updateAtPath(root, ["p:cSld", "p:spTree"], (tree) => addShapeToTree(tree, xml)));
    return { doc, added: acc.added + 1 };
  }, { doc: slideDoc, added: 0 });
}
async function addElementsAsync({
  slideDoc,
  specs,
  existingIds,
  ctx,
  builder
}) {
  const initial = { doc: slideDoc, added: 0 };
  return specs.reduce(async (accPromise, spec) => {
    const acc = await accPromise;
    const newId = generateShapeId(existingIds);
    existingIds.push(newId);
    const { xml } = await builder(spec, newId, ctx);
    const doc = updateDocumentRoot(acc.doc, (root) => updateAtPath(root, ["p:cSld", "p:spTree"], (tree) => addShapeToTree(tree, xml)));
    return { doc, added: acc.added + 1 };
  }, Promise.resolve(initial));
}

// packages/@oxen-builder/chart/src/chart-space-builder.ts
var CHART_NS = "http://schemas.openxmlformats.org/drawingml/2006/chart";
var DRAWING_NS = "http://schemas.openxmlformats.org/drawingml/2006/main";
function buildDefaultSeries() {
  return createElement("c:ser", {}, [
    createElement("c:idx", { val: "0" }),
    createElement("c:order", { val: "0" }),
    createElement("c:tx", {}, [createElement("c:v", {}, [{ type: "text", value: "Series 1" }])]),
    createElement("c:cat", {}, [
      createElement("c:strLit", {}, [
        createElement("c:ptCount", { val: "1" }),
        createElement("c:pt", { idx: "0" }, [createElement("c:v", {}, [{ type: "text", value: "A" }])])
      ])
    ]),
    createElement("c:val", {}, [
      createElement("c:numLit", {}, [
        createElement("c:ptCount", { val: "1" }),
        createElement("c:pt", { idx: "0" }, [createElement("c:v", {}, [{ type: "text", value: "1" }])])
      ])
    ])
  ]);
}
function buildDefaultScatterSeries() {
  return createElement("c:ser", {}, [
    createElement("c:idx", { val: "0" }),
    createElement("c:order", { val: "0" }),
    createElement("c:tx", {}, [createElement("c:v", {}, [{ type: "text", value: "Series 1" }])]),
    createElement("c:xVal", {}, [
      createElement("c:numLit", {}, [
        createElement("c:ptCount", { val: "1" }),
        createElement("c:pt", { idx: "0" }, [createElement("c:v", {}, [{ type: "text", value: "1" }])])
      ])
    ]),
    createElement("c:yVal", {}, [
      createElement("c:numLit", {}, [
        createElement("c:ptCount", { val: "1" }),
        createElement("c:pt", { idx: "0" }, [createElement("c:v", {}, [{ type: "text", value: "1" }])])
      ])
    ])
  ]);
}
function buildDefaultBubbleSeries() {
  return createElement("c:ser", {}, [
    createElement("c:idx", { val: "0" }),
    createElement("c:order", { val: "0" }),
    createElement("c:tx", {}, [createElement("c:v", {}, [{ type: "text", value: "Series 1" }])]),
    createElement("c:xVal", {}, [
      createElement("c:numLit", {}, [
        createElement("c:ptCount", { val: "1" }),
        createElement("c:pt", { idx: "0" }, [createElement("c:v", {}, [{ type: "text", value: "1" }])])
      ])
    ]),
    createElement("c:yVal", {}, [
      createElement("c:numLit", {}, [
        createElement("c:ptCount", { val: "1" }),
        createElement("c:pt", { idx: "0" }, [createElement("c:v", {}, [{ type: "text", value: "1" }])])
      ])
    ]),
    createElement("c:bubbleSize", {}, [
      createElement("c:numLit", {}, [
        createElement("c:ptCount", { val: "1" }),
        createElement("c:pt", { idx: "0" }, [createElement("c:v", {}, [{ type: "text", value: "10" }])])
      ])
    ])
  ]);
}
function buildBarChart(barDirection, grouping) {
  return createElement("c:barChart", {}, [
    createElement("c:barDir", { val: barDirection }),
    createElement("c:grouping", { val: grouping }),
    buildDefaultSeries()
  ]);
}
function buildBar3DChart(barDirection, grouping) {
  return createElement("c:bar3DChart", {}, [
    createElement("c:barDir", { val: barDirection }),
    createElement("c:grouping", { val: grouping }),
    buildDefaultSeries()
  ]);
}
function buildLineChart(grouping) {
  return createElement("c:lineChart", {}, [
    createElement("c:grouping", { val: grouping }),
    buildDefaultSeries()
  ]);
}
function buildLine3DChart(grouping) {
  return createElement("c:line3DChart", {}, [
    createElement("c:grouping", { val: grouping }),
    buildDefaultSeries()
  ]);
}
function buildPieChart() {
  return createElement("c:pieChart", {}, [
    createElement("c:varyColors", { val: "1" }),
    buildDefaultSeries()
  ]);
}
function buildPie3DChart() {
  return createElement("c:pie3DChart", {}, [
    createElement("c:varyColors", { val: "1" }),
    buildDefaultSeries()
  ]);
}
function buildDoughnutChart(holeSize) {
  return createElement("c:doughnutChart", {}, [
    createElement("c:varyColors", { val: "1" }),
    buildDefaultSeries(),
    createElement("c:holeSize", { val: String(holeSize) })
  ]);
}
function buildAreaChart(grouping) {
  return createElement("c:areaChart", {}, [
    createElement("c:grouping", { val: grouping }),
    buildDefaultSeries()
  ]);
}
function buildArea3DChart(grouping) {
  return createElement("c:area3DChart", {}, [
    createElement("c:grouping", { val: grouping }),
    buildDefaultSeries()
  ]);
}
function buildScatterChart(scatterStyle) {
  return createElement("c:scatterChart", {}, [
    createElement("c:scatterStyle", { val: scatterStyle }),
    buildDefaultScatterSeries()
  ]);
}
function buildRadarChart(radarStyle) {
  return createElement("c:radarChart", {}, [
    createElement("c:radarStyle", { val: radarStyle }),
    buildDefaultSeries()
  ]);
}
function buildBubbleChart(bubbleScale, sizeRepresents) {
  return createElement("c:bubbleChart", {}, [
    createElement("c:varyColors", { val: "0" }),
    buildDefaultBubbleSeries(),
    createElement("c:bubbleScale", { val: String(bubbleScale) }),
    createElement("c:sizeRepresents", { val: sizeRepresents })
  ]);
}
function buildOfPieChart(ofPieType) {
  return createElement("c:ofPieChart", {}, [
    createElement("c:ofPieType", { val: ofPieType }),
    createElement("c:varyColors", { val: "1" }),
    buildDefaultSeries()
  ]);
}
function buildStockChart() {
  const buildStockSeries = (idx, name) => createElement("c:ser", {}, [
    createElement("c:idx", { val: String(idx) }),
    createElement("c:order", { val: String(idx) }),
    createElement("c:tx", {}, [createElement("c:v", {}, [{ type: "text", value: name }])]),
    createElement("c:cat", {}, [
      createElement("c:strLit", {}, [
        createElement("c:ptCount", { val: "1" }),
        createElement("c:pt", { idx: "0" }, [createElement("c:v", {}, [{ type: "text", value: "Day 1" }])])
      ])
    ]),
    createElement("c:val", {}, [
      createElement("c:numLit", {}, [
        createElement("c:ptCount", { val: "1" }),
        createElement("c:pt", { idx: "0" }, [createElement("c:v", {}, [{ type: "text", value: "100" }])])
      ])
    ])
  ]);
  return createElement("c:stockChart", {}, [
    buildStockSeries(0, "Open"),
    buildStockSeries(1, "High"),
    buildStockSeries(2, "Low"),
    buildStockSeries(3, "Close")
  ]);
}
function buildSurfaceChart(wireframe) {
  return createElement("c:surfaceChart", {}, [
    createElement("c:wireframe", { val: wireframe ? "1" : "0" }),
    buildDefaultSeries()
  ]);
}
function buildSurface3DChart(wireframe) {
  return createElement("c:surface3DChart", {}, [
    createElement("c:wireframe", { val: wireframe ? "1" : "0" }),
    buildDefaultSeries()
  ]);
}
function buildChartTypeElement(chartType, options) {
  switch (chartType) {
    case "areaChart":
      return buildAreaChart(options?.grouping ?? "standard");
    case "area3DChart":
      return buildArea3DChart(options?.grouping ?? "standard");
    case "barChart":
      return buildBarChart(options?.barDirection ?? "col", options?.barGrouping ?? "clustered");
    case "bar3DChart":
      return buildBar3DChart(options?.barDirection ?? "col", options?.barGrouping ?? "clustered");
    case "bubbleChart":
      return buildBubbleChart(options?.bubbleScale ?? 100, options?.sizeRepresents ?? "area");
    case "doughnutChart":
      return buildDoughnutChart(options?.holeSize ?? 50);
    case "lineChart":
      return buildLineChart(options?.grouping ?? "standard");
    case "line3DChart":
      return buildLine3DChart(options?.grouping ?? "standard");
    case "ofPieChart":
      return buildOfPieChart(options?.ofPieType ?? "pie");
    case "pieChart":
      return buildPieChart();
    case "pie3DChart":
      return buildPie3DChart();
    case "radarChart":
      return buildRadarChart(options?.radarStyle ?? "standard");
    case "scatterChart":
      return buildScatterChart(options?.scatterStyle ?? "lineMarker");
    case "stockChart":
      return buildStockChart();
    case "surfaceChart":
      return buildSurfaceChart(options?.wireframe ?? false);
    case "surface3DChart":
      return buildSurface3DChart(options?.wireframe ?? false);
  }
}
function buildChartSpaceElement(chartType, options) {
  const chartTypeEl = buildChartTypeElement(chartType, options);
  return createElement("c:chartSpace", {
    "xmlns:c": CHART_NS,
    "xmlns:a": DRAWING_NS
  }, [createElement("c:chart", {}, [createElement("c:plotArea", {}, [chartTypeEl])])]);
}
function buildChartSpaceDocument(chartType, options) {
  return {
    children: [buildChartSpaceElement(chartType, options)]
  };
}
// packages/@oxen-builder/pptx/src/builders/chart-add-builder.ts
var CHART_CONTENT_TYPE = "application/vnd.openxmlformats-officedocument.drawingml.chart+xml";
function requireText(value, context) {
  if (!value) {
    throw new Error(context);
  }
  return value;
}
function getNextChartIndex(zipPackage) {
  const files = zipPackage.listFiles();
  const chartNumbers = files.map((f) => /^ppt\/charts\/chart(\d+)\.xml$/u.exec(f)).filter((match) => match !== null).map((match) => Number(match[1])).filter((n) => Number.isFinite(n));
  const max2 = chartNumbers.length > 0 ? Math.max(...chartNumbers) : 0;
  return max2 + 1;
}
function toChartData(data) {
  return {
    categories: [...data.categories],
    series: data.series.map((s) => ({ name: s.name, values: [...s.values] }))
  };
}
function buildGraphicFrameXml(shapeId, name, relId) {
  return createElement("p:graphicFrame", {}, [
    createElement("p:nvGraphicFramePr", {}, [
      createElement("p:cNvPr", { id: shapeId, name }),
      createElement("p:cNvGraphicFramePr"),
      createElement("p:nvPr")
    ]),
    createElement("p:xfrm", {}, [
      createElement("a:off", { x: "0", y: "0" }),
      createElement("a:ext", { cx: "0", cy: "0" })
    ]),
    createElement("a:graphic", {}, [
      createElement("a:graphicData", { uri: "http://schemas.openxmlformats.org/drawingml/2006/chart" }, [
        createElement("c:chart", { "r:id": relId })
      ])
    ])
  ]);
}
function buildTransform(spec) {
  return {
    x: spec.x,
    y: spec.y,
    width: spec.width,
    height: spec.height,
    rotation: 0,
    flipH: false,
    flipV: false
  };
}
function ensureChartContentType(zipPackage, chartPartPath) {
  const contentTypesPath = "[Content_Types].xml";
  const xml = requireText(zipPackage.readText(contentTypesPath), `ensureChartContentType: missing ${contentTypesPath}`);
  const doc = parseXml(xml);
  const updated = addOverride(doc, `/${chartPartPath}`, CHART_CONTENT_TYPE);
  const out = serializeDocument(updated, { declaration: true, standalone: true });
  zipPackage.writeText(contentTypesPath, out);
}
function ensureSlideChartRelationship(zipPackage, slidePath, chartPartPath) {
  const relsPath = getSlideRelsPath(slidePath);
  const relsXml = zipPackage.readText(relsPath);
  const relsDoc = ensureRelationshipsDocument(relsXml ? parseXml(relsXml) : null);
  const { updatedXml, rId } = addRelationship(relsDoc, `../charts/${chartPartPath.split("/").pop()}`, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart");
  const out = serializeDocument(updatedXml, { declaration: true, standalone: true });
  zipPackage.writeText(relsPath, out);
  return rId;
}
function buildChartDocument(spec) {
  const base = buildChartSpaceDocument(spec.chartType, spec.options);
  const withData = patchChartData(base, toChartData(spec.data));
  const withTitle = spec.title !== undefined ? patchChartTitle(withData, spec.title) : withData;
  return spec.styleId !== undefined ? patchChartStyle(withTitle, spec.styleId) : withTitle;
}
function addChartsToSlide(options) {
  if (options.specs.length === 0) {
    return { doc: options.slideDoc, added: 0 };
  }
  const firstChartIndex = getNextChartIndex(options.ctx.zipPackage);
  return options.specs.reduce((acc, spec) => {
    if (spec.data.categories.length === 0) {
      throw new Error("addChartsToSlide: data.categories must not be empty");
    }
    if (spec.data.series.length === 0) {
      throw new Error("addChartsToSlide: data.series must not be empty");
    }
    const chartIndex = firstChartIndex + acc.added;
    const chartFilename = `chart${chartIndex}.xml`;
    const chartPath = `ppt/charts/${chartFilename}`;
    const chartDoc = buildChartDocument(spec);
    ensureChartContentType(options.ctx.zipPackage, chartPath);
    const relId = ensureSlideChartRelationship(options.ctx.zipPackage, options.ctx.slidePath, chartPath);
    const chartXml = serializeDocument(chartDoc, { declaration: true, standalone: true });
    options.ctx.zipPackage.writeText(chartPath, chartXml);
    const newId = generateShapeId(options.ctx.existingIds);
    options.ctx.existingIds.push(newId);
    const frameName = spec.title ?? `Chart ${newId}`;
    const frameXml = buildGraphicFrameXml(newId, frameName, relId);
    const transformed = patchChartTransform(frameXml, buildTransform(spec));
    const nextDoc = updateDocumentRoot(acc.doc, (root) => updateAtPath(root, ["p:cSld", "p:spTree"], (tree) => addShapeToTree(tree, transformed)));
    return { doc: nextDoc, added: acc.added + 1 };
  }, { doc: options.slideDoc, added: 0 });
}

// packages/@oxen-builder/pptx/src/builders/chart-builder.ts
function requireXmlText(value, context) {
  if (!value) {
    throw new Error(context);
  }
  return value;
}
function getGraphicFrameId2(frame) {
  const cNvPr = getByPath(frame, ["p:nvGraphicFramePr", "p:cNvPr"]);
  if (!cNvPr || !isXmlElement(cNvPr)) {
    return;
  }
  return cNvPr.attrs.id;
}
function frameChartResourceId(frame) {
  const chart = getByPath(frame, ["a:graphic", "a:graphicData", "c:chart"]);
  if (!chart || !isXmlElement(chart)) {
    return;
  }
  return chart.attrs["r:id"];
}
function findGraphicFrameByChartRid(spTree, chartRid) {
  for (const child of spTree.children) {
    if (!isXmlElement(child) || child.name !== "p:graphicFrame") {
      continue;
    }
    if (frameChartResourceId(child) === chartRid) {
      return child;
    }
  }
  return;
}
function buildTransform2(spec) {
  if (!spec) {
    throw new Error("buildTransform: transform is required");
  }
  return {
    x: spec.x,
    y: spec.y,
    width: spec.width,
    height: spec.height,
    rotation: spec.rotation ?? 0,
    flipH: spec.flipH ?? false,
    flipV: spec.flipV ?? false
  };
}
function buildChartChanges(spec) {
  const changes = [];
  if (spec.title !== undefined) {
    changes.push({ type: "title", value: spec.title });
  }
  if (spec.data !== undefined) {
    changes.push({
      type: "data",
      data: {
        categories: [...spec.data.categories],
        series: spec.data.series.map((s) => ({ name: s.name, values: [...s.values] }))
      }
    });
  }
  if (spec.styleId !== undefined) {
    changes.push({ type: "style", style: { styleId: spec.styleId } });
  }
  return changes;
}
function applyChartUpdates(slideDoc, ctx, updates) {
  if (updates.length === 0) {
    return { doc: slideDoc, updated: 0 };
  }
  const relsPath = getSlideRelsPath(ctx.slidePath);
  const relsXml = requireXmlText(ctx.zipPackage.readText(relsPath), `applyChartUpdates: could not read slide rels: ${relsPath}`);
  const relsDoc = parseXml(relsXml);
  const relMap = new Map(listRelationships(relsDoc).map((r) => [r.id, r.target]));
  return updates.reduce((acc, update) => {
    const chartTarget = relMap.get(update.resourceId);
    if (!chartTarget) {
      throw new Error(`applyChartUpdates: missing chart relationship: ${update.resourceId}`);
    }
    const chartPartPath = resolveRelationshipTargetPath(ctx.slidePath, chartTarget);
    const chartXml = requireXmlText(ctx.zipPackage.readText(chartPartPath), `applyChartUpdates: could not read chart part: ${chartPartPath}`);
    const chartDoc = parseXml(chartXml);
    const spTree = getByPath(acc.doc, ["p:sld", "p:cSld", "p:spTree"]);
    if (!spTree || !isXmlElement(spTree)) {
      throw new Error("applyChartUpdates: invalid slide structure (missing p:spTree)");
    }
    const frame = findGraphicFrameByChartRid(spTree, update.resourceId);
    if (!frame) {
      throw new Error(`applyChartUpdates: could not find p:graphicFrame for chart ${update.resourceId}`);
    }
    const changes = buildChartChanges(update);
    const patched = patchChart({ graphicFrame: frame, chartXml: chartDoc }, changes);
    const patchedFrame = update.transform ? patchChartTransform(patched.graphicFrame, buildTransform2(update.transform)) : patched.graphicFrame;
    const frameId = getGraphicFrameId2(frame);
    if (!frameId) {
      throw new Error("applyChartUpdates: could not determine graphicFrame id");
    }
    const nextDoc = updateDocumentRoot(acc.doc, (root) => updateAtPath(root, ["p:cSld", "p:spTree"], (tree) => {
      const nextChildren = tree.children.map((child) => {
        if (!isXmlElement(child) || child.name !== "p:graphicFrame") {
          return child;
        }
        return getGraphicFrameId2(child) === frameId ? patchedFrame : child;
      });
      return { ...tree, children: nextChildren };
    }));
    const nextChartXml = serializeDocument(patched.chartXml, { declaration: true, standalone: true });
    ctx.zipPackage.writeText(chartPartPath, nextChartXml);
    return { doc: nextDoc, updated: acc.updated + 1 };
  }, { doc: slideDoc, updated: 0 });
}

// packages/@oxen-builder/pptx/src/builders/animation-builder.ts
function convertAnimationSpec(spec) {
  return {
    shapeId: spec.shapeId,
    class: spec.class,
    effect: spec.effect,
    trigger: spec.trigger,
    duration: spec.duration,
    delay: spec.delay,
    direction: spec.direction,
    repeat: spec.repeat,
    autoReverse: spec.autoReverse
  };
}
function applyAnimations(slideDoc, specs) {
  if (specs.length === 0) {
    return { doc: slideDoc, added: 0 };
  }
  const patcherSpecs = specs.map(convertAnimationSpec);
  const updatedDoc = addAnimationsToSlide(slideDoc, patcherSpecs);
  return {
    doc: updatedDoc,
    added: specs.length
  };
}

// packages/@oxen-builder/pptx/src/builders/comment-builder.ts
function applyComments(pkg, slidePath, specs) {
  for (const spec of specs) {
    addCommentToSlide(pkg, slidePath, {
      authorName: spec.authorName,
      authorInitials: spec.authorInitials,
      text: spec.text,
      x: spec.x,
      y: spec.y
    });
  }
}

// packages/@oxen-builder/pptx/src/builders/notes-builder.ts
function applyNotes(pkg, slidePath, spec) {
  setSlideNotes(pkg, slidePath, {
    text: spec.text
  });
}

// packages/@oxen-builder/pptx/src/builders/smartart-builder.ts
function findDiagramPaths(pkg, slideRelsPath, resourceId) {
  const relsXml = pkg.readText(slideRelsPath);
  if (!relsXml) {
    return null;
  }
  const relsDoc = parseXml(relsXml);
  const root = relsDoc.children.find(isXmlElement);
  if (!root) {
    return null;
  }
  const rels = getChildren(root, "Relationship");
  const diagramRel = rels.find((r) => r.attrs.Id === resourceId);
  if (!diagramRel) {
    return null;
  }
  const pathsFromRels = rels.reduce((acc, rel) => {
    const relType = rel.attrs.Type ?? "";
    const target = rel.attrs.Target ?? "";
    if (relType.includes("diagramData") && !acc.data) {
      return { ...acc, data: normalizeRelPath(slideRelsPath, target) };
    }
    if (relType.includes("diagramLayout") && !acc.layout) {
      return { ...acc, layout: normalizeRelPath(slideRelsPath, target) };
    }
    if (relType.includes("diagramColors") && !acc.colors) {
      return { ...acc, colors: normalizeRelPath(slideRelsPath, target) };
    }
    if (relType.includes("diagramQuickStyle") && !acc.quickStyle) {
      return { ...acc, quickStyle: normalizeRelPath(slideRelsPath, target) };
    }
    return acc;
  }, { data: null, layout: null, colors: null, quickStyle: null });
  const findDiagramFile = (suffix) => {
    const files = pkg.listFiles();
    return files.find((f) => f.includes("diagrams/") && f.endsWith(suffix)) ?? null;
  };
  const dataPath = pathsFromRels.data ?? findDiagramFile("data1.xml");
  const layoutPath = pathsFromRels.layout ?? findDiagramFile("layout1.xml");
  const colorsPath = pathsFromRels.colors ?? findDiagramFile("colors1.xml");
  const quickStylePath = pathsFromRels.quickStyle ?? findDiagramFile("quickStyle1.xml");
  if (!dataPath || !layoutPath || !colorsPath || !quickStylePath) {
    return null;
  }
  return {
    data: dataPath,
    layout: layoutPath,
    colors: colorsPath,
    quickStyle: quickStylePath
  };
}
function normalizeRelPath(relsPath, target) {
  if (target.startsWith("/")) {
    return target.slice(1);
  }
  const baseDir = relsPath.replace(/_rels\/[^/]+\.rels$/, "");
  const parts = baseDir.split("/").filter(Boolean);
  for (const segment of target.split("/")) {
    if (segment === "..") {
      parts.pop();
    } else if (segment !== ".") {
      parts.push(segment);
    }
  }
  return parts.join("/");
}
function convertChange(spec) {
  switch (spec.type) {
    case "nodeText":
      return { type: "nodeText", nodeId: spec.nodeId, text: spec.text };
    case "addNode":
      return { type: "addNode", parentId: spec.parentId, nodeId: spec.nodeId, text: spec.text };
    case "removeNode":
      return { type: "removeNode", nodeId: spec.nodeId };
    case "setConnection":
      return { type: "setConnection", srcId: spec.srcId, destId: spec.destId, connectionType: spec.connectionType };
  }
}
function applySmartArtUpdates(pkg, slidePath, specs) {
  if (specs.length === 0) {
    return;
  }
  const slideRelsPath = getSlideRelsPath(slidePath);
  for (const spec of specs) {
    const paths = findDiagramPaths(pkg, slideRelsPath, spec.resourceId);
    if (!paths) {
      throw new Error(`SmartArt update failed: could not find diagram for resourceId "${spec.resourceId}"`);
    }
    const dataXml = pkg.readText(paths.data);
    const layoutXml = pkg.readText(paths.layout);
    const colorsXml = pkg.readText(paths.colors);
    const quickStyleXml = pkg.readText(paths.quickStyle);
    if (!dataXml || !layoutXml || !colorsXml || !quickStyleXml) {
      throw new Error(`SmartArt update failed: missing diagram files for resourceId "${spec.resourceId}"`);
    }
    const diagramFiles = {
      data: parseXml(dataXml),
      layout: parseXml(layoutXml),
      colors: parseXml(colorsXml),
      quickStyle: parseXml(quickStyleXml)
    };
    const changes = spec.changes.map(convertChange);
    const updatedFiles = patchDiagram(diagramFiles, changes);
    pkg.writeText(paths.data, serializeDocument(updatedFiles.data, { declaration: true, standalone: true }));
  }
}

// packages/@oxen-builder/pptx/src/builders/transition-builder.ts
function insertTransitionAfter(root, transition, afterName) {
  const filtered = root.children.filter((c) => !(isXmlElement(c) && c.name === "p:transition"));
  const afterIndex = filtered.findIndex((c) => isXmlElement(c) && c.name === afterName);
  if (afterIndex === -1) {
    return { ...root, children: [...filtered, transition] };
  }
  const before = filtered.slice(0, afterIndex + 1);
  const after = filtered.slice(afterIndex + 1);
  return { ...root, children: [...before, transition, ...after] };
}
function removeTransition(root) {
  const children = root.children.filter((c) => !(isXmlElement(c) && c.name === "p:transition"));
  return { ...root, children };
}
function toSlideTransition(spec) {
  return {
    type: spec.type,
    duration: spec.duration,
    advanceOnClick: spec.advanceOnClick,
    advanceAfter: spec.advanceAfter,
    direction: spec.direction,
    orientation: spec.orientation,
    spokes: spec.spokes,
    inOutDirection: spec.inOutDirection
  };
}
function applySlideTransition(slideDoc, transition) {
  if (transition.type === "none") {
    return updateDocumentRoot(slideDoc, removeTransition);
  }
  const transitionEl = serializeSlideTransition(toSlideTransition(transition));
  if (!transitionEl) {
    return slideDoc;
  }
  return updateDocumentRoot(slideDoc, (root) => {
    const clrMapOvr = getChild(root, "p:clrMapOvr");
    if (clrMapOvr) {
      return insertTransitionAfter(root, transitionEl, "p:clrMapOvr");
    }
    return insertTransitionAfter(root, transitionEl, "p:cSld");
  });
}
// packages/@oxen-builder/pptx/src/builders/theme-builder.ts
var THEME_SCHEME_COLOR_NAMES = [
  "dk1",
  "lt1",
  "dk2",
  "lt2",
  "accent1",
  "accent2",
  "accent3",
  "accent4",
  "accent5",
  "accent6",
  "hlink",
  "folHlink"
];
function isThemeSchemeColorName(value) {
  return THEME_SCHEME_COLOR_NAMES.includes(value);
}
function requireThemePath(theme) {
  if (!theme.path) {
    throw new Error('theme.path is required (e.g., "ppt/theme/theme1.xml")');
  }
  return theme.path;
}
function toSrgbColor(hex) {
  return { spec: { type: "srgb", value: hex } };
}
function mergeFontSpec(base, patch) {
  if (!patch) {
    return base;
  }
  return {
    latin: patch.latin ?? base.latin,
    eastAsian: patch.eastAsian ?? base.eastAsian,
    complexScript: patch.complexScript ?? base.complexScript
  };
}
function mergeFontScheme(base, patch) {
  if (!patch) {
    return base;
  }
  return {
    majorFont: mergeFontSpec(base.majorFont, patch.majorFont),
    minorFont: mergeFontSpec(base.minorFont, patch.minorFont)
  };
}
function applyThemeEditsToThemeXml(themeXmlText, theme) {
  const hasColorScheme = theme.colorScheme && Object.keys(theme.colorScheme).length > 0;
  const hasFontScheme = theme.fontScheme && (theme.fontScheme.majorFont || theme.fontScheme.minorFont);
  if (!hasColorScheme && !hasFontScheme) {
    throw new Error("theme edits require at least one of colorScheme or fontScheme");
  }
  const themeXml = parseXml(themeXmlText);
  const changeList = [];
  if (hasColorScheme && theme.colorScheme) {
    const scheme = {};
    for (const [name, value] of Object.entries(theme.colorScheme)) {
      if (!isThemeSchemeColorName(name)) {
        throw new Error(`theme.colorScheme has unsupported key: ${name}`);
      }
      if (!value) {
        continue;
      }
      scheme[name] = toSrgbColor(value);
    }
    changeList.push({ type: "colorScheme", scheme });
  }
  if (hasFontScheme) {
    const base = parseFontScheme(themeXml);
    const merged = mergeFontScheme(base, theme.fontScheme);
    changeList.push({ type: "fontScheme", scheme: merged });
  }
  const updated = patchTheme(themeXml, changeList);
  return serializeDocument(updated, { declaration: true, standalone: true });
}
function applyThemeEditsToPackage(zipPackage, theme) {
  const themePath = requireThemePath(theme);
  const themeXmlText = zipPackage.readText(themePath);
  if (!themeXmlText) {
    throw new Error(`Theme XML not found in template: ${themePath}`);
  }
  const updated = applyThemeEditsToThemeXml(themeXmlText, theme);
  zipPackage.writeText(themePath, updated);
}
// packages/@oxen-builder/pptx/src/slide-ops/slide-operations.ts
var PRESENTATION_XML_PATH = "ppt/presentation.xml";
var PRESENTATION_RELS_PATH = "ppt/_rels/presentation.xml.rels";
var CONTENT_TYPES_PATH = "[Content_Types].xml";
var SLIDE_REL_TYPE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide";
var SLIDE_LAYOUT_REL_TYPE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout";
var NOTES_REL_TYPE2 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide";
var SLIDE_CONTENT_TYPE = "application/vnd.openxmlformats-officedocument.presentationml.slide+xml";
var NOTES_CONTENT_TYPE2 = "application/vnd.openxmlformats-officedocument.presentationml.notesSlide+xml";
var RELS_XMLNS = "http://schemas.openxmlformats.org/package/2006/relationships";
function readXmlOrThrow(pkg, path4) {
  const text = pkg.readText(path4);
  if (!text) {
    throw new Error(`Missing required xml part: ${path4}`);
  }
  return parseXml(text);
}
function writeXml(pkg, path4, doc) {
  const xml = serializeDocument(doc, { declaration: true, standalone: true });
  pkg.writeText(path4, xml);
}
function setChildren4(element, children) {
  return { ...element, children };
}
function updateDocumentRoot3(doc, updater) {
  const root = doc.children.find(isXmlElement);
  if (!root) {
    throw new Error("No root element found");
  }
  const updated = updater(root);
  return { children: doc.children.map((c) => isXmlElement(c) && c === root ? updated : c) };
}
function getSlideEntries(presentationXml) {
  const sldIdLst = getByPath(presentationXml, ["p:presentation", "p:sldIdLst"]);
  if (!sldIdLst) {
    return [];
  }
  return getChildren(sldIdLst, "p:sldId").map((el) => {
    const id = el.attrs.id;
    const rId = el.attrs["r:id"];
    if (!id || !rId) {
      throw new Error("Invalid p:sldId (missing id or r:id)");
    }
    const slideId = Number.parseInt(id, 10);
    if (!Number.isFinite(slideId)) {
      throw new Error(`Invalid slideId: ${id}`);
    }
    return { slideId, rId };
  });
}
function getRelationshipEntries(relsXml) {
  const relsRoot = getByPath(relsXml, ["Relationships"]);
  if (!relsRoot) {
    return [];
  }
  return getChildren(relsRoot, "Relationship").map((rel) => {
    const id = rel.attrs.Id ?? "";
    const type = rel.attrs.Type ?? "";
    const target = rel.attrs.Target ?? "";
    return { id, type, target };
  });
}
function generateSlideId(existing) {
  const used = new Set(existing);
  for (let id = 256;; id++) {
    if (!used.has(id)) {
      return id;
    }
  }
}
function generateRId(existing) {
  const used = new Set(existing);
  for (let i2 = 1;; i2++) {
    const rId = `rId${i2}`;
    if (!used.has(rId)) {
      return rId;
    }
  }
}
function getSlideNumbersFromPackage(pkg) {
  const numbers = [];
  for (const path4 of pkg.listFiles()) {
    const match = /^ppt\/slides\/slide(\d+)\.xml$/.exec(path4);
    if (match?.[1]) {
      numbers.push(Number.parseInt(match[1], 10));
    }
  }
  return numbers;
}
function getNextSlideNumber(pkg) {
  const existing = getSlideNumbersFromPackage(pkg);
  const max2 = existing.length > 0 ? Math.max(...existing) : 0;
  return max2 + 1;
}
function getNotesNumbersFromPackage(pkg) {
  const numbers = [];
  for (const path4 of pkg.listFiles()) {
    const match = /^ppt\/notesSlides\/notesSlide(\d+)\.xml$/.exec(path4);
    if (match?.[1]) {
      numbers.push(Number.parseInt(match[1], 10));
    }
  }
  return numbers;
}
function getNextNotesNumber(pkg) {
  const existing = getNotesNumbersFromPackage(pkg);
  const max2 = existing.length > 0 ? Math.max(...existing) : 0;
  return max2 + 1;
}
function normalizeNotesTarget(target) {
  return target.startsWith("../") ? `ppt/${target.slice(3)}` : `ppt/${target}`;
}
function findNotesPath(pkg, slideRelsPath) {
  const slideRelsText = pkg.readText(slideRelsPath);
  if (!slideRelsText) {
    return null;
  }
  const slideRelsXml = parseXml(slideRelsText);
  const slideRelEntries = getRelationshipEntries(slideRelsXml);
  const notesRel = slideRelEntries.find((r) => r.type === NOTES_REL_TYPE2);
  return notesRel ? normalizeNotesTarget(notesRel.target) : null;
}
function removeNotesSlideIfPresent(pkg, notesPath, contentTypesXml) {
  if (!notesPath || !pkg.exists(notesPath)) {
    return contentTypesXml;
  }
  pkg.remove(notesPath);
  const notesRelsPath = notesPath.replace(/\.xml$/, ".xml.rels").replace("/notesSlides/", "/notesSlides/_rels/");
  if (pkg.exists(notesRelsPath)) {
    pkg.remove(notesRelsPath);
  }
  return removeOverride(contentTypesXml, `/${notesPath}`);
}
function addSlideToList({ presentationXml, slideId, rId, position }) {
  return updateDocumentRoot3(presentationXml, (root) => {
    const sldIdLst = getChildren(root, "p:sldIdLst")[0];
    if (!sldIdLst) {
      throw new Error("Missing p:sldIdLst in presentation.xml");
    }
    const sldIds = getChildren(sldIdLst, "p:sldId");
    const newSldId = createElement("p:sldId", { id: `${slideId}`, "r:id": rId });
    const insertAt = position ?? sldIds.length;
    const nextSldIds = [...sldIds.slice(0, insertAt), newSldId, ...sldIds.slice(insertAt)];
    const updatedSldIdLst = setChildren4(sldIdLst, nextSldIds);
    return {
      ...root,
      children: root.children.map((c) => isXmlElement(c) && c.name === "p:sldIdLst" ? updatedSldIdLst : c)
    };
  });
}
function removeSlideFromList(presentationXml, slideId) {
  return updateDocumentRoot3(presentationXml, (root) => {
    const sldIdLst = getChildren(root, "p:sldIdLst")[0];
    if (!sldIdLst) {
      throw new Error("Missing p:sldIdLst in presentation.xml");
    }
    const sldIds = getChildren(sldIdLst, "p:sldId");
    const nextSldIds = sldIds.filter((el) => el.attrs.id !== `${slideId}`);
    const updatedSldIdLst = setChildren4(sldIdLst, nextSldIds);
    return {
      ...root,
      children: root.children.map((c) => isXmlElement(c) && c.name === "p:sldIdLst" ? updatedSldIdLst : c)
    };
  });
}
function reorderSlideInList(presentationXml, slideId, toIndex) {
  return updateDocumentRoot3(presentationXml, (root) => {
    const sldIdLst = getChildren(root, "p:sldIdLst")[0];
    if (!sldIdLst) {
      throw new Error("Missing p:sldIdLst in presentation.xml");
    }
    const sldIds = [...getChildren(sldIdLst, "p:sldId")];
    const fromIndex = sldIds.findIndex((el) => el.attrs.id === `${slideId}`);
    if (fromIndex === -1) {
      throw new Error(`Slide ${slideId} not found in sldIdLst`);
    }
    const [moved] = sldIds.splice(fromIndex, 1);
    sldIds.splice(toIndex, 0, moved);
    const updatedSldIdLst = setChildren4(sldIdLst, sldIds);
    return {
      ...root,
      children: root.children.map((c) => isXmlElement(c) && c.name === "p:sldIdLst" ? updatedSldIdLst : c)
    };
  });
}
function addRelationship2({ relsXml, id, type, target }) {
  return updateDocumentRoot3(relsXml, (root) => {
    const newRel = createElement("Relationship", { Id: id, Type: type, Target: target });
    const nextChildren = [...root.children.filter(isXmlElement), newRel];
    return setChildren4(root, nextChildren);
  });
}
function removeRelationship2(relsXml, rId) {
  return updateDocumentRoot3(relsXml, (root) => {
    const rels = getChildren(root, "Relationship");
    const nextRels = rels.filter((r) => r.attrs.Id !== rId);
    return setChildren4(root, nextRels);
  });
}
function updateRelationshipTarget(relsXml, rId, newTarget) {
  return updateDocumentRoot3(relsXml, (root) => {
    const rels = getChildren(root, "Relationship");
    const nextRels = rels.map((r) => r.attrs.Id !== rId ? r : createElement("Relationship", { ...r.attrs, Target: newTarget }));
    return setChildren4(root, nextRels);
  });
}
function addOverride2(contentTypesXml, partName, contentType) {
  return updateDocumentRoot3(contentTypesXml, (root) => {
    const overrides = getChildren(root, "Override");
    const exists = overrides.some((o) => o.attrs.PartName === partName && o.attrs.ContentType === contentType);
    if (exists) {
      return root;
    }
    const nonOverrides = root.children.filter((c) => isXmlElement(c) && c.name !== "Override");
    const newOverride = createElement("Override", { PartName: partName, ContentType: contentType });
    return setChildren4(root, [...nonOverrides, ...overrides, newOverride]);
  });
}
function removeOverride(contentTypesXml, partName) {
  return updateDocumentRoot3(contentTypesXml, (root) => {
    const filtered = root.children.filter((c) => !(isXmlElement(c) && c.name === "Override" && c.attrs.PartName === partName));
    return setChildren4(root, filtered);
  });
}
function buildBlankSlideXml() {
  return {
    children: [
      createElement("p:sld", {
        "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:p": "http://schemas.openxmlformats.org/presentationml/2006/main"
      }, [
        createElement("p:cSld", {}, [
          createElement("p:spTree", {}, [
            createElement("p:nvGrpSpPr", {}, [
              createElement("p:cNvPr", { id: "1", name: "" }),
              createElement("p:cNvGrpSpPr"),
              createElement("p:nvPr")
            ]),
            createElement("p:grpSpPr", {}, [
              createElement("a:xfrm", {}, [
                createElement("a:off", { x: "0", y: "0" }),
                createElement("a:ext", { cx: "0", cy: "0" }),
                createElement("a:chOff", { x: "0", y: "0" }),
                createElement("a:chExt", { cx: "0", cy: "0" })
              ])
            ])
          ])
        ]),
        createElement("p:clrMapOvr", {}, [createElement("a:masterClrMapping")])
      ])
    ]
  };
}
function normalizeLayoutPath(layoutPath) {
  return layoutPath.startsWith("ppt/") ? `../${layoutPath.slice(4)}` : layoutPath;
}
function buildSlideRelsXml2(layoutPath) {
  const targetFromSlides = normalizeLayoutPath(layoutPath);
  return {
    children: [
      createElement("Relationships", { xmlns: RELS_XMLNS }, [
        createElement("Relationship", {
          Id: "rId1",
          Type: SLIDE_LAYOUT_REL_TYPE,
          Target: targetFromSlides
        })
      ])
    ]
  };
}
function addSlideToPackage(pkg, spec) {
  if (!pkg.exists(spec.layoutPath)) {
    throw new Error(`Layout not found: ${spec.layoutPath}`);
  }
  const presentationXml = readXmlOrThrow(pkg, PRESENTATION_XML_PATH);
  const presentationRelsXml = readXmlOrThrow(pkg, PRESENTATION_RELS_PATH);
  const contentTypesXml = readXmlOrThrow(pkg, CONTENT_TYPES_PATH);
  const slideEntries = getSlideEntries(presentationXml);
  const relsEntries = getRelationshipEntries(presentationRelsXml);
  const slideId = generateSlideId(slideEntries.map((s) => s.slideId));
  const rId = generateRId(relsEntries.map((r) => r.id));
  const slideNumber = getNextSlideNumber(pkg);
  const slideFilename = `slide${slideNumber}`;
  const slidePath = `ppt/slides/${slideFilename}.xml`;
  const slideRelsPath = `ppt/slides/_rels/${slideFilename}.xml.rels`;
  writeXml(pkg, slidePath, buildBlankSlideXml());
  writeXml(pkg, slideRelsPath, buildSlideRelsXml2(spec.layoutPath));
  const updatedPresentationXml = addSlideToList({
    presentationXml,
    slideId,
    rId,
    position: spec.insertAt
  });
  const updatedPresentationRelsXml = addRelationship2({
    relsXml: presentationRelsXml,
    id: rId,
    type: SLIDE_REL_TYPE,
    target: `slides/${slideFilename}.xml`
  });
  const updatedContentTypesXml = addOverride2(contentTypesXml, `/ppt/slides/${slideFilename}.xml`, SLIDE_CONTENT_TYPE);
  writeXml(pkg, PRESENTATION_XML_PATH, updatedPresentationXml);
  writeXml(pkg, PRESENTATION_RELS_PATH, updatedPresentationRelsXml);
  writeXml(pkg, CONTENT_TYPES_PATH, updatedContentTypesXml);
  return { slideNumber };
}
function removeSlideFromPackage(pkg, slideIndex) {
  const presentationXml = readXmlOrThrow(pkg, PRESENTATION_XML_PATH);
  const presentationRelsXml = readXmlOrThrow(pkg, PRESENTATION_RELS_PATH);
  const contentTypesXml = readXmlOrThrow(pkg, CONTENT_TYPES_PATH);
  const slideEntries = getSlideEntries(presentationXml);
  if (slideIndex < 0 || slideIndex >= slideEntries.length) {
    throw new Error(`Slide index out of range: ${slideIndex}`);
  }
  const entry = slideEntries[slideIndex];
  const relsEntries = getRelationshipEntries(presentationRelsXml);
  const slideRel = relsEntries.find((r) => r.id === entry.rId);
  if (!slideRel) {
    throw new Error(`Relationship not found: ${entry.rId}`);
  }
  const slidePath = `ppt/${slideRel.target}`;
  const slideRelsPath = slidePath.replace(/\.xml$/, ".xml.rels").replace("/slides/", "/slides/_rels/");
  const notesPath = findNotesPath(pkg, slideRelsPath);
  pkg.remove(slidePath);
  if (pkg.exists(slideRelsPath)) {
    pkg.remove(slideRelsPath);
  }
  const updatedPresentationXml = removeSlideFromList(presentationXml, entry.slideId);
  const updatedPresentationRelsXml = removeRelationship2(presentationRelsXml, entry.rId);
  const baseContentTypes = removeOverride(contentTypesXml, `/${slidePath}`);
  const updatedContentTypesXml = removeNotesSlideIfPresent(pkg, notesPath, baseContentTypes);
  writeXml(pkg, PRESENTATION_XML_PATH, updatedPresentationXml);
  writeXml(pkg, PRESENTATION_RELS_PATH, updatedPresentationRelsXml);
  writeXml(pkg, CONTENT_TYPES_PATH, updatedContentTypesXml);
}
function reorderSlideInPackage(pkg, fromIndex, toIndex) {
  if (fromIndex === toIndex) {
    return;
  }
  const presentationXml = readXmlOrThrow(pkg, PRESENTATION_XML_PATH);
  const slideEntries = getSlideEntries(presentationXml);
  if (fromIndex < 0 || fromIndex >= slideEntries.length) {
    throw new Error(`From index out of range: ${fromIndex}`);
  }
  if (toIndex < 0 || toIndex >= slideEntries.length) {
    throw new Error(`To index out of range: ${toIndex}`);
  }
  const entry = slideEntries[fromIndex];
  const updatedPresentationXml = reorderSlideInList(presentationXml, entry.slideId, toIndex);
  writeXml(pkg, PRESENTATION_XML_PATH, updatedPresentationXml);
}
function updateSlideRelInNotesRels(notesRelsXml, slideFilename) {
  const notesRelEntries = getRelationshipEntries(notesRelsXml);
  const slideRel = notesRelEntries.find((rel) => rel.type === SLIDE_REL_TYPE);
  if (!slideRel) {
    return notesRelsXml;
  }
  return updateRelationshipTarget(notesRelsXml, slideRel.id, `../slides/${slideFilename}.xml`);
}
function updateNotesRelsForDuplicate({ pkg, sourceNotesPath, slideFilename, newNotesRelsPath }) {
  const sourceNotesRelsPath = sourceNotesPath.replace(/\.xml$/, ".xml.rels").replace("/notesSlides/", "/notesSlides/_rels/");
  const sourceNotesRelsText = pkg.readText(sourceNotesRelsPath);
  if (!sourceNotesRelsText) {
    return;
  }
  const notesRelsXml = parseXml(sourceNotesRelsText);
  const updatedNotesRelsXml = updateSlideRelInNotesRels(notesRelsXml, slideFilename);
  writeXml(pkg, newNotesRelsPath, updatedNotesRelsXml);
}
function duplicateNotesSlide(options) {
  const { pkg, notesRel, slideFilename, slideRelsXml, contentTypesXml } = options;
  const sourceNotesPath = normalizeNotesTarget(notesRel.target);
  const sourceNotesXml = pkg.readText(sourceNotesPath);
  if (!sourceNotesXml) {
    return { updatedSlideRelsXml: slideRelsXml, updatedContentTypesXml: contentTypesXml };
  }
  const notesNumber = getNextNotesNumber(pkg);
  const notesFilename = `notesSlide${notesNumber}`;
  const newNotesPath = `ppt/notesSlides/${notesFilename}.xml`;
  const newNotesRelsPath = `ppt/notesSlides/_rels/${notesFilename}.xml.rels`;
  pkg.writeText(newNotesPath, sourceNotesXml);
  const updatedContentTypesXml = addOverride2(contentTypesXml, `/${newNotesPath}`, NOTES_CONTENT_TYPE2);
  updateNotesRelsForDuplicate({ pkg, sourceNotesPath, slideFilename, newNotesRelsPath });
  const updatedSlideRelsXml = updateRelationshipTarget(slideRelsXml, notesRel.id, `../notesSlides/${notesFilename}.xml`);
  return { updatedSlideRelsXml, updatedContentTypesXml };
}
function duplicateSlideRelsAndNotes(options) {
  const { pkg, sourceSlideRelsText, slideFilename, newSlideRelsPath, contentTypesXml } = options;
  if (!sourceSlideRelsText) {
    return contentTypesXml;
  }
  const slideRelsXml = parseXml(sourceSlideRelsText);
  const slideRelEntries = getRelationshipEntries(slideRelsXml);
  const notesRel = slideRelEntries.find((r) => r.type === NOTES_REL_TYPE2);
  if (!notesRel) {
    writeXml(pkg, newSlideRelsPath, slideRelsXml);
    return contentTypesXml;
  }
  const { updatedSlideRelsXml, updatedContentTypesXml } = duplicateNotesSlide({
    pkg,
    notesRel,
    slideFilename,
    slideRelsXml,
    contentTypesXml
  });
  writeXml(pkg, newSlideRelsPath, updatedSlideRelsXml);
  return updatedContentTypesXml;
}
function duplicateSlideInPackage(pkg, slideIndex, insertAt) {
  const presentationXml = readXmlOrThrow(pkg, PRESENTATION_XML_PATH);
  const presentationRelsXml = readXmlOrThrow(pkg, PRESENTATION_RELS_PATH);
  const contentTypesXml = readXmlOrThrow(pkg, CONTENT_TYPES_PATH);
  const slideEntries = getSlideEntries(presentationXml);
  if (slideIndex < 0 || slideIndex >= slideEntries.length) {
    throw new Error(`Slide index out of range: ${slideIndex}`);
  }
  const sourceEntry = slideEntries[slideIndex];
  const relsEntries = getRelationshipEntries(presentationRelsXml);
  const sourceRel = relsEntries.find((r) => r.id === sourceEntry.rId);
  if (!sourceRel) {
    throw new Error(`Source slide relationship not found: ${sourceEntry.rId}`);
  }
  const sourceSlidePath = `ppt/${sourceRel.target}`;
  const sourceSlideXml = pkg.readText(sourceSlidePath);
  if (!sourceSlideXml) {
    throw new Error(`Source slide not found: ${sourceSlidePath}`);
  }
  const sourceSlideRelsPath = sourceSlidePath.replace(/\.xml$/, ".xml.rels").replace("/slides/", "/slides/_rels/");
  const sourceSlideRelsText = pkg.readText(sourceSlideRelsPath);
  const slideId = generateSlideId(slideEntries.map((s) => s.slideId));
  const rId = generateRId(relsEntries.map((r) => r.id));
  const slideNumber = getNextSlideNumber(pkg);
  const slideFilename = `slide${slideNumber}`;
  const newSlidePath = `ppt/slides/${slideFilename}.xml`;
  const newSlideRelsPath = `ppt/slides/_rels/${slideFilename}.xml.rels`;
  pkg.writeText(newSlidePath, sourceSlideXml);
  const baseContentTypes = addOverride2(contentTypesXml, `/ppt/slides/${slideFilename}.xml`, SLIDE_CONTENT_TYPE);
  const updatedContentTypesXml = duplicateSlideRelsAndNotes({
    pkg,
    sourceSlideRelsText,
    slideFilename,
    newSlideRelsPath,
    contentTypesXml: baseContentTypes
  });
  const effectiveInsertAt = insertAt ?? slideIndex + 1;
  const updatedPresentationXml = addSlideToList({ presentationXml, slideId, rId, position: effectiveInsertAt });
  const updatedPresentationRelsXml = addRelationship2({
    relsXml: presentationRelsXml,
    id: rId,
    type: SLIDE_REL_TYPE,
    target: `slides/${slideFilename}.xml`
  });
  writeXml(pkg, PRESENTATION_XML_PATH, updatedPresentationXml);
  writeXml(pkg, PRESENTATION_RELS_PATH, updatedPresentationRelsXml);
  writeXml(pkg, CONTENT_TYPES_PATH, updatedContentTypesXml);
}
async function applySlideOperations(pkg, options) {
  try {
    const addSlides = options.addSlides ?? [];
    addSlides.forEach((spec) => addSlideToPackage(pkg, spec));
    const duplicateSlides = options.duplicateSlides ?? [];
    duplicateSlides.forEach((spec) => duplicateSlideInPackage(pkg, spec.sourceSlideNumber - 1, spec.insertAt));
    const reorderSlides = options.reorderSlides ?? [];
    reorderSlides.forEach((spec) => reorderSlideInPackage(pkg, spec.from, spec.to));
    const removeSlides = [...options.removeSlides ?? []].sort((a, b) => b.slideNumber - a.slideNumber);
    removeSlides.forEach((spec) => removeSlideFromPackage(pkg, spec.slideNumber - 1));
    return {
      success: true,
      data: {
        added: addSlides.length,
        removed: removeSlides.length,
        reordered: reorderSlides.length,
        duplicated: duplicateSlides.length
      }
    };
  } catch (err2) {
    return {
      success: false,
      error: `Slide operation failed: ${err2.message}`
    };
  }
}
// packages/@oxen-cli/pptx-cli/src/commands/build.ts
function getShapeId2(shape) {
  return shape.type === "contentPart" ? "0" : shape.nonVisual?.id ?? "0";
}
function getExistingShapeIds(apiSlide) {
  const domainSlide = parseSlide(apiSlide.content);
  if (!domainSlide) {
    return [];
  }
  return domainSlide.shapes.map(getShapeId2);
}
async function applyBackgroundSpec(slideDoc, spec, ctx) {
  if (!spec) {
    return slideDoc;
  }
  if (isImageBackground(spec)) {
    return applyImageBackground(slideDoc, spec, ctx);
  }
  return applyBackground(slideDoc, spec);
}
async function processSlide(ctx, slideMod) {
  const slideNum = slideMod.slideNumber;
  if (slideNum < 1 || slideNum > ctx.presentation.count) {
    return { success: false, error: error("INVALID_SLIDE", `Slide ${slideNum} not found. Valid range: 1-${ctx.presentation.count}`) };
  }
  const apiSlide = ctx.presentation.getSlide(slideNum);
  const slidePath = `ppt/slides/${apiSlide.filename}.xml`;
  const slideXml = ctx.zipPackage.readText(slidePath);
  if (!slideXml) {
    return { success: false, error: error("SLIDE_NOT_FOUND", `Could not read slide XML: ${slidePath}`) };
  }
  const slideDoc = parseXml(slideXml);
  const spTree = getByPath(slideDoc, ["p:sld", "p:cSld", "p:spTree"]);
  if (!spTree) {
    return { success: false, error: error("INVALID_SLIDE", `Invalid slide structure: ${slidePath}`) };
  }
  const existingIds = getExistingShapeIds(apiSlide);
  const buildCtx = {
    existingIds,
    specDir: ctx.specDir,
    zipPackage: ctx.zipPackage,
    slidePath
  };
  const docWithBackground = await applyBackgroundSpec(slideDoc, slideMod.background, buildCtx);
  const { doc: afterShapes, added: shapesAdded } = addElementsSync({
    slideDoc: docWithBackground,
    specs: slideMod.addShapes ?? [],
    existingIds,
    ctx: buildCtx,
    builder: shapeBuilder
  });
  const { doc: afterImages, added: imagesAdded } = await addElementsAsync({
    slideDoc: afterShapes,
    specs: slideMod.addImages ?? [],
    existingIds,
    ctx: buildCtx,
    builder: imageBuilder
  });
  const { doc: afterConnectors, added: connectorsAdded } = addElementsSync({
    slideDoc: afterImages,
    specs: slideMod.addConnectors ?? [],
    existingIds,
    ctx: buildCtx,
    builder: connectorBuilder
  });
  const { doc: afterGroups, added: groupsAdded } = addElementsSync({
    slideDoc: afterConnectors,
    specs: slideMod.addGroups ?? [],
    existingIds,
    ctx: buildCtx,
    builder: groupBuilder
  });
  const { doc: afterTables, added: tablesAdded } = addElementsSync({
    slideDoc: afterGroups,
    specs: slideMod.addTables ?? [],
    existingIds,
    ctx: buildCtx,
    builder: tableBuilder
  });
  const { doc: afterChartAdds } = addChartsToSlide({
    slideDoc: afterTables,
    specs: slideMod.addCharts ?? [],
    ctx: { zipPackage: ctx.zipPackage, slidePath, existingIds }
  });
  const { doc: afterCharts } = applyChartUpdates(afterChartAdds, { zipPackage: ctx.zipPackage, slidePath }, slideMod.updateCharts ?? []);
  const { doc: afterTableUpdates } = applyTableUpdates(afterCharts, slideMod.updateTables ?? []);
  const { doc: afterAnimations } = applyAnimations(afterTableUpdates, slideMod.addAnimations ?? []);
  if (slideMod.addComments && slideMod.addComments.length > 0) {
    applyComments(ctx.zipPackage, slidePath, slideMod.addComments);
  }
  if (slideMod.speakerNotes) {
    applyNotes(ctx.zipPackage, slidePath, slideMod.speakerNotes);
  }
  if (slideMod.updateSmartArt && slideMod.updateSmartArt.length > 0) {
    applySmartArtUpdates(ctx.zipPackage, slidePath, slideMod.updateSmartArt);
  }
  const finalDoc = slideMod.transition ? applySlideTransition(afterAnimations, slideMod.transition) : afterAnimations;
  const totalAdded = shapesAdded + imagesAdded + connectorsAdded + groupsAdded + tablesAdded;
  const updatedXml = serializeDocument(finalDoc, { declaration: true, standalone: true });
  ctx.zipPackage.writeText(slidePath, updatedXml);
  return { success: true, shapesAdded: totalAdded };
}
async function runBuild(specPath) {
  try {
    const specJson = await fs3.readFile(specPath, "utf-8");
    const spec = JSON.parse(specJson);
    const specDir = path4.dirname(specPath);
    const templatePath = path4.resolve(specDir, spec.template);
    const templateBuffer = await fs3.readFile(templatePath);
    const { zipPackage, presentationFile } = await loadPptxBundleFromBuffer(templateBuffer);
    if (spec.theme) {
      applyThemeEditsToPackage(zipPackage, spec.theme);
    }
    const hasSlideOps = spec.addSlides && spec.addSlides.length > 0 || spec.duplicateSlides && spec.duplicateSlides.length > 0 || spec.reorderSlides && spec.reorderSlides.length > 0 || spec.removeSlides && spec.removeSlides.length > 0;
    if (hasSlideOps) {
      const slideOpsResult = await applySlideOperations(zipPackage, {
        addSlides: spec.addSlides,
        duplicateSlides: spec.duplicateSlides,
        reorderSlides: spec.reorderSlides,
        removeSlides: spec.removeSlides
      });
      if (!slideOpsResult.success) {
        return error("SLIDE_OPS_FAILED", slideOpsResult.error);
      }
    }
    const presentation = openPresentation(presentationFile);
    const ctx = { zipPackage, presentation, specDir };
    const slides = spec.slides ?? [];
    const processResults = [];
    for (const slideMod of slides) {
      const result = await processSlide(ctx, slideMod);
      processResults.push(result);
      if (!result.success) {
        break;
      }
    }
    const firstError = processResults.find((r) => !r.success);
    if (firstError) {
      return firstError.error;
    }
    const shapesAdded = processResults.filter((r) => r.success).reduce((sum, r) => sum + r.shapesAdded, 0);
    const outputPath = path4.resolve(specDir, spec.output);
    await fs3.mkdir(path4.dirname(outputPath), { recursive: true });
    const outputBuffer = await zipPackage.toArrayBuffer();
    await fs3.writeFile(outputPath, Buffer.from(outputBuffer));
    return success({ outputPath: spec.output, slideCount: presentation.count, shapesAdded });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${err2.path}`);
    }
    if (err2 instanceof SyntaxError) {
      return error("INVALID_JSON", `Invalid JSON: ${err2.message}`);
    }
    return error("BUILD_ERROR", `Build failed: ${err2.message}`);
  }
}

// packages/@oxen-cli/pptx-cli/src/commands/verify.ts
import * as fs4 from "fs/promises";
import * as path5 from "path";
function createAssertion(path6, expected, actual) {
  return {
    path: path6,
    expected,
    actual,
    passed: JSON.stringify(expected) === JSON.stringify(actual)
  };
}
function matchBounds(expected, actual, basePath) {
  const assertions = [];
  if (!actual) {
    assertions.push(createAssertion(`${basePath}.bounds`, expected, undefined));
    return assertions;
  }
  if (expected.x !== undefined) {
    assertions.push(createAssertion(`${basePath}.bounds.x`, expected.x, actual.x));
  }
  if (expected.y !== undefined) {
    assertions.push(createAssertion(`${basePath}.bounds.y`, expected.y, actual.y));
  }
  if (expected.width !== undefined) {
    assertions.push(createAssertion(`${basePath}.bounds.width`, expected.width, actual.width));
  }
  if (expected.height !== undefined) {
    assertions.push(createAssertion(`${basePath}.bounds.height`, expected.height, actual.height));
  }
  return assertions;
}
function matchGeometry(expected, actual, basePath) {
  const assertions = [];
  if (!actual) {
    assertions.push(createAssertion(`${basePath}.geometry`, expected, undefined));
    return assertions;
  }
  if (expected.kind !== undefined) {
    assertions.push(createAssertion(`${basePath}.geometry.kind`, expected.kind, actual.kind));
  }
  if (expected.preset !== undefined) {
    assertions.push(createAssertion(`${basePath}.geometry.preset`, expected.preset, actual.preset));
  }
  return assertions;
}
function matchFill(expected, actual, basePath) {
  const assertions = [];
  if (!actual) {
    if (expected.type === "none") {
      return assertions;
    }
    assertions.push(createAssertion(`${basePath}.fill`, expected, undefined));
    return assertions;
  }
  if (expected.type !== undefined) {
    assertions.push(createAssertion(`${basePath}.fill.type`, expected.type, actual.type));
  }
  if (expected.color !== undefined) {
    assertions.push(createAssertion(`${basePath}.fill.color`, expected.color, actual.color));
  }
  return assertions;
}
function matchLine(expected, actual, basePath) {
  const assertions = [];
  if (!actual) {
    assertions.push(createAssertion(`${basePath}.line`, expected, undefined));
    return assertions;
  }
  if (expected.color !== undefined) {
    assertions.push(createAssertion(`${basePath}.line.color`, expected.color, actual.color));
  }
  if (expected.width !== undefined) {
    assertions.push(createAssertion(`${basePath}.line.width`, expected.width, actual.width));
  }
  if (expected.dashStyle !== undefined) {
    assertions.push(createAssertion(`${basePath}.line.dashStyle`, expected.dashStyle, actual.dashStyle));
  }
  if (expected.compound !== undefined) {
    assertions.push(createAssertion(`${basePath}.line.compound`, expected.compound, actual.compound));
  }
  return assertions;
}
function matchEffects(expected, actual, basePath) {
  const assertions = [];
  if (!actual) {
    assertions.push(createAssertion(`${basePath}.effects`, expected, undefined));
    return assertions;
  }
  if (expected.shadow !== undefined) {
    if (!actual.shadow) {
      assertions.push(createAssertion(`${basePath}.effects.shadow`, expected.shadow, undefined));
    } else if (expected.shadow.type !== undefined) {
      assertions.push(createAssertion(`${basePath}.effects.shadow.type`, expected.shadow.type, actual.shadow.type));
    }
  }
  if (expected.glow !== undefined) {
    if (!actual.glow) {
      assertions.push(createAssertion(`${basePath}.effects.glow`, expected.glow, undefined));
    } else if (expected.glow.radius !== undefined) {
      assertions.push(createAssertion(`${basePath}.effects.glow.radius`, expected.glow.radius, actual.glow.radius));
    }
  }
  if (expected.softEdge !== undefined) {
    if (!actual.softEdge) {
      assertions.push(createAssertion(`${basePath}.effects.softEdge`, expected.softEdge, undefined));
    } else if (expected.softEdge.radius !== undefined) {
      assertions.push(createAssertion(`${basePath}.effects.softEdge.radius`, expected.softEdge.radius, actual.softEdge.radius));
    }
  }
  return assertions;
}
function matchShape3d(expected, actual, basePath) {
  const assertions = [];
  if (!actual) {
    assertions.push(createAssertion(`${basePath}.shape3d`, expected, undefined));
    return assertions;
  }
  if (expected.bevelTop !== undefined) {
    if (!actual.bevelTop) {
      assertions.push(createAssertion(`${basePath}.shape3d.bevelTop`, expected.bevelTop, undefined));
    } else if (expected.bevelTop.preset !== undefined) {
      assertions.push(createAssertion(`${basePath}.shape3d.bevelTop.preset`, expected.bevelTop.preset, actual.bevelTop.preset));
    }
  }
  if (expected.bevelBottom !== undefined) {
    if (!actual.bevelBottom) {
      assertions.push(createAssertion(`${basePath}.shape3d.bevelBottom`, expected.bevelBottom, undefined));
    } else if (expected.bevelBottom.preset !== undefined) {
      assertions.push(createAssertion(`${basePath}.shape3d.bevelBottom.preset`, expected.bevelBottom.preset, actual.bevelBottom.preset));
    }
  }
  if (expected.material !== undefined) {
    assertions.push(createAssertion(`${basePath}.shape3d.material`, expected.material, actual.material));
  }
  if (expected.extrusionHeight !== undefined) {
    assertions.push(createAssertion(`${basePath}.shape3d.extrusionHeight`, expected.extrusionHeight, actual.extrusionHeight));
  }
  return assertions;
}
function matchTableContent(expected, actual, basePath) {
  const assertions = [];
  if (!actual) {
    assertions.push(createAssertion(`${basePath}.table`, expected, undefined));
    return assertions;
  }
  if (expected.rows !== undefined) {
    assertions.push(createAssertion(`${basePath}.table.rows`, expected.rows, actual.rows));
  }
  if (expected.cols !== undefined) {
    assertions.push(createAssertion(`${basePath}.table.cols`, expected.cols, actual.cols));
  }
  if (expected.cells !== undefined) {
    for (const [rowIdx2, expectedRow] of expected.cells.entries()) {
      for (const [colIdx2, expectedCell] of expectedRow.entries()) {
        const actualCell = actual.data[rowIdx2]?.cells[colIdx2];
        if (expectedCell.text !== undefined) {
          assertions.push(createAssertion(`${basePath}.table.cells[${rowIdx2}][${colIdx2}].text`, expectedCell.text, actualCell?.text));
        }
      }
    }
  }
  return assertions;
}
function matchContent(expected, actual, basePath) {
  const assertions = [];
  if (!expected) {
    return assertions;
  }
  if (!actual) {
    assertions.push(createAssertion(`${basePath}.content`, expected, undefined));
    return assertions;
  }
  if (expected.type !== undefined) {
    assertions.push(createAssertion(`${basePath}.content.type`, expected.type, actual.type));
  }
  if (expected.table !== undefined && actual.type === "table") {
    assertions.push(...matchTableContent(expected.table, actual.table, basePath));
  }
  return assertions;
}
function matchShape(expected, actual, basePath) {
  const assertions = [];
  if (expected.type !== undefined) {
    assertions.push(createAssertion(`${basePath}.type`, expected.type, actual.type));
  }
  if (expected.bounds !== undefined) {
    assertions.push(...matchBounds(expected.bounds, actual.bounds, basePath));
  }
  if (expected.rotation !== undefined) {
    assertions.push(createAssertion(`${basePath}.rotation`, expected.rotation, actual.rotation));
  }
  if (expected.flipH !== undefined) {
    assertions.push(createAssertion(`${basePath}.flipH`, expected.flipH, actual.flipH));
  }
  if (expected.flipV !== undefined) {
    assertions.push(createAssertion(`${basePath}.flipV`, expected.flipV, actual.flipV));
  }
  if (expected.geometry !== undefined) {
    assertions.push(...matchGeometry(expected.geometry, actual.geometry, basePath));
  }
  if (expected.fill !== undefined) {
    assertions.push(...matchFill(expected.fill, actual.fill, basePath));
  }
  if (expected.line !== undefined) {
    assertions.push(...matchLine(expected.line, actual.line, basePath));
  }
  if (expected.effects !== undefined) {
    assertions.push(...matchEffects(expected.effects, actual.effects, basePath));
  }
  if (expected.shape3d !== undefined) {
    assertions.push(...matchShape3d(expected.shape3d, actual.shape3d, basePath));
  }
  if (expected.text !== undefined) {
    assertions.push(createAssertion(`${basePath}.text`, expected.text, actual.text));
  }
  if (expected.content !== undefined) {
    assertions.push(...matchContent(expected.content, actual.content, basePath));
  }
  return assertions;
}
function resolveShapeIndex(index, shapes) {
  if (index < 0) {
    return shapes.length + index;
  }
  return index;
}
async function matchSlide(expected, pptxPath) {
  const showResult = await runShow(pptxPath, expected.slideNumber);
  if (!showResult.success) {
    return { assertions: [], error: showResult.error.message };
  }
  const slide = showResult.data;
  const assertions = [];
  const basePath = `slides[${expected.slideNumber - 1}]`;
  if (expected.shapeCount !== undefined) {
    assertions.push(createAssertion(`${basePath}.shapeCount`, expected.shapeCount, slide.shapes.length));
  }
  if (expected.shapes) {
    for (const expectedShape of expected.shapes) {
      const shapeIndex = resolveShapeIndex(expectedShape.index, slide.shapes);
      const actualShape = slide.shapes[shapeIndex];
      const shapePath = `${basePath}.shapes[${shapeIndex}]`;
      if (!actualShape) {
        assertions.push(createAssertion(shapePath, expectedShape, undefined));
      } else {
        assertions.push(...matchShape(expectedShape, actualShape, shapePath));
      }
    }
  }
  return { assertions };
}
async function runTestCase(spec, specDir) {
  const assertions = [];
  const input = {
    ...spec.input,
    template: path5.resolve(specDir, spec.input.template),
    output: path5.resolve(specDir, spec.input.output)
  };
  await fs4.mkdir(path5.dirname(input.output), { recursive: true });
  const tempSpecPath = path5.join(path5.dirname(input.output), `${spec.name}.build.json`);
  await fs4.writeFile(tempSpecPath, JSON.stringify(input, null, 2));
  try {
    const buildResult = await runBuild(tempSpecPath);
    if (!buildResult.success) {
      return {
        name: spec.name,
        passed: false,
        assertions: [createAssertion("build", "success", buildResult.error.message)]
      };
    }
    if (spec.expected.slideCount !== undefined) {
      assertions.push(createAssertion("slideCount", spec.expected.slideCount, buildResult.data.slideCount));
    }
    if (spec.expected.slides) {
      for (const expectedSlide of spec.expected.slides) {
        const slideResult = await matchSlide(expectedSlide, input.output);
        if (slideResult.error) {
          assertions.push(createAssertion(`slides[${expectedSlide.slideNumber - 1}]`, "readable", slideResult.error));
        } else {
          assertions.push(...slideResult.assertions);
        }
      }
    }
    const passed = assertions.every((a) => a.passed);
    return { name: spec.name, passed, assertions };
  } finally {
    await fs4.unlink(tempSpecPath).catch(() => {});
  }
}
async function findTestCaseFiles(targetPath) {
  const stat2 = await fs4.stat(targetPath);
  if (stat2.isFile()) {
    return [targetPath];
  }
  const entries = await fs4.readdir(targetPath, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    if (entry.isFile() && entry.name.endsWith(".json") && !entry.name.includes(".build.")) {
      files.push(path5.join(targetPath, entry.name));
    } else if (entry.isDirectory() && !entry.name.startsWith("__") && !entry.name.startsWith(".")) {
      const subFiles = await findTestCaseFiles(path5.join(targetPath, entry.name));
      files.push(...subFiles);
    }
  }
  return files.sort();
}
async function loadTestCase(filePath) {
  const content = await fs4.readFile(filePath, "utf-8");
  return JSON.parse(content);
}
async function runVerify(specPath, options = {}) {
  try {
    const absolutePath = path5.resolve(specPath);
    const files = await findTestCaseFiles(absolutePath);
    if (files.length === 0) {
      return error("NO_TEST_CASES", `No test case files found in: ${specPath}`);
    }
    const results = [];
    for (const file of files) {
      const spec = await loadTestCase(file);
      if (options.tag && !spec.tags?.includes(options.tag)) {
        continue;
      }
      const specDir = path5.dirname(file);
      const result = await runTestCase(spec, specDir);
      results.push(result);
    }
    if (results.length === 0) {
      return error("NO_MATCHING_TESTS", `No test cases matched tag: ${options.tag}`);
    }
    const passed = results.filter((r) => r.passed).length;
    const failed = results.length - passed;
    return success({ passed, failed, results });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `Path not found: ${specPath}`);
    }
    if (err2 instanceof SyntaxError) {
      return error("INVALID_JSON", `Invalid JSON: ${err2.message}`);
    }
    return error("VERIFY_ERROR", `Verification failed: ${err2.message}`);
  }
}

// packages/@oxen-office/pptx/src/domain/resource-store.ts
function createResourceStore() {
  const store = new Map;
  return {
    get(id) {
      return store.get(id);
    },
    set(id, entry) {
      store.set(id, entry);
    },
    has(id) {
      return store.has(id);
    },
    keys() {
      return store.keys();
    },
    toDataUrl(id) {
      const entry = store.get(id);
      if (!entry?.data || !entry.mimeType) {
        return;
      }
      return toDataUrl(entry.data, entry.mimeType);
    },
    *getBySlide(slideId) {
      for (const [id, entry] of store) {
        if (entry.slideId === slideId) {
          yield id;
        }
      }
    },
    releaseSlide(slideId) {
      for (const [id, entry] of store) {
        if (entry.slideId === slideId) {
          store.delete(id);
        }
      }
    }
  };
}

// packages/@oxen-renderer/drawing-ml/src/ascii/ascii-canvas.ts
var BOX_CHARS = {
  topLeft: "\u250C",
  topRight: "\u2510",
  bottomLeft: "\u2514",
  bottomRight: "\u2518",
  horizontal: "\u2500",
  vertical: "\u2502"
};
var TABLE_CHARS = {
  ...BOX_CHARS,
  topTee: "\u252C",
  bottomTee: "\u2534",
  leftTee: "\u251C",
  rightTee: "\u2524",
  cross: "\u253C"
};
function createCanvas(width, height) {
  const cells = [];
  for (let row = 0;row < height; row++) {
    const rowCells = [];
    for (let col = 0;col < width; col++) {
      rowCells.push({ char: " ", z: 0 });
    }
    cells.push(rowCells);
  }
  return { width, height, cells };
}
function setCell(params) {
  const { canvas, col, row, char, z } = params;
  if (col < 0 || col >= canvas.width || row < 0 || row >= canvas.height) {
    return;
  }
  const cell = canvas.cells[row][col];
  if (z >= cell.z) {
    cell.char = char;
    cell.z = z;
  }
}
function drawBox(params) {
  const { canvas, col, row, w, h, z } = params;
  if (w < 2 || h < 2) {
    if (w >= 1 && h >= 1) {
      setCell({ canvas, col, row, char: "+", z });
    }
    return;
  }
  setCell({ canvas, col, row, char: BOX_CHARS.topLeft, z });
  setCell({ canvas, col: col + w - 1, row, char: BOX_CHARS.topRight, z });
  setCell({ canvas, col, row: row + h - 1, char: BOX_CHARS.bottomLeft, z });
  setCell({ canvas, col: col + w - 1, row: row + h - 1, char: BOX_CHARS.bottomRight, z });
  for (let c = col + 1;c < col + w - 1; c++) {
    setCell({ canvas, col: c, row, char: BOX_CHARS.horizontal, z });
    setCell({ canvas, col: c, row: row + h - 1, char: BOX_CHARS.horizontal, z });
  }
  for (let r = row + 1;r < row + h - 1; r++) {
    setCell({ canvas, col, row: r, char: BOX_CHARS.vertical, z });
    setCell({ canvas, col: col + w - 1, row: r, char: BOX_CHARS.vertical, z });
  }
}
function drawText(params) {
  const { canvas, col, row, text, maxLen, z } = params;
  if (maxLen <= 0) {
    return;
  }
  const truncated = truncateText(text, maxLen);
  for (let i2 = 0;i2 < truncated.length; i2++) {
    setCell({ canvas, col: col + i2, row, char: truncated[i2], z });
  }
}
function truncateText(text, maxLen) {
  if (text.length <= maxLen) {
    return text;
  }
  if (maxLen <= 3) {
    return text.substring(0, maxLen);
  }
  return text.substring(0, maxLen - 3) + "...";
}
function renderCanvas(canvas) {
  const lines = [];
  for (const row of canvas.cells) {
    const line = row.map((cell) => cell.char).join("");
    lines.push(line.trimEnd());
  }
  while (lines.length > 0 && lines[lines.length - 1] === "") {
    lines.pop();
  }
  return lines.join(`
`);
}
// packages/@oxen-renderer/drawing-ml/src/ascii/coordinate-mapper.ts
var CHAR_ASPECT_RATIO = 2;
function createMapperConfig(slideWidth, slideHeight, terminalWidth) {
  const gridWidth = terminalWidth;
  const pixelsPerCol = slideWidth / gridWidth;
  const pixelsPerRow = pixelsPerCol * CHAR_ASPECT_RATIO;
  const gridHeight = Math.max(1, Math.round(slideHeight / pixelsPerRow));
  return { slideWidth, slideHeight, gridWidth, gridHeight };
}
function mapBoundsToGrid(config, bounds) {
  const scaleX = config.gridWidth / config.slideWidth;
  const scaleY = config.gridHeight / config.slideHeight;
  const col = Math.round(bounds.x * scaleX);
  const row = Math.round(bounds.y * scaleY);
  const right = Math.round((bounds.x + bounds.width) * scaleX);
  const bottom = Math.round((bounds.y + bounds.height) * scaleY);
  const clampedCol = Math.max(0, Math.min(col, config.gridWidth - 1));
  const clampedRow = Math.max(0, Math.min(row, config.gridHeight - 1));
  const clampedRight = Math.max(clampedCol + 1, Math.min(right, config.gridWidth));
  const clampedBottom = Math.max(clampedRow + 1, Math.min(bottom, config.gridHeight));
  const w = clampedRight - clampedCol;
  const h = clampedBottom - clampedRow;
  if (w < 1 || h < 1) {
    return;
  }
  return { col: clampedCol, row: clampedRow, width: w, height: h };
}
// packages/@oxen-renderer/drawing-ml/src/ascii/text-utils.ts
function wrapText(text, width) {
  if (width <= 0) {
    return [];
  }
  const lines = [];
  const paragraphs = text.split(`
`);
  for (const paragraph of paragraphs) {
    if (paragraph.length === 0) {
      lines.push("");
      continue;
    }
    const words = paragraph.split(/\s+/);
    let currentLine = "";
    for (const word of words) {
      if (word.length === 0) {
        continue;
      }
      if (currentLine.length === 0) {
        if (word.length > width) {
          for (let i2 = 0;i2 < word.length; i2 += width) {
            lines.push(word.substring(i2, i2 + width));
          }
          currentLine = "";
          if (lines.length > 0 && lines[lines.length - 1].length < width) {
            currentLine = lines.pop();
          }
        } else {
          currentLine = word;
        }
      } else if (currentLine.length + 1 + word.length <= width) {
        currentLine += " " + word;
      } else {
        lines.push(currentLine);
        if (word.length > width) {
          for (let i2 = 0;i2 < word.length; i2 += width) {
            lines.push(word.substring(i2, i2 + width));
          }
          currentLine = "";
          if (lines.length > 0 && lines[lines.length - 1].length < width) {
            currentLine = lines.pop();
          }
        } else {
          currentLine = word;
        }
      }
    }
    if (currentLine.length > 0) {
      lines.push(currentLine);
    }
  }
  return lines;
}
// packages/@oxen-renderer/drawing-ml/src/ascii/table-renderer.ts
function computeColumnWidths(params) {
  if (params.columnWidths) {
    return params.columnWidths;
  }
  const colCount = Math.max(params.headers?.length ?? 0, ...params.rows.map((r) => r.length));
  if (colCount === 0) {
    return [];
  }
  const widths = new Array(colCount).fill(0);
  if (params.headers) {
    for (let c = 0;c < params.headers.length; c++) {
      widths[c] = Math.max(widths[c], params.headers[c].length);
    }
  }
  for (const row of params.rows) {
    for (let c = 0;c < row.length; c++) {
      if (c < widths.length) {
        widths[c] = Math.max(widths[c], row[c].length);
      }
    }
  }
  const borderOverhead = colCount + 1 + colCount * 2;
  const availableContent = params.maxWidth - borderOverhead;
  if (availableContent <= 0) {
    return widths.map(() => 1);
  }
  const totalContent = widths.reduce((a, b) => a + b, 0);
  if (totalContent <= availableContent) {
    return widths;
  }
  const scale = availableContent / totalContent;
  return widths.map((w) => Math.max(1, Math.floor(w * scale)));
}
function padCell(text, width, alignment) {
  const truncated = truncateText(text, width);
  const padding = width - truncated.length;
  if (padding <= 0) {
    return truncated;
  }
  switch (alignment) {
    case "right":
      return " ".repeat(padding) + truncated;
    case "center": {
      const left = Math.floor(padding / 2);
      const right = padding - left;
      return " ".repeat(left) + truncated + " ".repeat(right);
    }
    default:
      return truncated + " ".repeat(padding);
  }
}
function drawHorizontalLine(widths, left, middle, right) {
  return left + widths.map((w) => TABLE_CHARS.horizontal.repeat(w + 2)).join(middle) + right;
}
function drawDataRow(cells, widths, alignments) {
  const parts = [];
  for (let c = 0;c < widths.length; c++) {
    const text = c < cells.length ? cells[c] : "";
    const align = c < alignments.length ? alignments[c] : "left";
    parts.push(" " + padCell(text, widths[c], align) + " ");
  }
  return TABLE_CHARS.vertical + parts.join(TABLE_CHARS.vertical) + TABLE_CHARS.vertical;
}
function renderAsciiTable(params) {
  const widths = computeColumnWidths(params);
  if (widths.length === 0) {
    return "";
  }
  const colCount = widths.length;
  const alignments = [];
  for (let c = 0;c < colCount; c++) {
    alignments.push(params.alignments && c < params.alignments.length ? params.alignments[c] : "left");
  }
  const lines = [];
  lines.push(drawHorizontalLine(widths, TABLE_CHARS.topLeft, TABLE_CHARS.topTee, TABLE_CHARS.topRight));
  if (params.headers) {
    lines.push(drawDataRow(params.headers, widths, alignments));
    lines.push(drawHorizontalLine(widths, TABLE_CHARS.leftTee, TABLE_CHARS.cross, TABLE_CHARS.rightTee));
  }
  for (const row of params.rows) {
    lines.push(drawDataRow(row, widths, alignments));
  }
  lines.push(drawHorizontalLine(widths, TABLE_CHARS.bottomLeft, TABLE_CHARS.bottomTee, TABLE_CHARS.bottomRight));
  return lines.join(`
`);
}
// packages/@oxen-renderer/chart/src/ascii/bar-renderer.ts
var BAR_CHAR = "\u2588";
function renderBarAscii(params) {
  const { series, width } = params;
  if (series.length === 0) {
    return "";
  }
  const firstSeries = series[0];
  const categories = firstSeries.categories ?? firstSeries.values.map((_, i2) => `${i2 + 1}`);
  const values = firstSeries.values;
  if (values.length === 0) {
    return "";
  }
  const maxValue = Math.max(...values, 0);
  const maxLabelLen = Math.max(...categories.map((c) => c.length), 1);
  const valueStrings = values.map((v) => String(v));
  const maxValueLen = Math.max(...valueStrings.map((v) => v.length), 1);
  const barMaxWidth = Math.max(1, width - maxLabelLen - maxValueLen - 3);
  const lines = [];
  for (let i2 = 0;i2 < values.length; i2++) {
    const label = truncateText(categories[i2] ?? `${i2 + 1}`, maxLabelLen);
    const paddedLabel = label.padEnd(maxLabelLen);
    const value = values[i2];
    const barWidth = maxValue > 0 ? Math.round(value / maxValue * barMaxWidth) : 0;
    const bar = BAR_CHAR.repeat(barWidth);
    lines.push(`${paddedLabel} ${bar} ${valueStrings[i2]}`);
  }
  for (let s = 1;s < series.length; s++) {
    const ser = series[s];
    const serCats = ser.categories ?? ser.values.map((_, i2) => `${i2 + 1}`);
    if (ser.name) {
      lines.push("");
      lines.push(`[${ser.name}]`);
    }
    const serMax = Math.max(...ser.values, 0);
    for (let i2 = 0;i2 < ser.values.length; i2++) {
      const label = truncateText(serCats[i2] ?? `${i2 + 1}`, maxLabelLen);
      const paddedLabel = label.padEnd(maxLabelLen);
      const value = ser.values[i2];
      const barWidth = serMax > 0 ? Math.round(value / serMax * barMaxWidth) : 0;
      const bar = BAR_CHAR.repeat(barWidth);
      lines.push(`${paddedLabel} ${bar} ${value}`);
    }
  }
  return lines.join(`
`);
}

// packages/@oxen-renderer/chart/src/ascii/line-renderer.ts
var POINT_CHAR = "*";
var LINE_CHARS = { horizontal: "\u2500", vertical: "\u2502", corner: "\u2514" };
function renderLineAscii(params) {
  const { series, width } = params;
  if (series.length === 0 || series[0].values.length === 0) {
    return "";
  }
  const firstSeries = series[0];
  const categories = firstSeries.categories ?? firstSeries.values.map((_, i2) => `${i2 + 1}`);
  const allValues = series.flatMap((s) => [...s.values]);
  const maxVal = Math.max(...allValues, 0);
  const minVal = Math.min(...allValues, 0);
  const range2 = maxVal - minVal || 1;
  const labelWidth = Math.max(String(Math.round(maxVal)).length, String(Math.round(minVal)).length) + 1;
  const chartWidth = Math.max(1, width - labelWidth - 1);
  const chartHeight = Math.min(15, Math.max(5, Math.floor(chartWidth / 3)));
  const canvasWidth = labelWidth + 1 + chartWidth;
  const canvasHeight = chartHeight + 2;
  const canvas = createCanvas(canvasWidth, canvasHeight);
  for (let r = 0;r < chartHeight; r++) {
    setCell({ canvas, col: labelWidth, row: r, char: LINE_CHARS.vertical, z: 1 });
  }
  setCell({ canvas, col: labelWidth, row: chartHeight, char: LINE_CHARS.corner, z: 1 });
  for (let c = labelWidth + 1;c < canvasWidth; c++) {
    setCell({ canvas, col: c, row: chartHeight, char: LINE_CHARS.horizontal, z: 1 });
  }
  const topLabel = String(Math.round(maxVal));
  for (let i2 = 0;i2 < topLabel.length && i2 < labelWidth; i2++) {
    setCell({ canvas, col: labelWidth - topLabel.length + i2, row: 0, char: topLabel[i2], z: 1 });
  }
  const midVal = Math.round((maxVal + minVal) / 2);
  const midLabel = String(midVal);
  const midRow = Math.floor(chartHeight / 2);
  for (let i2 = 0;i2 < midLabel.length && i2 < labelWidth; i2++) {
    setCell({ canvas, col: labelWidth - midLabel.length + i2, row: midRow, char: midLabel[i2], z: 1 });
  }
  const numPoints = firstSeries.values.length;
  const xStep = numPoints > 1 ? (chartWidth - 1) / (numPoints - 1) : 0;
  for (let i2 = 0;i2 < categories.length; i2++) {
    const xPos = labelWidth + 1 + Math.round(i2 * xStep);
    const cat = categories[i2];
    for (let c = 0;c < cat.length && xPos + c < canvasWidth; c++) {
      setCell({ canvas, col: xPos + c, row: chartHeight + 1, char: cat[c], z: 1 });
    }
  }
  const seriesChars = [POINT_CHAR, "o", "+", "x"];
  for (let s = 0;s < series.length; s++) {
    const ser = series[s];
    const pointChar = seriesChars[s % seriesChars.length];
    let prevX = -1;
    let prevY = -1;
    for (let i2 = 0;i2 < ser.values.length; i2++) {
      const value = ser.values[i2];
      const xPos = labelWidth + 1 + Math.round(i2 * xStep);
      const yPos = chartHeight - 1 - Math.round((value - minVal) / range2 * (chartHeight - 1));
      if (prevX >= 0 && prevY >= 0) {
        const dx = xPos - prevX;
        const dy = yPos - prevY;
        const steps = Math.max(Math.abs(dx), Math.abs(dy));
        for (let step = 1;step < steps; step++) {
          const ix = Math.round(prevX + dx * step / steps);
          const iy = Math.round(prevY + dy * step / steps);
          if (iy >= 0 && iy < chartHeight) {
            const lineChar = Math.abs(dy) > Math.abs(dx) ? "|" : dy < 0 ? "/" : "\\";
            setCell({ canvas, col: ix, row: iy, char: lineChar, z: 2 });
          }
        }
      }
      if (yPos >= 0 && yPos < chartHeight) {
        setCell({ canvas, col: xPos, row: yPos, char: pointChar, z: 3 });
      }
      prevX = xPos;
      prevY = yPos;
    }
  }
  return renderCanvas(canvas);
}

// packages/@oxen-renderer/chart/src/ascii/pie-renderer.ts
var PIE_MARKERS = ["\u25A0", "\u25A1", "\u25AA", "\u25AB", "\u25CF", "\u25CB", "\u25C6", "\u25C7"];
var BAR_CHAR2 = "\u2588";
function renderPieAscii(params) {
  const { series, width } = params;
  if (series.length === 0) {
    return "";
  }
  const firstSeries = series[0];
  const categories = firstSeries.categories ?? firstSeries.values.map((_, i2) => `Item ${i2 + 1}`);
  const values = firstSeries.values;
  if (values.length === 0) {
    return "";
  }
  const total = values.reduce((a, b) => a + Math.abs(b), 0);
  if (total === 0) {
    return "(no data)";
  }
  const maxCatLen = Math.max(...categories.map((c) => c.length), 1);
  const pctWidth = 7;
  const barMaxWidth = Math.max(1, width - maxCatLen - pctWidth - 4);
  const lines = [];
  for (let i2 = 0;i2 < values.length; i2++) {
    const marker = PIE_MARKERS[i2 % PIE_MARKERS.length];
    const label = truncateText(categories[i2] ?? `Item ${i2 + 1}`, maxCatLen);
    const paddedLabel = label.padEnd(maxCatLen);
    const pct3 = Math.abs(values[i2]) / total * 100;
    const pctStr = pct3.toFixed(1).padStart(5) + "%";
    const barWidth = Math.round(Math.abs(values[i2]) / total * barMaxWidth);
    const bar = BAR_CHAR2.repeat(barWidth);
    lines.push(`${marker} ${paddedLabel}  ${pctStr}  ${bar}`);
  }
  return lines.join(`
`);
}

// packages/@oxen-renderer/chart/src/ascii/chart-renderer.ts
function renderChartAscii(params) {
  const { series, chartType, title, width } = params;
  const lines = [];
  if (title) {
    lines.push(title);
    lines.push("\u2500".repeat(Math.min(title.length + 4, width)));
  }
  let chart;
  switch (chartType) {
    case "line":
    case "area":
      chart = renderLineAscii({ series, width });
      break;
    case "pie":
      chart = renderPieAscii({ series, width });
      break;
    case "bar":
    case "scatter":
    case "radar":
    case "other":
    default:
      chart = renderBarAscii({ series, width });
      break;
  }
  if (chart) {
    lines.push(chart);
  }
  return lines.join(`
`);
}
// packages/@oxen-renderer/chart/src/ascii/data-extractor.ts
function normalizeChartType(type) {
  if (!type) {
    return "other";
  }
  const lower = type.toLowerCase();
  if (lower.includes("bar") || lower.includes("col")) {
    return "bar";
  }
  if (lower.includes("line")) {
    return "line";
  }
  if (lower.includes("pie") || lower.includes("doughnut")) {
    return "pie";
  }
  if (lower.includes("scatter") || lower.includes("bubble")) {
    return "scatter";
  }
  if (lower.includes("area")) {
    return "area";
  }
  if (lower.includes("radar")) {
    return "radar";
  }
  return "other";
}
function extractChartData(chart) {
  const chartType = normalizeChartType(chart.chartType);
  const seriesData = [];
  if (chart.series) {
    for (const s of chart.series) {
      const values = (s.values ?? []).map((v) => typeof v === "number" ? v : 0);
      const categories = s.categories ? s.categories.map((c) => c != null ? String(c) : "") : undefined;
      seriesData.push({
        name: s.name ?? undefined,
        values,
        categories
      });
    }
  }
  return { series: seriesData, chartType, title: chart.title };
}
// packages/@oxen-renderer/pptx/src/ascii/slide-renderer.ts
function renderTableLines(content, interiorWidth) {
  const table = "table" in content ? content.table : undefined;
  if (!table || table.data.length === 0)
    return ["{table}"];
  const headers = table.data[0]?.cells.map((c) => c.text);
  const rows = table.data.slice(1).map((r) => r.cells.map((c) => c.text));
  const rendered = renderAsciiTable({
    headers,
    rows,
    maxWidth: interiorWidth
  });
  return rendered.split(`
`);
}
function renderChartLines(content, interiorWidth) {
  const chart = "chart" in content ? content.chart : undefined;
  if (!chart?.series || chart.series.length === 0)
    return ["{chart}"];
  const extracted = extractChartData({
    title: chart.title,
    chartType: chart.chartType,
    series: chart.series.map((s) => ({
      name: s.name,
      values: s.values?.map((v) => v ?? 0),
      categories: s.categories
    }))
  });
  const rendered = renderChartAscii({
    ...extracted,
    width: interiorWidth
  });
  return rendered.split(`
`);
}
function renderDiagramLines(content) {
  const diagram = "diagram" in content ? content.diagram : undefined;
  if (!diagram?.shapes || diagram.shapes.length === 0)
    return ["{diagram}"];
  const lines = ["[diagram]"];
  for (const shape of diagram.shapes) {
    if (shape.text) {
      lines.push(`  ${shape.text}`);
    }
  }
  return lines;
}
function getShapeLines(shape, interiorWidth) {
  if (shape.text) {
    const lines = shape.text.split(`
`).map((l) => l.trim()).filter((l) => l.length > 0);
    if (lines.length > 0) {
      return lines;
    }
  }
  if (shape.placeholder?.type) {
    return [`[${shape.placeholder.type}]`];
  }
  if (shape.content) {
    switch (shape.content.type) {
      case "table":
        return renderTableLines(shape.content, interiorWidth);
      case "chart":
        return renderChartLines(shape.content, interiorWidth);
      case "diagram":
        return renderDiagramLines(shape.content);
      default:
        return [`{${shape.content.type}}`];
    }
  }
  if (shape.type === "pic") {
    return ["[image]"];
  }
  if (shape.type === "cxnSp") {
    return ["[connector]"];
  }
  if (shape.type === "grpSp") {
    return ["[group]"];
  }
  return [shape.name];
}
function flattenShapes(shapes) {
  const result = [];
  for (const shape of shapes) {
    if (shape.type === "grpSp" && shape.children) {
      result.push(shape);
      result.push(...flattenShapes(shape.children));
    } else {
      result.push(shape);
    }
  }
  return result;
}
function renderSlideAscii(params) {
  const { shapes, slideWidth, slideHeight, terminalWidth, showBorder } = params;
  const config = createMapperConfig(slideWidth, slideHeight, terminalWidth);
  const canvas = createCanvas(config.gridWidth, config.gridHeight);
  if (showBorder) {
    drawBox({ canvas, col: 0, row: 0, w: config.gridWidth, h: config.gridHeight, z: 0 });
  }
  const flatShapes = flattenShapes(shapes);
  for (let i2 = 0;i2 < flatShapes.length; i2++) {
    const shape = flatShapes[i2];
    if (!shape.bounds) {
      continue;
    }
    const gridRect = mapBoundsToGrid(config, shape.bounds);
    if (!gridRect) {
      continue;
    }
    const z = i2 + 1;
    const isInlineContent = shape.content?.type === "table" || shape.content?.type === "chart";
    if (!isInlineContent) {
      drawBox({ canvas, col: gridRect.col, row: gridRect.row, w: gridRect.width, h: gridRect.height, z });
    }
    if (gridRect.width > 2 && gridRect.height > 2) {
      const interiorWidth = isInlineContent ? gridRect.width : gridRect.width - 2;
      const interiorHeight = isInlineContent ? gridRect.height : gridRect.height - 2;
      const interiorCol = isInlineContent ? gridRect.col : gridRect.col + 1;
      const interiorRow = isInlineContent ? gridRect.row : gridRect.row + 1;
      const lines = getShapeLines(shape, interiorWidth);
      for (let lineIdx = 0;lineIdx < Math.min(lines.length, interiorHeight); lineIdx++) {
        drawText({
          canvas,
          col: interiorCol,
          row: interiorRow + lineIdx,
          text: lines[lineIdx],
          maxLen: interiorWidth,
          z
        });
      }
    }
  }
  return renderCanvas(canvas);
}
// packages/@oxen-cli/pptx-cli/src/commands/preview.ts
async function runPreview(filePath, slideNumber, options) {
  try {
    const { presentationFile } = await loadPresentationBundle(filePath);
    const presentation = openPresentation(presentationFile);
    if (slideNumber !== undefined && (slideNumber < 1 || slideNumber > presentation.count)) {
      return error("SLIDE_NOT_FOUND", `Slide ${slideNumber} not found. Valid range: 1-${presentation.count}`);
    }
    const start = slideNumber ?? 1;
    const end = slideNumber ?? presentation.count;
    const slides = [];
    const zipFile = createZipAdapter(presentationFile);
    for (let i2 = start;i2 <= end; i2++) {
      const apiSlide = presentation.getSlide(i2);
      const renderContext = createRenderContext({ apiSlide, zip: zipFile, slideSize: presentation.size });
      const parseCtx = createParseContext(renderContext.slideRenderContext);
      const domainSlide = parseSlide(apiSlide.content, parseCtx);
      if (!domainSlide) {
        continue;
      }
      const fileReader = {
        readFile: (path6) => apiSlide.zip.file(path6)?.asArrayBuffer() ?? null,
        resolveResource: (id) => apiSlide.relationships.getTarget(id),
        getResourceByType: (relType) => apiSlide.relationships.getTargetByType(relType)
      };
      const resourceStore = createResourceStore();
      const enrichedSlide = enrichSlideContent(domainSlide, fileReader, resourceStore);
      const ctx = {
        resolveChart: (resourceId) => resourceStore.get(resourceId)?.parsed,
        resolveDiagramShapes: (diagramRef) => {
          const entry = resourceStore.get(diagramRef.dataResourceId ?? "");
          return entry?.parsed?.shapes;
        }
      };
      const shapes = enrichedSlide.shapes.map((s) => serializeShape(s, ctx));
      const ascii = renderSlideAscii({
        shapes,
        slideWidth: presentation.size.width,
        slideHeight: presentation.size.height,
        terminalWidth: options.width,
        showBorder: options.border
      });
      slides.push({
        number: apiSlide.number,
        filename: apiSlide.filename,
        ascii,
        shapes,
        shapeCount: shapes.length
      });
    }
    return success({
      slides,
      slideWidth: presentation.size.width,
      slideHeight: presentation.size.height
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse PPTX: ${err2.message}`);
  }
}

// packages/@oxen-cli/pptx-cli/src/commands/inventory.ts
async function runInventory(filePath) {
  try {
    const { presentationFile } = await loadPresentationBundle(filePath);
    const presentation = openPresentation(presentationFile);
    let totalImages = 0;
    let totalTables = 0;
    let totalCharts = 0;
    let totalDiagrams = 0;
    const textOnlySlides = [];
    for (const apiSlide of presentation.slides()) {
      const domainSlide = parseSlide(apiSlide.content);
      const shapes = domainSlide?.shapes ?? [];
      const images = collectShapes(shapes, (s) => s.type === "pic" ? true : undefined);
      const tables = collectShapes(shapes, (s) => s.type === "graphicFrame" && s.content.type === "table" ? true : undefined);
      const charts = collectShapes(shapes, (s) => s.type === "graphicFrame" && s.content.type === "chart" ? true : undefined);
      const diagrams = collectShapes(shapes, (s) => s.type === "graphicFrame" && s.content.type === "diagram" ? true : undefined);
      totalImages += images.length;
      totalTables += tables.length;
      totalCharts += charts.length;
      totalDiagrams += diagrams.length;
      if (images.length === 0 && tables.length === 0 && charts.length === 0 && diagrams.length === 0) {
        textOnlySlides.push(apiSlide.number);
      }
    }
    return success({
      slides: presentation.count,
      images: totalImages,
      tables: totalTables,
      charts: totalCharts,
      diagrams: totalDiagrams,
      textOnlySlides
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse PPTX: ${err2.message}`);
  }
}

// packages/@oxen-cli/pptx-cli/src/commands/tables.ts
function getFirstCellPreview(table) {
  const firstCell = table.rows[0]?.cells[0];
  if (!firstCell?.textBody) {
    return;
  }
  const text = extractTextFromBody(firstCell.textBody).trim();
  if (!text) {
    return;
  }
  return text.length > 50 ? text.substring(0, 50) + "..." : text;
}
async function runTables(filePath, options) {
  try {
    const { presentationFile } = await loadPresentationBundle(filePath);
    const presentation = openPresentation(presentationFile);
    const slideNumbers = getSlideNumbers(options.slides, presentation.count);
    const tables = [];
    let tableIndex = 0;
    for (const slideNumber of slideNumbers) {
      const apiSlide = presentation.getSlide(slideNumber);
      const domainSlide = parseSlide(apiSlide.content);
      const shapes = domainSlide?.shapes ?? [];
      const foundTables = collectShapes(shapes, (s) => {
        if (s.type === "graphicFrame" && s.content.type === "table") {
          return s.content.data.table;
        }
        return;
      });
      for (const table of foundTables) {
        const summary = {
          slideNumber,
          index: tableIndex,
          rowCount: table.rows.length,
          colCount: table.grid.columns.length,
          ...table.properties.tableStyleId && { styleId: table.properties.tableStyleId },
          ...(() => {
            const preview = getFirstCellPreview(table);
            return preview ? { firstCellPreview: preview } : {};
          })()
        };
        tables.push(summary);
        tableIndex++;
      }
    }
    return success({ count: tables.length, tables });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse PPTX: ${err2.message}`);
  }
}

// packages/@oxen-cli/pptx-cli/src/commands/images.ts
async function runImages(filePath, options) {
  try {
    const { presentationFile } = await loadPresentationBundle(filePath);
    const presentation = openPresentation(presentationFile);
    const slideNumbers = getSlideNumbers(options.slides, presentation.count);
    const images = [];
    let imageIndex = 0;
    for (const slideNumber of slideNumbers) {
      const apiSlide = presentation.getSlide(slideNumber);
      const domainSlide = parseSlide(apiSlide.content);
      const shapes = domainSlide?.shapes ?? [];
      const picShapes = collectShapes(shapes, (s) => s.type === "pic" ? s : undefined);
      for (const pic of picShapes) {
        const entry = {
          slideNumber,
          index: imageIndex,
          resourceId: pic.blipFill.resourceId,
          ...pic.nonVisual.name && { name: pic.nonVisual.name },
          ...pic.nonVisual.description && { description: pic.nonVisual.description },
          ...pic.properties.transform?.width != null && { width: Math.round(pic.properties.transform.width) },
          ...pic.properties.transform?.height != null && { height: Math.round(pic.properties.transform.height) },
          ...pic.mediaType && { mediaType: pic.mediaType }
        };
        images.push(entry);
        imageIndex++;
      }
    }
    return success({ count: images.length, images });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse PPTX: ${err2.message}`);
  }
}

// packages/@oxen-cli/pptx-cli/src/commands/diff.ts
function collectAllText2(shapes) {
  const texts = [];
  for (const shape of shapes) {
    const text = extractTextFromShape(shape).trim();
    if (text) {
      texts.push(text);
    }
    if (shape.type === "grpSp") {
      texts.push(...collectAllText2(shape.children));
    }
  }
  return texts;
}
async function extractSlideTexts(filePath) {
  const { presentationFile } = await loadPresentationBundle(filePath);
  const presentation = openPresentation(presentationFile);
  const texts = [];
  for (const apiSlide of presentation.slides()) {
    const domainSlide = parseSlide(apiSlide.content);
    const shapes = domainSlide?.shapes ?? [];
    texts.push(collectAllText2(shapes).join(`
`));
  }
  return texts;
}
async function runDiff(fileA, fileB) {
  let textsA;
  try {
    textsA = await extractSlideTexts(fileA);
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${fileA}`);
    }
    return error("PARSE_ERROR", `Failed to parse PPTX: ${fileA}: ${err2.message}`);
  }
  let textsB;
  try {
    textsB = await extractSlideTexts(fileB);
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${fileB}`);
    }
    return error("PARSE_ERROR", `Failed to parse PPTX: ${fileB}: ${err2.message}`);
  }
  const commonCount = Math.min(textsA.length, textsB.length);
  const identicalSlides = [];
  const diffSlides = [];
  for (let i2 = 0;i2 < commonCount; i2++) {
    if (textsA[i2] === textsB[i2]) {
      identicalSlides.push(i2 + 1);
    } else {
      diffSlides.push(i2 + 1);
    }
  }
  const result = {
    fileA,
    fileB,
    slideCountA: textsA.length,
    slideCountB: textsB.length,
    identicalSlides,
    diffSlides,
    ...textsB.length > textsA.length && {
      addedSlides: Array.from({ length: textsB.length - textsA.length }, (_, i2) => textsA.length + i2 + 1)
    },
    ...textsA.length > textsB.length && {
      removedSlides: Array.from({ length: textsA.length - textsB.length }, (_, i2) => textsB.length + i2 + 1)
    }
  };
  return success(result);
}

// packages/@oxen-cli/pptx-cli/src/output/pretty-output.ts
function getSlideFlags(slide) {
  const flags = [];
  if (slide.hasTable) {
    flags.push("table");
  }
  if (slide.hasChart) {
    flags.push("chart");
  }
  if (slide.hasImage) {
    flags.push("image");
  }
  if (slide.transitionType && slide.transitionType !== "none") {
    flags.push(`transition:${slide.transitionType}`);
  }
  return flags;
}
function formatInfoPretty(data) {
  const lines = [];
  lines.push(`Slides: ${data.slideCount}`);
  lines.push(`Size: ${data.slideSize.width}x${data.slideSize.height} pixels`);
  lines.push(`EMU: ${data.slideSize.widthEmu}x${data.slideSize.heightEmu}`);
  if (data.appVersion !== null) {
    lines.push(`App Version: ${data.appVersion}`);
  }
  return lines.join(`
`);
}
function formatListPretty(data) {
  const lines = [];
  for (const slide of data.slides) {
    const parts = [`#${slide.number}`];
    if (slide.title) {
      parts.push(`"${slide.title}"`);
    }
    parts.push(`(${slide.shapeCount} shapes)`);
    const flags = getSlideFlags(slide);
    if (flags.length > 0) {
      parts.push(`[${flags.join(", ")}]`);
    }
    lines.push(parts.join(" "));
  }
  return lines.join(`
`);
}
function formatShowPretty(data) {
  const lines = [];
  lines.push(`Slide ${data.number} (${data.filename})`);
  if (data.transition && data.transition.type !== "none") {
    lines.push(`Transition: ${data.transition.type}`);
  }
  lines.push(`Shapes: ${data.shapes.length}`);
  if (data.charts && data.charts.length > 0) {
    lines.push(`Charts: ${data.charts.length}`);
  }
  lines.push("");
  for (const shape of data.shapes) {
    const typePart = shape.placeholder ? `[${shape.placeholder.type ?? "ph"}]` : `(${shape.type})`;
    lines.push(`  ${shape.id}: ${shape.name} ${typePart}`);
    if (shape.text) {
      const preview = shape.text.length > 60 ? shape.text.substring(0, 60) + "..." : shape.text;
      lines.push(`      "${preview}"`);
    }
  }
  if (data.charts && data.charts.length > 0) {
    lines.push("");
    lines.push("Charts:");
    for (const c of data.charts) {
      if (c.error) {
        lines.push(`  ${c.resourceId}: ERROR ${c.error}`);
        continue;
      }
      const types = c.chart?.types ?? [];
      const typeLabel = types.length ? types.join(", ") : "(unknown)";
      lines.push(`  ${c.resourceId}: ${typeLabel}${c.partPath ? ` (${c.partPath})` : ""}`);
    }
  }
  return lines.join(`
`);
}
function formatExtractPretty(data) {
  const lines = [];
  for (const slide of data.slides) {
    lines.push(`--- Slide ${slide.number} ---`);
    lines.push(slide.text);
    lines.push("");
  }
  return lines.join(`
`).trimEnd();
}
function formatFont(label, font) {
  const parts = [];
  if (font.latin) {
    parts.push(`Latin: ${font.latin}`);
  }
  if (font.eastAsian) {
    parts.push(`EA: ${font.eastAsian}`);
  }
  if (font.complexScript) {
    parts.push(`CS: ${font.complexScript}`);
  }
  return `  ${label}: ${parts.length > 0 ? parts.join(", ") : "(none)"}`;
}
function formatThemePretty(data) {
  const lines = [];
  lines.push("Font Scheme:");
  lines.push(formatFont("Major", data.fontScheme.majorFont));
  lines.push(formatFont("Minor", data.fontScheme.minorFont));
  lines.push("");
  lines.push("Color Scheme:");
  for (const [name, color] of Object.entries(data.colorScheme)) {
    lines.push(`  ${name}: #${color}`);
  }
  lines.push("");
  lines.push("Format Scheme:");
  lines.push(`  Line styles: ${data.formatScheme.lineStyleCount}`);
  lines.push(`  Fill styles: ${data.formatScheme.fillStyleCount}`);
  lines.push(`  Effect styles: ${data.formatScheme.effectStyleCount}`);
  lines.push(`  Background fills: ${data.formatScheme.bgFillStyleCount}`);
  lines.push("");
  if (data.customColors.length > 0) {
    lines.push("Custom Colors:");
    for (const color of data.customColors) {
      lines.push(`  ${color.name ?? "(unnamed)"}: #${color.color ?? "?"}`);
    }
    lines.push("");
  }
  if (data.extraColorSchemeCount > 0) {
    lines.push(`Extra Color Schemes: ${data.extraColorSchemeCount}`);
    lines.push("");
  }
  const defaults = [];
  if (data.hasObjectDefaults.line) {
    defaults.push("line");
  }
  if (data.hasObjectDefaults.shape) {
    defaults.push("shape");
  }
  if (data.hasObjectDefaults.text) {
    defaults.push("text");
  }
  if (defaults.length > 0) {
    lines.push(`Object Defaults: ${defaults.join(", ")}`);
  }
  return lines.join(`
`).trimEnd();
}
function formatBuildPretty(data) {
  const lines = [];
  lines.push(`Output: ${data.outputPath}`);
  lines.push(`Slides: ${data.slideCount}`);
  lines.push(`Shapes added: ${data.shapesAdded}`);
  return lines.join(`
`);
}
function formatPreviewPretty(data) {
  const lines = [];
  for (let i2 = 0;i2 < data.slides.length; i2++) {
    const slide = data.slides[i2];
    if (i2 > 0) {
      lines.push("");
    }
    lines.push(`Slide ${slide.number} (${data.slideWidth}x${data.slideHeight}px, ${slide.shapeCount} shapes)`);
    lines.push("");
    lines.push(slide.ascii);
  }
  return lines.join(`
`);
}
function formatVerifyPretty(data) {
  const lines = [];
  const total = data.passed + data.failed;
  const status = data.failed === 0 ? "PASS" : "FAIL";
  lines.push(`${status}: ${data.passed}/${total} tests passed`);
  lines.push("");
  for (const result of data.results) {
    const icon = result.passed ? "\u2713" : "\u2717";
    lines.push(`${icon} ${result.name}`);
    if (!result.passed) {
      const failedAssertions = result.assertions.filter((a) => !a.passed);
      for (const assertion of failedAssertions) {
        lines.push(`    ${assertion.path}:`);
        lines.push(`      expected: ${JSON.stringify(assertion.expected)}`);
        lines.push(`      actual:   ${JSON.stringify(assertion.actual)}`);
      }
    }
  }
  return lines.join(`
`);
}
function formatInventoryPretty(data) {
  const lines = [];
  lines.push(`Slides: ${data.slides}`);
  lines.push(`Images: ${data.images}`);
  lines.push(`Tables: ${data.tables}`);
  lines.push(`Charts: ${data.charts}`);
  lines.push(`Diagrams: ${data.diagrams}`);
  if (data.textOnlySlides.length > 0) {
    lines.push(`Text-only slides: ${data.textOnlySlides.join(", ")}`);
  } else {
    lines.push("Text-only slides: (none)");
  }
  return lines.join(`
`);
}
function formatTablesPretty(data) {
  if (data.count === 0) {
    return "No tables found";
  }
  const lines = [`Tables: ${data.count}`, ""];
  for (const table of data.tables) {
    lines.push(`Slide ${table.slideNumber}, Table ${table.index + 1}: ${table.rowCount} rows x ${table.colCount} cols`);
    if (table.styleId) {
      lines.push(`  Style: ${table.styleId}`);
    }
    if (table.firstCellPreview) {
      lines.push(`  First cell: "${table.firstCellPreview}"`);
    }
  }
  return lines.join(`
`);
}
function formatImagesPretty(data) {
  if (data.count === 0) {
    return "No images found";
  }
  const lines = [`Images: ${data.count}`, ""];
  for (const img of data.images) {
    const name = img.name || `Image ${img.index + 1}`;
    lines.push(`Slide ${img.slideNumber} [${img.index}] ${name}`);
    if (img.description) {
      lines.push(`  Description: ${img.description}`);
    }
    if (img.width != null && img.height != null) {
      lines.push(`  Size: ${img.width} x ${img.height} px`);
    }
    lines.push(`  Resource: ${img.resourceId}`);
    if (img.mediaType) {
      lines.push(`  Media: ${img.mediaType}`);
    }
  }
  return lines.join(`
`);
}
function formatSlideRanges(numbers) {
  if (numbers.length === 0) {
    return "(none)";
  }
  const ranges = [];
  let start = numbers[0];
  let end = start;
  for (let i2 = 1;i2 < numbers.length; i2++) {
    if (numbers[i2] === end + 1) {
      end = numbers[i2];
    } else {
      ranges.push(start === end ? `${start}` : `${start}-${end}`);
      start = numbers[i2];
      end = start;
    }
  }
  ranges.push(start === end ? `${start}` : `${start}-${end}`);
  return ranges.join(", ");
}
function formatDiffPretty(data) {
  const lines = [];
  lines.push(`File A: ${data.fileA} (${data.slideCountA} slides)`);
  lines.push(`File B: ${data.fileB} (${data.slideCountB} slides)`);
  lines.push("");
  if (data.diffSlides.length === 0 && !data.addedSlides?.length && !data.removedSlides?.length) {
    lines.push("All slides identical");
  } else {
    if (data.identicalSlides.length > 0) {
      lines.push(`Identical: slides ${formatSlideRanges(data.identicalSlides)}`);
    }
    if (data.diffSlides.length > 0) {
      lines.push(`Diff: slides ${formatSlideRanges(data.diffSlides)}`);
    }
    if (data.addedSlides && data.addedSlides.length > 0) {
      lines.push(`Added in B: slides ${formatSlideRanges(data.addedSlides)}`);
    }
    if (data.removedSlides && data.removedSlides.length > 0) {
      lines.push(`Removed from A: slides ${formatSlideRanges(data.removedSlides)}`);
    }
  }
  return lines.join(`
`);
}

// packages/@oxen/mermaid/src/escape.ts
function escapeMermaidLabel(text) {
  return text.replace(/"/g, "#quot;").replace(/\n/g, " ").replace(/\r/g, "");
}
function sanitizeNodeId(id) {
  const sanitized = id.replace(/[^a-zA-Z0-9_]/g, "_");
  if (/^[0-9]/.test(sanitized)) {
    return `n${sanitized}`;
  }
  return sanitized || "node";
}
// packages/@oxen/mermaid/src/fence.ts
function wrapInMermaidFence(content) {
  return `\`\`\`mermaid
${content}
\`\`\``;
}
// packages/@oxen/mermaid/src/markdown-table.ts
function escapeCell(text) {
  return text.replace(/\|/g, "\\|").replace(/\n/g, " ");
}
function buildSeparator(columnCount, alignments) {
  const cells = [];
  for (let i2 = 0;i2 < columnCount; i2++) {
    const align = alignments?.[i2] ?? "left";
    switch (align) {
      case "right":
        cells.push("---:");
        break;
      case "center":
        cells.push(":---:");
        break;
      case "left":
      default:
        cells.push("---");
        break;
    }
  }
  return `| ${cells.join(" | ")} |`;
}
function renderMarkdownTable(params) {
  const { headers, rows, alignments } = params;
  const columnCount = headers.length;
  if (columnCount === 0) {
    return "";
  }
  const lines = [];
  const headerCells = headers.map(escapeCell);
  lines.push(`| ${headerCells.join(" | ")} |`);
  lines.push(buildSeparator(columnCount, alignments));
  for (const row of rows) {
    const cells = [];
    for (let i2 = 0;i2 < columnCount; i2++) {
      cells.push(escapeCell(i2 < row.length ? row[i2] : ""));
    }
    lines.push(`| ${cells.join(" | ")} |`);
  }
  return lines.join(`
`);
}
// packages/@oxen-builder/mermaid/src/chart-serializer.ts
function serializePie(input) {
  const lines = [];
  if (input.title) {
    lines.push(`pie title "${escapeMermaidLabel(input.title)}"`);
  } else {
    lines.push("pie");
  }
  for (const series of input.series) {
    const categories = series.categories ?? [];
    for (let i2 = 0;i2 < series.values.length; i2++) {
      const label = i2 < categories.length ? categories[i2] : `Item ${i2 + 1}`;
      lines.push(`  "${escapeMermaidLabel(label)}" : ${series.values[i2]}`);
    }
  }
  return lines.join(`
`);
}
function serializeXYChart(input) {
  const lines = [];
  lines.push("xychart-beta");
  if (input.title) {
    lines.push(`  title "${escapeMermaidLabel(input.title)}"`);
  }
  const categorySeries = input.series.find((s) => s.categories && s.categories.length > 0);
  if (categorySeries?.categories) {
    const cats = categorySeries.categories.map((c) => `"${escapeMermaidLabel(c)}"`);
    lines.push(`  x-axis [${cats.join(", ")}]`);
  }
  const isLine = input.chartType === "line" || input.chartType === "area";
  for (const series of input.series) {
    const values = series.values.map((v) => String(v));
    const keyword = isLine ? "line" : "bar";
    lines.push(`  ${keyword} [${values.join(", ")}]`);
  }
  return lines.join(`
`);
}
function serializeChartToMermaid(input) {
  if (input.series.length === 0) {
    return "";
  }
  switch (input.chartType) {
    case "pie":
      return serializePie(input);
    case "line":
    case "area":
    case "bar":
    case "scatter":
    case "radar":
    case "other":
    default:
      return serializeXYChart(input);
  }
}
// packages/@oxen-builder/mermaid/src/diagram-serializer.ts
function inferDirection(shapes) {
  if (shapes.length < 2) {
    return "TD";
  }
  const withBounds = shapes.filter((s) => s.bounds);
  if (withBounds.length < 2) {
    return "TD";
  }
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (const s of withBounds) {
    const b = s.bounds;
    minX = Math.min(minX, b.x);
    maxX = Math.max(maxX, b.x + b.width);
    minY = Math.min(minY, b.y);
    maxY = Math.max(maxY, b.y + b.height);
  }
  const spanX = maxX - minX;
  const spanY = maxY - minY;
  return spanY >= spanX ? "TD" : "LR";
}
function serializeDiagramToMermaid(input) {
  const { shapes } = input;
  if (shapes.length === 0) {
    return "";
  }
  const direction = inferDirection(shapes);
  const lines = [`flowchart ${direction}`];
  for (const shape of shapes) {
    const id = sanitizeNodeId(shape.id);
    const label = shape.text ? escapeMermaidLabel(shape.text) : id;
    lines.push(`  ${id}["${label}"]`);
  }
  if (shapes.length > 1) {
    for (let i2 = 0;i2 < shapes.length - 1; i2++) {
      const fromId = sanitizeNodeId(shapes[i2].id);
      const toId = sanitizeNodeId(shapes[i2 + 1].id);
      lines.push(`  ${fromId} --> ${toId}`);
    }
  }
  return lines.join(`
`);
}
// packages/@oxen-renderer/chart/src/mermaid/chart-renderer.ts
function renderChartMermaid(params) {
  const content = serializeChartToMermaid({
    series: params.series,
    chartType: params.chartType,
    title: params.title
  });
  if (!content) {
    return "";
  }
  return wrapInMermaidFence(content);
}
// packages/@oxen-renderer/diagram/src/mermaid/diagram-renderer.ts
function renderDiagramMermaid(params) {
  const content = serializeDiagramToMermaid({ shapes: params.shapes });
  if (!content) {
    return "";
  }
  return wrapInMermaidFence(content);
}
// packages/@oxen-renderer/pptx/src/mermaid/slide-renderer.ts
function renderTable(content) {
  const table = content.table;
  if (!table || table.data.length === 0) {
    return "";
  }
  const headers = table.data[0]?.cells.map((c) => c.text) ?? [];
  const rows = table.data.slice(1).map((r) => r.cells.map((c) => c.text));
  return renderMarkdownTable({ headers, rows });
}
function renderChart(content) {
  const chart = content.chart;
  if (!chart?.series || chart.series.length === 0) {
    return "";
  }
  const extracted = extractChartData({
    title: chart.title,
    chartType: chart.chartType,
    series: chart.series.map((s) => ({
      name: s.name,
      values: s.values?.map((v) => v ?? 0),
      categories: s.categories
    }))
  });
  return renderChartMermaid({
    series: extracted.series,
    chartType: extracted.chartType,
    title: extracted.title
  });
}
function renderDiagram(content) {
  const diagram = content.diagram;
  if (!diagram?.shapes || diagram.shapes.length === 0) {
    return "";
  }
  return renderDiagramMermaid({
    shapes: diagram.shapes.map((s, i2) => ({
      id: `shape_${i2}`,
      text: s.text,
      bounds: s.bounds
    }))
  });
}
function renderShape(shape) {
  if (shape.content) {
    switch (shape.content.type) {
      case "table":
        return renderTable(shape.content);
      case "chart":
        return renderChart(shape.content);
      case "diagram":
        return renderDiagram(shape.content);
      default:
        return;
    }
  }
  if (shape.text) {
    return shape.text;
  }
  if (shape.placeholder?.type) {
    return `*[${shape.placeholder.type}]*`;
  }
  return;
}
function renderSlideMermaid(params) {
  const blocks = [];
  for (const shape of params.shapes) {
    const rendered = renderShape(shape);
    if (rendered) {
      blocks.push(rendered);
    }
  }
  return blocks.join(`

`);
}
// packages/@oxen-cli/pptx-cli/src/output/mermaid-output.ts
function formatPreviewMermaid(data) {
  const sections = [];
  for (const slide of data.slides) {
    const header = `## Slide ${slide.number}`;
    const mermaid = renderSlideMermaid({ shapes: slide.shapes, slideNumber: slide.number });
    sections.push(mermaid ? `${header}

${mermaid}` : header);
  }
  return sections.join(`

`);
}

// packages/@oxen-cli/pptx-cli/src/program.ts
function createProgram() {
  const program2 = new Command;
  program2.name("pptx").description("CLI tool for inspecting PPTX files").version("0.1.0").option("-o, --output <mode>", "Output mode (json|pretty|mermaid)", "pretty");
  program2.command("info").description("Display presentation metadata").argument("<file>", "PPTX/PPT file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runInfo(file);
    output(result, mode, formatInfoPretty);
  });
  program2.command("list").description("List slides with summary").argument("<file>", "PPTX/PPT file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runList(file);
    output(result, mode, formatListPretty);
  });
  program2.command("show").description("Display slide content").argument("<file>", "PPTX/PPT file path").argument("<slide>", "Slide number (1-based)").action(async (file, slide) => {
    const mode = program2.opts().output;
    const slideNumber = parseInt(slide, 10);
    if (Number.isNaN(slideNumber)) {
      console.error("Error: Slide number must be a valid integer");
      process.exitCode = 1;
      return;
    }
    const result = await runShow(file, slideNumber);
    output(result, mode, formatShowPretty);
  });
  program2.command("extract").description("Extract text from slides").argument("<file>", "PPTX/PPT file path").option("--slides <range>", 'Slide range (e.g., "1,3-5")').action(async (file, options) => {
    const mode = program2.opts().output;
    const result = await runExtract(file, options);
    output(result, mode, formatExtractPretty);
  });
  program2.command("theme").description("Display theme information (fonts, colors, styles)").argument("<file>", "PPTX/PPT file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runTheme(file);
    output(result, mode, formatThemePretty);
  });
  program2.command("build").description("Build PPTX from JSON specification").argument("<spec>", "JSON spec file path").action(async (spec) => {
    const mode = program2.opts().output;
    const result = await runBuild(spec);
    output(result, mode, formatBuildPretty);
  });
  program2.command("verify").description("Verify PPTX build results against expected values").argument("<path>", "Test case file or directory path").option("--tag <tag>", "Filter test cases by tag").action(async (specPath, options) => {
    const mode = program2.opts().output;
    const result = await runVerify(specPath, options);
    output(result, mode, formatVerifyPretty);
  });
  program2.command("preview").description("Render ASCII art preview of a slide (omit slide number to show all)").argument("<file>", "PPTX/PPT file path").argument("[slide]", "Slide number (1-based, omit for all)").option("--width <columns>", "Terminal width in columns", "80").option("--border", "Show slide border outline").action(async (file, slide, options) => {
    const mode = program2.opts().output;
    let slideNumber;
    if (slide !== undefined) {
      slideNumber = parseInt(slide, 10);
      if (Number.isNaN(slideNumber)) {
        console.error("Error: Slide number must be a valid integer");
        process.exitCode = 1;
        return;
      }
    }
    const width = parseInt(options.width, 10);
    if (Number.isNaN(width) || width < 20) {
      console.error("Error: Width must be an integer >= 20");
      process.exitCode = 1;
      return;
    }
    const result = await runPreview(file, slideNumber, { width, border: options.border });
    output(result, mode, formatPreviewPretty, formatPreviewMermaid);
  });
  program2.command("inventory").description("Display media inventory summary").argument("<file>", "PPTX/PPT file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runInventory(file);
    output(result, mode, formatInventoryPretty);
  });
  program2.command("tables").description("Display table information from slides").argument("<file>", "PPTX/PPT file path").option("--slides <range>", 'Slide range (e.g., "1,3-5")').action(async (file, options) => {
    const mode = program2.opts().output;
    const result = await runTables(file, options);
    output(result, mode, formatTablesPretty);
  });
  program2.command("images").description("Display embedded image information from slides").argument("<file>", "PPTX/PPT file path").option("--slides <range>", 'Slide range (e.g., "1,3-5")').action(async (file, options) => {
    const mode = program2.opts().output;
    const result = await runImages(file, options);
    output(result, mode, formatImagesPretty);
  });
  program2.command("diff").description("Compare text content between two PPTX files").argument("<fileA>", "First PPTX/PPT file path").argument("<fileB>", "Second PPTX/PPT file path").action(async (fileA, fileB) => {
    const mode = program2.opts().output;
    const result = await runDiff(fileA, fileB);
    output(result, mode, formatDiffPretty);
  });
  return program2;
}
// packages/@oxen-cli/docx-cli/src/commands/info.ts
import * as fs5 from "fs/promises";

// packages/@oxen-office/docx/src/constants.ts
var RELATIONSHIP_TYPES2 = {
  officeDocument: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  styles: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  numbering: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering",
  fontTable: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable",
  settings: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
  webSettings: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings",
  theme: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  header: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header",
  footer: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer",
  footnotes: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes",
  endnotes: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/endnotes",
  comments: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  image: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  hyperlink: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  oleObject: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject",
  package: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/package"
};
var DEFAULT_PART_PATHS = {
  document: "word/document.xml",
  styles: "word/styles.xml",
  numbering: "word/numbering.xml",
  fontTable: "word/fontTable.xml",
  settings: "word/settings.xml",
  webSettings: "word/webSettings.xml",
  theme: "word/theme/theme1.xml",
  documentRels: "word/_rels/document.xml.rels",
  rootRels: "_rels/.rels",
  contentTypes: "[Content_Types].xml"
};

// packages/@oxen-office/docx/src/domain/types.ts
var docxStyleId = (v) => v;
var docxAbstractNumId = (v) => v;
var docxNumId = (v) => v;
var docxIlvl = (v) => v;
var docxRelId = (v) => v;
var twips = (v) => v;
function twipsToPoints(value) {
  return value / 20;
}
var halfPoints = (v) => v;
// packages/@oxen-office/docx/src/parser/context.ts
function findDefaultStyle(styles, type) {
  return styles?.style?.find((style) => style.default && style.type === type);
}
function createParseContext2(config) {
  const { styles, numbering, relationships } = config;
  const styleMap = new Map;
  if (styles?.style) {
    for (const style of styles.style) {
      styleMap.set(style.styleId, style);
    }
  }
  const defaultParagraphStyle = findDefaultStyle(styles, "paragraph");
  const defaultRunStyle = findDefaultStyle(styles, "character");
  const numMap = new Map;
  const abstractNumMap = new Map;
  if (numbering?.abstractNum) {
    for (const abstractNum of numbering.abstractNum) {
      abstractNumMap.set(abstractNum.abstractNumId, abstractNum);
    }
  }
  if (numbering?.num) {
    for (const num of numbering.num) {
      numMap.set(num.numId, num);
    }
  }
  const relMap = new Map;
  if (relationships?.relationship) {
    for (const rel of relationships.relationship) {
      relMap.set(rel.id, rel);
    }
  }
  return {
    getStyle: (styleId2) => {
      return styleMap.get(styleId2);
    },
    getNumbering: (numId) => {
      return numMap.get(numId);
    },
    getAbstractNumbering: (abstractNumId) => {
      return abstractNumMap.get(abstractNumId);
    },
    getNumberingLevel: (numId, ilvl) => {
      const num = numMap.get(numId);
      if (!num) {
        return;
      }
      if (num.lvlOverride) {
        const override = num.lvlOverride.find((o) => o.ilvl === ilvl);
        if (override?.lvl) {
          return override.lvl;
        }
      }
      const abstractNum = abstractNumMap.get(num.abstractNumId);
      if (!abstractNum) {
        return;
      }
      return abstractNum.lvl.find((l) => l.ilvl === ilvl);
    },
    getRelationship: (rId) => {
      return relMap.get(rId);
    },
    getDefaultParagraphStyle: () => {
      return defaultParagraphStyle;
    },
    getDefaultRunStyle: () => {
      return defaultRunStyle;
    }
  };
}
// packages/@oxen-office/docx/src/parser/primitive.ts
var TWIPS_PER_INCH = 1440;
var STANDARD_DPI4 = 96;
var TWIPS_TO_PX = STANDARD_DPI4 / TWIPS_PER_INCH;
var POINTS_PER_INCH3 = 72;
var PT_TO_PX3 = STANDARD_DPI4 / POINTS_PER_INCH3;
function parseInt323(value) {
  if (value === undefined) {
    return;
  }
  const num = parseInt(value, 10);
  return isNaN(num) ? undefined : num;
}
function parseBoolean3(value) {
  if (value === undefined) {
    return;
  }
  const lower = value.toLowerCase();
  if (lower === "1" || lower === "true" || lower === "on" || lower === "") {
    return true;
  }
  if (lower === "0" || lower === "false" || lower === "off") {
    return false;
  }
  return;
}
function parseOnOff(element) {
  if (!element) {
    return;
  }
  const val = getAttr(element, "val");
  if (val === undefined) {
    return true;
  }
  return parseBoolean3(val);
}
function parseTwips(value) {
  const num = parseInt323(value);
  if (num === undefined) {
    return;
  }
  return twips(num);
}
function parseHalfPoints(value) {
  const num = parseInt323(value);
  if (num === undefined) {
    return;
  }
  return halfPoints(num);
}
function parseEighthPoints(value) {
  const num = parseInt323(value);
  if (num === undefined) {
    return;
  }
  return eighthPt(num);
}
function parseStyleId(value) {
  if (value === undefined || value === "") {
    return;
  }
  return docxStyleId(value);
}
function parseNumId(value) {
  const num = parseInt323(value);
  if (num === undefined) {
    return;
  }
  return docxNumId(num);
}
function parseAbstractNumId(value) {
  const num = parseInt323(value);
  if (num === undefined) {
    return;
  }
  return docxAbstractNumId(num);
}
function parseIlvl(value) {
  const num = parseInt323(value);
  if (num === undefined || num < 0 || num > 8) {
    return;
  }
  return docxIlvl(num);
}
function parseRelId(value) {
  if (value === undefined || value === "") {
    return;
  }
  return docxRelId(value);
}
function getChildAttr(parent, childName, attrName) {
  const child = getChild(parent, childName);
  if (!child) {
    return;
  }
  return getAttr(child, attrName);
}
function getChildVal(parent, childName) {
  return getChildAttr(parent, childName, "val");
}
function getChildIntVal(parent, childName) {
  const val = getChildVal(parent, childName);
  return parseInt323(val);
}
function parseToggleChild(parent, childName) {
  const child = getChild(parent, childName);
  return parseOnOff(child);
}

// packages/@oxen-office/docx/src/parser/math.ts
function localName(element) {
  return element.name.split(":").pop() ?? element.name;
}
function getValAttr(element) {
  if (!element) {
    return;
  }
  return getAttr(element, "m:val") ?? getAttr(element, "val");
}
function parseMathStyle(value) {
  switch (value) {
    case "p":
    case "b":
    case "i":
    case "bi":
      return value;
    default:
      return;
  }
}
function parseMathScript(value) {
  switch (value) {
    case "roman":
    case "script":
    case "fraktur":
    case "double-struck":
    case "sans-serif":
    case "monospace":
      return value;
    default:
      return;
  }
}
function parseMathRunProperties(element) {
  if (!element) {
    return;
  }
  const styEl = getChild(element, "sty");
  const scrEl = getChild(element, "scr");
  const norEl = getChild(element, "nor");
  const brkEl = getChild(element, "brk");
  const alnEl = getChild(element, "aln");
  const litEl = getChild(element, "lit");
  return {
    sty: parseMathStyle(getValAttr(styEl)),
    scr: parseMathScript(getValAttr(scrEl)),
    nor: norEl ? parseBoolean3(getValAttr(norEl)) ?? true : undefined,
    brk: brkEl ? parseInt323(getAttr(brkEl, "alnAt")) : undefined,
    aln: alnEl ? parseBoolean3(getValAttr(alnEl)) ?? true : undefined,
    lit: litEl ? parseBoolean3(getValAttr(litEl)) ?? true : undefined
  };
}
function parseFractionType(value) {
  switch (value) {
    case "bar":
    case "skw":
    case "lin":
    case "noBar":
      return value;
    default:
      return;
  }
}
function parseLimitLocation(value) {
  switch (value) {
    case "subSup":
    case "undOvr":
      return value;
    default:
      return;
  }
}
function parseBarPosition(value) {
  switch (value) {
    case "top":
    case "bot":
      return value;
    default:
      return;
  }
}
function parseMathJustification(value) {
  switch (value) {
    case "left":
    case "right":
    case "center":
    case "centerGroup":
      return value;
    default:
      return;
  }
}
function parseMathContentChildren(element, context) {
  const content = [];
  for (const child of element.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    const parsed = parseMathElement(child, context);
    if (parsed) {
      content.push(parsed);
    }
  }
  return content;
}
function parseArgument(parent, name, context) {
  const argEl = getChild(parent, name);
  if (!argEl) {
    return [];
  }
  return parseMathContentChildren(argEl, context);
}
function parseMathRun(element, context) {
  const rPrEl = getChild(element, "rPr");
  const tEl = getChild(element, "t");
  return {
    type: "mathRun",
    properties: parseMathRunProperties(rPrEl),
    rPr: parseRunProperties3(rPrEl ? getChild(rPrEl, "rPr") : undefined, context),
    text: tEl ? getTextContent(tEl) : ""
  };
}
function parseFraction(element, context) {
  const fPrEl = getChild(element, "fPr");
  const typeEl = fPrEl ? getChild(fPrEl, "type") : undefined;
  return {
    type: "mathFraction",
    fracType: parseFractionType(getValAttr(typeEl)),
    numerator: parseArgument(element, "num", context),
    denominator: parseArgument(element, "den", context)
  };
}
function parseRadical(element, context) {
  const radPrEl = getChild(element, "radPr");
  const degHideEl = radPrEl ? getChild(radPrEl, "degHide") : undefined;
  return {
    type: "mathRadical",
    hideDeg: degHideEl ? parseBoolean3(getValAttr(degHideEl)) ?? true : undefined,
    degree: parseArgument(element, "deg", context),
    base: parseArgument(element, "e", context)
  };
}
function parseNary(element, context) {
  const naryPrEl = getChild(element, "naryPr");
  const chrEl = naryPrEl ? getChild(naryPrEl, "chr") : undefined;
  const limLocEl = naryPrEl ? getChild(naryPrEl, "limLoc") : undefined;
  const growEl = naryPrEl ? getChild(naryPrEl, "grow") : undefined;
  const subHideEl = naryPrEl ? getChild(naryPrEl, "subHide") : undefined;
  const supHideEl = naryPrEl ? getChild(naryPrEl, "supHide") : undefined;
  return {
    type: "mathNary",
    char: getValAttr(chrEl),
    limLoc: parseLimitLocation(getValAttr(limLocEl)),
    grow: growEl ? parseBoolean3(getValAttr(growEl)) ?? true : undefined,
    subHide: subHideEl ? parseBoolean3(getValAttr(subHideEl)) ?? true : undefined,
    supHide: supHideEl ? parseBoolean3(getValAttr(supHideEl)) ?? true : undefined,
    subscript: parseArgument(element, "sub", context),
    superscript: parseArgument(element, "sup", context),
    base: parseArgument(element, "e", context)
  };
}
function parseSuperscript(element, context) {
  return {
    type: "mathSuperscript",
    base: parseArgument(element, "e", context),
    superscript: parseArgument(element, "sup", context)
  };
}
function parseSubscript(element, context) {
  return {
    type: "mathSubscript",
    base: parseArgument(element, "e", context),
    subscript: parseArgument(element, "sub", context)
  };
}
function parseSubSup(element, context) {
  return {
    type: "mathSubSup",
    base: parseArgument(element, "e", context),
    subscript: parseArgument(element, "sub", context),
    superscript: parseArgument(element, "sup", context)
  };
}
function parsePreSubSup(element, context) {
  return {
    type: "mathPreSubSup",
    subscript: parseArgument(element, "sub", context),
    superscript: parseArgument(element, "sup", context),
    base: parseArgument(element, "e", context)
  };
}
function parseDelimiter(element, context) {
  const dPrEl = getChild(element, "dPr");
  const begChrEl = dPrEl ? getChild(dPrEl, "begChr") : undefined;
  const endChrEl = dPrEl ? getChild(dPrEl, "endChr") : undefined;
  const sepChrEl = dPrEl ? getChild(dPrEl, "sepChr") : undefined;
  const growEl = dPrEl ? getChild(dPrEl, "grow") : undefined;
  const shpEl = dPrEl ? getChild(dPrEl, "shp") : undefined;
  const elements = [];
  for (const eEl of getChildren(element, "e")) {
    elements.push(parseMathContentChildren(eEl, context));
  }
  return {
    type: "mathDelimiter",
    begChr: getValAttr(begChrEl),
    endChr: getValAttr(endChrEl),
    sepChr: getValAttr(sepChrEl),
    grow: growEl ? parseBoolean3(getValAttr(growEl)) ?? true : undefined,
    shp: shpEl ? getValAttr(shpEl) : undefined,
    elements
  };
}
function parseMatrix(element, context) {
  const mPrEl = getChild(element, "mPr");
  const baseJcEl = mPrEl ? getChild(mPrEl, "baseJc") : undefined;
  const rSpEl = mPrEl ? getChild(mPrEl, "rSp") : undefined;
  const rSpRuleEl = mPrEl ? getChild(mPrEl, "rSpRule") : undefined;
  const cGpEl = mPrEl ? getChild(mPrEl, "cGp") : undefined;
  const cGpRuleEl = mPrEl ? getChild(mPrEl, "cGpRule") : undefined;
  const rows = [];
  for (const mrEl of getChildren(element, "mr")) {
    const cells = [];
    for (const eEl of getChildren(mrEl, "e")) {
      cells.push(parseMathContentChildren(eEl, context));
    }
    rows.push({ cells });
  }
  return {
    type: "mathMatrix",
    rows,
    baseJc: baseJcEl ? getValAttr(baseJcEl) : undefined,
    rSp: rSpEl ? parseInt323(getValAttr(rSpEl)) : undefined,
    rSpRule: rSpRuleEl ? parseInt323(getValAttr(rSpRuleEl)) : undefined,
    cGp: cGpEl ? parseInt323(getValAttr(cGpEl)) : undefined,
    cGpRule: cGpRuleEl ? parseInt323(getValAttr(cGpRuleEl)) : undefined
  };
}
function parseLimitLower(element, context) {
  return {
    type: "mathLimitLower",
    base: parseArgument(element, "e", context),
    limit: parseArgument(element, "lim", context)
  };
}
function parseLimitUpper(element, context) {
  return {
    type: "mathLimitUpper",
    base: parseArgument(element, "e", context),
    limit: parseArgument(element, "lim", context)
  };
}
function parseAccent(element, context) {
  const accPrEl = getChild(element, "accPr");
  const chrEl = accPrEl ? getChild(accPrEl, "chr") : undefined;
  return {
    type: "mathAccent",
    char: getValAttr(chrEl),
    base: parseArgument(element, "e", context)
  };
}
function parseBar(element, context) {
  const barPrEl = getChild(element, "barPr");
  const posEl = barPrEl ? getChild(barPrEl, "pos") : undefined;
  return {
    type: "mathBar",
    pos: parseBarPosition(getValAttr(posEl)),
    base: parseArgument(element, "e", context)
  };
}
function parseBox(element, context) {
  const boxPrEl = getChild(element, "boxPr");
  const opEmuEl = boxPrEl ? getChild(boxPrEl, "opEmu") : undefined;
  const noBreakEl = boxPrEl ? getChild(boxPrEl, "noBreak") : undefined;
  const diffEl = boxPrEl ? getChild(boxPrEl, "diff") : undefined;
  const brkEl = boxPrEl ? getChild(boxPrEl, "brk") : undefined;
  const alnEl = boxPrEl ? getChild(boxPrEl, "aln") : undefined;
  return {
    type: "mathBox",
    base: parseArgument(element, "e", context),
    opEmu: opEmuEl ? parseBoolean3(getValAttr(opEmuEl)) ?? true : undefined,
    noBreak: noBreakEl ? parseBoolean3(getValAttr(noBreakEl)) ?? true : undefined,
    diff: diffEl ? parseBoolean3(getValAttr(diffEl)) ?? true : undefined,
    brk: brkEl ? parseInt323(getAttr(brkEl, "alnAt")) : undefined,
    aln: alnEl ? parseBoolean3(getValAttr(alnEl)) ?? true : undefined
  };
}
function parseBorderBox(element, context) {
  const borderBoxPrEl = getChild(element, "borderBoxPr");
  const hideTopEl = borderBoxPrEl ? getChild(borderBoxPrEl, "hideTop") : undefined;
  const hideBotEl = borderBoxPrEl ? getChild(borderBoxPrEl, "hideBot") : undefined;
  const hideLeftEl = borderBoxPrEl ? getChild(borderBoxPrEl, "hideLeft") : undefined;
  const hideRightEl = borderBoxPrEl ? getChild(borderBoxPrEl, "hideRight") : undefined;
  const strikeHEl = borderBoxPrEl ? getChild(borderBoxPrEl, "strikeH") : undefined;
  const strikeVEl = borderBoxPrEl ? getChild(borderBoxPrEl, "strikeV") : undefined;
  const strikeBLTREl = borderBoxPrEl ? getChild(borderBoxPrEl, "strikeBLTR") : undefined;
  const strikeTLBREl = borderBoxPrEl ? getChild(borderBoxPrEl, "strikeTLBR") : undefined;
  return {
    type: "mathBorderBox",
    hideTop: hideTopEl ? parseBoolean3(getValAttr(hideTopEl)) ?? true : undefined,
    hideBot: hideBotEl ? parseBoolean3(getValAttr(hideBotEl)) ?? true : undefined,
    hideLeft: hideLeftEl ? parseBoolean3(getValAttr(hideLeftEl)) ?? true : undefined,
    hideRight: hideRightEl ? parseBoolean3(getValAttr(hideRightEl)) ?? true : undefined,
    strikeH: strikeHEl ? parseBoolean3(getValAttr(strikeHEl)) ?? true : undefined,
    strikeV: strikeVEl ? parseBoolean3(getValAttr(strikeVEl)) ?? true : undefined,
    strikeBLTR: strikeBLTREl ? parseBoolean3(getValAttr(strikeBLTREl)) ?? true : undefined,
    strikeTLBR: strikeTLBREl ? parseBoolean3(getValAttr(strikeTLBREl)) ?? true : undefined,
    base: parseArgument(element, "e", context)
  };
}
function parseFunction(element, context) {
  return {
    type: "mathFunction",
    functionName: parseArgument(element, "fName", context),
    base: parseArgument(element, "e", context)
  };
}
function parseEquationArray(element, context) {
  const eqArrPrEl = getChild(element, "eqArrPr");
  const baseJcEl = eqArrPrEl ? getChild(eqArrPrEl, "baseJc") : undefined;
  const maxDistEl = eqArrPrEl ? getChild(eqArrPrEl, "maxDist") : undefined;
  const objDistEl = eqArrPrEl ? getChild(eqArrPrEl, "objDist") : undefined;
  const rSpEl = eqArrPrEl ? getChild(eqArrPrEl, "rSp") : undefined;
  const rSpRuleEl = eqArrPrEl ? getChild(eqArrPrEl, "rSpRule") : undefined;
  const equations = [];
  for (const eEl of getChildren(element, "e")) {
    equations.push(parseMathContentChildren(eEl, context));
  }
  return {
    type: "mathEquationArray",
    baseJc: baseJcEl ? getValAttr(baseJcEl) : undefined,
    maxDist: maxDistEl ? parseBoolean3(getValAttr(maxDistEl)) ?? true : undefined,
    objDist: objDistEl ? parseBoolean3(getValAttr(objDistEl)) ?? true : undefined,
    rSp: rSpEl ? parseInt323(getValAttr(rSpEl)) : undefined,
    rSpRule: rSpRuleEl ? parseInt323(getValAttr(rSpRuleEl)) : undefined,
    equations
  };
}
function parseGroupChar(element, context) {
  const groupChrPrEl = getChild(element, "groupChrPr");
  const chrEl = groupChrPrEl ? getChild(groupChrPrEl, "chr") : undefined;
  const posEl = groupChrPrEl ? getChild(groupChrPrEl, "pos") : undefined;
  const vertJcEl = groupChrPrEl ? getChild(groupChrPrEl, "vertJc") : undefined;
  return {
    type: "mathGroupChar",
    char: getValAttr(chrEl),
    pos: parseBarPosition(getValAttr(posEl)),
    vertJc: vertJcEl ? getValAttr(vertJcEl) : undefined,
    base: parseArgument(element, "e", context)
  };
}
function parsePhantom(element, context) {
  const phantPrEl = getChild(element, "phantPr");
  const showEl = phantPrEl ? getChild(phantPrEl, "show") : undefined;
  const zeroWidEl = phantPrEl ? getChild(phantPrEl, "zeroWid") : undefined;
  const zeroAscEl = phantPrEl ? getChild(phantPrEl, "zeroAsc") : undefined;
  const zeroDescEl = phantPrEl ? getChild(phantPrEl, "zeroDesc") : undefined;
  const transpEl = phantPrEl ? getChild(phantPrEl, "transp") : undefined;
  return {
    type: "mathPhantom",
    show: showEl ? parseBoolean3(getValAttr(showEl)) ?? true : undefined,
    zeroWid: zeroWidEl ? parseBoolean3(getValAttr(zeroWidEl)) ?? true : undefined,
    zeroAsc: zeroAscEl ? parseBoolean3(getValAttr(zeroAscEl)) ?? true : undefined,
    zeroDesc: zeroDescEl ? parseBoolean3(getValAttr(zeroDescEl)) ?? true : undefined,
    transp: transpEl ? parseBoolean3(getValAttr(transpEl)) ?? true : undefined,
    base: parseArgument(element, "e", context)
  };
}
function parseMathElement(element, context) {
  const name = localName(element);
  switch (name) {
    case "r":
      return parseMathRun(element, context);
    case "f":
      return parseFraction(element, context);
    case "rad":
      return parseRadical(element, context);
    case "nary":
      return parseNary(element, context);
    case "sSup":
      return parseSuperscript(element, context);
    case "sSub":
      return parseSubscript(element, context);
    case "sSubSup":
      return parseSubSup(element, context);
    case "sPre":
      return parsePreSubSup(element, context);
    case "d":
      return parseDelimiter(element, context);
    case "m":
      return parseMatrix(element, context);
    case "limLow":
      return parseLimitLower(element, context);
    case "limUpp":
      return parseLimitUpper(element, context);
    case "acc":
      return parseAccent(element, context);
    case "bar":
      return parseBar(element, context);
    case "box":
      return parseBox(element, context);
    case "borderBox":
      return parseBorderBox(element, context);
    case "func":
      return parseFunction(element, context);
    case "eqArr":
      return parseEquationArray(element, context);
    case "groupChr":
      return parseGroupChar(element, context);
    case "phant":
      return parsePhantom(element, context);
    default:
      return;
  }
}
function parseOfficeMath(element, context) {
  return {
    type: "oMath",
    content: parseMathContentChildren(element, context)
  };
}
function parseOfficeMathPara(element, context) {
  const oMathParaPrEl = getChild(element, "oMathParaPr");
  const jcEl = oMathParaPrEl ? getChild(oMathParaPrEl, "jc") : undefined;
  const content = [];
  for (const oMathEl of getChildren(element, "oMath")) {
    content.push(parseOfficeMath(oMathEl, context));
  }
  return {
    type: "oMathPara",
    justification: parseMathJustification(getValAttr(jcEl)),
    content
  };
}

// packages/@oxen-office/docx/src/parser/section.ts
function parsePageSize(element) {
  if (!element) {
    return;
  }
  const w = parseTwips(getAttr(element, "w"));
  const h = parseTwips(getAttr(element, "h"));
  if (w === undefined || h === undefined) {
    return;
  }
  return {
    w,
    h,
    orient: parseOrientation(getAttr(element, "orient")),
    code: parseInt323(getAttr(element, "code"))
  };
}
function parseOrientation(value) {
  switch (value) {
    case "portrait":
    case "landscape":
      return value;
    default:
      return;
  }
}
function parsePageMargins2(element) {
  if (!element) {
    return;
  }
  const top = parseTwips(getAttr(element, "top"));
  const right = parseTwips(getAttr(element, "right"));
  const bottom = parseTwips(getAttr(element, "bottom"));
  const left = parseTwips(getAttr(element, "left"));
  if (top === undefined || right === undefined || bottom === undefined || left === undefined) {
    return;
  }
  return {
    top,
    right,
    bottom,
    left,
    header: parseTwips(getAttr(element, "header")),
    footer: parseTwips(getAttr(element, "footer")),
    gutter: parseTwips(getAttr(element, "gutter"))
  };
}
function parsePageBorderEdge(element) {
  if (!element) {
    return;
  }
  const val = getAttr(element, "val");
  if (!val) {
    return;
  }
  return {
    val,
    sz: parseInt323(getAttr(element, "sz")),
    space: parseInt323(getAttr(element, "space")),
    color: getAttr(element, "color") ?? undefined,
    themeColor: getAttr(element, "themeColor") ?? undefined,
    shadow: parseBoolean3(getAttr(element, "shadow")),
    frame: parseBoolean3(getAttr(element, "frame"))
  };
}
function parsePageBorders(element) {
  if (!element) {
    return;
  }
  return {
    display: parseDisplayOption(getAttr(element, "display")),
    offsetFrom: parseOffsetFrom(getAttr(element, "offsetFrom")),
    zOrder: parseZOrder(getAttr(element, "zOrder")),
    top: parsePageBorderEdge(getChild(element, "top")),
    left: parsePageBorderEdge(getChild(element, "left")),
    bottom: parsePageBorderEdge(getChild(element, "bottom")),
    right: parsePageBorderEdge(getChild(element, "right"))
  };
}
function parseDisplayOption(value) {
  switch (value) {
    case "allPages":
    case "firstPage":
    case "notFirstPage":
      return value;
    default:
      return;
  }
}
function parseOffsetFrom(value) {
  switch (value) {
    case "page":
    case "text":
      return value;
    default:
      return;
  }
}
function parseZOrder(value) {
  switch (value) {
    case "front":
    case "back":
      return value;
    default:
      return;
  }
}
function parseColumn(element) {
  return {
    w: parseTwips(getAttr(element, "w")),
    space: parseTwips(getAttr(element, "space"))
  };
}
function parseColumns(element) {
  if (!element) {
    return;
  }
  const col = [];
  for (const c of getChildren(element, "col")) {
    col.push(parseColumn(c));
  }
  return {
    num: parseInt323(getAttr(element, "num")),
    equalWidth: parseBoolean3(getAttr(element, "equalWidth")),
    space: parseTwips(getAttr(element, "space")),
    sep: parseBoolean3(getAttr(element, "sep")),
    col: col.length > 0 ? col : undefined
  };
}
function parseHeaderFooterType(value) {
  switch (value) {
    case "default":
    case "first":
    case "even":
      return value;
    default:
      return;
  }
}
function parseHeaderFooterRef(element) {
  const type = parseHeaderFooterType(getAttr(element, "type"));
  const rId = parseRelId(getAttr(element, "r:id"));
  if (!type || !rId) {
    return;
  }
  return { type, rId };
}
function parseHeaderReferences(element) {
  const refs = [];
  for (const ref of getChildren(element, "headerReference")) {
    const parsed = parseHeaderFooterRef(ref);
    if (parsed) {
      refs.push(parsed);
    }
  }
  return refs.length > 0 ? refs : undefined;
}
function parseFooterReferences(element) {
  const refs = [];
  for (const ref of getChildren(element, "footerReference")) {
    const parsed = parseHeaderFooterRef(ref);
    if (parsed) {
      refs.push(parsed);
    }
  }
  return refs.length > 0 ? refs : undefined;
}
function parseLineNumbering(element) {
  if (!element) {
    return;
  }
  return {
    countBy: parseInt323(getAttr(element, "countBy")),
    start: parseInt323(getAttr(element, "start")),
    restart: parseLineNumberRestart(getAttr(element, "restart")),
    distance: parseTwips(getAttr(element, "distance"))
  };
}
function parseLineNumberRestart(value) {
  switch (value) {
    case "continuous":
    case "newPage":
    case "newSection":
      return value;
    default:
      return;
  }
}
function parsePageNumberFormat(value) {
  switch (value) {
    case "decimal":
    case "upperRoman":
    case "lowerRoman":
    case "upperLetter":
    case "lowerLetter":
    case "ordinal":
    case "cardinalText":
    case "ordinalText":
    case "none":
      return value;
    default:
      return;
  }
}
function parseChapSep(value) {
  switch (value) {
    case "colon":
    case "period":
    case "hyphen":
    case "emDash":
    case "enDash":
      return value;
    default:
      return;
  }
}
function parsePageNumberType(element) {
  if (!element) {
    return;
  }
  return {
    fmt: parsePageNumberFormat(getAttr(element, "fmt")),
    start: parseInt323(getAttr(element, "start")),
    chapStyle: parseInt323(getAttr(element, "chapStyle")),
    chapSep: parseChapSep(getAttr(element, "chapSep"))
  };
}
function parseDocGridType(value) {
  switch (value) {
    case "default":
    case "lines":
    case "linesAndChars":
    case "snapToChars":
      return value;
    default:
      return;
  }
}
function parseDocGrid(element) {
  if (!element) {
    return;
  }
  return {
    type: parseDocGridType(getAttr(element, "type")),
    linePitch: parseTwips(getAttr(element, "linePitch")),
    charSpace: parseInt323(getAttr(element, "charSpace"))
  };
}
function parseSectionBreakType(value) {
  switch (value) {
    case "continuous":
    case "evenPage":
    case "nextColumn":
    case "nextPage":
    case "oddPage":
      return value;
    default:
      return;
  }
}
function parseVerticalJc(value) {
  switch (value) {
    case "top":
    case "center":
    case "both":
    case "bottom":
      return value;
    default:
      return;
  }
}
function parseSectionTextDirection(value) {
  switch (value) {
    case "lrTb":
    case "tbRl":
    case "btLr":
    case "lrTbV":
    case "tbRlV":
    case "tbLrV":
      return value;
    default:
      return;
  }
}
function parseNotePos(value) {
  switch (value) {
    case "pageBottom":
    case "beneathText":
    case "sectEnd":
    case "docEnd":
      return value;
    default:
      return;
  }
}
function parseNumRestart(value) {
  switch (value) {
    case "continuous":
    case "eachSect":
    case "eachPage":
      return value;
    default:
      return;
  }
}
function parseNotePr(element) {
  if (!element) {
    return;
  }
  return {
    pos: parseNotePos(getChildVal(element, "pos")),
    numFmt: parsePageNumberFormat(getChildVal(element, "numFmt")),
    numStart: getChildIntVal(element, "numStart"),
    numRestart: parseNumRestart(getChildVal(element, "numRestart"))
  };
}
function parseSectionProperties(element) {
  if (!element) {
    return;
  }
  return {
    type: parseSectionBreakType(getChildVal(element, "type")),
    pgSz: parsePageSize(getChild(element, "pgSz")),
    pgMar: parsePageMargins2(getChild(element, "pgMar")),
    pgBorders: parsePageBorders(getChild(element, "pgBorders")),
    cols: parseColumns(getChild(element, "cols")),
    headerReference: parseHeaderReferences(element),
    footerReference: parseFooterReferences(element),
    titlePg: getChild(element, "titlePg") !== undefined,
    lnNumType: parseLineNumbering(getChild(element, "lnNumType")),
    pgNumType: parsePageNumberType(getChild(element, "pgNumType")),
    docGrid: parseDocGrid(getChild(element, "docGrid")),
    bidi: getChild(element, "bidi") !== undefined,
    rtlGutter: getChild(element, "rtlGutter") !== undefined,
    textDirection: parseSectionTextDirection(getChildVal(element, "textDirection")),
    vAlign: parseVerticalJc(getChildVal(element, "vAlign")),
    footnotePr: parseNotePr(getChild(element, "footnotePr")),
    endnotePr: parseNotePr(getChild(element, "endnotePr")),
    noEndnote: getChild(element, "noEndnote") !== undefined
  };
}

// packages/@oxen-office/docx/src/parser/paragraph.ts
function parseSpacing(element) {
  if (!element) {
    return;
  }
  return {
    before: parseTwips(getAttr(element, "before")),
    beforeAutospacing: parseBoolean3(getAttr(element, "beforeAutospacing")),
    after: parseTwips(getAttr(element, "after")),
    afterAutospacing: parseBoolean3(getAttr(element, "afterAutospacing")),
    line: parseInt323(getAttr(element, "line")),
    lineRule: parseLineRule(getAttr(element, "lineRule")),
    beforeLines: parseInt323(getAttr(element, "beforeLines")),
    afterLines: parseInt323(getAttr(element, "afterLines"))
  };
}
function parseLineRule(value) {
  switch (value) {
    case "auto":
    case "exact":
    case "atLeast":
      return value;
    default:
      return;
  }
}
function parseIndent(element) {
  if (!element) {
    return;
  }
  return {
    left: parseTwips(getAttr(element, "left")),
    leftChars: parseInt323(getAttr(element, "leftChars")),
    right: parseTwips(getAttr(element, "right")),
    rightChars: parseInt323(getAttr(element, "rightChars")),
    firstLine: parseTwips(getAttr(element, "firstLine")),
    firstLineChars: parseInt323(getAttr(element, "firstLineChars")),
    hanging: parseTwips(getAttr(element, "hanging")),
    hangingChars: parseInt323(getAttr(element, "hangingChars")),
    start: parseTwips(getAttr(element, "start")),
    startChars: parseInt323(getAttr(element, "startChars")),
    end: parseTwips(getAttr(element, "end")),
    endChars: parseInt323(getAttr(element, "endChars"))
  };
}
function parseParagraphBorderEdge(element) {
  if (!element) {
    return;
  }
  const val = parseBorderStyle(getAttr(element, "val"));
  if (!val) {
    return;
  }
  return {
    val,
    sz: parseEighthPoints(getAttr(element, "sz")),
    space: parseInt323(getAttr(element, "space")),
    color: getAttr(element, "color") ?? undefined,
    themeColor: parseThemeColor(getAttr(element, "themeColor")),
    shadow: parseBoolean3(getAttr(element, "shadow")),
    frame: parseBoolean3(getAttr(element, "frame"))
  };
}
function parseBorderStyle(value) {
  switch (value) {
    case "nil":
    case "none":
    case "single":
    case "thick":
    case "double":
    case "dotted":
    case "dashed":
    case "dotDash":
    case "dotDotDash":
    case "triple":
    case "thinThickSmallGap":
    case "thickThinSmallGap":
    case "thinThickThinSmallGap":
    case "thinThickMediumGap":
    case "thickThinMediumGap":
    case "thinThickThinMediumGap":
    case "thinThickLargeGap":
    case "thickThinLargeGap":
    case "thinThickThinLargeGap":
    case "wave":
    case "doubleWave":
    case "dashSmallGap":
    case "dashDotStroked":
    case "threeDEmboss":
    case "threeDEngrave":
    case "outset":
    case "inset":
      return value;
    default:
      return;
  }
}
function parseThemeColor(value) {
  switch (value) {
    case "dark1":
    case "light1":
    case "dark2":
    case "light2":
    case "accent1":
    case "accent2":
    case "accent3":
    case "accent4":
    case "accent5":
    case "accent6":
    case "hyperlink":
    case "followedHyperlink":
    case "background1":
    case "background2":
    case "text1":
    case "text2":
      return value;
    default:
      return;
  }
}
function parseParagraphBorders(element) {
  if (!element) {
    return;
  }
  return {
    top: parseParagraphBorderEdge(getChild(element, "top")),
    left: parseParagraphBorderEdge(getChild(element, "left")),
    bottom: parseParagraphBorderEdge(getChild(element, "bottom")),
    right: parseParagraphBorderEdge(getChild(element, "right")),
    between: parseParagraphBorderEdge(getChild(element, "between")),
    bar: parseParagraphBorderEdge(getChild(element, "bar"))
  };
}
function parseTabStop(element) {
  const val = parseTabAlignment(getAttr(element, "val"));
  const pos = parseTwips(getAttr(element, "pos"));
  if (!val || pos === undefined) {
    return;
  }
  return {
    val,
    pos,
    leader: parseTabLeader(getAttr(element, "leader"))
  };
}
function parseTabAlignment(value) {
  switch (value) {
    case "left":
    case "center":
    case "right":
    case "decimal":
    case "bar":
    case "clear":
    case "num":
    case "start":
    case "end":
      return value;
    default:
      return;
  }
}
function parseTabLeader(value) {
  switch (value) {
    case "none":
    case "dot":
    case "hyphen":
    case "underscore":
    case "heavy":
    case "middleDot":
      return value;
    default:
      return;
  }
}
function parseTabStops2(element) {
  if (!element) {
    return;
  }
  const tabs = [];
  for (const child of getChildren(element, "tab")) {
    const tab = parseTabStop(child);
    if (tab) {
      tabs.push(tab);
    }
  }
  if (tabs.length === 0) {
    return;
  }
  return { tabs };
}
function parseNumberingProperties(element) {
  if (!element) {
    return;
  }
  return {
    numId: parseNumId(getChildVal(element, "numId")),
    ilvl: parseIlvl(getChildVal(element, "ilvl"))
  };
}
function parseFrameProperties(element) {
  if (!element) {
    return;
  }
  return {
    w: parseTwips(getAttr(element, "w")),
    h: parseTwips(getAttr(element, "h")),
    hRule: parseHeightRule(getAttr(element, "hRule")),
    hAnchor: parseAnchor(getAttr(element, "hAnchor")),
    vAnchor: parseAnchor(getAttr(element, "vAnchor")),
    x: parseTwips(getAttr(element, "x")),
    xAlign: parseHAlign(getAttr(element, "xAlign")),
    y: parseTwips(getAttr(element, "y")),
    yAlign: parseVAlign(getAttr(element, "yAlign")),
    hSpace: parseTwips(getAttr(element, "hSpace")),
    vSpace: parseTwips(getAttr(element, "vSpace")),
    wrap: parseWrap(getAttr(element, "wrap")),
    dropCap: parseDropCap(getAttr(element, "dropCap")),
    lines: parseInt323(getAttr(element, "lines")),
    anchorLock: parseBoolean3(getAttr(element, "anchorLock"))
  };
}
function parseHeightRule(value) {
  switch (value) {
    case "auto":
    case "atLeast":
    case "exact":
      return value;
    default:
      return;
  }
}
function parseAnchor(value) {
  switch (value) {
    case "page":
    case "margin":
    case "text":
      return value;
    default:
      return;
  }
}
function parseHAlign(value) {
  switch (value) {
    case "left":
    case "center":
    case "right":
    case "inside":
    case "outside":
      return value;
    default:
      return;
  }
}
function parseVAlign(value) {
  switch (value) {
    case "top":
    case "center":
    case "bottom":
    case "inside":
    case "outside":
    case "inline":
      return value;
    default:
      return;
  }
}
function parseWrap(value) {
  switch (value) {
    case "around":
    case "auto":
    case "none":
    case "notBeside":
    case "through":
    case "tight":
      return value;
    default:
      return;
  }
}
function parseDropCap(value) {
  switch (value) {
    case "none":
    case "drop":
    case "margin":
      return value;
    default:
      return;
  }
}
function parseParagraphAlignment(value) {
  switch (value) {
    case "left":
    case "center":
    case "right":
    case "both":
    case "justify":
    case "distribute":
    case "start":
    case "end":
    case "numTab":
    case "highKashida":
    case "mediumKashida":
    case "lowKashida":
    case "thaiDistribute":
      return value;
    default:
      return;
  }
}
function parseTextDirection2(value) {
  switch (value) {
    case "lrTb":
    case "tbRl":
    case "btLr":
    case "lrTbV":
    case "tbRlV":
    case "tbLrV":
      return value;
    default:
      return;
  }
}
function parseTextAlignment(value) {
  switch (value) {
    case "auto":
    case "baseline":
    case "bottom":
    case "center":
    case "top":
      return value;
    default:
      return;
  }
}
function parseOutlineLevel(value) {
  const num = parseInt323(value);
  if (num === undefined || num < 0 || num > 9) {
    return;
  }
  return num;
}
function parseParagraphProperties3(element, context) {
  if (!element) {
    return;
  }
  return {
    pStyle: parseStyleId(getChildVal(element, "pStyle")),
    jc: parseParagraphAlignment(getChildVal(element, "jc")),
    textDirection: parseTextDirection2(getChildVal(element, "textDirection")),
    spacing: parseSpacing(getChild(element, "spacing")),
    ind: parseIndent(getChild(element, "ind")),
    pBdr: parseParagraphBorders(getChild(element, "pBdr")),
    shd: parseShading(getChild(element, "shd")),
    tabs: parseTabStops2(getChild(element, "tabs")),
    numPr: parseNumberingProperties(getChild(element, "numPr")),
    keepNext: parseToggleChild(element, "keepNext"),
    keepLines: parseToggleChild(element, "keepLines"),
    pageBreakBefore: parseToggleChild(element, "pageBreakBefore"),
    widowControl: parseToggleChild(element, "widowControl"),
    suppressLineNumbers: parseToggleChild(element, "suppressLineNumbers"),
    suppressAutoHyphens: parseToggleChild(element, "suppressAutoHyphens"),
    framePr: parseFrameProperties(getChild(element, "framePr")),
    outlineLvl: parseOutlineLevel(getChildVal(element, "outlineLvl")),
    kinsoku: parseToggleChild(element, "kinsoku"),
    wordWrap: parseToggleChild(element, "wordWrap"),
    overflowPunct: parseToggleChild(element, "overflowPunct"),
    topLinePunct: parseToggleChild(element, "topLinePunct"),
    autoSpaceDE: parseToggleChild(element, "autoSpaceDE"),
    autoSpaceDN: parseToggleChild(element, "autoSpaceDN"),
    bidi: parseToggleChild(element, "bidi"),
    textAlignment: parseTextAlignment(getChildVal(element, "textAlignment")),
    contextualSpacing: parseToggleChild(element, "contextualSpacing"),
    mirrorIndents: parseToggleChild(element, "mirrorIndents"),
    rPr: parseRunProperties3(getChild(element, "rPr"), context),
    sectPr: parseSectionProperties(getChild(element, "sectPr"))
  };
}
function parseHyperlink2(element, context) {
  const content = [];
  for (const child of getChildren(element, "r")) {
    content.push(parseRun(child, context));
  }
  return {
    type: "hyperlink",
    rId: parseRelId(getAttr(element, "r:id")),
    anchor: getAttr(element, "anchor") ?? undefined,
    tooltip: getAttr(element, "tooltip") ?? undefined,
    tgtFrame: getAttr(element, "tgtFrame") ?? undefined,
    history: parseBoolean3(getAttr(element, "history")),
    content
  };
}
function parseBookmarkStart(element) {
  const id = parseInt323(getAttr(element, "id"));
  const name = getAttr(element, "name");
  if (id === undefined || name === undefined) {
    return;
  }
  return {
    type: "bookmarkStart",
    id,
    name
  };
}
function parseBookmarkEnd(element) {
  const id = parseInt323(getAttr(element, "id"));
  if (id === undefined) {
    return;
  }
  return {
    type: "bookmarkEnd",
    id
  };
}
function parseSimpleField(element, context) {
  const instr = getAttr(element, "instr") ?? "";
  const dirty = parseBoolean3(getAttr(element, "dirty"));
  const content = [];
  for (const child of getChildren(element, "r")) {
    content.push(parseRun(child, context));
  }
  return {
    type: "simpleField",
    instr,
    ...dirty !== undefined && { dirty },
    content
  };
}
function parseRevisionInfo(element) {
  return {
    id: getAttr(element, "id") ?? "",
    author: getAttr(element, "author") ?? undefined,
    date: getAttr(element, "date") ?? undefined
  };
}
function parseRevisionRuns(element, context) {
  const runs = [];
  for (const child of getChildren(element, "r")) {
    runs.push(parseRun(child, context));
  }
  return runs;
}
function parseInsertedContent(element, context) {
  return {
    type: "ins",
    revision: parseRevisionInfo(element),
    content: parseRevisionRuns(element, context)
  };
}
function parseDeletedContent(element, context) {
  return {
    type: "del",
    revision: parseRevisionInfo(element),
    content: parseRevisionRuns(element, context)
  };
}
function parseMoveFromContent(element, context) {
  return {
    type: "moveFrom",
    revision: parseRevisionInfo(element),
    content: parseRevisionRuns(element, context)
  };
}
function parseMoveToContent(element, context) {
  return {
    type: "moveTo",
    revision: parseRevisionInfo(element),
    content: parseRevisionRuns(element, context)
  };
}
function parseMoveFromRangeStart(element) {
  const id = parseInt323(getAttr(element, "id"));
  if (id === undefined) {
    return;
  }
  return {
    type: "moveFromRangeStart",
    id,
    name: getAttr(element, "name") ?? undefined
  };
}
function parseMoveFromRangeEnd(element) {
  const id = parseInt323(getAttr(element, "id"));
  if (id === undefined) {
    return;
  }
  return {
    type: "moveFromRangeEnd",
    id
  };
}
function parseMoveToRangeStart(element) {
  const id = parseInt323(getAttr(element, "id"));
  if (id === undefined) {
    return;
  }
  return {
    type: "moveToRangeStart",
    id,
    name: getAttr(element, "name") ?? undefined
  };
}
function parseMoveToRangeEnd(element) {
  const id = parseInt323(getAttr(element, "id"));
  if (id === undefined) {
    return;
  }
  return {
    type: "moveToRangeEnd",
    id
  };
}
function parseSdtLock(value) {
  switch (value) {
    case "sdtLocked":
    case "contentLocked":
    case "sdtContentLocked":
    case "unlocked":
      return value;
    default:
      return;
  }
}
function parseSdtListItem(element) {
  return {
    displayText: getAttr(element, "displayText") ?? undefined,
    value: getAttr(element, "value") ?? ""
  };
}
function parseSdtProperties(element) {
  if (!element) {
    return;
  }
  const dropDownListEl = getChild(element, "dropDownList");
  const comboBoxEl = getChild(element, "comboBox");
  return {
    alias: getChildVal(element, "alias") ?? undefined,
    tag: getChildVal(element, "tag") ?? undefined,
    id: parseInt323(getChildVal(element, "id")),
    lock: parseSdtLock(getChildVal(element, "lock")),
    showingPlcHdr: parseBoolean3(getChildVal(element, "showingPlcHdr")),
    temporary: parseBoolean3(getChildVal(element, "temporary")),
    checked: parseBoolean3(getChildVal(element, "checked")),
    dropDownList: dropDownListEl ? getChildren(dropDownListEl, "listItem").map(parseSdtListItem) : undefined,
    comboBox: comboBoxEl ? getChildren(comboBoxEl, "listItem").map(parseSdtListItem) : undefined
  };
}
function parseInlineSdt(element, context) {
  const sdtPr = getChild(element, "sdtPr");
  const sdtContent = getChild(element, "sdtContent");
  const content = [];
  if (sdtContent) {
    for (const child of getChildren(sdtContent, "r")) {
      content.push(parseRun(child, context));
    }
  }
  return {
    type: "sdt",
    properties: parseSdtProperties(sdtPr),
    content
  };
}
function parseParagraphContent(element, context) {
  const localName2 = element.name.split(":").pop() ?? element.name;
  switch (localName2) {
    case "r":
      return parseRun(element, context);
    case "hyperlink":
      return parseHyperlink2(element, context);
    case "bookmarkStart":
      return parseBookmarkStart(element);
    case "bookmarkEnd":
      return parseBookmarkEnd(element);
    case "fldSimple":
      return parseSimpleField(element, context);
    case "ins":
      return parseInsertedContent(element, context);
    case "del":
      return parseDeletedContent(element, context);
    case "moveFrom":
      return parseMoveFromContent(element, context);
    case "moveTo":
      return parseMoveToContent(element, context);
    case "moveFromRangeStart":
      return parseMoveFromRangeStart(element);
    case "moveFromRangeEnd":
      return parseMoveFromRangeEnd(element);
    case "moveToRangeStart":
      return parseMoveToRangeStart(element);
    case "moveToRangeEnd":
      return parseMoveToRangeEnd(element);
    case "sdt":
      return parseInlineSdt(element, context);
    case "oMath":
      return parseOfficeMath(element, context);
    case "oMathPara":
      return parseOfficeMathPara(element, context);
    default:
      return;
  }
}
function parseParagraph2(element, context) {
  const properties = parseParagraphProperties3(getChild(element, "pPr"), context);
  const content = [];
  for (const node of element.children) {
    if (!isXmlElement(node)) {
      continue;
    }
    const parsed = parseParagraphContent(node, context);
    if (parsed) {
      content.push(parsed);
    }
  }
  return {
    type: "paragraph",
    properties,
    content
  };
}

// packages/@oxen-office/docx/src/parser/drawing.ts
function getLocalName(name) {
  return name.split(":").pop() ?? name;
}
function getChildByLocalName(element, localName2) {
  for (const child of element.children) {
    if (isXmlElement(child) && getLocalName(child.name) === localName2) {
      return child;
    }
  }
  return;
}
function parseIntAttr(element, attrName) {
  return parseInt32(element.attrs[attrName]);
}
function parseBoolAttr(element, attrName) {
  return parseBoolean(element.attrs[attrName]);
}
function parseExtent(element) {
  if (element === undefined) {
    return { cx: emu(0), cy: emu(0) };
  }
  return {
    cx: emu(parseIntAttr(element, "cx") ?? 0),
    cy: emu(parseIntAttr(element, "cy") ?? 0)
  };
}
function parseEffectExtent(element) {
  if (element === undefined) {
    return;
  }
  return {
    l: emu(parseIntAttr(element, "l") ?? 0),
    t: emu(parseIntAttr(element, "t") ?? 0),
    r: emu(parseIntAttr(element, "r") ?? 0),
    b: emu(parseIntAttr(element, "b") ?? 0)
  };
}
function parseDocPr(element) {
  if (element === undefined) {
    return { id: 0, name: "" };
  }
  return {
    id: parseIntAttr(element, "id") ?? 0,
    name: element.attrs.name ?? "",
    descr: element.attrs.descr,
    title: element.attrs.title,
    hidden: parseBoolAttr(element, "hidden")
  };
}
function parseBlip(element) {
  if (element === undefined) {
    return;
  }
  const rEmbed = element.attrs["r:embed"] ?? element.attrs.embed;
  const rLink = element.attrs["r:link"] ?? element.attrs.link;
  return {
    rEmbed: rEmbed !== undefined ? docxRelId(rEmbed) : undefined,
    rLink: rLink !== undefined ? docxRelId(rLink) : undefined,
    cstate: element.attrs.cstate
  };
}
function parseBlipFill2(element) {
  if (element === undefined) {
    return;
  }
  const blipEl = getChildByLocalName(element, "blip");
  const stretchEl = getChildByLocalName(element, "stretch");
  const srcRectEl = getChildByLocalName(element, "srcRect");
  function parseSrcRect(el) {
    if (!el) {
      return;
    }
    return {
      l: parseIntAttr(el, "l"),
      t: parseIntAttr(el, "t"),
      r: parseIntAttr(el, "r"),
      b: parseIntAttr(el, "b")
    };
  }
  return {
    blip: parseBlip(blipEl),
    stretch: stretchEl !== undefined,
    srcRect: parseSrcRect(srcRectEl)
  };
}
function parseSpPr(element) {
  if (element === undefined) {
    return;
  }
  const xfrmEl = getChildByLocalName(element, "xfrm");
  const prstGeomEl = getChildByLocalName(element, "prstGeom");
  function parseXfrm(el) {
    if (!el) {
      return;
    }
    return {
      rot: parseIntAttr(el, "rot"),
      flipH: parseBoolAttr(el, "flipH"),
      flipV: parseBoolAttr(el, "flipV")
    };
  }
  return {
    xfrm: parseXfrm(xfrmEl),
    prstGeom: prstGeomEl?.attrs.prst
  };
}
function parsePicture(element) {
  if (element === undefined) {
    return;
  }
  const nvPicPrEl = getChildByLocalName(element, "nvPicPr");
  const cNvPrEl = nvPicPrEl !== undefined ? getChildByLocalName(nvPicPrEl, "cNvPr") : undefined;
  const blipFillEl = getChildByLocalName(element, "blipFill");
  const spPrEl = getChildByLocalName(element, "spPr");
  function parseNvPicPr(args) {
    const { nvPicPrEl: nvPicPrEl2, cNvPrEl: cNvPrEl2 } = args;
    if (!nvPicPrEl2) {
      return;
    }
    return {
      cNvPr: cNvPrEl2 !== undefined ? parseDocPr(cNvPrEl2) : undefined
    };
  }
  return {
    nvPicPr: parseNvPicPr({ nvPicPrEl, cNvPrEl }),
    blipFill: parseBlipFill2(blipFillEl),
    spPr: parseSpPr(spPrEl)
  };
}
function parsePositionH(element) {
  if (element === undefined) {
    return;
  }
  const relativeFrom = parseRelFromH(element.attrs.relativeFrom);
  const posOffsetEl = getChildByLocalName(element, "posOffset");
  const alignEl = getChildByLocalName(element, "align");
  return {
    relativeFrom: relativeFrom ?? "column",
    posOffset: posOffsetEl !== undefined ? parseInt32(getTextContent(posOffsetEl)) : undefined,
    align: alignEl !== undefined ? parseAlignH(getTextContent(alignEl).trim()) : undefined
  };
}
function parsePositionV(element) {
  if (element === undefined) {
    return;
  }
  const relativeFrom = parseRelFromV(element.attrs.relativeFrom);
  const posOffsetEl = getChildByLocalName(element, "posOffset");
  const alignEl = getChildByLocalName(element, "align");
  return {
    relativeFrom: relativeFrom ?? "paragraph",
    posOffset: posOffsetEl !== undefined ? parseInt32(getTextContent(posOffsetEl)) : undefined,
    align: alignEl !== undefined ? parseAlignV(getTextContent(alignEl).trim()) : undefined
  };
}
function parseWrap2(inlineEl) {
  for (const child of inlineEl.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    const localName2 = getLocalName(child.name);
    switch (localName2) {
      case "wrapNone":
        return { type: "none" };
      case "wrapTopAndBottom":
        return { type: "topAndBottom" };
      case "wrapSquare":
        return { type: "square", wrapText: parseWrapText(child.attrs.wrapText) };
      case "wrapTight":
        return { type: "tight", wrapText: parseWrapText(child.attrs.wrapText) };
      case "wrapThrough":
        return { type: "through", wrapText: parseWrapText(child.attrs.wrapText) };
    }
  }
  return;
}
function parseBodyPr(element) {
  if (element === undefined) {
    return;
  }
  return {
    rot: parseIntAttr(element, "rot"),
    wrap: element.attrs.wrap,
    lIns: parseIntAttr(element, "lIns"),
    tIns: parseIntAttr(element, "tIns"),
    rIns: parseIntAttr(element, "rIns"),
    bIns: parseIntAttr(element, "bIns"),
    anchor: element.attrs.anchor,
    anchorCtr: parseBoolAttr(element, "anchorCtr"),
    vert: element.attrs.vert,
    upright: parseBoolAttr(element, "upright")
  };
}
function parseShapeStyle2(element) {
  if (element === undefined) {
    return;
  }
  const lnRefEl = getChildByLocalName(element, "lnRef");
  const fillRefEl = getChildByLocalName(element, "fillRef");
  const effectRefEl = getChildByLocalName(element, "effectRef");
  const fontRefEl = getChildByLocalName(element, "fontRef");
  return {
    lnRef: lnRefEl !== undefined ? parseIntAttr(lnRefEl, "idx") : undefined,
    fillRef: fillRefEl !== undefined ? parseIntAttr(fillRefEl, "idx") : undefined,
    effectRef: effectRefEl !== undefined ? parseIntAttr(effectRefEl, "idx") : undefined,
    fontRef: fontRefEl !== undefined ? parseIntAttr(fontRefEl, "idx") : undefined
  };
}
function parseTextBoxContent(element, context) {
  if (element === undefined) {
    return;
  }
  const txbxContentEl = getChildByLocalName(element, "txbxContent");
  if (txbxContentEl === undefined) {
    return;
  }
  const paragraphs = [];
  for (const child of txbxContentEl.children) {
    if (isXmlElement(child) && getLocalName(child.name) === "p") {
      paragraphs.push(parseParagraph2(child, context));
    }
  }
  return { content: paragraphs };
}
function parseWordprocessingShape(element, context) {
  if (element === undefined) {
    return;
  }
  const cNvPrEl = getChildByLocalName(element, "cNvPr");
  const spPrEl = getChildByLocalName(element, "spPr");
  const styleEl = getChildByLocalName(element, "style");
  const txbxEl = getChildByLocalName(element, "txbx");
  const bodyPrEl = getChildByLocalName(element, "bodyPr");
  return {
    cNvPr: cNvPrEl !== undefined ? parseDocPr(cNvPrEl) : undefined,
    spPr: parseSpPr(spPrEl),
    style: parseShapeStyle2(styleEl),
    txbx: parseTextBoxContent(txbxEl, context),
    bodyPr: parseBodyPr(bodyPrEl)
  };
}
function parseChart2(element) {
  if (element === undefined) {
    return;
  }
  const rId = element.attrs["r:id"] ?? element.attrs.id;
  if (rId === undefined) {
    return;
  }
  return {
    type: "chart",
    rId
  };
}
function parseInlineDrawing(element, context) {
  const extentEl = getChildByLocalName(element, "extent");
  const effectExtentEl = getChildByLocalName(element, "effectExtent");
  const docPrEl = getChildByLocalName(element, "docPr");
  const graphicEl = getChildByLocalName(element, "graphic");
  const graphicDataEl = graphicEl !== undefined ? getChildByLocalName(graphicEl, "graphicData") : undefined;
  const picEl = graphicDataEl !== undefined ? getChildByLocalName(graphicDataEl, "pic") : undefined;
  const wspEl = graphicDataEl !== undefined ? getChildByLocalName(graphicDataEl, "wsp") : undefined;
  const chartEl = graphicDataEl !== undefined ? getChildByLocalName(graphicDataEl, "chart") : undefined;
  return {
    type: "inline",
    distT: parseIntAttr(element, "distT"),
    distB: parseIntAttr(element, "distB"),
    distL: parseIntAttr(element, "distL"),
    distR: parseIntAttr(element, "distR"),
    extent: parseExtent(extentEl),
    effectExtent: parseEffectExtent(effectExtentEl),
    docPr: parseDocPr(docPrEl),
    pic: parsePicture(picEl),
    wsp: parseWordprocessingShape(wspEl, context),
    chart: parseChart2(chartEl)
  };
}
function parseAnchorDrawing(element, context) {
  const extentEl = getChildByLocalName(element, "extent");
  const effectExtentEl = getChildByLocalName(element, "effectExtent");
  const docPrEl = getChildByLocalName(element, "docPr");
  const positionHEl = getChildByLocalName(element, "positionH");
  const positionVEl = getChildByLocalName(element, "positionV");
  const graphicEl = getChildByLocalName(element, "graphic");
  const graphicDataEl = graphicEl !== undefined ? getChildByLocalName(graphicEl, "graphicData") : undefined;
  const picEl = graphicDataEl !== undefined ? getChildByLocalName(graphicDataEl, "pic") : undefined;
  const wspEl = graphicDataEl !== undefined ? getChildByLocalName(graphicDataEl, "wsp") : undefined;
  const chartEl = graphicDataEl !== undefined ? getChildByLocalName(graphicDataEl, "chart") : undefined;
  return {
    type: "anchor",
    distT: parseIntAttr(element, "distT"),
    distB: parseIntAttr(element, "distB"),
    distL: parseIntAttr(element, "distL"),
    distR: parseIntAttr(element, "distR"),
    simplePos: parseBoolAttr(element, "simplePos"),
    allowOverlap: parseBoolAttr(element, "allowOverlap"),
    behindDoc: parseBoolAttr(element, "behindDoc"),
    locked: parseBoolAttr(element, "locked"),
    layoutInCell: parseBoolAttr(element, "layoutInCell"),
    relativeHeight: parseIntAttr(element, "relativeHeight"),
    positionH: parsePositionH(positionHEl),
    positionV: parsePositionV(positionVEl),
    extent: parseExtent(extentEl),
    effectExtent: parseEffectExtent(effectExtentEl),
    wrap: parseWrap2(element),
    docPr: parseDocPr(docPrEl),
    pic: parsePicture(picEl),
    wsp: parseWordprocessingShape(wspEl, context),
    chart: parseChart2(chartEl)
  };
}
function parseDrawing(element, context) {
  for (const child of element.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    const localName2 = getLocalName(child.name);
    if (localName2 === "inline") {
      return parseInlineDrawing(child, context);
    }
    if (localName2 === "anchor") {
      return parseAnchorDrawing(child, context);
    }
  }
  return;
}

// packages/@oxen-office/docx/src/parser/run.ts
function parseRunFonts(element) {
  if (!element) {
    return;
  }
  const fonts = {
    ascii: getAttr(element, "ascii") ?? undefined,
    hAnsi: getAttr(element, "hAnsi") ?? undefined,
    eastAsia: getAttr(element, "eastAsia") ?? undefined,
    cs: getAttr(element, "cs") ?? undefined,
    asciiTheme: parseThemeFont(getAttr(element, "asciiTheme")),
    hAnsiTheme: parseThemeFont(getAttr(element, "hAnsiTheme")),
    eastAsiaTheme: parseThemeFont(getAttr(element, "eastAsiaTheme")),
    csTheme: parseThemeFont(getAttr(element, "csTheme"))
  };
  if (fonts.ascii === undefined && fonts.hAnsi === undefined && fonts.eastAsia === undefined && fonts.cs === undefined && fonts.asciiTheme === undefined && fonts.hAnsiTheme === undefined && fonts.eastAsiaTheme === undefined && fonts.csTheme === undefined) {
    return;
  }
  return fonts;
}
function parseThemeFont(value) {
  switch (value) {
    case "majorAscii":
    case "majorHAnsi":
    case "majorEastAsia":
    case "majorBidi":
    case "minorAscii":
    case "minorHAnsi":
    case "minorEastAsia":
    case "minorBidi":
      return value;
    default:
      return;
  }
}
function parseColor3(element) {
  if (!element) {
    return;
  }
  const val = getAttr(element, "val");
  const themeColor = parseThemeColor2(getAttr(element, "themeColor"));
  const themeTint = parseInt323(getAttr(element, "themeTint"));
  const themeShade = parseInt323(getAttr(element, "themeShade"));
  if (val === undefined && themeColor === undefined) {
    return;
  }
  return {
    val: val === "auto" ? undefined : val,
    themeColor,
    themeTint,
    themeShade
  };
}
function parseThemeColor2(value) {
  switch (value) {
    case "dark1":
    case "light1":
    case "dark2":
    case "light2":
    case "accent1":
    case "accent2":
    case "accent3":
    case "accent4":
    case "accent5":
    case "accent6":
    case "hyperlink":
    case "followedHyperlink":
    case "background1":
    case "background2":
    case "text1":
    case "text2":
      return value;
    default:
      return;
  }
}
function parseShading(element) {
  if (!element) {
    return;
  }
  const val = parseShadingPattern(getAttr(element, "val"));
  const color = getAttr(element, "color") ?? undefined;
  const fill = getAttr(element, "fill") ?? undefined;
  const themeColor = parseThemeColor2(getAttr(element, "themeColor"));
  const themeFill = parseThemeColor2(getAttr(element, "themeFill"));
  if (val === undefined && color === undefined && fill === undefined) {
    return;
  }
  return { val, color, fill, themeColor, themeFill };
}
function parseShadingPattern(value) {
  switch (value) {
    case "nil":
    case "clear":
    case "solid":
    case "horzStripe":
    case "vertStripe":
    case "reverseDiagStripe":
    case "diagStripe":
    case "horzCross":
    case "diagCross":
    case "thinHorzStripe":
    case "thinVertStripe":
    case "thinReverseDiagStripe":
    case "thinDiagStripe":
    case "thinHorzCross":
    case "thinDiagCross":
    case "pct5":
    case "pct10":
    case "pct12":
    case "pct15":
    case "pct20":
    case "pct25":
    case "pct30":
    case "pct35":
    case "pct37":
    case "pct40":
    case "pct45":
    case "pct50":
    case "pct55":
    case "pct60":
    case "pct62":
    case "pct65":
    case "pct70":
    case "pct75":
    case "pct80":
    case "pct85":
    case "pct87":
    case "pct90":
    case "pct95":
      return value;
    default:
      return;
  }
}
function parseRunBorder(element) {
  if (!element) {
    return;
  }
  const val = parseBorderStyle2(getAttr(element, "val"));
  if (!val) {
    return;
  }
  return {
    val,
    sz: parseEighthPoints(getAttr(element, "sz")),
    space: parseInt323(getAttr(element, "space")),
    color: getAttr(element, "color") ?? undefined,
    themeColor: parseThemeColor2(getAttr(element, "themeColor")),
    frame: parseBoolean3(getAttr(element, "frame")),
    shadow: parseBoolean3(getAttr(element, "shadow"))
  };
}
function parseBorderStyle2(value) {
  switch (value) {
    case "nil":
    case "none":
    case "single":
    case "thick":
    case "double":
    case "dotted":
    case "dashed":
    case "dotDash":
    case "dotDotDash":
    case "triple":
    case "thinThickSmallGap":
    case "thickThinSmallGap":
    case "thinThickThinSmallGap":
    case "thinThickMediumGap":
    case "thickThinMediumGap":
    case "thinThickThinMediumGap":
    case "thinThickLargeGap":
    case "thickThinLargeGap":
    case "thinThickThinLargeGap":
    case "wave":
    case "doubleWave":
    case "dashSmallGap":
    case "dashDotStroked":
    case "threeDEmboss":
    case "threeDEngrave":
    case "outset":
    case "inset":
      return value;
    default:
      return;
  }
}
function parseUnderline(element) {
  if (!element) {
    return;
  }
  const val = parseUnderlineStyle(getAttr(element, "val"));
  if (!val) {
    return;
  }
  return {
    val,
    color: getAttr(element, "color") ?? undefined,
    themeColor: parseThemeColor2(getAttr(element, "themeColor"))
  };
}
function parseUnderlineStyle(value) {
  switch (value) {
    case "none":
    case "single":
    case "words":
    case "double":
    case "thick":
    case "dotted":
    case "dottedHeavy":
    case "dash":
    case "dashedHeavy":
    case "dashLong":
    case "dashLongHeavy":
    case "dotDash":
    case "dashDotHeavy":
    case "dotDotDash":
    case "dashDotDotHeavy":
    case "wave":
    case "wavyHeavy":
    case "wavyDouble":
      return value;
    default:
      return;
  }
}
function parseHighlightColor(value) {
  switch (value) {
    case "black":
    case "blue":
    case "cyan":
    case "green":
    case "magenta":
    case "red":
    case "yellow":
    case "white":
    case "darkBlue":
    case "darkCyan":
    case "darkGreen":
    case "darkMagenta":
    case "darkRed":
    case "darkYellow":
    case "darkGray":
    case "lightGray":
    case "none":
      return value;
    default:
      return;
  }
}
function parseVerticalAlignRun(value) {
  switch (value) {
    case "baseline":
    case "superscript":
    case "subscript":
      return value;
    default:
      return;
  }
}
function parseEmphasisMark(value) {
  switch (value) {
    case "none":
    case "dot":
    case "comma":
    case "circle":
    case "underDot":
      return value;
    default:
      return;
  }
}
function parseEastAsianLayout(element) {
  if (!element) {
    return;
  }
  return {
    combine: parseBoolean3(getAttr(element, "combine")),
    combineBrackets: parseCombineBrackets(getAttr(element, "combineBrackets")),
    vert: parseBoolean3(getAttr(element, "vert")),
    vertCompress: parseBoolean3(getAttr(element, "vertCompress"))
  };
}
function parseCombineBrackets(value) {
  switch (value) {
    case "none":
    case "round":
    case "square":
    case "angle":
    case "curly":
      return value;
    default:
      return;
  }
}
function parseRunProperties3(element, _context) {
  if (!element) {
    return;
  }
  const props = {
    rStyle: parseStyleId(getChildVal(element, "rStyle")),
    rFonts: parseRunFonts(getChild(element, "rFonts")),
    sz: parseHalfPoints(getChildVal(element, "sz")),
    szCs: parseHalfPoints(getChildVal(element, "szCs")),
    b: parseToggleChild(element, "b"),
    bCs: parseToggleChild(element, "bCs"),
    i: parseToggleChild(element, "i"),
    iCs: parseToggleChild(element, "iCs"),
    caps: parseToggleChild(element, "caps"),
    smallCaps: parseToggleChild(element, "smallCaps"),
    strike: parseToggleChild(element, "strike"),
    dstrike: parseToggleChild(element, "dstrike"),
    outline: parseToggleChild(element, "outline"),
    shadow: parseToggleChild(element, "shadow"),
    emboss: parseToggleChild(element, "emboss"),
    imprint: parseToggleChild(element, "imprint"),
    vanish: parseToggleChild(element, "vanish"),
    webHidden: parseToggleChild(element, "webHidden"),
    color: parseColor3(getChild(element, "color")),
    highlight: parseHighlightColor(getChildVal(element, "highlight")),
    shd: parseShading(getChild(element, "shd")),
    u: parseUnderline(getChild(element, "u")),
    spacing: parseTwips(getChildVal(element, "spacing")),
    w: getChildIntVal(element, "w"),
    kern: parseHalfPoints(getChildVal(element, "kern")),
    position: parseHalfPoints(getChildVal(element, "position")),
    vertAlign: parseVerticalAlignRun(getChildVal(element, "vertAlign")),
    bdr: parseRunBorder(getChild(element, "bdr")),
    em: parseEmphasisMark(getChildVal(element, "em")),
    eastAsianLayout: parseEastAsianLayout(getChild(element, "eastAsianLayout")),
    rtl: parseToggleChild(element, "rtl"),
    cs: parseToggleChild(element, "cs")
  };
  return props;
}
function parseText(element) {
  const space = getAttr(element, "xml:space");
  return {
    type: "text",
    value: getTextContent(element) ?? "",
    space: space === "preserve" ? "preserve" : "default"
  };
}
function parseTab(_element) {
  return { type: "tab" };
}
function parseBreakType(value) {
  if (value === "page" || value === "column" || value === "textWrapping") {
    return value;
  }
  return;
}
function parseBreakClear(value) {
  if (value === "none" || value === "left" || value === "right" || value === "all") {
    return value;
  }
  return;
}
function parseBreak(element) {
  return {
    type: "break",
    breakType: parseBreakType(getAttr(element, "type")),
    clear: parseBreakClear(getAttr(element, "clear"))
  };
}
function parseSymbol(element) {
  return {
    type: "symbol",
    font: getAttr(element, "font") ?? "",
    char: getAttr(element, "char") ?? ""
  };
}
function parseDrawingContent(element) {
  const drawing = parseDrawing(element);
  if (drawing === undefined) {
    return;
  }
  return {
    type: "drawing",
    drawing
  };
}
function parseFieldCharType(value) {
  switch (value) {
    case "begin":
    case "separate":
    case "end":
      return value;
    default:
      return;
  }
}
function parseFieldCharContent(element) {
  const fldCharType = parseFieldCharType(getAttr(element, "fldCharType"));
  if (!fldCharType)
    return;
  const dirty = parseBoolean3(getAttr(element, "dirty"));
  const fldLock = parseBoolean3(getAttr(element, "fldLock"));
  return {
    type: "fieldChar",
    fldCharType,
    ...dirty !== undefined && { dirty },
    ...fldLock !== undefined && { fldLock }
  };
}
function parseInstrText(element) {
  const space = getAttr(element, "xml:space");
  return {
    type: "instrText",
    value: getTextContent(element) ?? "",
    space: space === "preserve" ? "preserve" : "default"
  };
}
function parseRunContent(element) {
  const localName2 = element.name.split(":").pop() ?? element.name;
  switch (localName2) {
    case "t":
      return parseText(element);
    case "tab":
      return parseTab(element);
    case "br":
      return parseBreak(element);
    case "sym":
      return parseSymbol(element);
    case "drawing":
      return parseDrawingContent(element);
    case "fldChar":
      return parseFieldCharContent(element);
    case "instrText":
      return parseInstrText(element);
    default:
      return;
  }
}
function parseRun(element, context) {
  const properties = parseRunProperties3(getChild(element, "rPr"), context);
  const content = [];
  for (const node of element.children) {
    if (!isXmlElement(node)) {
      continue;
    }
    const parsed = parseRunContent(node);
    if (parsed) {
      content.push(parsed);
    }
  }
  return {
    type: "run",
    properties,
    content
  };
}

// packages/@oxen-office/docx/src/parser/table.ts
var TWIPS_TO_PX2 = 96 / 1440;
function parseTableWidth(element) {
  if (!element) {
    return;
  }
  const w = parseInt323(getAttr(element, "w"));
  const type = parseWidthType(getAttr(element, "type"));
  if (w === undefined) {
    return;
  }
  return {
    value: w,
    type: type ?? "dxa"
  };
}
function parseWidthType(value) {
  switch (value) {
    case "auto":
    case "dxa":
    case "nil":
    case "pct":
      return value;
    default:
      return;
  }
}
function parseBorderStyle3(value) {
  switch (value) {
    case "nil":
    case "none":
    case "single":
    case "thick":
    case "double":
    case "dotted":
    case "dashed":
    case "dotDash":
    case "dotDotDash":
    case "triple":
    case "thinThickSmallGap":
    case "thickThinSmallGap":
    case "thinThickThinSmallGap":
    case "thinThickMediumGap":
    case "thickThinMediumGap":
    case "thinThickThinMediumGap":
    case "thinThickLargeGap":
    case "thickThinLargeGap":
    case "thinThickThinLargeGap":
    case "wave":
    case "doubleWave":
    case "dashSmallGap":
    case "dashDotStroked":
    case "threeDEmboss":
    case "threeDEngrave":
    case "outset":
    case "inset":
      return value;
    default:
      return;
  }
}
function parseThemeColor3(value) {
  switch (value) {
    case "dark1":
    case "light1":
    case "dark2":
    case "light2":
    case "accent1":
    case "accent2":
    case "accent3":
    case "accent4":
    case "accent5":
    case "accent6":
    case "hyperlink":
    case "followedHyperlink":
    case "background1":
    case "background2":
    case "text1":
    case "text2":
      return value;
    default:
      return;
  }
}
function parseTableBorderEdge(element) {
  if (!element) {
    return;
  }
  const val = parseBorderStyle3(getAttr(element, "val"));
  if (!val) {
    return;
  }
  return {
    val,
    sz: parseEighthPoints(getAttr(element, "sz")),
    space: parseInt323(getAttr(element, "space")),
    color: getAttr(element, "color") ?? undefined,
    themeColor: parseThemeColor3(getAttr(element, "themeColor")),
    shadow: parseBoolean3(getAttr(element, "shadow")),
    frame: parseBoolean3(getAttr(element, "frame"))
  };
}
function parseTableBorders(element) {
  if (!element) {
    return;
  }
  return {
    top: parseTableBorderEdge(getChild(element, "top")),
    left: parseTableBorderEdge(getChild(element, "left")),
    bottom: parseTableBorderEdge(getChild(element, "bottom")),
    right: parseTableBorderEdge(getChild(element, "right")),
    insideH: parseTableBorderEdge(getChild(element, "insideH")),
    insideV: parseTableBorderEdge(getChild(element, "insideV"))
  };
}
function parseCellBorders2(element) {
  if (!element) {
    return;
  }
  return {
    top: parseTableBorderEdge(getChild(element, "top")),
    left: parseTableBorderEdge(getChild(element, "left")),
    bottom: parseTableBorderEdge(getChild(element, "bottom")),
    right: parseTableBorderEdge(getChild(element, "right")),
    insideH: parseTableBorderEdge(getChild(element, "insideH")),
    insideV: parseTableBorderEdge(getChild(element, "insideV")),
    tl2br: parseTableBorderEdge(getChild(element, "tl2br")),
    tr2bl: parseTableBorderEdge(getChild(element, "tr2bl"))
  };
}
function parseCellMargins2(element) {
  if (!element) {
    return;
  }
  const top = parseTableWidth(getChild(element, "top"));
  const left = parseTableWidth(getChild(element, "left") ?? getChild(element, "start"));
  const bottom = parseTableWidth(getChild(element, "bottom"));
  const right = parseTableWidth(getChild(element, "right") ?? getChild(element, "end"));
  return {
    top: top ? px(top.value * TWIPS_TO_PX2) : undefined,
    left: left ? px(left.value * TWIPS_TO_PX2) : undefined,
    bottom: bottom ? px(bottom.value * TWIPS_TO_PX2) : undefined,
    right: right ? px(right.value * TWIPS_TO_PX2) : undefined
  };
}
function parseTableAlignment(value) {
  switch (value) {
    case "start":
    case "center":
    case "end":
    case "left":
    case "right":
      return value;
    default:
      return;
  }
}
function parseCellVerticalAlignment(value) {
  switch (value) {
    case "top":
    case "center":
    case "bottom":
    case "both":
      return value;
    default:
      return;
  }
}
function parseTableLayout(value) {
  switch (value) {
    case "fixed":
    case "autofit":
      return value;
    default:
      return;
  }
}
function parseTextDirection3(value) {
  switch (value) {
    case "lrTb":
    case "tbRl":
    case "btLr":
    case "lrTbV":
    case "tbRlV":
    case "tbLrV":
      return value;
    default:
      return;
  }
}
function parseTablePositioning(element) {
  if (!element) {
    return;
  }
  return {
    horzAnchor: parseAnchor2(getAttr(element, "horzAnchor")),
    vertAnchor: parseAnchor2(getAttr(element, "vertAnchor")),
    tblpX: parseTwips(getAttr(element, "tblpX")),
    tblpXSpec: parseHorizontalAlign(getAttr(element, "tblpXSpec")),
    tblpY: parseTwips(getAttr(element, "tblpY")),
    tblpYSpec: parseVerticalAlign(getAttr(element, "tblpYSpec")),
    leftFromText: parseTwips(getAttr(element, "leftFromText")),
    rightFromText: parseTwips(getAttr(element, "rightFromText")),
    topFromText: parseTwips(getAttr(element, "topFromText")),
    bottomFromText: parseTwips(getAttr(element, "bottomFromText"))
  };
}
function parseAnchor2(value) {
  switch (value) {
    case "margin":
    case "page":
    case "text":
      return value;
    default:
      return;
  }
}
function parseHorizontalAlign(value) {
  switch (value) {
    case "left":
    case "center":
    case "right":
    case "inside":
    case "outside":
      return value;
    default:
      return;
  }
}
function parseVerticalAlign(value) {
  switch (value) {
    case "top":
    case "center":
    case "bottom":
    case "inside":
    case "outside":
      return value;
    default:
      return;
  }
}
function parseTableLook(element) {
  if (!element) {
    return;
  }
  return {
    firstRow: parseBoolean3(getAttr(element, "firstRow")),
    lastRow: parseBoolean3(getAttr(element, "lastRow")),
    firstColumn: parseBoolean3(getAttr(element, "firstColumn")),
    lastColumn: parseBoolean3(getAttr(element, "lastColumn")),
    noHBand: parseBoolean3(getAttr(element, "noHBand")),
    noVBand: parseBoolean3(getAttr(element, "noVBand"))
  };
}
function parseTableProperties2(element) {
  if (!element) {
    return;
  }
  return {
    tblStyle: parseStyleId(getChildVal(element, "tblStyle")),
    tblW: parseTableWidth(getChild(element, "tblW")),
    jc: parseTableAlignment(getChildVal(element, "jc")),
    tblInd: parseTableWidth(getChild(element, "tblInd")),
    tblBorders: parseTableBorders(getChild(element, "tblBorders")),
    shd: parseShading(getChild(element, "shd")),
    tblCellMar: parseCellMargins2(getChild(element, "tblCellMar")),
    tblCellSpacing: parseTableCellSpacing(getChild(element, "tblCellSpacing")),
    tblLayout: parseTableLayout(getChildVal(element, "tblLayout")),
    tblpPr: parseTablePositioning(getChild(element, "tblpPr")),
    tblLook: parseTableLook(getChild(element, "tblLook")),
    tblCaption: getChildVal(element, "tblCaption"),
    tblDescription: getChildVal(element, "tblDescription"),
    tblOverlap: parseTableOverlap(getChildVal(element, "tblOverlap")),
    bidiVisual: parseToggleChild(element, "bidiVisual")
  };
}
function parseTableCellSpacing(element) {
  if (!element) {
    return;
  }
  return {
    w: parseInt323(getAttr(element, "w")),
    type: parseWidthType(getAttr(element, "type"))
  };
}
function parseTableOverlap(value) {
  switch (value) {
    case "never":
    case "overlap":
      return value;
    default:
      return;
  }
}
function parseTableGrid2(element) {
  if (!element) {
    return;
  }
  const columns = [];
  for (const gridCol of getChildren(element, "gridCol")) {
    const w = parseTwips(getAttr(gridCol, "w"));
    if (w !== undefined) {
      columns.push({ width: px(w * TWIPS_TO_PX2) });
    }
  }
  if (columns.length === 0) {
    return;
  }
  return { columns };
}
function parseRowHeight(element) {
  if (!element) {
    return;
  }
  const val = parseTwips(getAttr(element, "val"));
  if (val === undefined) {
    return;
  }
  return {
    val,
    hRule: parseHeightRule2(getAttr(element, "hRule"))
  };
}
function parseHeightRule2(value) {
  switch (value) {
    case "auto":
    case "atLeast":
    case "exact":
      return value;
    default:
      return;
  }
}
function parseRowProperties(element) {
  if (!element) {
    return;
  }
  return {
    trHeight: parseRowHeight(getChild(element, "trHeight")),
    tblHeader: parseToggleChild(element, "tblHeader"),
    cantSplit: parseToggleChild(element, "cantSplit"),
    jc: parseTableAlignment(getChildVal(element, "jc")),
    hidden: parseToggleChild(element, "hidden"),
    gridBefore: parseInt323(getChildVal(element, "gridBefore")),
    wBefore: parseTableWidth(getChild(element, "wBefore")),
    gridAfter: parseInt323(getChildVal(element, "gridAfter")),
    wAfter: parseTableWidth(getChild(element, "wAfter"))
  };
}
function parseGridSpan(value) {
  const num = parseInt323(value);
  if (num === undefined || num < 1) {
    return;
  }
  return gridSpan(num);
}
function parseVerticalMerge(value) {
  if (value === undefined || value === "") {
    return "continue";
  }
  switch (value) {
    case "restart":
    case "continue":
      return value;
    default:
      return;
  }
}
function parseHorizontalMerge(value) {
  switch (value) {
    case "restart":
    case "continue":
      return value;
    default:
      return;
  }
}
function parseCellProperties(element) {
  if (!element) {
    return;
  }
  return {
    tcW: parseTableWidth(getChild(element, "tcW")),
    gridSpan: parseGridSpan(getChildVal(element, "gridSpan")),
    hMerge: parseHorizontalMerge(getChildVal(element, "hMerge")),
    vMerge: getChild(element, "vMerge") ? parseVerticalMerge(getChildVal(element, "vMerge")) : undefined,
    tcBorders: parseCellBorders2(getChild(element, "tcBorders")),
    shd: parseShading(getChild(element, "shd")),
    tcMar: parseCellMargins2(getChild(element, "tcMar")),
    textDirection: parseTextDirection3(getChildVal(element, "textDirection")),
    vAlign: parseCellVerticalAlignment(getChildVal(element, "vAlign")),
    noWrap: parseToggleChild(element, "noWrap"),
    tcFitText: parseToggleChild(element, "tcFitText"),
    hideMark: parseToggleChild(element, "hideMark")
  };
}
function parseTableCell2(element, context) {
  const properties = parseCellProperties(getChild(element, "tcPr"));
  const content = [];
  for (const node of element.children) {
    if (!isXmlElement(node)) {
      continue;
    }
    const localName2 = node.name.split(":").pop() ?? node.name;
    if (localName2 === "p") {
      content.push(parseParagraph2(node, context));
    } else if (localName2 === "tbl") {
      content.push(parseTable2(node, context));
    }
  }
  return {
    type: "tableCell",
    properties,
    content
  };
}
function parseTableRow2(element, context) {
  const properties = parseRowProperties(getChild(element, "trPr"));
  const cells = [];
  for (const tc of getChildren(element, "tc")) {
    cells.push(parseTableCell2(tc, context));
  }
  return {
    type: "tableRow",
    properties,
    cells
  };
}
function parseTable2(element, context) {
  const properties = parseTableProperties2(getChild(element, "tblPr"));
  const grid = parseTableGrid2(getChild(element, "tblGrid"));
  const rows = [];
  for (const tr of getChildren(element, "tr")) {
    rows.push(parseTableRow2(tr, context));
  }
  return {
    type: "table",
    properties,
    grid,
    rows
  };
}

// packages/@oxen-office/docx/src/parser/styles.ts
function parseNameProperty(element, childName) {
  const child = getChild(element, childName);
  if (!child) {
    return;
  }
  return { val: getChildVal(element, childName) ?? "" };
}
function parseStyleIdProperty(element, childName) {
  const styleId2 = parseStyleId(getChildVal(element, childName));
  if (!styleId2) {
    return;
  }
  return { val: styleId2 };
}
function parseUiPriorityProperty(element) {
  const value = parseInt323(getChildVal(element, "uiPriority"));
  if (value === undefined) {
    return;
  }
  return { val: value };
}
function parseStyleType(value) {
  switch (value) {
    case "paragraph":
    case "character":
    case "table":
    case "numbering":
      return value;
    default:
      return;
  }
}
function parseTableStyleType(value) {
  switch (value) {
    case "wholeTable":
    case "firstRow":
    case "lastRow":
    case "firstCol":
    case "lastCol":
    case "band1Vert":
    case "band2Vert":
    case "band1Horz":
    case "band2Horz":
    case "neCell":
    case "nwCell":
    case "seCell":
    case "swCell":
      return value;
    default:
      return;
  }
}
function parseTableStylePr(element) {
  const type = parseTableStyleType(getAttr(element, "type"));
  if (!type) {
    return;
  }
  return {
    type,
    rPr: parseRunProperties3(getChild(element, "rPr")),
    pPr: parseParagraphProperties3(getChild(element, "pPr")),
    tcPr: undefined
  };
}
function parseStyle(element) {
  const type = parseStyleType(getAttr(element, "type"));
  const styleId2 = parseStyleId(getAttr(element, "styleId"));
  if (!type || !styleId2) {
    return;
  }
  const tblStylePr = [];
  for (const tsp of getChildren(element, "tblStylePr")) {
    const parsed = parseTableStylePr(tsp);
    if (parsed) {
      tblStylePr.push(parsed);
    }
  }
  return {
    type,
    styleId: styleId2,
    name: parseNameProperty(element, "name"),
    aliases: parseNameProperty(element, "aliases"),
    basedOn: parseStyleIdProperty(element, "basedOn"),
    next: parseStyleIdProperty(element, "next"),
    link: parseStyleIdProperty(element, "link"),
    uiPriority: parseUiPriorityProperty(element),
    default: parseBoolean3(getAttr(element, "default")),
    customStyle: parseBoolean3(getAttr(element, "customStyle")),
    semiHidden: getChild(element, "semiHidden") !== undefined,
    unhideWhenUsed: getChild(element, "unhideWhenUsed") !== undefined,
    qFormat: getChild(element, "qFormat") !== undefined,
    locked: getChild(element, "locked") !== undefined,
    personal: getChild(element, "personal") !== undefined,
    personalReply: getChild(element, "personalReply") !== undefined,
    personalCompose: getChild(element, "personalCompose") !== undefined,
    rPr: parseRunProperties3(getChild(element, "rPr")),
    pPr: parseParagraphProperties3(getChild(element, "pPr")),
    tblPr: undefined,
    trPr: undefined,
    tcPr: undefined,
    tblStylePr: tblStylePr.length > 0 ? tblStylePr : undefined
  };
}
function parseDocDefaults(element) {
  if (!element) {
    return;
  }
  return {
    rPrDefault: parseRPrDefault(getChild(element, "rPrDefault")),
    pPrDefault: parsePPrDefault(getChild(element, "pPrDefault"))
  };
}
function parseRPrDefault(element) {
  if (!element) {
    return;
  }
  return { rPr: parseRunProperties3(getChild(element, "rPr")) };
}
function parsePPrDefault(element) {
  if (!element) {
    return;
  }
  return { pPr: parseParagraphProperties3(getChild(element, "pPr")) };
}
function parseLatentStyleException(element) {
  const name = getAttr(element, "name");
  if (!name) {
    return;
  }
  return {
    name,
    locked: parseBoolean3(getAttr(element, "locked")),
    uiPriority: parseInt323(getAttr(element, "uiPriority")),
    semiHidden: parseBoolean3(getAttr(element, "semiHidden")),
    unhideWhenUsed: parseBoolean3(getAttr(element, "unhideWhenUsed")),
    qFormat: parseBoolean3(getAttr(element, "qFormat"))
  };
}
function parseLatentStyles(element) {
  if (!element) {
    return;
  }
  const lsdException = [];
  for (const exc of getChildren(element, "lsdException")) {
    const parsed = parseLatentStyleException(exc);
    if (parsed) {
      lsdException.push(parsed);
    }
  }
  return {
    defLockedState: parseBoolean3(getAttr(element, "defLockedState")),
    defUIPriority: parseInt323(getAttr(element, "defUIPriority")),
    defSemiHidden: parseBoolean3(getAttr(element, "defSemiHidden")),
    defUnhideWhenUsed: parseBoolean3(getAttr(element, "defUnhideWhenUsed")),
    defQFormat: parseBoolean3(getAttr(element, "defQFormat")),
    count: parseInt323(getAttr(element, "count")),
    lsdException: lsdException.length > 0 ? lsdException : undefined
  };
}
function parseStyles(element) {
  const styles = [];
  for (const style of getChildren(element, "style")) {
    const parsed = parseStyle(style);
    if (parsed) {
      styles.push(parsed);
    }
  }
  return {
    docDefaults: parseDocDefaults(getChild(element, "docDefaults")),
    latentStyles: parseLatentStyles(getChild(element, "latentStyles")),
    style: styles
  };
}

// packages/@oxen-office/docx/src/parser/numbering.ts
function parseLevelPicBulletId(element) {
  const id = parseInt323(getChildVal(element, "lvlPicBulletId"));
  if (id === undefined) {
    return;
  }
  return { numPicBulletId: id };
}
function parseNumberFormat(value) {
  switch (value) {
    case "decimal":
    case "upperRoman":
    case "lowerRoman":
    case "upperLetter":
    case "lowerLetter":
    case "ordinal":
    case "cardinalText":
    case "ordinalText":
    case "hex":
    case "chicago":
    case "ideographDigital":
    case "japaneseCounting":
    case "aiueo":
    case "iroha":
    case "decimalFullWidth":
    case "decimalHalfWidth":
    case "japaneseLegal":
    case "japaneseDigitalTenThousand":
    case "decimalEnclosedCircle":
    case "decimalFullWidth2":
    case "aiueoFullWidth":
    case "irohaFullWidth":
    case "decimalZero":
    case "bullet":
    case "ganada":
    case "chosung":
    case "decimalEnclosedFullstop":
    case "decimalEnclosedParen":
    case "decimalEnclosedCircleChinese":
    case "ideographEnclosedCircle":
    case "ideographTraditional":
    case "ideographZodiac":
    case "ideographZodiacTraditional":
    case "taiwaneseCounting":
    case "ideographLegalTraditional":
    case "taiwaneseCountingThousand":
    case "taiwaneseDigital":
    case "chineseCounting":
    case "chineseLegalSimplified":
    case "chineseCountingThousand":
    case "koreanDigital":
    case "koreanCounting":
    case "koreanLegal":
    case "koreanDigital2":
    case "vietnameseCounting":
    case "russianLower":
    case "russianUpper":
    case "none":
    case "numberInDash":
    case "hebrew1":
    case "hebrew2":
    case "arabicAlpha":
    case "arabicAbjad":
    case "hindiVowels":
    case "hindiConsonants":
    case "hindiNumbers":
    case "hindiCounting":
    case "thaiLetters":
    case "thaiNumbers":
    case "thaiCounting":
    case "bahtText":
    case "dollarText":
    case "custom":
      return value;
    default:
      return;
  }
}
function parseLevelSuffix(value) {
  switch (value) {
    case "tab":
    case "space":
    case "nothing":
      return value;
    default:
      return;
  }
}
function parseMultiLevelType(value) {
  switch (value) {
    case "singleLevel":
    case "multilevel":
    case "hybridMultilevel":
      return value;
    default:
      return;
  }
}
function parseLevelJustification(value) {
  switch (value) {
    case "left":
    case "center":
    case "right":
      return value;
    default:
      return;
  }
}
function parseLevelText(element) {
  if (!element) {
    return;
  }
  return {
    val: getAttr(element, "val") ?? "",
    null: parseBoolean3(getAttr(element, "null"))
  };
}
function parseLegacy(element) {
  if (!element) {
    return;
  }
  return {
    legacy: parseBoolean3(getAttr(element, "legacy")),
    legacySpace: parseTwips(getAttr(element, "legacySpace")),
    legacyIndent: parseTwips(getAttr(element, "legacyIndent"))
  };
}
function parseLevel(element) {
  const ilvl = parseIlvl(getAttr(element, "ilvl"));
  if (ilvl === undefined) {
    return;
  }
  return {
    ilvl,
    start: parseInt323(getChildVal(element, "start")),
    numFmt: parseNumberFormat(getChildVal(element, "numFmt")),
    lvlRestart: parseInt323(getChildVal(element, "lvlRestart")),
    pStyle: parseStyleId(getChildVal(element, "pStyle")),
    isLgl: getChild(element, "isLgl") !== undefined,
    suff: parseLevelSuffix(getChildVal(element, "suff")),
    lvlText: parseLevelText(getChild(element, "lvlText")),
    lvlJc: parseLevelJustification(getChildVal(element, "lvlJc")),
    lvlPicBulletId: parseLevelPicBulletId(element),
    legacy: parseLegacy(getChild(element, "legacy")),
    pPr: parseParagraphProperties3(getChild(element, "pPr")),
    rPr: parseRunProperties3(getChild(element, "rPr"))
  };
}
function parseAbstractNum(element) {
  const abstractNumId = parseAbstractNumId(getAttr(element, "abstractNumId"));
  if (abstractNumId === undefined) {
    return;
  }
  const lvl = [];
  for (const level of getChildren(element, "lvl")) {
    const parsed = parseLevel(level);
    if (parsed) {
      lvl.push(parsed);
    }
  }
  return {
    abstractNumId,
    nsid: getChildVal(element, "nsid"),
    multiLevelType: parseMultiLevelType(getChildVal(element, "multiLevelType")),
    tmpl: getChildVal(element, "tmpl"),
    styleLink: parseStyleId(getChildVal(element, "styleLink")),
    numStyleLink: parseStyleId(getChildVal(element, "numStyleLink")),
    lvl
  };
}
function parseLevelOverride(element) {
  const ilvl = parseIlvl(getAttr(element, "ilvl"));
  if (ilvl === undefined) {
    return;
  }
  const lvlElement = getChild(element, "lvl");
  return {
    ilvl,
    startOverride: parseInt323(getChildVal(element, "startOverride")),
    lvl: lvlElement ? parseLevel(lvlElement) : undefined
  };
}
function parseNum(element) {
  const numId = parseNumId(getAttr(element, "numId"));
  const abstractNumId = parseAbstractNumId(getChildVal(element, "abstractNumId"));
  if (numId === undefined || abstractNumId === undefined) {
    return;
  }
  const lvlOverride = [];
  for (const override of getChildren(element, "lvlOverride")) {
    const parsed = parseLevelOverride(override);
    if (parsed) {
      lvlOverride.push(parsed);
    }
  }
  return {
    numId,
    abstractNumId,
    lvlOverride: lvlOverride.length > 0 ? lvlOverride : undefined
  };
}
function parseNumbering(element) {
  const abstractNum = [];
  for (const an of getChildren(element, "abstractNum")) {
    const parsed = parseAbstractNum(an);
    if (parsed) {
      abstractNum.push(parsed);
    }
  }
  const num = [];
  for (const n of getChildren(element, "num")) {
    const parsed = parseNum(n);
    if (parsed) {
      num.push(parsed);
    }
  }
  return {
    numPicBullet: undefined,
    abstractNum,
    num
  };
}

// packages/@oxen-office/docx/src/parser/document.ts
function parseBlockContent(element, context) {
  const localName2 = element.name.split(":").pop() ?? element.name;
  switch (localName2) {
    case "p":
      return parseParagraph2(element, context);
    case "tbl":
      return parseTable2(element, context);
    default:
      return;
  }
}
function parseBody(element, context) {
  if (!element) {
    return { content: [] };
  }
  const content = [];
  for (const node of element.children) {
    if (!isXmlElement(node)) {
      continue;
    }
    const localName2 = node.name.split(":").pop() ?? node.name;
    if (localName2 === "sectPr") {
      continue;
    }
    const parsed = parseBlockContent(node, context);
    if (parsed) {
      content.push(parsed);
    }
  }
  const sectPr = parseSectionProperties(getChild(element, "sectPr"));
  return {
    content,
    sectPr
  };
}
function parseHeader2(element, context) {
  const content = [];
  for (const node of element.children) {
    if (!isXmlElement(node)) {
      continue;
    }
    const parsed = parseBlockContent(node, context);
    if (parsed) {
      content.push(parsed);
    }
  }
  return { content };
}
function parseFooter(element, context) {
  const content = [];
  for (const node of element.children) {
    if (!isXmlElement(node)) {
      continue;
    }
    const parsed = parseBlockContent(node, context);
    if (parsed) {
      content.push(parsed);
    }
  }
  return { content };
}
function parseDocument(element, context) {
  const body = parseBody(getChild(element, "body"), context);
  return {
    body
  };
}

// packages/@oxen-office/docx/src/parser/settings.ts
function parseZoom(element) {
  if (!element)
    return;
  const percent = parseInt323(getAttr(element, "percent"));
  const val = getAttr(element, "val");
  if (percent === undefined && val === undefined)
    return;
  return {
    ...percent !== undefined && { percent },
    ...val && { val }
  };
}
function parseCompatSettings(element) {
  if (!element)
    return;
  const spaceForUL = parseToggleChild(element, "w:spaceForUL");
  const balanceSingleByteDoubleByteWidth = parseToggleChild(element, "w:balanceSingleByteDoubleByteWidth");
  const doNotExpandShiftReturn = parseToggleChild(element, "w:doNotExpandShiftReturn");
  const doNotUseHTMLParagraphAutoSpacing = parseToggleChild(element, "w:doNotUseHTMLParagraphAutoSpacing");
  const useAnsiKerningPairs = parseToggleChild(element, "w:useAnsiKerningPairs");
  const useFELayout = parseToggleChild(element, "w:useFELayout");
  if (spaceForUL === undefined && balanceSingleByteDoubleByteWidth === undefined && doNotExpandShiftReturn === undefined && doNotUseHTMLParagraphAutoSpacing === undefined && useAnsiKerningPairs === undefined && useFELayout === undefined) {
    return;
  }
  return {
    ...spaceForUL !== undefined && { spaceForUL },
    ...balanceSingleByteDoubleByteWidth !== undefined && { balanceSingleByteDoubleByteWidth },
    ...doNotExpandShiftReturn !== undefined && { doNotExpandShiftReturn },
    ...doNotUseHTMLParagraphAutoSpacing !== undefined && { doNotUseHTMLParagraphAutoSpacing },
    ...useAnsiKerningPairs !== undefined && { useAnsiKerningPairs },
    ...useFELayout !== undefined && { useFELayout }
  };
}
function parseDocumentProtection(element) {
  if (!element)
    return;
  const edit = getAttr(element, "edit");
  const password = getAttr(element, "password");
  const cryptAlgorithmType = getAttr(element, "cryptAlgorithmType");
  const cryptAlgorithmClass = getAttr(element, "cryptAlgorithmClass");
  const cryptSpinCount = parseInt323(getAttr(element, "cryptSpinCount"));
  const hash = getAttr(element, "hash");
  const salt = getAttr(element, "salt");
  const enforcement = parseBoolean3(getAttr(element, "enforcement"));
  return {
    ...edit && { edit },
    ...password && { password },
    ...cryptAlgorithmType && { cryptAlgorithmType },
    ...cryptAlgorithmClass && { cryptAlgorithmClass },
    ...cryptSpinCount !== undefined && { cryptSpinCount },
    ...hash && { hash },
    ...salt && { salt },
    ...enforcement !== undefined && { enforcement }
  };
}
function parseThemeFontLang(element) {
  if (!element)
    return;
  const val = getAttr(element, "val");
  const eastAsia = getAttr(element, "eastAsia");
  const bidi = getAttr(element, "bidi");
  if (val === undefined && eastAsia === undefined && bidi === undefined) {
    return;
  }
  return {
    ...val && { val },
    ...eastAsia && { eastAsia },
    ...bidi && { bidi }
  };
}
function parseSettings(element) {
  const zoom = parseZoom(getChild(element, "w:zoom"));
  const removePersonalInformation = parseToggleChild(element, "w:removePersonalInformation");
  const removeDateAndTime = parseToggleChild(element, "w:removeDateAndTime");
  const doNotTrackMoves = parseToggleChild(element, "w:doNotTrackMoves");
  const doNotTrackFormatting = parseToggleChild(element, "w:doNotTrackFormatting");
  const documentProtection = parseDocumentProtection(getChild(element, "w:documentProtection"));
  const defaultTabStop = getChildIntVal(element, "w:defaultTabStop");
  const hyphenationZone = getChildIntVal(element, "w:hyphenationZone");
  const trackRevisions = parseToggleChild(element, "w:trackRevisions");
  const doNotUseMarginsForDrawingGridOrigin = parseToggleChild(element, "w:doNotUseMarginsForDrawingGridOrigin");
  const compat = parseCompatSettings(getChild(element, "w:compat"));
  const themeFontLang = parseThemeFontLang(getChild(element, "w:themeFontLang"));
  return {
    ...zoom && { zoom },
    ...removePersonalInformation !== undefined && { removePersonalInformation },
    ...removeDateAndTime !== undefined && { removeDateAndTime },
    ...doNotTrackMoves !== undefined && { doNotTrackMoves },
    ...doNotTrackFormatting !== undefined && { doNotTrackFormatting },
    ...documentProtection && Object.keys(documentProtection).length > 0 && { documentProtection },
    ...defaultTabStop !== undefined && { defaultTabStop },
    ...hyphenationZone !== undefined && { hyphenationZone },
    ...trackRevisions !== undefined && { trackRevisions },
    ...doNotUseMarginsForDrawingGridOrigin !== undefined && { doNotUseMarginsForDrawingGridOrigin },
    ...compat && { compat },
    ...themeFontLang && { themeFontLang }
  };
}

// packages/@oxen-office/docx/src/document-parser.ts
function getRootElement(doc) {
  for (const child of doc.children) {
    if (isXmlElement(child)) {
      return child;
    }
  }
  return;
}
function parseRelationships3(element) {
  const relationships = [];
  for (const node of element.children) {
    if (!isXmlElement(node)) {
      continue;
    }
    const rel = node;
    if (rel.name === "Relationship" || rel.name.endsWith(":Relationship")) {
      const id = rel.attrs.Id;
      const type = rel.attrs.Type;
      const target = rel.attrs.Target;
      if (id && type && target) {
        relationships.push({
          id: docxRelId(id),
          type,
          target,
          targetMode: rel.attrs.TargetMode === "External" ? "External" : "Internal"
        });
      }
    }
  }
  return { relationship: relationships };
}
function getRelationshipByType(relationships, type) {
  return relationships.relationship.find((r) => r.type === type);
}
function loadXmlPart(pkg, path6) {
  const content = pkg.readText(path6);
  if (!content) {
    return;
  }
  const doc = parseXml(content);
  return getRootElement(doc);
}
function resolvePath(sourcePath, targetPath) {
  if (targetPath.startsWith("/")) {
    return targetPath.slice(1);
  }
  const sourceDir = sourcePath.substring(0, sourcePath.lastIndexOf("/"));
  const parts = [...sourceDir.split("/"), ...targetPath.split("/")];
  const resolved = [];
  for (const part of parts) {
    if (part === "..") {
      resolved.pop();
    } else if (part !== "." && part !== "") {
      resolved.push(part);
    }
  }
  return resolved.join("/");
}
function normalizeDocumentPath(target) {
  return target.startsWith("/") ? target.slice(1) : target;
}
function loadStyles(params) {
  const { pkg, documentPath, relationships, shouldParse } = params;
  if (!shouldParse) {
    return;
  }
  const rel = getRelationshipByType(relationships, RELATIONSHIP_TYPES2.styles);
  if (!rel) {
    return;
  }
  const path6 = resolvePath(documentPath, rel.target);
  const element = loadXmlPart(pkg, path6);
  if (!element) {
    return;
  }
  return parseStyles(element);
}
function loadNumbering(params) {
  const { pkg, documentPath, relationships, shouldParse } = params;
  if (!shouldParse) {
    return;
  }
  const rel = getRelationshipByType(relationships, RELATIONSHIP_TYPES2.numbering);
  if (!rel) {
    return;
  }
  const path6 = resolvePath(documentPath, rel.target);
  const element = loadXmlPart(pkg, path6);
  if (!element) {
    return;
  }
  return parseNumbering(element);
}
function loadSettingsPart(params) {
  const { pkg, documentPath, relationships, shouldParse } = params;
  if (!shouldParse) {
    return;
  }
  const rel = getRelationshipByType(relationships, RELATIONSHIP_TYPES2.settings);
  if (!rel) {
    return;
  }
  const path6 = resolvePath(documentPath, rel.target);
  const element = loadXmlPart(pkg, path6);
  if (!element) {
    return;
  }
  return parseSettings(element);
}
function loadDocumentRelationships(pkg, path6) {
  const element = loadXmlPart(pkg, path6);
  return element ? parseRelationships3(element) : { relationship: [] };
}
function loadHeaders(params) {
  const { pkg, documentPath, relationships, context } = params;
  const headers = new Map;
  const headerRels = relationships.relationship.filter((r) => r.type === RELATIONSHIP_TYPES2.header);
  for (const rel of headerRels) {
    const path6 = resolvePath(documentPath, rel.target);
    const element = loadXmlPart(pkg, path6);
    if (element) {
      headers.set(rel.id, parseHeader2(element, context));
    }
  }
  return headers;
}
function loadFooters(params) {
  const { pkg, documentPath, relationships, context } = params;
  const footers = new Map;
  const footerRels = relationships.relationship.filter((r) => r.type === RELATIONSHIP_TYPES2.footer);
  for (const rel of footerRels) {
    const path6 = resolvePath(documentPath, rel.target);
    const element = loadXmlPart(pkg, path6);
    if (element) {
      footers.set(rel.id, parseFooter(element, context));
    }
  }
  return footers;
}
var DEFAULT_OPTIONS2 = {
  parseStyles: true,
  parseNumbering: true,
  parseHeadersFooters: true,
  parseSettings: true
};
async function loadDocx(data, options = {}) {
  const opts = { ...DEFAULT_OPTIONS2, ...options };
  const pkg = await loadZipPackage(data);
  const rootRels = loadXmlPart(pkg, DEFAULT_PART_PATHS.rootRels);
  if (!rootRels) {
    throw new Error("Cannot find root relationships file");
  }
  const rootRelationships = parseRelationships3(rootRels);
  const documentRel = getRelationshipByType(rootRelationships, RELATIONSHIP_TYPES2.officeDocument);
  if (!documentRel) {
    throw new Error("Cannot find main document relationship");
  }
  const documentPath = normalizeDocumentPath(documentRel.target);
  const documentRelsPath = resolvePath(documentPath, "_rels/" + documentPath.split("/").pop() + ".rels");
  const documentRelationships = loadDocumentRelationships(pkg, documentRelsPath);
  const styles = loadStyles({ pkg, documentPath, relationships: documentRelationships, shouldParse: opts.parseStyles });
  const numbering = loadNumbering({ pkg, documentPath, relationships: documentRelationships, shouldParse: opts.parseNumbering });
  const settings = loadSettingsPart({ pkg, documentPath, relationships: documentRelationships, shouldParse: opts.parseSettings });
  const context = createParseContext2({
    styles,
    numbering,
    relationships: documentRelationships
  });
  const documentElement = loadXmlPart(pkg, documentPath);
  if (!documentElement) {
    throw new Error(`Cannot find main document at ${documentPath}`);
  }
  const document = parseDocument(documentElement, context);
  let headers;
  let footers;
  if (opts.parseHeadersFooters) {
    headers = loadHeaders({ pkg, documentPath, relationships: documentRelationships, context });
    footers = loadFooters({ pkg, documentPath, relationships: documentRelationships, context });
  }
  return {
    ...document,
    styles,
    numbering,
    settings,
    relationships: documentRelationships,
    headers: headers?.size ? headers : undefined,
    footers: footers?.size ? footers : undefined
  };
}
// packages/@oxen-cli/docx-cli/src/commands/info.ts
function countParagraphs(content) {
  return content.filter((c) => c.type === "paragraph").length;
}
function countTables(content) {
  return content.filter((c) => c.type === "table").length;
}
function countSections(content) {
  const sectionBreaks = content.filter((c) => c.type === "sectionBreak").length;
  return sectionBreaks + 1;
}
function buildPageSize(pgSz) {
  if (!pgSz) {
    return;
  }
  return {
    width: twipsToPoints(pgSz.w),
    height: twipsToPoints(pgSz.h),
    widthTwips: pgSz.w,
    heightTwips: pgSz.h,
    orientation: pgSz.orient
  };
}
function buildSettingsInfo(settings) {
  if (!settings) {
    return;
  }
  return {
    ...settings.trackRevisions !== undefined && { trackRevisions: settings.trackRevisions },
    ...settings.defaultTabStop !== undefined && { defaultTabStop: settings.defaultTabStop },
    ...settings.zoom?.percent !== undefined && { zoom: settings.zoom.percent },
    ...settings.documentProtection?.edit && { protection: settings.documentProtection.edit }
  };
}
async function runInfo2(filePath) {
  try {
    const buffer = await fs5.readFile(filePath);
    const doc = await loadDocx(buffer);
    const sectPr = doc.body.sectPr;
    const pageSize = buildPageSize(sectPr?.pgSz);
    const settingsInfo = buildSettingsInfo(doc.settings);
    return success({
      paragraphCount: countParagraphs(doc.body.content),
      tableCount: countTables(doc.body.content),
      sectionCount: countSections(doc.body.content),
      pageSize,
      hasStyles: doc.styles !== undefined,
      hasNumbering: doc.numbering !== undefined,
      hasHeaders: doc.headers !== undefined && doc.headers.size > 0,
      hasFooters: doc.footers !== undefined && doc.footers.size > 0,
      hasComments: doc.comments !== undefined && doc.comments.comment.length > 0,
      hasSettings: doc.settings !== undefined,
      ...settingsInfo && Object.keys(settingsInfo).length > 0 && { settings: settingsInfo }
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse DOCX: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/commands/list.ts
import * as fs6 from "fs/promises";

// packages/@oxen-office/docx/src/domain/text-utils.ts
function extractTextFromRunContent(content) {
  switch (content.type) {
    case "text":
      return content.value;
    case "tab":
      return "\t";
    case "break":
      return content.breakType === "page" ? `

` : `
`;
    default:
      return "";
  }
}
function extractTextFromRun2(run) {
  return run.content.map(extractTextFromRunContent).join("");
}
function extractTextFromParagraphContent(content) {
  switch (content.type) {
    case "run":
      return extractTextFromRun2(content);
    case "hyperlink":
      return content.content.map(extractTextFromRun2).join("");
    default:
      return "";
  }
}
function extractTextFromParagraph2(paragraph) {
  return paragraph.content.map(extractTextFromParagraphContent).join("");
}
function extractTextFromBlockContent(content) {
  switch (content.type) {
    case "paragraph":
      return extractTextFromParagraph2(content);
    case "table":
      return content.rows.map((row) => row.cells.map((cell) => cell.content.filter((c) => c.type === "paragraph").map(extractTextFromParagraph2).join(" ")).join("\t")).join(`
`);
    default:
      return "";
  }
}

// packages/@oxen-cli/docx-cli/src/commands/list.ts
function splitIntoSections(body) {
  const sections = [];
  const currentContent = [];
  for (const block of body.content) {
    if (block.type === "sectionBreak") {
      sections.push({
        content: [...currentContent],
        sectPr: block.sectPr
      });
      currentContent.length = 0;
    } else {
      currentContent.push(block);
    }
  }
  sections.push({
    content: currentContent,
    sectPr: body.sectPr
  });
  return sections;
}
function getFirstParagraphText(content) {
  const firstParagraph = content.find((c) => c.type === "paragraph");
  if (!firstParagraph) {
    return;
  }
  const text = extractTextFromParagraph2(firstParagraph).trim();
  if (!text) {
    return;
  }
  return text.length > 50 ? `${text.slice(0, 47)}...` : text;
}
async function runList2(filePath) {
  try {
    const buffer = await fs6.readFile(filePath);
    const doc = await loadDocx(buffer);
    const sections = splitIntoSections(doc.body);
    const items = sections.map((section, index) => {
      const paragraphCount = section.content.filter((c) => c.type === "paragraph").length;
      const tableCount = section.content.filter((c) => c.type === "table").length;
      const sectPr = section.sectPr;
      const item = {
        number: index + 1,
        paragraphCount,
        tableCount
      };
      if (sectPr?.pgSz) {
        return {
          ...item,
          pageWidth: twipsToPoints(sectPr.pgSz.w),
          pageHeight: twipsToPoints(sectPr.pgSz.h),
          orientation: sectPr.pgSz.orient
        };
      }
      if (sectPr?.cols?.num) {
        return { ...item, columns: sectPr.cols.num };
      }
      const firstParagraphText = getFirstParagraphText(section.content);
      if (firstParagraphText) {
        return { ...item, firstParagraphText };
      }
      return item;
    });
    return success({ sections: items });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse DOCX: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/commands/show.ts
import * as fs7 from "fs/promises";

// packages/@oxen-cli/docx-cli/src/serializers/paragraph-serializer.ts
function extractTextFromRunContent2(content) {
  switch (content.type) {
    case "text":
      return content.value;
    case "tab":
      return "\t";
    case "break":
      return content.breakType === "page" ? `

` : `
`;
    default:
      return "";
  }
}
function serializeRun3(run) {
  const text = run.content.map(extractTextFromRunContent2).join("");
  const props = run.properties;
  return {
    type: "run",
    text,
    ...props?.b && { bold: true },
    ...props?.i && { italic: true },
    ...props?.u && { underline: true },
    ...props?.strike && { strike: true },
    ...props?.sz && { fontSize: props.sz / 2 },
    ...props?.rFonts?.ascii && { fontFamily: props.rFonts.ascii },
    ...props?.color?.val && { color: props.color.val },
    ...props?.highlight && { highlight: props.highlight }
  };
}
function serializeParagraphContent(content) {
  switch (content.type) {
    case "run":
      return serializeRun3(content);
    case "hyperlink":
      return {
        type: "hyperlink",
        anchor: content.anchor,
        tooltip: content.tooltip,
        text: content.content.map((r) => r.content.map(extractTextFromRunContent2).join("")).join("")
      };
    default:
      return;
  }
}
function serializeParagraph3(paragraph) {
  const props = paragraph.properties;
  const content = paragraph.content.map(serializeParagraphContent).filter((c) => c !== undefined);
  return {
    content,
    ...props?.pStyle && { style: props.pStyle },
    ...props?.jc && { alignment: props.jc },
    ...props?.numPr?.numId !== undefined && props?.numPr?.ilvl !== undefined && {
      numbering: {
        numId: props.numPr.numId,
        level: props.numPr.ilvl
      }
    }
  };
}

// packages/@oxen-cli/docx-cli/src/serializers/section-serializer.ts
function serializePageSize(pgSz) {
  return {
    width: twipsToPoints(pgSz.w),
    height: twipsToPoints(pgSz.h),
    widthTwips: pgSz.w,
    heightTwips: pgSz.h,
    orientation: pgSz.orient
  };
}
function serializePageMargins(pgMar) {
  const result = {
    top: twipsToPoints(pgMar.top),
    right: twipsToPoints(pgMar.right),
    bottom: twipsToPoints(pgMar.bottom),
    left: twipsToPoints(pgMar.left)
  };
  if (pgMar.header !== undefined) {
    return { ...result, header: twipsToPoints(pgMar.header) };
  }
  if (pgMar.footer !== undefined) {
    return { ...result, footer: twipsToPoints(pgMar.footer) };
  }
  if (pgMar.gutter !== undefined) {
    return { ...result, gutter: twipsToPoints(pgMar.gutter) };
  }
  return result;
}
function serializeColumns(cols) {
  const result = {};
  if (cols.num !== undefined) {
    return { ...result, num: cols.num };
  }
  if (cols.equalWidth !== undefined) {
    return { ...result, equalWidth: cols.equalWidth };
  }
  if (cols.space !== undefined) {
    return { ...result, space: twipsToPoints(cols.space) };
  }
  if (cols.sep !== undefined) {
    return { ...result, sep: cols.sep };
  }
  return result;
}
function serializeSection(sectPr) {
  const result = {};
  if (sectPr.type) {
    return { ...result, type: sectPr.type };
  }
  if (sectPr.pgSz) {
    return { ...result, pageSize: serializePageSize(sectPr.pgSz) };
  }
  if (sectPr.pgMar) {
    return { ...result, pageMargins: serializePageMargins(sectPr.pgMar) };
  }
  if (sectPr.cols) {
    return { ...result, columns: serializeColumns(sectPr.cols) };
  }
  if (sectPr.titlePg) {
    return { ...result, titlePage: sectPr.titlePg };
  }
  if (sectPr.bidi) {
    return { ...result, bidi: sectPr.bidi };
  }
  return result;
}

// packages/@oxen-cli/docx-cli/src/commands/show.ts
function splitIntoSections2(body) {
  const sections = [];
  const currentContent = [];
  for (const block of body.content) {
    if (block.type === "sectionBreak") {
      sections.push({
        content: [...currentContent],
        sectPr: block.sectPr
      });
      currentContent.length = 0;
    } else {
      currentContent.push(block);
    }
  }
  sections.push({
    content: currentContent,
    sectPr: body.sectPr
  });
  return sections;
}
function extractCellText(cell) {
  return cell.content.filter((c) => c.type === "paragraph").map((p) => p.content.map((c) => c.type === "run" ? c.content.map((rc) => rc.type === "text" ? rc.value : "").join("") : "").join("")).join(`
`);
}
function serializeTable2(table) {
  const rows = table.rows.map((row) => ({
    cells: row.cells.map((cell) => ({ text: extractCellText(cell) }))
  }));
  return {
    type: "table",
    rows,
    rowCount: table.rows.length,
    colCount: table.rows[0]?.cells.length ?? 0
  };
}
function serializeBlockContent(block) {
  switch (block.type) {
    case "paragraph":
      return { type: "paragraph", ...serializeParagraph3(block) };
    case "table":
      return serializeTable2(block);
    default:
      return;
  }
}
async function runShow2(filePath, sectionNumber) {
  try {
    const buffer = await fs7.readFile(filePath);
    const doc = await loadDocx(buffer);
    const sections = splitIntoSections2(doc.body);
    if (sectionNumber < 1 || sectionNumber > sections.length) {
      return error("SECTION_NOT_FOUND", `Section ${sectionNumber} not found. Valid range: 1-${sections.length}`);
    }
    const section = sections[sectionNumber - 1];
    const content = section.content.map(serializeBlockContent).filter((c) => c !== undefined);
    return success({
      sectionNumber,
      sectionProperties: section.sectPr ? serializeSection(section.sectPr) : undefined,
      content
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse DOCX: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/commands/extract.ts
import * as fs8 from "fs/promises";
function parseRangePart2(part, maxSection, result) {
  if (part.includes("-")) {
    const [startStr, endStr] = part.split("-").map((s) => s.trim());
    const start = parseInt(startStr, 10);
    const end = parseInt(endStr, 10);
    if (Number.isNaN(start) || Number.isNaN(end)) {
      return;
    }
    for (let i2 = Math.max(1, start);i2 <= Math.min(maxSection, end); i2++) {
      if (!result.includes(i2)) {
        result.push(i2);
      }
    }
  } else {
    const num = parseInt(part, 10);
    if (!Number.isNaN(num) && num >= 1 && num <= maxSection && !result.includes(num)) {
      result.push(num);
    }
  }
}
function parseSectionRange(range2, maxSection) {
  const result = [];
  const parts = range2.split(",").map((s) => s.trim());
  for (const part of parts) {
    parseRangePart2(part, maxSection, result);
  }
  return result.sort((a, b) => a - b);
}
function splitIntoSections3(body) {
  const sections = [];
  const currentContent = [];
  for (const block of body.content) {
    if (block.type === "sectionBreak") {
      sections.push({ content: [...currentContent] });
      currentContent.length = 0;
    } else {
      currentContent.push(block);
    }
  }
  sections.push({ content: currentContent });
  return sections;
}
function getSectionNumbers(options, count) {
  if (options.sections) {
    return parseSectionRange(options.sections, count);
  }
  return Array.from({ length: count }, (_, i2) => i2 + 1);
}
async function runExtract2(filePath, options) {
  try {
    const buffer = await fs8.readFile(filePath);
    const doc = await loadDocx(buffer);
    const sections = splitIntoSections3(doc.body);
    const sectionNumbers = getSectionNumbers(options, sections.length);
    const items = sectionNumbers.map((sectionNumber) => {
      const section = sections[sectionNumber - 1];
      const text = section.content.map(extractTextFromBlockContent).join(`
`);
      return { number: sectionNumber, text };
    });
    return success({ sections: items });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse DOCX: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/commands/build.ts
import * as fs9 from "fs/promises";
import * as path6 from "path";
async function runBuild2(specPath) {
  try {
    const specJson = await fs9.readFile(specPath, "utf-8");
    const spec = JSON.parse(specJson);
    const specDir = path6.dirname(specPath);
    const templatePath = path6.resolve(specDir, spec.template);
    const outputPath = path6.resolve(specDir, spec.output);
    await fs9.access(templatePath);
    await fs9.mkdir(path6.dirname(outputPath), { recursive: true });
    await fs9.copyFile(templatePath, outputPath);
    return success({ outputPath: spec.output, success: true });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${err2.path}`);
    }
    if (err2 instanceof SyntaxError) {
      return error("INVALID_JSON", `Invalid JSON: ${err2.message}`);
    }
    return error("BUILD_ERROR", `Build failed: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/commands/verify.ts
import * as fs10 from "fs/promises";
import * as path7 from "path";
function createAssertion2(path8, expected, actual) {
  return {
    path: path8,
    expected,
    actual,
    passed: JSON.stringify(expected) === JSON.stringify(actual)
  };
}
async function runTestCase2(spec, specDir) {
  const assertions = [];
  const input = {
    ...spec.input,
    template: path7.resolve(specDir, spec.input.template),
    output: path7.resolve(specDir, spec.input.output)
  };
  await fs10.mkdir(path7.dirname(input.output), { recursive: true });
  const tempSpecPath = path7.join(path7.dirname(input.output), `${spec.name}.build.json`);
  await fs10.writeFile(tempSpecPath, JSON.stringify(input, null, 2));
  try {
    const buildResult = await runBuild2(tempSpecPath);
    if (!buildResult.success) {
      return {
        name: spec.name,
        passed: false,
        assertions: [createAssertion2("build", "success", buildResult.error.message)]
      };
    }
    const infoResult = await runInfo2(input.output);
    if (!infoResult.success) {
      return {
        name: spec.name,
        passed: false,
        assertions: [createAssertion2("info", "readable", infoResult.error.message)]
      };
    }
    const info = infoResult.data;
    if (spec.expected.paragraphCount !== undefined) {
      assertions.push(createAssertion2("paragraphCount", spec.expected.paragraphCount, info.paragraphCount));
    }
    if (spec.expected.tableCount !== undefined) {
      assertions.push(createAssertion2("tableCount", spec.expected.tableCount, info.tableCount));
    }
    if (spec.expected.sectionCount !== undefined) {
      assertions.push(createAssertion2("sectionCount", spec.expected.sectionCount, info.sectionCount));
    }
    if (spec.expected.hasStyles !== undefined) {
      assertions.push(createAssertion2("hasStyles", spec.expected.hasStyles, info.hasStyles));
    }
    if (spec.expected.hasNumbering !== undefined) {
      assertions.push(createAssertion2("hasNumbering", spec.expected.hasNumbering, info.hasNumbering));
    }
    const passed = assertions.every((a) => a.passed);
    return { name: spec.name, passed, assertions };
  } finally {
    await fs10.unlink(tempSpecPath).catch(() => {});
  }
}
async function findTestCaseFiles2(targetPath) {
  const stat3 = await fs10.stat(targetPath);
  if (stat3.isFile()) {
    return [targetPath];
  }
  const entries = await fs10.readdir(targetPath, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    if (entry.isFile() && entry.name.endsWith(".json") && !entry.name.includes(".build.")) {
      files.push(path7.join(targetPath, entry.name));
    } else if (entry.isDirectory() && !entry.name.startsWith("__") && !entry.name.startsWith(".")) {
      const subFiles = await findTestCaseFiles2(path7.join(targetPath, entry.name));
      files.push(...subFiles);
    }
  }
  return files.sort();
}
async function loadTestCase2(filePath) {
  const content = await fs10.readFile(filePath, "utf-8");
  return JSON.parse(content);
}
async function runVerify2(specPath, options = {}) {
  try {
    const absolutePath = path7.resolve(specPath);
    const files = await findTestCaseFiles2(absolutePath);
    if (files.length === 0) {
      return error("NO_TEST_CASES", `No test case files found in: ${specPath}`);
    }
    const results = [];
    for (const file of files) {
      const spec = await loadTestCase2(file);
      if (options.tag && !spec.tags?.includes(options.tag)) {
        continue;
      }
      const specDir = path7.dirname(file);
      const result = await runTestCase2(spec, specDir);
      results.push(result);
    }
    if (results.length === 0) {
      return error("NO_MATCHING_TESTS", `No test cases matched tag: ${options.tag}`);
    }
    const passed = results.filter((r) => r.passed).length;
    const failed = results.length - passed;
    return success({ passed, failed, results });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `Path not found: ${specPath}`);
    }
    if (err2 instanceof SyntaxError) {
      return error("INVALID_JSON", `Invalid JSON: ${err2.message}`);
    }
    return error("VERIFY_ERROR", `Verification failed: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/commands/styles.ts
import * as fs11 from "fs/promises";
async function runStyles(filePath, options = {}) {
  try {
    const buffer = await fs11.readFile(filePath);
    const doc = await loadDocx(buffer);
    if (!doc.styles) {
      return success({
        totalCount: 0,
        paragraphCount: 0,
        characterCount: 0,
        tableCount: 0,
        numberingCount: 0,
        styles: []
      });
    }
    if (options.type) {
      const validTypes = ["paragraph", "character", "table", "numbering"];
      if (!validTypes.includes(options.type)) {
        return error("INVALID_ARGUMENT", `Invalid style type: ${options.type}. Must be one of: ${validTypes.join(", ")}`);
      }
    }
    const filteredStyles = doc.styles.style.filter((s) => !options.type || s.type === options.type).filter((s) => options.all || !s.semiHidden);
    const styles = filteredStyles.map((style) => ({
      styleId: style.styleId,
      type: style.type,
      ...style.name?.val && { name: style.name.val },
      ...style.basedOn?.val && { basedOn: style.basedOn.val },
      ...style.next?.val && { next: style.next.val },
      ...style.link?.val && { link: style.link.val },
      ...style.default && { default: true },
      ...style.customStyle && { customStyle: true },
      ...style.qFormat && { qFormat: true },
      ...style.semiHidden && { semiHidden: true },
      ...style.uiPriority?.val !== undefined && { uiPriority: style.uiPriority.val }
    }));
    const paragraphCount = doc.styles.style.filter((s) => s.type === "paragraph").length;
    const characterCount = doc.styles.style.filter((s) => s.type === "character").length;
    const tableCount = doc.styles.style.filter((s) => s.type === "table").length;
    const numberingCount = doc.styles.style.filter((s) => s.type === "numbering").length;
    return success({
      totalCount: doc.styles.style.length,
      paragraphCount,
      characterCount,
      tableCount,
      numberingCount,
      styles
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse DOCX: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/commands/numbering.ts
import * as fs12 from "fs/promises";
function serializeLevel(level) {
  return {
    ilvl: level.ilvl,
    ...level.start !== undefined && { start: level.start },
    ...level.numFmt && { numFmt: level.numFmt },
    ...level.lvlText?.val && { lvlText: level.lvlText.val },
    ...level.lvlJc && { lvlJc: level.lvlJc },
    ...level.suff && { suff: level.suff },
    ...level.pStyle && { pStyle: level.pStyle }
  };
}
function serializeAbstractNum(abstractNum) {
  return {
    abstractNumId: abstractNum.abstractNumId,
    ...abstractNum.multiLevelType && { multiLevelType: abstractNum.multiLevelType },
    ...abstractNum.nsid && { nsid: abstractNum.nsid },
    levels: abstractNum.lvl.map(serializeLevel)
  };
}
function serializeNum(num) {
  return {
    numId: num.numId,
    abstractNumId: num.abstractNumId,
    hasOverrides: (num.lvlOverride?.length ?? 0) > 0
  };
}
async function runNumbering(filePath) {
  try {
    const buffer = await fs12.readFile(filePath);
    const doc = await loadDocx(buffer);
    if (!doc.numbering) {
      return success({
        abstractNumCount: 0,
        numCount: 0,
        abstractNums: [],
        nums: []
      });
    }
    const abstractNums = doc.numbering.abstractNum.map(serializeAbstractNum);
    const nums = doc.numbering.num.map(serializeNum);
    return success({
      abstractNumCount: abstractNums.length,
      numCount: nums.length,
      abstractNums,
      nums
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse DOCX: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/commands/headers-footers.ts
import * as fs13 from "fs/promises";
async function runHeadersFooters(filePath) {
  try {
    const buffer = await fs13.readFile(filePath);
    const doc = await loadDocx(buffer);
    const items = [];
    if (doc.headers) {
      for (const [relId, header] of doc.headers) {
        const paragraphCount = header.content.filter((c) => c.type === "paragraph").length;
        const text = header.content.map((c) => extractTextFromBlockContent(c)).join(" ").trim();
        const preview = text.length > 80 ? `${text.slice(0, 77)}...` : text || undefined;
        items.push({
          relId,
          kind: "header",
          paragraphCount,
          ...preview && { preview }
        });
      }
    }
    if (doc.footers) {
      for (const [relId, footer] of doc.footers) {
        const paragraphCount = footer.content.filter((c) => c.type === "paragraph").length;
        const text = footer.content.map((c) => extractTextFromBlockContent(c)).join(" ").trim();
        const preview = text.length > 80 ? `${text.slice(0, 77)}...` : text || undefined;
        items.push({
          relId,
          kind: "footer",
          paragraphCount,
          ...preview && { preview }
        });
      }
    }
    const headerCount = items.filter((i2) => i2.kind === "header").length;
    const footerCount = items.filter((i2) => i2.kind === "footer").length;
    return success({
      headerCount,
      footerCount,
      items
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse DOCX: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/commands/tables.ts
import * as fs14 from "fs/promises";
function serializeTable3(table, index) {
  const rowCount = table.rows.length;
  const colCount = table.rows[0]?.cells.length ?? 0;
  const style = table.properties?.tblStyle;
  let firstCellPreview;
  const firstCell = table.rows[0]?.cells[0];
  if (firstCell) {
    const text = firstCell.content.map((c) => extractTextFromBlockContent(c)).join(" ").trim();
    firstCellPreview = text.length > 50 ? `${text.slice(0, 47)}...` : text || undefined;
  }
  return {
    index,
    rowCount,
    colCount,
    ...style && { style },
    ...firstCellPreview && { firstCellPreview }
  };
}
async function runTables2(filePath) {
  try {
    const buffer = await fs14.readFile(filePath);
    const doc = await loadDocx(buffer);
    const tables = [];
    let tableIndex = 0;
    for (const block of doc.body.content) {
      if (block.type === "table") {
        tables.push(serializeTable3(block, tableIndex));
        tableIndex++;
      }
    }
    return success({
      count: tables.length,
      tables
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse DOCX: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/commands/comments.ts
import * as fs15 from "fs/promises";
async function runComments(filePath) {
  try {
    const buffer = await fs15.readFile(filePath);
    const doc = await loadDocx(buffer);
    if (!doc.comments || doc.comments.comment.length === 0) {
      return success({
        count: 0,
        comments: []
      });
    }
    const comments = doc.comments.comment.map((c) => ({
      id: c.id,
      author: c.author,
      ...c.initials && { initials: c.initials },
      ...c.date && { date: c.date },
      text: c.content.map(extractTextFromBlockContent).join(`
`)
    }));
    return success({
      count: comments.length,
      comments
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse DOCX: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/commands/images.ts
import * as fs16 from "fs/promises";
function extractImageFromDrawing(drawing, index) {
  const base = {
    index,
    type: drawing.type,
    name: drawing.docPr?.name,
    description: drawing.docPr?.descr,
    width: drawing.extent?.cx,
    height: drawing.extent?.cy,
    embedId: drawing.pic?.blipFill?.blip?.rEmbed,
    linkId: drawing.pic?.blipFill?.blip?.rLink
  };
  if (drawing.type === "anchor") {
    const posH = drawing.positionH;
    const posV = drawing.positionV;
    return {
      ...base,
      position: {
        horizontal: posH ? `${posH.relativeFrom}${posH.align ? `:${posH.align}` : ""}` : undefined,
        vertical: posV ? `${posV.relativeFrom}${posV.align ? `:${posV.align}` : ""}` : undefined
      },
      wrap: drawing.wrap?.type
    };
  }
  return base;
}
function extractImagesFromRun(run, images) {
  for (const content of run.content) {
    if (content.type === "drawing") {
      images.push(extractImageFromDrawing(content.drawing, images.length));
    }
  }
}
function extractImagesFromParagraph(paragraph, images) {
  for (const content of paragraph.content) {
    if (content.type === "run") {
      extractImagesFromRun(content, images);
    } else if (content.type === "hyperlink") {
      for (const run of content.content) {
        extractImagesFromRun(run, images);
      }
    }
  }
}
function extractImagesFromContent(content, images) {
  for (const block of content) {
    if (block.type === "paragraph") {
      extractImagesFromParagraph(block, images);
    } else if (block.type === "table") {
      for (const row of block.content) {
        for (const cell of row.content) {
          extractImagesFromContent(cell.content, images);
        }
      }
    }
  }
}
async function runImages2(filePath) {
  try {
    const buffer = await fs16.readFile(filePath);
    const doc = await loadDocx(buffer);
    const images = [];
    extractImagesFromContent(doc.body.content, images);
    if (doc.headers) {
      for (const [, header] of doc.headers) {
        extractImagesFromContent(header.content, images);
      }
    }
    if (doc.footers) {
      for (const [, footer] of doc.footers) {
        extractImagesFromContent(footer.content, images);
      }
    }
    return success({
      count: images.length,
      images
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse DOCX: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/commands/toc.ts
import * as fs17 from "fs/promises";
function extractTocFromParagraph(paragraph, entries) {
  const outlineLvl = paragraph.properties?.outlineLvl;
  if (outlineLvl === undefined) {
    return;
  }
  const text = extractTextFromBlockContent(paragraph).trim();
  if (!text) {
    return;
  }
  entries.push({
    level: outlineLvl,
    text,
    style: paragraph.properties?.pStyle
  });
}
function extractTocFromContent(content, entries) {
  for (const block of content) {
    if (block.type === "paragraph") {
      extractTocFromParagraph(block, entries);
    }
  }
}
async function runToc(filePath, options = {}) {
  try {
    const buffer = await fs17.readFile(filePath);
    const doc = await loadDocx(buffer);
    const entries = [];
    extractTocFromContent(doc.body.content, entries);
    const maxLevelFilter = options.maxLevel ?? 9;
    const filteredEntries = entries.filter((e) => e.level <= maxLevelFilter);
    const maxLevel = filteredEntries.reduce((max2, e) => Math.max(max2, e.level), -1);
    return success({
      count: filteredEntries.length,
      maxLevel: maxLevel >= 0 ? maxLevel : 0,
      entries: filteredEntries
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse DOCX: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/commands/preview.ts
import * as fs18 from "fs/promises";

// packages/@oxen-renderer/docx/src/ascii/paragraph-renderer.ts
function renderHeading(para, width) {
  const level = para.headingLevel ?? 0;
  const prefix = "#".repeat(level + 1) + " ";
  const text = prefix + para.text;
  return wrapText(text, width);
}
function renderNumberedItem(para, width) {
  const level = para.numbering?.level ?? 0;
  const indent = "  ".repeat(level);
  const prefix = `${indent}${para.numbering?.numId ?? 1}. `;
  const lines = wrapText(para.text, width - prefix.length);
  return lines.map((line, i2) => i2 === 0 ? prefix + line : " ".repeat(prefix.length) + line);
}
function renderBulletItem(para, width) {
  const level = para.numbering?.level ?? 0;
  const indent = "  ".repeat(level);
  const bullet = `${indent}\u2022 `;
  const lines = wrapText(para.text, width - bullet.length);
  return lines.map((line, i2) => i2 === 0 ? bullet + line : " ".repeat(bullet.length) + line);
}
function renderPlainParagraph(text, width) {
  if (text.length === 0) {
    return [""];
  }
  const indent = "  ";
  const lines = wrapText(text, width - indent.length);
  return lines.map((line) => indent + line);
}
function renderParagraphAscii(para, width) {
  if (para.headingLevel !== undefined) {
    return renderHeading(para, width);
  }
  if (para.numbering) {
    return renderNumberedItem(para, width);
  }
  if (para.text.startsWith("\u2022") || para.text.startsWith("-") || para.text.startsWith("*")) {
    return renderBulletItem({ ...para, text: para.text.replace(/^[\u2022\-*]\s*/, ""), numbering: { numId: 0, level: 0 } }, width);
  }
  return renderPlainParagraph(para.text, width);
}

// packages/@oxen-renderer/docx/src/ascii/table-renderer.ts
function renderDocxTableAscii(table, width) {
  if (table.rows.length === 0) {
    return "";
  }
  const firstRow = table.rows[0];
  const headers = firstRow.cells.map((c) => c.text);
  const dataRows = table.rows.slice(1).map((row) => row.cells.map((c) => c.text));
  return renderAsciiTable({
    headers,
    rows: dataRows,
    maxWidth: width
  });
}

// packages/@oxen-renderer/docx/src/ascii/document-renderer.ts
function renderDocxAscii(params) {
  const { blocks, width } = params;
  const sections = [];
  for (const block of blocks) {
    if (block.type === "paragraph") {
      const lines = renderParagraphAscii(block, width);
      sections.push(lines.join(`
`));
    } else if (block.type === "table") {
      sections.push(renderDocxTableAscii(block, width));
    }
  }
  return sections.join(`

`);
}
// packages/@oxen-cli/docx-cli/src/commands/preview.ts
function splitIntoSections4(body) {
  const sections = [];
  const currentContent = [];
  for (const block of body.content) {
    if (block.type === "sectionBreak") {
      sections.push({ content: [...currentContent] });
      currentContent.length = 0;
    } else {
      currentContent.push(block);
    }
  }
  sections.push({ content: currentContent });
  return sections;
}
function extractParagraphText(para) {
  return para.content.map((c) => {
    if (c.type === "run") {
      return c.content.map((rc) => rc.type === "text" ? rc.value : "").join("");
    }
    return "";
  }).join("");
}
function getHeadingLevel(para) {
  const props = para.properties;
  if (!props) {
    return;
  }
  if ("outlineLvl" in props && typeof props.outlineLvl === "number") {
    return props.outlineLvl;
  }
  const style = props.pStyle;
  if (style) {
    const match = style.match(/^Heading(\d+)$/i);
    if (match) {
      return parseInt(match[1], 10) - 1;
    }
  }
  return;
}
function convertParagraph(para) {
  const text = extractParagraphText(para);
  const headingLevel = getHeadingLevel(para);
  const props = para.properties;
  let numbering;
  if (props && "numPr" in props && props.numPr) {
    const numPr = props.numPr;
    numbering = { numId: numPr.numId ?? 0, level: numPr.ilvl ?? 0 };
  }
  return {
    type: "paragraph",
    style: props?.pStyle,
    headingLevel,
    numbering,
    text
  };
}
function extractCellText2(cell) {
  return cell.content.filter((c) => c.type === "paragraph").map(extractParagraphText).join(`
`);
}
function convertTable(table) {
  return {
    type: "table",
    rows: table.rows.map((row) => ({
      cells: row.cells.map((cell) => ({ text: extractCellText2(cell) }))
    }))
  };
}
function convertBlock(block) {
  switch (block.type) {
    case "paragraph":
      return convertParagraph(block);
    case "table":
      return convertTable(block);
    default:
      return;
  }
}
async function runPreview2(filePath, sectionNumber, options) {
  try {
    const buffer = await fs18.readFile(filePath);
    const doc = await loadDocx(buffer);
    const sections = splitIntoSections4(doc.body);
    if (sectionNumber !== undefined && (sectionNumber < 1 || sectionNumber > sections.length)) {
      return error("SECTION_NOT_FOUND", `Section ${sectionNumber} not found. Valid range: 1-${sections.length}`);
    }
    const start = sectionNumber ?? 1;
    const end = sectionNumber ?? sections.length;
    const results = [];
    for (let i2 = start;i2 <= end; i2++) {
      const section = sections[i2 - 1];
      const blocks = [];
      let paragraphCount = 0;
      let tableCount = 0;
      for (const block of section.content) {
        const converted = convertBlock(block);
        if (converted) {
          blocks.push(converted);
          if (converted.type === "paragraph") {
            paragraphCount++;
          } else {
            tableCount++;
          }
        }
      }
      const ascii = renderDocxAscii({ blocks, width: options.width });
      results.push({
        number: i2,
        ascii,
        blocks,
        paragraphCount,
        tableCount
      });
    }
    return success({ sections: results });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse DOCX: ${err2.message}`);
  }
}

// packages/@oxen-cli/docx-cli/src/output/pretty-output.ts
function formatInfoPretty2(data) {
  const lines = [
    `Paragraphs: ${data.paragraphCount}`,
    `Tables: ${data.tableCount}`,
    `Sections: ${data.sectionCount}`
  ];
  if (data.pageSize) {
    lines.push(`Page Size: ${data.pageSize.width}pt \xD7 ${data.pageSize.height}pt (${data.pageSize.orientation ?? "portrait"})`);
  }
  lines.push(`Styles: ${data.hasStyles ? "yes" : "no"}`);
  lines.push(`Numbering: ${data.hasNumbering ? "yes" : "no"}`);
  lines.push(`Headers: ${data.hasHeaders ? "yes" : "no"}`);
  lines.push(`Footers: ${data.hasFooters ? "yes" : "no"}`);
  lines.push(`Comments: ${data.hasComments ? "yes" : "no"}`);
  lines.push(`Settings: ${data.hasSettings ? "yes" : "no"}`);
  if (data.settings) {
    if (data.settings.trackRevisions !== undefined) {
      lines.push(`  Track Revisions: ${data.settings.trackRevisions ? "yes" : "no"}`);
    }
    if (data.settings.defaultTabStop !== undefined) {
      lines.push(`  Default Tab Stop: ${data.settings.defaultTabStop} twips`);
    }
    if (data.settings.zoom !== undefined) {
      lines.push(`  Zoom: ${data.settings.zoom}%`);
    }
    if (data.settings.protection) {
      lines.push(`  Protection: ${data.settings.protection}`);
    }
  }
  return lines.join(`
`);
}
function formatListPretty2(data) {
  if (data.sections.length === 0) {
    return "No sections found";
  }
  return data.sections.map((section) => {
    const parts = [
      `Section ${section.number}:`,
      `  Paragraphs: ${section.paragraphCount}`,
      `  Tables: ${section.tableCount}`
    ];
    if (section.pageWidth && section.pageHeight) {
      parts.push(`  Page: ${section.pageWidth}pt \xD7 ${section.pageHeight}pt`);
    }
    if (section.orientation) {
      parts.push(`  Orientation: ${section.orientation}`);
    }
    if (section.columns) {
      parts.push(`  Columns: ${section.columns}`);
    }
    if (section.firstParagraphText) {
      parts.push(`  Preview: "${section.firstParagraphText}"`);
    }
    return parts.join(`
`);
  }).join(`

`);
}
function formatShowPretty2(data) {
  const lines = [`Section ${data.sectionNumber}:`];
  if (data.sectionProperties) {
    if (data.sectionProperties.type) {
      lines.push(`  Type: ${data.sectionProperties.type}`);
    }
    if (data.sectionProperties.pageSize) {
      lines.push(`  Page: ${data.sectionProperties.pageSize.width}pt \xD7 ${data.sectionProperties.pageSize.height}pt`);
    }
  }
  lines.push("");
  lines.push(`Content (${data.content.length} blocks):`);
  for (const block of data.content) {
    if (block.type === "paragraph") {
      const text = block.content.map((c) => ("text" in c) ? c.text : "").join("").trim();
      if (text) {
        const preview = text.length > 80 ? `${text.slice(0, 77)}...` : text;
        lines.push(`  [P] ${preview}`);
      } else {
        lines.push("  [P] (empty)");
      }
    } else if (block.type === "table") {
      lines.push(`  [T] ${block.rowCount} rows \xD7 ${block.colCount} cols`);
    }
  }
  return lines.join(`
`);
}
function formatExtractPretty2(data) {
  return data.sections.map((section) => `--- Section ${section.number} ---
${section.text || "(empty)"}`).join(`

`);
}
function formatBuildPretty2(data) {
  return `Built: ${data.outputPath}`;
}
function formatVerifyPretty2(data) {
  const lines = [`Results: ${data.passed} passed, ${data.failed} failed`];
  lines.push("");
  for (const result of data.results) {
    const status = result.passed ? "\u2713" : "\u2717";
    lines.push(`${status} ${result.name}`);
    if (!result.passed) {
      for (const assertion of result.assertions.filter((a) => !a.passed)) {
        lines.push(`    ${assertion.path}: expected ${JSON.stringify(assertion.expected)}, got ${JSON.stringify(assertion.actual)}`);
      }
    }
  }
  return lines.join(`
`);
}
function formatStylesPretty(data) {
  if (data.totalCount === 0) {
    return "No styles found";
  }
  const lines = [
    `Total Styles: ${data.totalCount}`,
    `  Paragraph: ${data.paragraphCount}`,
    `  Character: ${data.characterCount}`,
    `  Table: ${data.tableCount}`,
    `  Numbering: ${data.numberingCount}`,
    ""
  ];
  const byType = new Map;
  for (const style of data.styles) {
    const list = byType.get(style.type) ?? [];
    byType.set(style.type, [...list, style]);
  }
  for (const [type, styles] of byType) {
    lines.push(`${type.charAt(0).toUpperCase() + type.slice(1)} Styles:`);
    for (const style of styles) {
      const flags = [];
      if (style.default) {
        flags.push("default");
      }
      if (style.customStyle) {
        flags.push("custom");
      }
      if (style.qFormat) {
        flags.push("qFormat");
      }
      if (style.semiHidden) {
        flags.push("hidden");
      }
      const name = style.name ?? style.styleId;
      const flagStr = flags.length > 0 ? ` [${flags.join(", ")}]` : "";
      lines.push(`  ${style.styleId}: ${name}${flagStr}`);
      if (style.basedOn) {
        lines.push(`    Based on: ${style.basedOn}`);
      }
    }
    lines.push("");
  }
  return lines.join(`
`).trim();
}
function formatNumberingPretty(data) {
  if (data.abstractNumCount === 0 && data.numCount === 0) {
    return "No numbering definitions found";
  }
  const lines = [
    `Abstract Numberings: ${data.abstractNumCount}`,
    `Numbering Instances: ${data.numCount}`,
    ""
  ];
  if (data.abstractNums.length > 0) {
    lines.push("Abstract Numberings:");
    for (const an of data.abstractNums) {
      lines.push(`  [${an.abstractNumId}] ${an.multiLevelType ?? "unknown"}`);
      for (const lvl of an.levels) {
        const parts = [`    Level ${lvl.ilvl}:`];
        if (lvl.numFmt) {
          parts.push(`fmt=${lvl.numFmt}`);
        }
        if (lvl.lvlText) {
          parts.push(`text="${lvl.lvlText}"`);
        }
        if (lvl.start !== undefined) {
          parts.push(`start=${lvl.start}`);
        }
        lines.push(parts.join(" "));
      }
    }
    lines.push("");
  }
  if (data.nums.length > 0) {
    lines.push("Numbering Instances:");
    for (const num of data.nums) {
      const override = num.hasOverrides ? " [has overrides]" : "";
      lines.push(`  numId=${num.numId} -> abstractNumId=${num.abstractNumId}${override}`);
    }
  }
  return lines.join(`
`).trim();
}
function formatHeadersFootersPretty(data) {
  if (data.headerCount === 0 && data.footerCount === 0) {
    return "No headers or footers found";
  }
  const lines = [
    `Headers: ${data.headerCount}`,
    `Footers: ${data.footerCount}`,
    ""
  ];
  const headers = data.items.filter((i2) => i2.kind === "header");
  const footers = data.items.filter((i2) => i2.kind === "footer");
  if (headers.length > 0) {
    lines.push("Headers:");
    for (const h of headers) {
      lines.push(`  ${h.relId}: ${h.paragraphCount} paragraphs`);
      if (h.preview) {
        lines.push(`    "${h.preview}"`);
      }
    }
    lines.push("");
  }
  if (footers.length > 0) {
    lines.push("Footers:");
    for (const f of footers) {
      lines.push(`  ${f.relId}: ${f.paragraphCount} paragraphs`);
      if (f.preview) {
        lines.push(`    "${f.preview}"`);
      }
    }
  }
  return lines.join(`
`).trim();
}
function formatTablesPretty2(data) {
  if (data.count === 0) {
    return "No tables found";
  }
  const lines = [`Tables: ${data.count}`, ""];
  for (const table of data.tables) {
    lines.push(`Table ${table.index + 1}: ${table.rowCount} rows \xD7 ${table.colCount} cols`);
    if (table.style) {
      lines.push(`  Style: ${table.style}`);
    }
    if (table.firstCellPreview) {
      lines.push(`  First cell: "${table.firstCellPreview}"`);
    }
  }
  return lines.join(`
`).trim();
}
function formatImagesPretty2(data) {
  if (data.count === 0) {
    return "No images found";
  }
  const lines = [`Images: ${data.count}`, ""];
  for (const img of data.images) {
    const name = img.name || `Image ${img.index + 1}`;
    lines.push(`[${img.index}] ${name} (${img.type})`);
    if (img.description) {
      lines.push(`  Description: ${img.description}`);
    }
    if (img.width !== undefined && img.height !== undefined) {
      const widthPx = Math.round(img.width / 9525);
      const heightPx = Math.round(img.height / 9525);
      lines.push(`  Size: ${widthPx}px \xD7 ${heightPx}px`);
    }
    if (img.embedId) {
      lines.push(`  Embed ID: ${img.embedId}`);
    }
    if (img.linkId) {
      lines.push(`  Link ID: ${img.linkId}`);
    }
    if (img.position) {
      const posStr = [
        img.position.horizontal ? `H: ${img.position.horizontal}` : null,
        img.position.vertical ? `V: ${img.position.vertical}` : null
      ].filter(Boolean).join(", ");
      if (posStr) {
        lines.push(`  Position: ${posStr}`);
      }
    }
    if (img.wrap) {
      lines.push(`  Wrap: ${img.wrap}`);
    }
    lines.push("");
  }
  return lines.join(`
`).trim();
}
function formatTocPretty(data) {
  if (data.count === 0) {
    return "No headings found (no paragraphs with outline levels)";
  }
  const lines = [`Table of Contents: ${data.count} entries (max level: ${data.maxLevel})`, ""];
  for (const entry of data.entries) {
    const indent = "  ".repeat(entry.level);
    const styleStr = entry.style ? ` [${entry.style}]` : "";
    lines.push(`${indent}${entry.level}. ${entry.text}${styleStr}`);
  }
  return lines.join(`
`);
}
function formatPreviewPretty2(data) {
  const lines = [];
  for (let i2 = 0;i2 < data.sections.length; i2++) {
    const section = data.sections[i2];
    if (i2 > 0) {
      lines.push("");
    }
    lines.push(`Section ${section.number} (${section.paragraphCount} paragraphs, ${section.tableCount} tables)`);
    lines.push("");
    lines.push(section.ascii);
  }
  return lines.join(`
`);
}
function formatCommentsPretty(data) {
  if (data.count === 0) {
    return "No comments found";
  }
  const lines = [`Comments: ${data.count}`, ""];
  for (const comment of data.comments) {
    const dateStr = comment.date ? ` (${comment.date})` : "";
    const initialsStr = comment.initials ? ` [${comment.initials}]` : "";
    lines.push(`[${comment.id}] ${comment.author}${initialsStr}${dateStr}`);
    const textLines = comment.text.split(`
`);
    for (const line of textLines) {
      lines.push(`  ${line}`);
    }
    lines.push("");
  }
  return lines.join(`
`).trim();
}

// packages/@oxen-renderer/docx/src/mermaid/document-renderer.ts
function renderParagraph(para) {
  const text = para.text.trim();
  if (!text) {
    return "";
  }
  if (para.headingLevel !== undefined) {
    const hashes = "#".repeat(Math.min(para.headingLevel + 1, 6));
    return `${hashes} ${text}`;
  }
  if (para.numbering) {
    const indent = "  ".repeat(para.numbering.level);
    return `${indent}1. ${text}`;
  }
  return text;
}
function renderTable2(table) {
  if (table.rows.length === 0) {
    return "";
  }
  const headers = table.rows[0]?.cells.map((c) => c.text) ?? [];
  const dataRows = table.rows.slice(1).map((r) => r.cells.map((c) => c.text));
  return renderMarkdownTable({ headers, rows: dataRows });
}
function renderDocxMermaid(params) {
  const sections = [];
  for (const block of params.blocks) {
    if (block.type === "paragraph") {
      const rendered = renderParagraph(block);
      if (rendered) {
        sections.push(rendered);
      }
    } else if (block.type === "table") {
      const rendered = renderTable2(block);
      if (rendered) {
        sections.push(rendered);
      }
    }
  }
  return sections.join(`

`);
}
// packages/@oxen-cli/docx-cli/src/output/mermaid-output.ts
function formatPreviewMermaid2(data) {
  const sections = [];
  for (const section of data.sections) {
    const header = `## Section ${section.number}`;
    const mermaid = renderDocxMermaid({ blocks: section.blocks });
    sections.push(mermaid ? `${header}

${mermaid}` : header);
  }
  return sections.join(`

`);
}

// packages/@oxen-cli/docx-cli/src/program.ts
function createProgram2() {
  const program2 = new Command;
  program2.name("docx").description("CLI tool for inspecting DOCX files").version("0.1.0").option("-o, --output <mode>", "Output mode (json|pretty|mermaid)", "pretty");
  program2.command("info").description("Display document metadata").argument("<file>", "DOCX file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runInfo2(file);
    output(result, mode, formatInfoPretty2);
  });
  program2.command("list").description("List sections with summary").argument("<file>", "DOCX file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runList2(file);
    output(result, mode, formatListPretty2);
  });
  program2.command("show").description("Display section content").argument("<file>", "DOCX file path").argument("<section>", "Section number (1-based)").action(async (file, section) => {
    const mode = program2.opts().output;
    const sectionNumber = parseInt(section, 10);
    if (Number.isNaN(sectionNumber)) {
      console.error("Error: Section number must be a valid integer");
      process.exitCode = 1;
      return;
    }
    const result = await runShow2(file, sectionNumber);
    output(result, mode, formatShowPretty2);
  });
  program2.command("extract").description("Extract text from sections").argument("<file>", "DOCX file path").option("--sections <range>", 'Section range (e.g., "1,3-5")').action(async (file, options) => {
    const mode = program2.opts().output;
    const result = await runExtract2(file, options);
    output(result, mode, formatExtractPretty2);
  });
  program2.command("build").description("Build DOCX from JSON specification").argument("<spec>", "JSON spec file path").action(async (spec) => {
    const mode = program2.opts().output;
    const result = await runBuild2(spec);
    output(result, mode, formatBuildPretty2);
  });
  program2.command("verify").description("Verify DOCX build results against expected values").argument("<path>", "Test case file or directory path").option("--tag <tag>", "Filter test cases by tag").action(async (specPath, options) => {
    const mode = program2.opts().output;
    const result = await runVerify2(specPath, options);
    output(result, mode, formatVerifyPretty2);
  });
  program2.command("styles").description("Display document styles").argument("<file>", "DOCX file path").option("--type <type>", "Filter by style type (paragraph|character|table|numbering)").option("--all", "Include semi-hidden styles").action(async (file, options) => {
    const mode = program2.opts().output;
    const result = await runStyles(file, options);
    output(result, mode, formatStylesPretty);
  });
  program2.command("numbering").description("Display numbering definitions").argument("<file>", "DOCX file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runNumbering(file);
    output(result, mode, formatNumberingPretty);
  });
  program2.command("headers-footers").description("Display headers and footers").argument("<file>", "DOCX file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runHeadersFooters(file);
    output(result, mode, formatHeadersFootersPretty);
  });
  program2.command("tables").description("Display table information").argument("<file>", "DOCX file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runTables2(file);
    output(result, mode, formatTablesPretty2);
  });
  program2.command("comments").description("Display document comments").argument("<file>", "DOCX file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runComments(file);
    output(result, mode, formatCommentsPretty);
  });
  program2.command("images").description("Display embedded images").argument("<file>", "DOCX file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runImages2(file);
    output(result, mode, formatImagesPretty2);
  });
  program2.command("toc").description("Display table of contents (based on outline levels)").argument("<file>", "DOCX file path").option("--max-level <level>", "Maximum heading level to include (0-9)", "9").action(async (file, options) => {
    const mode = program2.opts().output;
    const maxLevel = options.maxLevel ? parseInt(options.maxLevel, 10) : undefined;
    const result = await runToc(file, { maxLevel });
    output(result, mode, formatTocPretty);
  });
  program2.command("preview").description("Render ASCII art preview of document content").argument("<file>", "DOCX file path").argument("[section]", "Section number (1-based, omit for all)").option("--width <columns>", "Terminal width in columns", "80").action(async (file, section, options) => {
    const mode = program2.opts().output;
    let sectionNumber;
    if (section !== undefined) {
      sectionNumber = parseInt(section, 10);
      if (Number.isNaN(sectionNumber)) {
        console.error("Error: Section number must be a valid integer");
        process.exitCode = 1;
        return;
      }
    }
    const width = parseInt(options.width, 10);
    if (Number.isNaN(width) || width < 20) {
      console.error("Error: Width must be an integer >= 20");
      process.exitCode = 1;
      return;
    }
    const result = await runPreview2(file, sectionNumber, { width });
    output(result, mode, formatPreviewPretty2, formatPreviewMermaid2);
  });
  return program2;
}
// packages/@oxen-cli/xlsx-cli/src/utils/xlsx-loader.ts
import * as fs19 from "fs/promises";

// packages/@oxen-office/xlsx/src/domain/style/types.ts
function createDefaultStyleSheet() {
  const defaultFont = {
    name: "Calibri",
    size: 11,
    scheme: "minor"
  };
  const defaultFills = [
    { type: "none" },
    { type: "pattern", pattern: { patternType: "gray125" } }
  ];
  const defaultBorder = {};
  const defaultCellXf = {
    numFmtId: numFmtId(0),
    fontId: fontId(0),
    fillId: fillId(0),
    borderId: borderId(0)
  };
  const defaultCellStyleXf = {
    numFmtId: numFmtId(0),
    fontId: fontId(0),
    fillId: fillId(0),
    borderId: borderId(0)
  };
  const defaultCellStyle = {
    name: "Normal",
    xfId: 0,
    builtinId: 0
  };
  return {
    fonts: [defaultFont],
    fills: defaultFills,
    borders: [defaultBorder],
    numberFormats: [],
    cellXfs: [defaultCellXf],
    cellStyleXfs: [defaultCellStyleXf],
    cellStyles: [defaultCellStyle]
  };
}

// packages/@oxen-office/xlsx/src/parser/context.ts
function createParseContext3(params) {
  return params;
}

// packages/@oxen-office/xlsx/src/domain/date-system.ts
var EXCEL_1904_TO_1900_DAY_OFFSET = 1462;
function resolveXlsxDateSystem(date1904) {
  return date1904 ? "1904" : "1900";
}

// packages/@oxen-office/xlsx/src/parser/shared-strings.ts
function parseSharedStrings(sstElement) {
  const result = [];
  const siElements = getChildren(sstElement, "si");
  for (const si of siElements) {
    const t = getChild(si, "t");
    if (t) {
      result.push(getTextContent(t));
      continue;
    }
    const runs = getChildren(si, "r");
    const text = runs.map((r) => {
      const rt = getChild(r, "t");
      return rt ? getTextContent(rt) : "";
    }).join("");
    result.push(text);
  }
  return result;
}
function parseColor4(colorElement) {
  if (!colorElement) {
    return;
  }
  const rgb = getAttr(colorElement, "rgb");
  if (rgb) {
    return { type: "rgb", value: rgb };
  }
  const theme = getAttr(colorElement, "theme");
  if (theme !== undefined) {
    const tint = getAttr(colorElement, "tint");
    return {
      type: "theme",
      theme: parseInt(theme, 10),
      tint: tint !== undefined ? parseFloat(tint) : undefined
    };
  }
  const indexed = getAttr(colorElement, "indexed");
  if (indexed !== undefined) {
    return { type: "indexed", index: parseInt(indexed, 10) };
  }
  const auto = getAttr(colorElement, "auto");
  if (auto === "1" || auto === "true") {
    return { type: "auto" };
  }
  return;
}
function parseRunProperties4(rPrElement) {
  if (!rPrElement) {
    return;
  }
  const props = {};
  const b = getChild(rPrElement, "b");
  if (b) {
    const val = getAttr(b, "val");
    props.bold = val === undefined || val === "1" || val === "true";
  }
  const i2 = getChild(rPrElement, "i");
  if (i2) {
    const val = getAttr(i2, "val");
    props.italic = val === undefined || val === "1" || val === "true";
  }
  const u = getChild(rPrElement, "u");
  if (u) {
    const val = getAttr(u, "val");
    props.underline = val !== "none";
  }
  const strike = getChild(rPrElement, "strike");
  if (strike) {
    const val = getAttr(strike, "val");
    props.strike = val === undefined || val === "1" || val === "true";
  }
  const sz = getChild(rPrElement, "sz");
  if (sz) {
    const val = getAttr(sz, "val");
    if (val !== undefined) {
      props.fontSize = parseFloat(val);
    }
  }
  const rFont = getChild(rPrElement, "rFont");
  if (rFont) {
    const val = getAttr(rFont, "val");
    if (val !== undefined) {
      props.fontName = val;
    }
  }
  const color = getChild(rPrElement, "color");
  const parsedColor = parseColor4(color);
  if (parsedColor) {
    props.color = parsedColor;
  }
  if (Object.keys(props).length === 0) {
    return;
  }
  return props;
}
function parseRichTextRun(rElement) {
  const t = getChild(rElement, "t");
  const text = t ? getTextContent(t) : "";
  const rPr = getChild(rElement, "rPr");
  const properties = parseRunProperties4(rPr);
  return properties ? { text, properties } : { text };
}
function parseSharedStringsRich(sstElement) {
  const result = [];
  const siElements = getChildren(sstElement, "si");
  for (const si of siElements) {
    const t = getChild(si, "t");
    const runs = getChildren(si, "r");
    if (t && runs.length === 0) {
      result.push({
        type: "plain",
        text: getTextContent(t)
      });
      continue;
    }
    if (runs.length > 0) {
      const parsedRuns = runs.map(parseRichTextRun);
      result.push({
        type: "rich",
        runs: parsedRuns
      });
      continue;
    }
    result.push({
      type: "plain",
      text: ""
    });
  }
  return result;
}

// packages/@oxen-office/xlsx/src/parser/primitive.ts
function parseIntAttr2(value) {
  if (value === undefined || value === "") {
    return;
  }
  const num = parseInt(value, 10);
  if (isNaN(num)) {
    return;
  }
  return num;
}
function parseIntRequired(value, attrName) {
  const result = parseIntAttr2(value);
  if (result === undefined) {
    throw new Error(`Required attribute "${attrName}" is missing or invalid`);
  }
  return result;
}
function parseFloatAttr(value) {
  if (value === undefined || value === "") {
    return;
  }
  const num = parseFloat(value);
  if (isNaN(num)) {
    return;
  }
  return num;
}
function parseBooleanAttr(value) {
  if (value === undefined) {
    return;
  }
  if (value === "1" || value === "true") {
    return true;
  }
  if (value === "0" || value === "false") {
    return false;
  }
  return;
}

// packages/@oxen-office/xlsx/src/parser/styles/font.ts
function parseColor5(colorElement) {
  const rgb = getAttr(colorElement, "rgb");
  if (rgb) {
    return { type: "rgb", value: rgb };
  }
  const theme = getAttr(colorElement, "theme");
  if (theme !== undefined) {
    const tint = parseFloatAttr(getAttr(colorElement, "tint"));
    return {
      type: "theme",
      theme: parseInt(theme, 10),
      tint
    };
  }
  const indexed = getAttr(colorElement, "indexed");
  if (indexed !== undefined) {
    return { type: "indexed", index: parseInt(indexed, 10) };
  }
  if (getAttr(colorElement, "auto") !== undefined) {
    return { type: "auto" };
  }
  return;
}
function parseBoolElement(el) {
  if (!el) {
    return;
  }
  const val = getAttr(el, "val");
  if (val === undefined) {
    return true;
  }
  return parseBooleanAttr(val);
}
function parseUnderlineElement(uEl) {
  if (!uEl) {
    return;
  }
  const uVal = getAttr(uEl, "val");
  if (uVal === undefined) {
    return "single";
  }
  return uVal;
}
function parseSchemeElement(schemeEl) {
  if (!schemeEl) {
    return;
  }
  const schemeVal = getAttr(schemeEl, "val");
  if (schemeVal === "major" || schemeVal === "minor" || schemeVal === "none") {
    return schemeVal;
  }
  return;
}
function parseVertAlignElement(vertAlignEl) {
  if (!vertAlignEl) {
    return;
  }
  const vertAlignVal = getAttr(vertAlignEl, "val");
  if (vertAlignVal === "superscript" || vertAlignVal === "subscript" || vertAlignVal === "baseline") {
    return vertAlignVal;
  }
  return;
}
function parseFont(fontElement) {
  const nameEl = getChild(fontElement, "name");
  const szEl = getChild(fontElement, "sz");
  const bEl = getChild(fontElement, "b");
  const iEl = getChild(fontElement, "i");
  const uEl = getChild(fontElement, "u");
  const strikeEl = getChild(fontElement, "strike");
  const colorEl = getChild(fontElement, "color");
  const familyEl = getChild(fontElement, "family");
  const schemeEl = getChild(fontElement, "scheme");
  const vertAlignEl = getChild(fontElement, "vertAlign");
  const outlineEl = getChild(fontElement, "outline");
  const shadowEl = getChild(fontElement, "shadow");
  const condenseEl = getChild(fontElement, "condense");
  const extendEl = getChild(fontElement, "extend");
  return {
    name: nameEl ? getAttr(nameEl, "val") ?? "Calibri" : "Calibri",
    size: parseFloatAttr(szEl ? getAttr(szEl, "val") : undefined) ?? 11,
    bold: parseBoolElement(bEl),
    italic: parseBoolElement(iEl),
    underline: parseUnderlineElement(uEl),
    strikethrough: parseBoolElement(strikeEl),
    color: colorEl ? parseColor5(colorEl) : undefined,
    family: parseIntAttr2(familyEl ? getAttr(familyEl, "val") : undefined),
    scheme: parseSchemeElement(schemeEl),
    vertAlign: parseVertAlignElement(vertAlignEl),
    outline: parseBoolElement(outlineEl),
    shadow: parseBoolElement(shadowEl),
    condense: parseBoolElement(condenseEl),
    extend: parseBoolElement(extendEl)
  };
}
function parseFonts(fontsElement) {
  const result = [];
  const fontElements = getChildren(fontsElement, "font");
  for (const fontEl of fontElements) {
    result.push(parseFont(fontEl));
  }
  return result;
}

// packages/@oxen-office/xlsx/src/parser/styles/fill.ts
function parseColor6(colorElement) {
  const rgb = getAttr(colorElement, "rgb");
  if (rgb) {
    return { type: "rgb", value: rgb };
  }
  const theme = getAttr(colorElement, "theme");
  if (theme !== undefined) {
    const tint = getAttr(colorElement, "tint");
    return {
      type: "theme",
      theme: parseIntAttr2(theme) ?? 0,
      tint: tint !== undefined ? parseFloatAttr(tint) : undefined
    };
  }
  const indexed = getAttr(colorElement, "indexed");
  if (indexed !== undefined) {
    return { type: "indexed", index: parseIntAttr2(indexed) ?? 0 };
  }
  const auto = getAttr(colorElement, "auto");
  if (auto === "1" || auto === "true") {
    return { type: "auto" };
  }
  return;
}
function parsePatternFill2(patternFillElement) {
  const patternType = getAttr(patternFillElement, "patternType") ?? "none";
  const fgColorEl = getChild(patternFillElement, "fgColor");
  const bgColorEl = getChild(patternFillElement, "bgColor");
  return {
    patternType,
    fgColor: fgColorEl ? parseColor6(fgColorEl) : undefined,
    bgColor: bgColorEl ? parseColor6(bgColorEl) : undefined
  };
}
function parseGradientFill2(gradientFillElement) {
  const gradientType = getAttr(gradientFillElement, "type") ?? "linear";
  const degree = parseFloatAttr(getAttr(gradientFillElement, "degree"));
  const stops = [];
  const stopElements = getChildren(gradientFillElement, "stop");
  for (const stopEl of stopElements) {
    const position = parseFloatAttr(getAttr(stopEl, "position")) ?? 0;
    const colorEl = getChild(stopEl, "color");
    if (colorEl) {
      const color = parseColor6(colorEl);
      if (color) {
        stops.push({ position, color });
      }
    }
  }
  return { gradientType, degree, stops };
}
function parseFill2(fillElement) {
  const patternFillEl = getChild(fillElement, "patternFill");
  if (patternFillEl) {
    const patternType = getAttr(patternFillEl, "patternType");
    if (patternType === "none") {
      return { type: "none" };
    }
    return { type: "pattern", pattern: parsePatternFill2(patternFillEl) };
  }
  const gradientFillEl = getChild(fillElement, "gradientFill");
  if (gradientFillEl) {
    return { type: "gradient", gradient: parseGradientFill2(gradientFillEl) };
  }
  return { type: "none" };
}
function parseFills(fillsElement) {
  const result = [];
  const fillElements = getChildren(fillsElement, "fill");
  for (const fillEl of fillElements) {
    result.push(parseFill2(fillEl));
  }
  return result;
}

// packages/@oxen-office/xlsx/src/parser/styles/border.ts
function parseBorderEdge(edgeElement) {
  if (!edgeElement) {
    return;
  }
  const style = getAttr(edgeElement, "style");
  if (!style || style === "none") {
    return;
  }
  const colorEl = getChild(edgeElement, "color");
  const color = colorEl ? parseColor5(colorEl) : undefined;
  return { style, color };
}
function parseBorder(borderElement) {
  const left = parseBorderEdge(getChild(borderElement, "left"));
  const right = parseBorderEdge(getChild(borderElement, "right"));
  const top = parseBorderEdge(getChild(borderElement, "top"));
  const bottom = parseBorderEdge(getChild(borderElement, "bottom"));
  const diagonal = parseBorderEdge(getChild(borderElement, "diagonal"));
  const diagonalUp = parseBooleanAttr(getAttr(borderElement, "diagonalUp"));
  const diagonalDown = parseBooleanAttr(getAttr(borderElement, "diagonalDown"));
  const outline = parseBooleanAttr(getAttr(borderElement, "outline"));
  return {
    left,
    right,
    top,
    bottom,
    diagonal,
    diagonalUp,
    diagonalDown,
    outline
  };
}
function parseBorders(bordersElement) {
  const result = [];
  const borderElements = getChildren(bordersElement, "border");
  for (const borderEl of borderElements) {
    result.push(parseBorder(borderEl));
  }
  return result;
}

// packages/@oxen-office/xlsx/src/domain/style/number-format.ts
var BUILTIN_NUMBER_FORMATS = new Map([
  [0, "General"],
  [1, "0"],
  [2, "0.00"],
  [3, "#,##0"],
  [4, "#,##0.00"],
  [9, "0%"],
  [10, "0.00%"],
  [11, "0.00E+00"],
  [12, "# ?/?"],
  [13, "# ??/??"],
  [14, "mm-dd-yy"],
  [15, "d-mmm-yy"],
  [16, "d-mmm"],
  [17, "mmm-yy"],
  [18, "h:mm AM/PM"],
  [19, "h:mm:ss AM/PM"],
  [20, "h:mm"],
  [21, "h:mm:ss"],
  [22, "m/d/yy h:mm"],
  [37, "#,##0 ;(#,##0)"],
  [38, "#,##0 ;[Red](#,##0)"],
  [39, "#,##0.00;(#,##0.00)"],
  [40, "#,##0.00;[Red](#,##0.00)"],
  [45, "mm:ss"],
  [46, "[h]:mm:ss"],
  [47, "mmss.0"],
  [48, "##0.0E+0"],
  [49, "@"]
]);
function isDateFormat(formatCode) {
  const withoutQuoted = formatCode.replace(/"[^"]*"/g, "");
  return /[ymdhs]|AM\/PM/i.test(withoutQuoted);
}

// packages/@oxen-office/xlsx/src/parser/styles/number-format.ts
function parseNumFmt(numFmtElement) {
  const numFmtIdAttr = getAttr(numFmtElement, "numFmtId");
  const formatCode = getAttr(numFmtElement, "formatCode") ?? "";
  const id = parseIntRequired(numFmtIdAttr, "numFmtId");
  return {
    numFmtId: numFmtId(id),
    formatCode
  };
}
function parseNumFmts(numFmtsElement) {
  if (!numFmtsElement) {
    return [];
  }
  const result = [];
  const numFmtElements = getChildren(numFmtsElement, "numFmt");
  for (const numFmtEl of numFmtElements) {
    result.push(parseNumFmt(numFmtEl));
  }
  return result;
}

// packages/@oxen-office/xlsx/src/parser/styles/dxf.ts
function parseDxfNumberFormat(numFmtEl) {
  const id = parseIntAttr2(getAttr(numFmtEl, "numFmtId")) ?? 0;
  const formatCode = getAttr(numFmtEl, "formatCode") ?? "";
  return { numFmtId: numFmtId(id), formatCode };
}
function parseBoolElement2(el) {
  if (!el) {
    return;
  }
  const val = getAttr(el, "val");
  if (val === undefined) {
    return true;
  }
  return parseBooleanAttr(val);
}
function parseUnderlineElement2(uEl) {
  if (!uEl) {
    return;
  }
  const uVal = getAttr(uEl, "val");
  if (uVal === undefined) {
    return "single";
  }
  return uVal;
}
function parseDxfFont(fontEl) {
  const nameEl = getChild(fontEl, "name");
  const szEl = getChild(fontEl, "sz");
  const bEl = getChild(fontEl, "b");
  const iEl = getChild(fontEl, "i");
  const uEl = getChild(fontEl, "u");
  const strikeEl = getChild(fontEl, "strike");
  const colorEl = getChild(fontEl, "color");
  return {
    name: nameEl ? getAttr(nameEl, "val") ?? undefined : undefined,
    size: parseFloatAttr(szEl ? getAttr(szEl, "val") : undefined),
    bold: parseBoolElement2(bEl),
    italic: parseBoolElement2(iEl),
    underline: parseUnderlineElement2(uEl),
    strikethrough: parseBoolElement2(strikeEl),
    color: colorEl ? parseColor5(colorEl) : undefined
  };
}
function parseDxf(dxfEl) {
  const numFmtEl = getChild(dxfEl, "numFmt");
  const fontEl = getChild(dxfEl, "font");
  const fillEl = getChild(dxfEl, "fill");
  const borderEl = getChild(dxfEl, "border");
  return {
    numFmt: numFmtEl ? parseDxfNumberFormat(numFmtEl) : undefined,
    font: fontEl ? parseDxfFont(fontEl) : undefined,
    fill: fillEl ? parseFill2(fillEl) : undefined,
    border: borderEl ? parseBorder(borderEl) : undefined
  };
}
function parseDxfs(dxfsEl) {
  if (!dxfsEl) {
    return [];
  }
  return getChildren(dxfsEl, "dxf").map(parseDxf);
}

// packages/@oxen-office/xlsx/src/parser/styles/index.ts
function parseAlignment(alignmentElement) {
  return {
    horizontal: getAttr(alignmentElement, "horizontal"),
    vertical: getAttr(alignmentElement, "vertical"),
    wrapText: parseBooleanAttr(getAttr(alignmentElement, "wrapText")),
    shrinkToFit: parseBooleanAttr(getAttr(alignmentElement, "shrinkToFit")),
    textRotation: parseIntAttr2(getAttr(alignmentElement, "textRotation")),
    indent: parseIntAttr2(getAttr(alignmentElement, "indent")),
    readingOrder: parseIntAttr2(getAttr(alignmentElement, "readingOrder"))
  };
}
function parseProtection2(protectionElement) {
  return {
    locked: parseBooleanAttr(getAttr(protectionElement, "locked")),
    hidden: parseBooleanAttr(getAttr(protectionElement, "hidden"))
  };
}
function parseCellXf(xfElement) {
  const alignmentEl = getChild(xfElement, "alignment");
  const protectionEl = getChild(xfElement, "protection");
  return {
    numFmtId: numFmtId(parseIntAttr2(getAttr(xfElement, "numFmtId")) ?? 0),
    fontId: fontId(parseIntAttr2(getAttr(xfElement, "fontId")) ?? 0),
    fillId: fillId(parseIntAttr2(getAttr(xfElement, "fillId")) ?? 0),
    borderId: borderId(parseIntAttr2(getAttr(xfElement, "borderId")) ?? 0),
    xfId: parseIntAttr2(getAttr(xfElement, "xfId")),
    alignment: alignmentEl ? parseAlignment(alignmentEl) : undefined,
    protection: protectionEl ? parseProtection2(protectionEl) : undefined,
    applyNumberFormat: parseBooleanAttr(getAttr(xfElement, "applyNumberFormat")),
    applyFont: parseBooleanAttr(getAttr(xfElement, "applyFont")),
    applyFill: parseBooleanAttr(getAttr(xfElement, "applyFill")),
    applyBorder: parseBooleanAttr(getAttr(xfElement, "applyBorder")),
    applyAlignment: parseBooleanAttr(getAttr(xfElement, "applyAlignment")),
    applyProtection: parseBooleanAttr(getAttr(xfElement, "applyProtection"))
  };
}
function parseCellXfs(cellXfsElement) {
  if (!cellXfsElement) {
    return [];
  }
  return getChildren(cellXfsElement, "xf").map(parseCellXf);
}
function parseCellStyle(cellStyleElement) {
  return {
    name: getAttr(cellStyleElement, "name") ?? "Normal",
    xfId: parseIntAttr2(getAttr(cellStyleElement, "xfId")) ?? 0,
    builtinId: parseIntAttr2(getAttr(cellStyleElement, "builtinId"))
  };
}
function parseCellStyles(cellStylesElement) {
  if (!cellStylesElement) {
    return [];
  }
  return getChildren(cellStylesElement, "cellStyle").map(parseCellStyle);
}
function parseIndexedColors(styleSheetElement) {
  const colorsEl = getChild(styleSheetElement, "colors");
  if (!colorsEl) {
    return [];
  }
  const indexedColorsEl = getChild(colorsEl, "indexedColors");
  if (!indexedColorsEl) {
    return [];
  }
  return getChildren(indexedColorsEl, "rgbColor").map((el) => getAttr(el, "rgb")).filter((value) => typeof value === "string" && value.length > 0);
}
function parseTableStyleElementType(raw) {
  switch (raw) {
    case "wholeTable":
    case "headerRow":
    case "totalRow":
    case "firstColumn":
    case "lastColumn":
    case "firstRowStripe":
    case "secondRowStripe":
    case "firstColumnStripe":
    case "secondColumnStripe":
    case "firstHeaderCell":
    case "lastHeaderCell":
    case "firstTotalCell":
    case "lastTotalCell":
      return raw;
  }
  return;
}
function parseTableStyles(styleSheetElement) {
  const tableStylesEl = getChild(styleSheetElement, "tableStyles");
  if (!tableStylesEl) {
    return { tableStyles: [], defaultTableStyle: undefined, defaultPivotStyle: undefined };
  }
  const defaultTableStyle = getAttr(tableStylesEl, "defaultTableStyle") ?? undefined;
  const defaultPivotStyle = getAttr(tableStylesEl, "defaultPivotStyle") ?? undefined;
  const tableStyles = getChildren(tableStylesEl, "tableStyle").map((tableStyleEl) => {
    const name = getAttr(tableStyleEl, "name");
    if (!name) {
      throw new Error('tableStyle missing required attribute "name"');
    }
    const pivot = parseBooleanAttr(getAttr(tableStyleEl, "pivot"));
    const count = parseIntAttr2(getAttr(tableStyleEl, "count"));
    const elements = getChildren(tableStyleEl, "tableStyleElement").map((el) => {
      const typeRaw = getAttr(el, "type");
      const type = typeRaw ? parseTableStyleElementType(typeRaw) : undefined;
      const dxfId = parseIntAttr2(getAttr(el, "dxfId"));
      if (!type || dxfId === undefined) {
        return;
      }
      return { type, dxfId };
    }).filter((value) => value !== undefined);
    return { name, pivot, count, elements };
  });
  return { tableStyles, defaultTableStyle, defaultPivotStyle };
}
function parseStyleSheet(styleSheetElement) {
  const numFmtsEl = getChild(styleSheetElement, "numFmts");
  const fontsEl = getChild(styleSheetElement, "fonts");
  const fillsEl = getChild(styleSheetElement, "fills");
  const bordersEl = getChild(styleSheetElement, "borders");
  const cellStyleXfsEl = getChild(styleSheetElement, "cellStyleXfs");
  const cellXfsEl = getChild(styleSheetElement, "cellXfs");
  const cellStylesEl = getChild(styleSheetElement, "cellStyles");
  const dxfsEl = getChild(styleSheetElement, "dxfs");
  const indexedColors = parseIndexedColors(styleSheetElement);
  const parsedTableStyles = parseTableStyles(styleSheetElement);
  const dxfs = parseDxfs(dxfsEl);
  return {
    numberFormats: parseNumFmts(numFmtsEl),
    fonts: fontsEl ? parseFonts(fontsEl) : [],
    fills: fillsEl ? parseFills(fillsEl) : [],
    borders: bordersEl ? parseBorders(bordersEl) : [],
    cellStyleXfs: parseCellXfs(cellStyleXfsEl),
    cellXfs: parseCellXfs(cellXfsEl),
    cellStyles: parseCellStyles(cellStylesEl),
    ...indexedColors.length > 0 ? { indexedColors } : {},
    ...dxfs.length > 0 ? { dxfs } : {},
    ...parsedTableStyles.tableStyles.length > 0 ? { tableStyles: parsedTableStyles.tableStyles } : {},
    ...parsedTableStyles.defaultTableStyle ? { defaultTableStyle: parsedTableStyles.defaultTableStyle } : {},
    ...parsedTableStyles.defaultPivotStyle ? { defaultPivotStyle: parsedTableStyles.defaultPivotStyle } : {}
  };
}

// packages/@oxen-office/xlsx/src/domain/cell/address.ts
function columnLetterToIndex(col) {
  if (!col || col.length === 0) {
    throw new Error("Column letter cannot be empty");
  }
  const upper = col.toUpperCase();
  for (const char of upper) {
    const charCode = char.charCodeAt(0);
    if (charCode < 65 || charCode > 90) {
      throw new Error(`Invalid column letter: ${col}`);
    }
  }
  const index = [...upper].reduce((acc, char) => acc * 26 + (char.charCodeAt(0) - 64), 0);
  return colIdx(index);
}
function indexToColumnLetterRecursive(n, acc) {
  if (n <= 0) {
    return acc;
  }
  const adjusted = n - 1;
  const char = String.fromCharCode(adjusted % 26 + 65);
  return indexToColumnLetterRecursive(Math.floor(adjusted / 26), char + acc);
}
function indexToColumnLetter(idx) {
  if (idx < 1) {
    throw new Error(`Column index must be >= 1, got ${idx}`);
  }
  return indexToColumnLetterRecursive(idx, "");
}
var CELL_REF_REGEX = /^(\$)?([A-Za-z]+)(\$)?(\d+)$/;
function parseCellRef(ref) {
  const match = ref.match(CELL_REF_REGEX);
  if (!match) {
    throw new Error(`Invalid cell reference: ${ref}`);
  }
  const [, colDollar, colLetters, rowDollar, rowDigits] = match;
  return {
    col: columnLetterToIndex(colLetters),
    row: rowIdx(parseInt(rowDigits, 10)),
    colAbsolute: colDollar === "$",
    rowAbsolute: rowDollar === "$"
  };
}
var RANGE_REGEX = /^(?:(?:'([^']+)'|([^!]+))!)?(\$?[A-Za-z]+\$?\d+)(?::(\$?[A-Za-z]+\$?\d+))?$/;
function parseRange(range2) {
  const match = range2.match(RANGE_REGEX);
  if (!match) {
    throw new Error(`Invalid range reference: ${range2}`);
  }
  const [, quotedSheet, unquotedSheet, startRef, endRef] = match;
  const sheetName = quotedSheet ?? unquotedSheet;
  const start = parseCellRef(startRef);
  const end = endRef ? parseCellRef(endRef) : start;
  return {
    start,
    end,
    ...sheetName ? { sheetName } : {}
  };
}
function formatCellRef(addr) {
  const colPrefix = addr.colAbsolute ? "$" : "";
  const rowPrefix = addr.rowAbsolute ? "$" : "";
  return `${colPrefix}${indexToColumnLetter(addr.col)}${rowPrefix}${addr.row}`;
}
function formatRange(range2) {
  const startStr = formatCellRef(range2.start);
  const endStr = formatCellRef(range2.end);
  const isSingleCell = range2.start.col === range2.end.col && range2.start.row === range2.end.row && range2.start.colAbsolute === range2.end.colAbsolute && range2.start.rowAbsolute === range2.end.rowAbsolute;
  const rangeStr = isSingleCell ? startStr : `${startStr}:${endStr}`;
  if (range2.sheetName) {
    const needsQuotes = /[\s!']/.test(range2.sheetName);
    const quotedName = needsQuotes ? `'${range2.sheetName}'` : range2.sheetName;
    return `${quotedName}!${rangeStr}`;
  }
  return rangeStr;
}

// packages/@oxen-office/xlsx/src/parser/comments.ts
function matchesLocalName(element, localName2) {
  return element.name === localName2 || element.name.endsWith(`:${localName2}`);
}
function collectDescendantsByLocalName(element, localName2) {
  const self = matchesLocalName(element, localName2) ? [element] : [];
  const children = element.children.flatMap((child) => {
    if (!isXmlElement(child)) {
      return [];
    }
    return collectDescendantsByLocalName(child, localName2);
  });
  return [...self, ...children];
}
function parseCommentText(textElement) {
  const tNodes = collectDescendantsByLocalName(textElement, "t");
  const raw = tNodes.map((t) => getTextContent(t)).join("");
  return raw.replace(/\r\n?/gu, `
`);
}
function parseAuthors(root) {
  const authorsEl = getChild(root, "authors");
  if (!authorsEl) {
    return [];
  }
  return getChildren(authorsEl, "author").map((author) => getTextContent(author));
}
function parseCommentList2(root, authors) {
  const listEl = getChild(root, "commentList");
  if (!listEl) {
    return [];
  }
  return getChildren(listEl, "comment").flatMap((commentEl) => {
    const ref = getAttr(commentEl, "ref");
    if (!ref) {
      return [];
    }
    const authorId = parseIntAttr2(getAttr(commentEl, "authorId"));
    const author = authorId !== undefined ? authors[authorId] : undefined;
    const textEl = getChild(commentEl, "text");
    const text = textEl ? parseCommentText(textEl) : "";
    return [{ address: parseCellRef(ref), author, text }];
  });
}
function parseComments(commentsRoot) {
  const authors = parseAuthors(commentsRoot);
  return parseCommentList2(commentsRoot, authors);
}

// packages/@oxen-office/xlsx/src/parser/table.ts
function requireAttr(element, name) {
  const value = getAttr(element, name);
  if (!value) {
    throw new Error(`Missing required attribute "${name}"`);
  }
  return value;
}
function parseTableColumns(tableElement) {
  const columnsEl = getChildren(tableElement, "tableColumns")[0];
  if (!columnsEl) {
    return [];
  }
  return getChildren(columnsEl, "tableColumn").map((col) => {
    const id = parseIntAttr2(getAttr(col, "id"));
    if (id === undefined) {
      throw new Error('tableColumn missing required attribute "id"');
    }
    const name = requireAttr(col, "name");
    const calculatedColumnFormulaEl = getChild(col, "calculatedColumnFormula");
    const calculatedColumnFormula = calculatedColumnFormulaEl ? getTextContent(calculatedColumnFormulaEl) || undefined : undefined;
    const totalsRowFormula = getAttr(col, "totalsRowFunction") !== "custom" ? undefined : (() => {
      const totalsEl = getChild(col, "totalsRowFormula");
      return totalsEl ? getTextContent(totalsEl) || undefined : undefined;
    })();
    const totalsRowLabel = getAttr(col, "totalsRowLabel") ?? undefined;
    const dataDxfId = parseIntAttr2(getAttr(col, "dataDxfId"));
    return {
      id,
      name,
      calculatedColumnFormula,
      totalsRowFormula,
      totalsRowLabel,
      dataDxfId
    };
  });
}
function parseTableStyleInfo(tableElement) {
  const styleInfoEl = getChild(tableElement, "tableStyleInfo");
  if (!styleInfoEl) {
    return;
  }
  const name = getAttr(styleInfoEl, "name");
  if (!name) {
    return;
  }
  return {
    name,
    showFirstColumn: parseBooleanAttr(getAttr(styleInfoEl, "showFirstColumn")),
    showLastColumn: parseBooleanAttr(getAttr(styleInfoEl, "showLastColumn")),
    showRowStripes: parseBooleanAttr(getAttr(styleInfoEl, "showRowStripes")),
    showColumnStripes: parseBooleanAttr(getAttr(styleInfoEl, "showColumnStripes"))
  };
}
function parseTable3(tableElement, sheetIndex) {
  const id = parseIntAttr2(getAttr(tableElement, "id")) ?? 0;
  const name = requireAttr(tableElement, "name");
  const displayName = getAttr(tableElement, "displayName") ?? undefined;
  const ref = parseRange(requireAttr(tableElement, "ref"));
  const headerRowCount = parseIntAttr2(getAttr(tableElement, "headerRowCount")) ?? 1;
  const totalsRowCountAttr = parseIntAttr2(getAttr(tableElement, "totalsRowCount"));
  const totalsRowShown = parseBooleanAttr(getAttr(tableElement, "totalsRowShown")) === true;
  const totalsRowCount = totalsRowCountAttr ?? (totalsRowShown ? 1 : 0);
  const columns = parseTableColumns(tableElement);
  const styleInfo = parseTableStyleInfo(tableElement);
  return {
    id,
    name,
    displayName,
    ref,
    headerRowCount,
    totalsRowCount,
    sheetIndex,
    columns,
    styleInfo
  };
}

// packages/@oxen-office/xlsx/src/parser/cell.ts
function parseFormula(formulaElement) {
  const expression = getTextContent(formulaElement);
  const type = getAttr(formulaElement, "t") ?? "normal";
  const refAttr = getAttr(formulaElement, "ref");
  const siAttr = getAttr(formulaElement, "si");
  const caAttr = getAttr(formulaElement, "ca");
  return {
    expression,
    type,
    ref: refAttr ? parseRange(refAttr) : undefined,
    sharedIndex: siAttr ? parseInt(siAttr, 10) : undefined,
    calculateAlways: parseBooleanAttr(caAttr)
  };
}
function parseCellValue(cellElement, cellType, context) {
  const v = getChild(cellElement, "v");
  const vText = v ? getTextContent(v) : "";
  const t = cellType ?? "n";
  switch (t) {
    case "s": {
      const idx = parseInt(vText, 10);
      const str = context.sharedStrings[idx] ?? "";
      return { type: "string", value: str };
    }
    case "n": {
      if (vText === "") {
        return { type: "empty" };
      }
      return { type: "number", value: parseFloat(vText) };
    }
    case "b": {
      return { type: "boolean", value: vText === "1" };
    }
    case "e": {
      return { type: "error", value: vText };
    }
    case "str": {
      return { type: "string", value: vText };
    }
    case "inlineStr": {
      const is = getChild(cellElement, "is");
      const t2 = is ? getChild(is, "t") : undefined;
      return { type: "string", value: t2 ? getTextContent(t2) : "" };
    }
    case "d": {
      return { type: "date", value: new Date(vText) };
    }
    default:
      return { type: "string", value: vText };
  }
}
function parseCellWithAddress(cellElement, context, address) {
  const s = getAttr(cellElement, "s");
  const t = getAttr(cellElement, "t");
  const value = parseCellValue(cellElement, t, context);
  const f = getChild(cellElement, "f");
  const formula = f ? parseFormula(f) : undefined;
  return {
    address,
    value,
    formula,
    styleId: s ? styleId(parseInt(s, 10)) : undefined
  };
}

// packages/@oxen-office/xlsx/src/domain/constants.ts
var EXCEL_MAX_ROWS = 1048576;
var EXCEL_MAX_COLS = 16384;

// packages/@oxen-office/xlsx/src/formula/types.ts
function isFormulaError(value) {
  return typeof value === "object" && value !== null && "type" in value && value.type === "error";
}

// packages/@oxen-office/xlsx/src/formula/format.ts
function formatSheetName(sheetName) {
  const needsQuotes = /[\s!']/u.test(sheetName);
  if (!needsQuotes) {
    return sheetName;
  }
  const escaped = sheetName.replaceAll("'", "''");
  return `'${escaped}'`;
}
function formatReferenceWithSheet(sheetName, address) {
  const ref = formatCellRef(address);
  if (!sheetName) {
    return ref;
  }
  return `${formatSheetName(sheetName)}!${ref}`;
}
function formatRangeWithSheet(range2) {
  const start = formatReferenceWithSheet(range2.sheetName, range2.start);
  const end = formatCellRef(range2.end);
  const isSingleCell = range2.start.col === range2.end.col && range2.start.row === range2.end.row && range2.start.colAbsolute === range2.end.colAbsolute && range2.start.rowAbsolute === range2.end.rowAbsolute;
  if (isSingleCell) {
    return start;
  }
  if (range2.sheetName) {
    return `${formatSheetName(range2.sheetName)}!${formatCellRef(range2.start)}:${end}`;
  }
  return `${start}:${end}`;
}
function escapeStringLiteral(value) {
  return value.replaceAll('"', '""');
}
function formatScalar(value) {
  if (value === null) {
    return "0";
  }
  if (typeof value === "string") {
    return `"${escapeStringLiteral(value)}"`;
  }
  if (typeof value === "number") {
    return Number.isFinite(value) ? String(value) : "0";
  }
  if (typeof value === "boolean") {
    return value ? "TRUE" : "FALSE";
  }
  if (isFormulaError(value)) {
    return value.value;
  }
  return "0";
}
function precedence(node) {
  switch (node.type) {
    case "Compare":
      return 0;
    case "Binary":
      switch (node.operator) {
        case "&":
          return 1;
        case "+":
        case "-":
          return 2;
        case "*":
        case "/":
          return 3;
        case "^":
          return 4;
      }
      return 2;
    case "Unary":
      return 5;
    case "Literal":
    case "Reference":
    case "Range":
    case "Name":
    case "StructuredTableReference":
    case "Function":
    case "Array":
      return 6;
  }
}
function needsParens(params) {
  const childPrec = precedence(params.child);
  if (childPrec < params.parentPrec) {
    return true;
  }
  if (childPrec > params.parentPrec) {
    return false;
  }
  if (params.position === "right" && (params.parentOperator === "-" || params.parentOperator === "/" || params.parentOperator === "^")) {
    return params.child.type === "Binary";
  }
  return false;
}
function formatNode(params) {
  const { node, parentPrec, position, parentOperator } = params;
  const selfPrec = precedence(node);
  const wrapIfNeeded = (wrapParams) => {
    const { text, child, childPosition, operator } = wrapParams;
    if (needsParens({ child, parentPrec: selfPrec, position: childPosition, parentOperator: operator })) {
      return `(${text})`;
    }
    return text;
  };
  const formatNodeBody = () => {
    switch (node.type) {
      case "Literal":
        return formatScalar(node.value);
      case "Reference":
        return formatReferenceWithSheet(node.sheetName, node.reference);
      case "Range":
        return formatRangeWithSheet(node.range);
      case "Name":
        return node.name;
      case "StructuredTableReference": {
        const item = node.item;
        const start = node.startColumnName;
        const end = node.endColumnName;
        if (item && !start && !end) {
          return `${node.tableName}[${item}]`;
        }
        if (item && start && end) {
          const itemToken = `[${item}]`;
          const left2 = `[${start}]`;
          const right2 = `[${end}]`;
          const colToken = start === end ? left2 : `${left2}:${right2}`;
          return `${node.tableName}[${itemToken},${colToken}]`;
        }
        if (!start || !end) {
          return `${node.tableName}[#REF!]`;
        }
        if (start === end) {
          return `${node.tableName}[${start}]`;
        }
        const left = `[${start}]`;
        const right = `[${end}]`;
        return `${node.tableName}[${left}:${right}]`;
      }
      case "Function":
        return `${node.name}(${node.args.map((arg) => formatNode({ node: arg, parentPrec: 0, position: "left" })).join(",")})`;
      case "Array": {
        const isEmpty = node.elements.length === 1 && (node.elements[0]?.length ?? 0) === 0;
        if (isEmpty) {
          return "{}";
        }
        const rows = node.elements.map((row) => row.map((el) => formatNode({ node: el, parentPrec: 0, position: "left" })).join(",")).join(";");
        return `{${rows}}`;
      }
      case "Unary": {
        const arg = formatNode({ node: node.argument, parentPrec: selfPrec, position: "right", parentOperator: node.operator });
        const wrapped = wrapIfNeeded({ text: arg, child: node.argument, childPosition: "right", operator: node.operator });
        return `${node.operator}${wrapped}`;
      }
      case "Binary": {
        const left = formatNode({ node: node.left, parentPrec: selfPrec, position: "left", parentOperator: node.operator });
        const right = formatNode({ node: node.right, parentPrec: selfPrec, position: "right", parentOperator: node.operator });
        const leftWrapped = wrapIfNeeded({ text: left, child: node.left, childPosition: "left", operator: node.operator });
        const rightWrapped = wrapIfNeeded({ text: right, child: node.right, childPosition: "right", operator: node.operator });
        return `${leftWrapped}${node.operator}${rightWrapped}`;
      }
      case "Compare": {
        const left = formatNode({ node: node.left, parentPrec: selfPrec, position: "left", parentOperator: node.operator });
        const right = formatNode({ node: node.right, parentPrec: selfPrec, position: "right", parentOperator: node.operator });
        const leftWrapped = wrapIfNeeded({ text: left, child: node.left, childPosition: "left", operator: node.operator });
        const rightWrapped = wrapIfNeeded({ text: right, child: node.right, childPosition: "right", operator: node.operator });
        return `${leftWrapped}${node.operator}${rightWrapped}`;
      }
    }
  };
  const body = formatNodeBody();
  if (needsParens({ child: node, parentPrec, position, parentOperator })) {
    return `(${body})`;
  }
  return body;
}
function formatFormula(ast) {
  return formatNode({ node: ast, parentPrec: 0, position: "left" });
}

// packages/@oxen-office/xlsx/src/formula/parser.ts
var NUMBER_PATTERN = /^[0-9]+(\.[0-9]+)?$/u;
var COLUMN_REF_PATTERN = /^(\$)?([A-Za-z]+)$/u;
var ROW_REF_PATTERN = /^(\$)?(\d+)$/u;
function isDigit(character) {
  return /[0-9]/u.test(character);
}
function isLetter(character) {
  return /[A-Za-z]/u.test(character);
}
function isIdentifierStart(character) {
  return isLetter(character) || character === "_";
}
function isIdentifierBodyStandard(character) {
  return isLetter(character) || isDigit(character) || character === "_";
}
function isIdentifierBodyNamespaced(character) {
  return isIdentifierBodyStandard(character) || character === ".";
}
function isWhitespace2(character) {
  return /\s/u.test(character);
}
function normalizeSheetNameToken(sheetRaw) {
  if (!sheetRaw) {
    return;
  }
  if (sheetRaw.startsWith("'") && sheetRaw.endsWith("'")) {
    return sheetRaw.slice(1, -1).replace(/''/gu, "'");
  }
  return sheetRaw;
}
function parseErrorValue(text) {
  switch (text) {
    case "#NULL!":
    case "#DIV/0!":
    case "#VALUE!":
    case "#REF!":
    case "#NAME?":
    case "#NUM!":
    case "#N/A":
    case "#GETTING_DATA":
      return text;
  }
  return;
}
function readWhile(input, start, condition) {
  const cursor = { index: start, result: "" };
  while (cursor.index < input.length && condition(input[cursor.index] ?? "")) {
    cursor.result += input[cursor.index];
    cursor.index += 1;
  }
  return {
    value: cursor.result,
    next: cursor.index
  };
}
function readNumberToken(input, start) {
  const { value, next } = readWhile(input, start, (char) => isDigit(char) || char === ".");
  if (!NUMBER_PATTERN.test(value)) {
    throw new Error(`Invalid number literal "${value}"`);
  }
  return { token: { type: "number", value: Number.parseFloat(value) }, next };
}
function readStringToken(input, start) {
  const cursor = { index: start + 1, value: "" };
  while (cursor.index < input.length) {
    const char = input[cursor.index] ?? "";
    if (char === '"') {
      if (input[cursor.index + 1] === '"') {
        cursor.value += '"';
        cursor.index += 2;
        continue;
      }
      return { token: { type: "string", value: cursor.value }, next: cursor.index + 1 };
    }
    cursor.value += char;
    cursor.index += 1;
  }
  throw new Error("Unterminated string literal");
}
function isErrorBodyChar(char) {
  return isLetter(char) || isDigit(char) || char === "/" || char === "!" || char === "?" || char === "_";
}
function readErrorToken(input, start) {
  const { value, next } = readWhile(input, start, (char) => isErrorBodyChar(char) || char === "#");
  if (!value.startsWith("#")) {
    throw new Error("Error token must start with '#'");
  }
  const parsed = parseErrorValue(value);
  if (!parsed) {
    throw new Error(`Unknown error literal "${value}"`);
  }
  return { token: { type: "error", value: parsed }, next };
}
function readColumnReferenceLabel(input, start) {
  const cursor = { index: start, label: "" };
  const maybeDollar = input[cursor.index] ?? "";
  if (maybeDollar === "$") {
    cursor.label += "$";
    cursor.index += 1;
  }
  const { value: letters, next } = readWhile(input, cursor.index, (char) => isLetter(char));
  if (letters.length === 0) {
    throw new Error("Missing column in column reference");
  }
  cursor.label += letters.toUpperCase();
  cursor.index = next;
  return { label: cursor.label, next: cursor.index };
}
function readRowReferenceLabel(input, start) {
  const cursor = { index: start, label: "" };
  const maybeDollar = input[cursor.index] ?? "";
  if (maybeDollar === "$") {
    cursor.label += "$";
    cursor.index += 1;
  }
  const { value: digits, next } = readWhile(input, cursor.index, (char) => isDigit(char));
  if (digits.length === 0) {
    throw new Error("Missing row in row reference");
  }
  cursor.label += digits;
  cursor.index = next;
  return { label: cursor.label, next: cursor.index };
}
function readCellLabel(input, start) {
  const cursor = { index: start, label: "" };
  const maybeDollar1 = input[cursor.index] ?? "";
  if (maybeDollar1 === "$") {
    cursor.label += "$";
    cursor.index += 1;
  }
  const { value: columnPart, next: afterColumn } = readWhile(input, cursor.index, (char) => isLetter(char));
  if (columnPart.length === 0) {
    throw new Error("Missing column in cell reference");
  }
  cursor.label += columnPart.toUpperCase();
  cursor.index = afterColumn;
  const maybeDollar2 = input[cursor.index] ?? "";
  if (maybeDollar2 === "$") {
    cursor.label += "$";
    cursor.index += 1;
  }
  const { value: rowPart, next } = readWhile(input, cursor.index, (char) => isDigit(char));
  if (rowPart.length === 0) {
    throw new Error("Missing row in cell reference");
  }
  cursor.label += rowPart;
  return { label: cursor.label, next };
}
function readReferenceLabel(input, start) {
  const first = input[start] ?? "";
  if (first === "$") {
    const next = input[start + 1] ?? "";
    if (isDigit(next)) {
      return readRowReferenceLabel(input, start);
    }
    try {
      return readCellLabel(input, start);
    } catch (error2) {
      if (error2 instanceof Error && error2.message === "Missing row in cell reference") {
        return readColumnReferenceLabel(input, start);
      }
      throw error2;
    }
  }
  if (isLetter(first)) {
    try {
      return readCellLabel(input, start);
    } catch (error2) {
      if (error2 instanceof Error && error2.message === "Missing row in cell reference") {
        return readColumnReferenceLabel(input, start);
      }
      throw error2;
    }
  }
  if (isDigit(first)) {
    return readRowReferenceLabel(input, start);
  }
  throw new Error(`Unexpected reference label start "${first}"`);
}
function escapeSheetNameForFormula(sheetName) {
  return sheetName.replace(/'/gu, "''");
}
function readQuotedSheetReference(input, start) {
  const cursor = { index: start + 1, sheetName: "" };
  while (cursor.index < input.length) {
    const char = input[cursor.index] ?? "";
    if (char === "'") {
      if (input[cursor.index + 1] === "'") {
        cursor.sheetName += "'";
        cursor.index += 2;
        continue;
      }
      cursor.index += 1;
      if (input[cursor.index] !== "!") {
        throw new Error("Quoted sheet reference must be followed by '!'");
      }
      cursor.index += 1;
      const { label, next } = readReferenceLabel(input, cursor.index);
      return { reference: `'${escapeSheetNameForFormula(cursor.sheetName)}'!${label}`, next };
    }
    cursor.sheetName += char;
    cursor.index += 1;
  }
  throw new Error("Unterminated quoted sheet reference");
}
function tryReadSheetSpanReferenceToken(input, start) {
  const first = input[start] ?? "";
  if (!isLetter(first)) {
    return;
  }
  const { value: sheetStart, next: afterStart } = readWhile(input, start, (char) => isLetter(char) || isDigit(char) || char === "_");
  if (sheetStart.length === 0 || (input[afterStart] ?? "") !== ":") {
    return;
  }
  const sheetEndStart = afterStart + 1;
  const { value: sheetEnd, next: afterEnd } = readWhile(input, sheetEndStart, (char) => isLetter(char) || isDigit(char) || char === "_");
  if (sheetEnd.length === 0 || (input[afterEnd] ?? "") !== "!") {
    return;
  }
  const refStart = afterEnd + 1;
  const { label, next } = readReferenceLabel(input, refStart);
  return {
    token: { type: "reference", value: `${sheetStart}:${sheetEnd}!${label}` },
    next
  };
}
function readIdentifierOrReferenceToken(input, start) {
  const allowNamespaceSeparator = (input[start] ?? "") === "_";
  const { value: head, next } = readWhile(input, start, (char) => allowNamespaceSeparator ? isIdentifierBodyNamespaced(char) : isIdentifierBodyStandard(char));
  const upcoming = input[next] ?? "";
  if (upcoming === "[") {
    const cursor = { index: next, depth: 0, value: "" };
    while (cursor.index < input.length) {
      const c = input[cursor.index] ?? "";
      cursor.value += c;
      if (c === "[") {
        cursor.depth += 1;
      } else if (c === "]") {
        cursor.depth -= 1;
        if (cursor.depth === 0) {
          return { token: { type: "reference", value: `${head}${cursor.value}` }, next: cursor.index + 1 };
        }
      }
      cursor.index += 1;
    }
    throw new Error("Unterminated structured reference");
  }
  if (upcoming === "!") {
    const sheetName = head;
    const { label, next: afterLabel } = readReferenceLabel(input, next + 1);
    return { token: { type: "reference", value: `${sheetName}!${label}` }, next: afterLabel };
  }
  if (upcoming === "$") {
    const { label, next: afterLabel } = readReferenceLabel(input, start);
    return { token: { type: "reference", value: label }, next: afterLabel };
  }
  if (/^[A-Za-z]+\d+$/u.test(head) && upcoming !== "(") {
    return { token: { type: "reference", value: head.toUpperCase() }, next };
  }
  if (/^[A-Za-z]+$/u.test(head) && upcoming === ":") {
    return { token: { type: "reference", value: head.toUpperCase() }, next };
  }
  return { token: { type: "identifier", value: head }, next };
}
function tokenize(formula) {
  const tokens = [];
  const cursor = { index: 0 };
  while (cursor.index < formula.length) {
    const char = formula[cursor.index] ?? "";
    if (isWhitespace2(char)) {
      cursor.index += 1;
      continue;
    }
    if (char === "#") {
      const { token, next } = readErrorToken(formula, cursor.index);
      tokens.push(token);
      cursor.index = next;
      continue;
    }
    if (isDigit(char)) {
      const { value: digits, next } = readWhile(formula, cursor.index, (c) => isDigit(c));
      if ((formula[next] ?? "") === ":") {
        tokens.push({ type: "reference", value: digits });
        cursor.index = next;
        continue;
      }
      const { token, next: afterNumber } = readNumberToken(formula, cursor.index);
      tokens.push(token);
      cursor.index = afterNumber;
      continue;
    }
    if (char === '"') {
      const { token, next } = readStringToken(formula, cursor.index);
      tokens.push(token);
      cursor.index = next;
      continue;
    }
    if (char === "'") {
      const { reference, next } = readQuotedSheetReference(formula, cursor.index);
      tokens.push({ type: "reference", value: reference });
      cursor.index = next;
      continue;
    }
    if (char === "$") {
      const { label, next } = readReferenceLabel(formula, cursor.index);
      tokens.push({ type: "reference", value: label });
      cursor.index = next;
      continue;
    }
    if (isIdentifierStart(char)) {
      if (isLetter(char)) {
        const sheetSpan = tryReadSheetSpanReferenceToken(formula, cursor.index);
        if (sheetSpan) {
          tokens.push(sheetSpan.token);
          cursor.index = sheetSpan.next;
          continue;
        }
      }
      const { token, next } = readIdentifierOrReferenceToken(formula, cursor.index);
      tokens.push(token);
      cursor.index = next;
      continue;
    }
    if (char === "(" || char === ")") {
      tokens.push({ type: "paren", value: char });
      cursor.index += 1;
      continue;
    }
    if (char === "{" || char === "}") {
      tokens.push({ type: "bracket", value: char });
      cursor.index += 1;
      continue;
    }
    if (char === ",") {
      tokens.push({ type: "comma" });
      cursor.index += 1;
      continue;
    }
    if (char === ";") {
      tokens.push({ type: "semicolon" });
      cursor.index += 1;
      continue;
    }
    if (char === ":") {
      tokens.push({ type: "colon" });
      cursor.index += 1;
      continue;
    }
    if (char === "+" || char === "-" || char === "*" || char === "/" || char === "^" || char === "&") {
      tokens.push({ type: "operator", value: char });
      cursor.index += 1;
      continue;
    }
    if (char === "<" || char === ">" || char === "=") {
      const nextChar = formula[cursor.index + 1] ?? "";
      if (char === "<" && nextChar === ">") {
        tokens.push({ type: "comparator", value: "<>" });
        cursor.index += 2;
        continue;
      }
      if ((char === "<" || char === ">") && nextChar === "=") {
        tokens.push({ type: "comparator", value: char + "=" });
        cursor.index += 2;
        continue;
      }
      tokens.push({ type: "comparator", value: char });
      cursor.index += 1;
      continue;
    }
    throw new Error(`Unexpected character "${char}"`);
  }
  tokens.push({ type: "end" });
  return tokens;
}
function peek(state) {
  return state.tokens[state.index] ?? { type: "end" };
}
function consume(state) {
  const token = peek(state);
  state.index += 1;
  return token;
}
function expectToken(state, type) {
  const token = consume(state);
  if (token.type !== type) {
    throw new Error(`Expected token "${type}", got "${token.type}"`);
  }
  return token;
}
function parsePrimary(state) {
  const token = peek(state);
  if (token.type === "number") {
    consume(state);
    return { type: "Literal", value: token.value };
  }
  if (token.type === "string") {
    consume(state);
    return { type: "Literal", value: token.value };
  }
  if (token.type === "error") {
    consume(state);
    const error2 = { type: "error", value: token.value };
    return { type: "Literal", value: error2 };
  }
  if (token.type === "reference") {
    consume(state);
    if (token.value.includes("[") === true) {
      const bracket = token.value.indexOf("[");
      const tableName = token.value.slice(0, bracket);
      const remainder = token.value.slice(bracket);
      if (!remainder.startsWith("[") || !remainder.endsWith("]")) {
        throw new Error(`Unsupported structured reference token "${token.value}"`);
      }
      const inner = remainder.slice(1, -1);
      if (inner.startsWith("#")) {
        return { type: "StructuredTableReference", tableName, item: inner };
      }
      if (!inner.startsWith("[")) {
        return { type: "StructuredTableReference", tableName, startColumnName: inner, endColumnName: inner };
      }
      const parseBracketedName = (text, start) => {
        if ((text[start] ?? "") !== "[") {
          throw new Error("Expected '[' in structured reference");
        }
        const end = text.indexOf("]", start + 1);
        if (end === -1) {
          throw new Error("Unterminated column name in structured reference");
        }
        const name = text.slice(start + 1, end);
        return { name, next: end + 1 };
      };
      const first = parseBracketedName(inner, 0);
      const afterFirst = inner[first.next] ?? "";
      if (afterFirst === "") {
        if (first.name.trim().startsWith("#")) {
          return { type: "StructuredTableReference", tableName, item: first.name };
        }
        return { type: "StructuredTableReference", tableName, startColumnName: first.name, endColumnName: first.name };
      }
      if (afterFirst === ":") {
        const second = parseBracketedName(inner, first.next + 1);
        if (inner[second.next] !== undefined) {
          throw new Error(`Unsupported structured reference token "${token.value}"`);
        }
        return { type: "StructuredTableReference", tableName, startColumnName: first.name, endColumnName: second.name };
      }
      if (afterFirst === ",") {
        const item = first.name;
        const second = parseBracketedName(inner, first.next + 1);
        const afterSecond = inner[second.next] ?? "";
        if (afterSecond === "") {
          return { type: "StructuredTableReference", tableName, item, startColumnName: second.name, endColumnName: second.name };
        }
        if (afterSecond !== ":") {
          throw new Error(`Unsupported structured reference token "${token.value}"`);
        }
        const third = parseBracketedName(inner, second.next + 1);
        if (inner[third.next] !== undefined) {
          throw new Error(`Unsupported structured reference token "${token.value}"`);
        }
        return { type: "StructuredTableReference", tableName, item, startColumnName: second.name, endColumnName: third.name };
      }
      throw new Error(`Unsupported structured reference token "${token.value}"`);
    }
    const parseReferenceToken = (value) => {
      const bang = value.lastIndexOf("!");
      const sheetRaw = bang === -1 ? undefined : value.slice(0, bang);
      const ref = bang === -1 ? value : value.slice(bang + 1);
      const sheetName = normalizeSheetNameToken(sheetRaw);
      try {
        const address = parseCellRef(ref);
        return { kind: "cell", start: address, end: address, ...sheetName ? { sheetName } : {} };
      } catch (error2) {
        if (!(error2 instanceof Error)) {
          throw error2;
        }
      }
      const colMatch = ref.match(COLUMN_REF_PATTERN);
      if (colMatch) {
        const [, dollar, letters] = colMatch;
        const col = columnLetterToIndex(letters);
        const colAbsolute = dollar === "$";
        return {
          kind: "column",
          ...sheetName ? { sheetName } : {},
          start: { col, row: rowIdx(1), colAbsolute, rowAbsolute: true },
          end: { col, row: rowIdx(EXCEL_MAX_ROWS), colAbsolute, rowAbsolute: true }
        };
      }
      const rowMatch = ref.match(ROW_REF_PATTERN);
      if (rowMatch) {
        const [, dollar, digits] = rowMatch;
        const rowNumber = Number.parseInt(digits, 10);
        const rowAbsolute = dollar === "$";
        return {
          kind: "row",
          ...sheetName ? { sheetName } : {},
          start: { col: colIdx(1), row: rowIdx(rowNumber), colAbsolute: true, rowAbsolute },
          end: { col: colIdx(EXCEL_MAX_COLS), row: rowIdx(rowNumber), colAbsolute: true, rowAbsolute }
        };
      }
      throw new Error(`Unsupported reference token "${value}"`);
    };
    const left = parseReferenceToken(token.value);
    if (peek(state).type === "colon") {
      consume(state);
      const endToken = expectToken(state, "reference");
      const right = parseReferenceToken(endToken.value);
      if (left.kind !== right.kind) {
        throw new Error("Mixed row/column/cell reference kinds are not supported");
      }
      if (left.sheetName && right.sheetName && left.sheetName !== right.sheetName) {
        throw new Error("Cross-sheet ranges are not supported");
      }
      const sheetName = left.sheetName ?? right.sheetName;
      const range2 = {
        start: left.start,
        end: right.end,
        ...sheetName ? { sheetName } : {}
      };
      return { type: "Range", range: range2 };
    }
    if (left.kind !== "cell") {
      throw new Error("Expected a cell reference");
    }
    if (left.sheetName?.includes(":") === true) {
      return {
        type: "Range",
        range: { start: left.start, end: left.end, sheetName: left.sheetName }
      };
    }
    return { type: "Reference", reference: left.start, ...left.sheetName ? { sheetName: left.sheetName } : {} };
  }
  if (token.type === "bracket" && token.value === "{") {
    consume(state);
    const rows = [];
    const rowState = { currentRow: [] };
    const closingToken = peek(state);
    if (closingToken.type === "bracket" && closingToken.value === "}") {
      consume(state);
      return { type: "Array", elements: [[]] };
    }
    while (true) {
      rowState.currentRow.push(parseExpression(state));
      const separator = peek(state);
      if (separator.type === "comma") {
        consume(state);
        continue;
      }
      if (separator.type === "semicolon") {
        consume(state);
        rows.push(rowState.currentRow);
        rowState.currentRow = [];
        continue;
      }
      if (separator.type === "bracket" && separator.value === "}") {
        consume(state);
        rows.push(rowState.currentRow);
        return { type: "Array", elements: rows };
      }
      throw new Error(`Unexpected token in array literal: ${separator.type}`);
    }
  }
  if (token.type === "identifier") {
    consume(state);
    const upper = token.value.toUpperCase();
    if (peek(state).type === "paren" && peek(state).value === "(") {
      consume(state);
      const args = [];
      if (peek(state).type !== "paren" || peek(state).value !== ")") {
        while (true) {
          args.push(parseExpression(state));
          const next = peek(state);
          if (next.type === "comma") {
            consume(state);
            continue;
          }
          break;
        }
      }
      expectToken(state, "paren");
      return { type: "Function", name: upper, args };
    }
    if (upper === "TRUE" || upper === "FALSE") {
      return { type: "Literal", value: upper === "TRUE" };
    }
    if (upper === "NULL" || upper === "NIL") {
      return { type: "Literal", value: null };
    }
    return { type: "Name", name: token.value };
  }
  if (token.type === "paren" && token.value === "(") {
    consume(state);
    const expr = parseExpression(state);
    const close = expectToken(state, "paren");
    if (close.value !== ")") {
      throw new Error("Expected ')'");
    }
    return expr;
  }
  throw new Error(`Unexpected token "${token.type}"`);
}
function parseUnary(state) {
  const token = peek(state);
  if (token.type === "operator" && (token.value === "+" || token.value === "-")) {
    consume(state);
    const argument = parseUnary(state);
    return { type: "Unary", operator: token.value, argument };
  }
  return parsePrimary(state);
}
function parsePower(state) {
  const node = parseUnary(state);
  return parsePowerTail(state, node);
}
function parsePowerTail(state, left) {
  const token = peek(state);
  if (token.type === "operator" && token.value === "^") {
    consume(state);
    return parsePowerTail(state, { type: "Binary", operator: "^", left, right: parseUnary(state) });
  }
  return left;
}
function parseMultiplicative(state) {
  const node = parsePower(state);
  return parseMultiplicativeTail(state, node);
}
function parseMultiplicativeTail(state, left) {
  const token = peek(state);
  if (token.type === "operator" && (token.value === "*" || token.value === "/")) {
    consume(state);
    return parseMultiplicativeTail(state, { type: "Binary", operator: token.value, left, right: parsePower(state) });
  }
  return left;
}
function parseAdditive(state) {
  const node = parseMultiplicative(state);
  return parseAdditiveTail(state, node);
}
function parseAdditiveTail(state, left) {
  const token = peek(state);
  if (token.type === "operator" && (token.value === "+" || token.value === "-")) {
    consume(state);
    return parseAdditiveTail(state, { type: "Binary", operator: token.value, left, right: parseMultiplicative(state) });
  }
  return left;
}
function parseConcatenation(state) {
  const node = parseAdditive(state);
  return parseConcatenationTail(state, node);
}
function parseConcatenationTail(state, left) {
  const token = peek(state);
  if (token.type === "operator" && token.value === "&") {
    consume(state);
    return parseConcatenationTail(state, { type: "Binary", operator: "&", left, right: parseAdditive(state) });
  }
  return left;
}
function parseComparison(state) {
  const node = parseConcatenation(state);
  return parseComparisonTail(state, node);
}
function parseComparisonTail(state, left) {
  const token = peek(state);
  if (token.type === "comparator") {
    consume(state);
    return parseComparisonTail(state, { type: "Compare", operator: token.value, left, right: parseConcatenation(state) });
  }
  return left;
}
function parseExpression(state) {
  return parseComparison(state);
}
function parseFormula2(formula) {
  const tokens = tokenize(formula);
  const state = { tokens, index: 0 };
  const expr = parseExpression(state);
  const end = consume(state);
  if (end.type !== "end") {
    throw new Error("Unexpected trailing tokens");
  }
  return expr;
}

// packages/@oxen-office/xlsx/src/formula/shift.ts
var REF_ERROR = { type: "error", value: "#REF!" };
function shiftAddress(address, deltaCols, deltaRows) {
  const col = address.col;
  const row = address.row;
  const nextCol = address.colAbsolute ? col : col + deltaCols;
  const nextRow = address.rowAbsolute ? row : row + deltaRows;
  if (nextCol < 1 || nextCol > EXCEL_MAX_COLS) {
    return;
  }
  if (nextRow < 1 || nextRow > EXCEL_MAX_ROWS) {
    return;
  }
  return {
    col: colIdx(nextCol),
    row: rowIdx(nextRow),
    colAbsolute: address.colAbsolute,
    rowAbsolute: address.rowAbsolute
  };
}
function shiftRange(range2, deltaCols, deltaRows) {
  const start = shiftAddress(range2.start, deltaCols, deltaRows);
  const end = shiftAddress(range2.end, deltaCols, deltaRows);
  if (!start || !end) {
    return;
  }
  return {
    start,
    end,
    ...range2.sheetName ? { sheetName: range2.sheetName } : {}
  };
}
function shiftAst(node, deltaCols, deltaRows) {
  switch (node.type) {
    case "Literal":
      return node;
    case "Reference": {
      const shifted = shiftAddress(node.reference, deltaCols, deltaRows);
      if (!shifted) {
        return { type: "Literal", value: REF_ERROR };
      }
      return {
        type: "Reference",
        reference: shifted,
        ...node.sheetName ? { sheetName: node.sheetName } : {}
      };
    }
    case "Range": {
      const shifted = shiftRange(node.range, deltaCols, deltaRows);
      if (!shifted) {
        return { type: "Literal", value: REF_ERROR };
      }
      return { type: "Range", range: shifted };
    }
    case "Name":
      return node;
    case "StructuredTableReference":
      return node;
    case "Unary":
      return { type: "Unary", operator: node.operator, argument: shiftAst(node.argument, deltaCols, deltaRows) };
    case "Binary":
      return {
        type: "Binary",
        operator: node.operator,
        left: shiftAst(node.left, deltaCols, deltaRows),
        right: shiftAst(node.right, deltaCols, deltaRows)
      };
    case "Compare":
      return {
        type: "Compare",
        operator: node.operator,
        left: shiftAst(node.left, deltaCols, deltaRows),
        right: shiftAst(node.right, deltaCols, deltaRows)
      };
    case "Function":
      return { type: "Function", name: node.name, args: node.args.map((arg) => shiftAst(arg, deltaCols, deltaRows)) };
    case "Array":
      return { type: "Array", elements: node.elements.map((row) => row.map((el) => shiftAst(el, deltaCols, deltaRows))) };
  }
}
function tryParseFormulaAst(formula) {
  try {
    return parseFormula2(formula);
  } catch (error2) {
    if (!(error2 instanceof Error)) {
      throw error2;
    }
    return;
  }
}
function shiftFormulaReferences(formula, deltaCols, deltaRows) {
  if (deltaCols === 0 && deltaRows === 0) {
    return formula;
  }
  const parsed = tryParseFormulaAst(formula);
  if (!parsed) {
    return formula;
  }
  const shifted = shiftAst(parsed, deltaCols, deltaRows);
  return formatFormula(shifted);
}

// packages/@oxen-office/xlsx/src/parser/shared-formulas.ts
function hasExpression(formula) {
  return formula.expression.trim().length > 0;
}
function collectSharedFormulaSeeds(rows) {
  const seeds = new Map;
  for (const row of rows) {
    for (const cell of row.cells) {
      const formula = cell.formula;
      const sharedIndex = formula?.sharedIndex;
      if (!formula || formula.type !== "shared" || sharedIndex === undefined) {
        continue;
      }
      if (!hasExpression(formula)) {
        continue;
      }
      if (seeds.has(sharedIndex)) {
        continue;
      }
      seeds.set(sharedIndex, { baseAddress: cell.address, expression: formula.expression });
    }
  }
  return seeds;
}
function expandSharedFormulaCell(cell, seeds) {
  const formula = cell.formula;
  const sharedIndex = formula?.sharedIndex;
  if (!formula || formula.type !== "shared" || sharedIndex === undefined) {
    return cell;
  }
  if (hasExpression(formula)) {
    return cell;
  }
  const seed = seeds.get(sharedIndex);
  if (!seed) {
    return cell;
  }
  const deltaCols = cell.address.col - seed.baseAddress.col;
  const deltaRows = cell.address.row - seed.baseAddress.row;
  const shifted = shiftFormulaReferences(seed.expression, deltaCols, deltaRows);
  if (shifted === formula.expression) {
    return cell;
  }
  return { ...cell, formula: { ...formula, expression: shifted } };
}
function expandSharedFormulas(rows) {
  const seeds = collectSharedFormulaSeeds(rows);
  if (seeds.size === 0) {
    return rows;
  }
  const nextRows = rows.map((row) => {
    const nextCells = row.cells.map((cell) => expandSharedFormulaCell(cell, seeds));
    const changed = nextCells.some((cell, index) => cell !== row.cells[index]);
    return changed ? { ...row, cells: nextCells } : row;
  });
  const anyRowChanged = nextRows.some((row, index) => row !== rows[index]);
  return anyRowChanged ? nextRows : rows;
}

// packages/@oxen-office/xlsx/src/parser/page-setup.ts
function parsePageSetup2(pageSetupElement) {
  if (!pageSetupElement) {
    return;
  }
  const paperSize = parseIntAttr2(getAttr(pageSetupElement, "paperSize"));
  const orientation = getAttr(pageSetupElement, "orientation");
  const scale = parseIntAttr2(getAttr(pageSetupElement, "scale"));
  const fitToWidth = parseIntAttr2(getAttr(pageSetupElement, "fitToWidth"));
  const fitToHeight = parseIntAttr2(getAttr(pageSetupElement, "fitToHeight"));
  const firstPageNumber = parseIntAttr2(getAttr(pageSetupElement, "firstPageNumber"));
  const useFirstPageNumber = parseBooleanAttr(getAttr(pageSetupElement, "useFirstPageNumber"));
  const blackAndWhite = parseBooleanAttr(getAttr(pageSetupElement, "blackAndWhite"));
  const draft = parseBooleanAttr(getAttr(pageSetupElement, "draft"));
  const cellComments = getAttr(pageSetupElement, "cellComments");
  const pageOrder = getAttr(pageSetupElement, "pageOrder");
  const horizontalDpi = parseIntAttr2(getAttr(pageSetupElement, "horizontalDpi"));
  const verticalDpi = parseIntAttr2(getAttr(pageSetupElement, "verticalDpi"));
  const copies = parseIntAttr2(getAttr(pageSetupElement, "copies"));
  return {
    ...paperSize !== undefined && { paperSize },
    ...orientation && { orientation },
    ...scale !== undefined && { scale },
    ...fitToWidth !== undefined && { fitToWidth },
    ...fitToHeight !== undefined && { fitToHeight },
    ...firstPageNumber !== undefined && { firstPageNumber },
    ...useFirstPageNumber !== undefined && { useFirstPageNumber },
    ...blackAndWhite !== undefined && { blackAndWhite },
    ...draft !== undefined && { draft },
    ...cellComments && { cellComments },
    ...pageOrder && { pageOrder },
    ...horizontalDpi !== undefined && { horizontalDpi },
    ...verticalDpi !== undefined && { verticalDpi },
    ...copies !== undefined && { copies }
  };
}
function parsePageMargins3(pageMarginsElement) {
  if (!pageMarginsElement) {
    return;
  }
  const left = parseFloatAttr(getAttr(pageMarginsElement, "left"));
  const right = parseFloatAttr(getAttr(pageMarginsElement, "right"));
  const top = parseFloatAttr(getAttr(pageMarginsElement, "top"));
  const bottom = parseFloatAttr(getAttr(pageMarginsElement, "bottom"));
  const header = parseFloatAttr(getAttr(pageMarginsElement, "header"));
  const footer = parseFloatAttr(getAttr(pageMarginsElement, "footer"));
  return {
    ...left !== undefined && { left },
    ...right !== undefined && { right },
    ...top !== undefined && { top },
    ...bottom !== undefined && { bottom },
    ...header !== undefined && { header },
    ...footer !== undefined && { footer }
  };
}
function parseHeaderFooter2(headerFooterElement) {
  if (!headerFooterElement) {
    return;
  }
  const differentOddEven = parseBooleanAttr(getAttr(headerFooterElement, "differentOddEven"));
  const differentFirst = parseBooleanAttr(getAttr(headerFooterElement, "differentFirst"));
  const scaleWithDoc = parseBooleanAttr(getAttr(headerFooterElement, "scaleWithDoc"));
  const alignWithMargins = parseBooleanAttr(getAttr(headerFooterElement, "alignWithMargins"));
  const oddHeaderEl = getChild(headerFooterElement, "oddHeader");
  const oddFooterEl = getChild(headerFooterElement, "oddFooter");
  const evenHeaderEl = getChild(headerFooterElement, "evenHeader");
  const evenFooterEl = getChild(headerFooterElement, "evenFooter");
  const firstHeaderEl = getChild(headerFooterElement, "firstHeader");
  const firstFooterEl = getChild(headerFooterElement, "firstFooter");
  const oddHeader = oddHeaderEl ? getTextContent(oddHeaderEl) : undefined;
  const oddFooter = oddFooterEl ? getTextContent(oddFooterEl) : undefined;
  const evenHeader = evenHeaderEl ? getTextContent(evenHeaderEl) : undefined;
  const evenFooter = evenFooterEl ? getTextContent(evenFooterEl) : undefined;
  const firstHeader = firstHeaderEl ? getTextContent(firstHeaderEl) : undefined;
  const firstFooter = firstFooterEl ? getTextContent(firstFooterEl) : undefined;
  return {
    ...oddHeader && { oddHeader },
    ...oddFooter && { oddFooter },
    ...evenHeader && { evenHeader },
    ...evenFooter && { evenFooter },
    ...firstHeader && { firstHeader },
    ...firstFooter && { firstFooter },
    ...differentOddEven !== undefined && { differentOddEven },
    ...differentFirst !== undefined && { differentFirst },
    ...scaleWithDoc !== undefined && { scaleWithDoc },
    ...alignWithMargins !== undefined && { alignWithMargins }
  };
}
function parsePrintOptions(printOptionsElement) {
  if (!printOptionsElement) {
    return;
  }
  const gridLines = parseBooleanAttr(getAttr(printOptionsElement, "gridLines"));
  const headings = parseBooleanAttr(getAttr(printOptionsElement, "headings"));
  const gridLinesSet = parseBooleanAttr(getAttr(printOptionsElement, "gridLinesSet"));
  const horizontalCentered = parseBooleanAttr(getAttr(printOptionsElement, "horizontalCentered"));
  const verticalCentered = parseBooleanAttr(getAttr(printOptionsElement, "verticalCentered"));
  return {
    ...gridLines !== undefined && { gridLines },
    ...headings !== undefined && { headings },
    ...gridLinesSet !== undefined && { gridLinesSet },
    ...horizontalCentered !== undefined && { horizontalCentered },
    ...verticalCentered !== undefined && { verticalCentered }
  };
}

// packages/@oxen-office/xlsx/src/parser/protection.ts
function parseWorkbookProtection(workbookProtectionElement) {
  if (!workbookProtectionElement) {
    return;
  }
  const lockStructure = parseBooleanAttr(getAttr(workbookProtectionElement, "lockStructure"));
  const lockWindows = parseBooleanAttr(getAttr(workbookProtectionElement, "lockWindows"));
  const lockRevision = parseBooleanAttr(getAttr(workbookProtectionElement, "lockRevision"));
  const workbookPassword = getAttr(workbookProtectionElement, "workbookPassword") ?? undefined;
  const revisionsPassword = getAttr(workbookProtectionElement, "revisionsPassword") ?? undefined;
  const workbookAlgorithmName = getAttr(workbookProtectionElement, "workbookAlgorithmName") ?? undefined;
  const workbookHashValue = getAttr(workbookProtectionElement, "workbookHashValue") ?? undefined;
  const workbookSaltValue = getAttr(workbookProtectionElement, "workbookSaltValue") ?? undefined;
  const workbookSpinCount = parseIntAttr2(getAttr(workbookProtectionElement, "workbookSpinCount"));
  return {
    ...lockStructure !== undefined && { lockStructure },
    ...lockWindows !== undefined && { lockWindows },
    ...lockRevision !== undefined && { lockRevision },
    ...workbookPassword && { workbookPassword },
    ...revisionsPassword && { revisionsPassword },
    ...workbookAlgorithmName && { workbookAlgorithmName },
    ...workbookHashValue && { workbookHashValue },
    ...workbookSaltValue && { workbookSaltValue },
    ...workbookSpinCount !== undefined && { workbookSpinCount }
  };
}
function parseSheetProtection(sheetProtectionElement) {
  if (!sheetProtectionElement) {
    return;
  }
  const sheet = parseBooleanAttr(getAttr(sheetProtectionElement, "sheet"));
  const objects = parseBooleanAttr(getAttr(sheetProtectionElement, "objects"));
  const scenarios = parseBooleanAttr(getAttr(sheetProtectionElement, "scenarios"));
  const formatCells = parseBooleanAttr(getAttr(sheetProtectionElement, "formatCells"));
  const formatColumns = parseBooleanAttr(getAttr(sheetProtectionElement, "formatColumns"));
  const formatRows = parseBooleanAttr(getAttr(sheetProtectionElement, "formatRows"));
  const insertColumns = parseBooleanAttr(getAttr(sheetProtectionElement, "insertColumns"));
  const insertRows = parseBooleanAttr(getAttr(sheetProtectionElement, "insertRows"));
  const insertHyperlinks = parseBooleanAttr(getAttr(sheetProtectionElement, "insertHyperlinks"));
  const deleteColumns = parseBooleanAttr(getAttr(sheetProtectionElement, "deleteColumns"));
  const deleteRows = parseBooleanAttr(getAttr(sheetProtectionElement, "deleteRows"));
  const selectLockedCells = parseBooleanAttr(getAttr(sheetProtectionElement, "selectLockedCells"));
  const sort = parseBooleanAttr(getAttr(sheetProtectionElement, "sort"));
  const autoFilter = parseBooleanAttr(getAttr(sheetProtectionElement, "autoFilter"));
  const pivotTables = parseBooleanAttr(getAttr(sheetProtectionElement, "pivotTables"));
  const selectUnlockedCells = parseBooleanAttr(getAttr(sheetProtectionElement, "selectUnlockedCells"));
  const password = getAttr(sheetProtectionElement, "password") ?? undefined;
  const algorithmName = getAttr(sheetProtectionElement, "algorithmName") ?? undefined;
  const hashValue = getAttr(sheetProtectionElement, "hashValue") ?? undefined;
  const saltValue = getAttr(sheetProtectionElement, "saltValue") ?? undefined;
  const spinCount = parseIntAttr2(getAttr(sheetProtectionElement, "spinCount"));
  return {
    ...sheet !== undefined && { sheet },
    ...objects !== undefined && { objects },
    ...scenarios !== undefined && { scenarios },
    ...formatCells !== undefined && { formatCells },
    ...formatColumns !== undefined && { formatColumns },
    ...formatRows !== undefined && { formatRows },
    ...insertColumns !== undefined && { insertColumns },
    ...insertRows !== undefined && { insertRows },
    ...insertHyperlinks !== undefined && { insertHyperlinks },
    ...deleteColumns !== undefined && { deleteColumns },
    ...deleteRows !== undefined && { deleteRows },
    ...selectLockedCells !== undefined && { selectLockedCells },
    ...sort !== undefined && { sort },
    ...autoFilter !== undefined && { autoFilter },
    ...pivotTables !== undefined && { pivotTables },
    ...selectUnlockedCells !== undefined && { selectUnlockedCells },
    ...password && { password },
    ...algorithmName && { algorithmName },
    ...hashValue && { hashValue },
    ...saltValue && { saltValue },
    ...spinCount !== undefined && { spinCount }
  };
}

// packages/@oxen-office/xlsx/src/parser/worksheet.ts
function parseBreak2(brkElement) {
  return {
    id: parseIntAttr2(getAttr(brkElement, "id")) ?? 0,
    max: parseIntAttr2(getAttr(brkElement, "max")),
    min: parseIntAttr2(getAttr(brkElement, "min")),
    manual: parseBooleanAttr(getAttr(brkElement, "man")),
    pt: parseBooleanAttr(getAttr(brkElement, "pt"))
  };
}
function parsePageBreaks(worksheetElement) {
  const rowBreaksEl = getChild(worksheetElement, "rowBreaks");
  const colBreaksEl = getChild(worksheetElement, "colBreaks");
  if (!rowBreaksEl && !colBreaksEl) {
    return;
  }
  const rowBreaks = rowBreaksEl ? getChildren(rowBreaksEl, "brk").map(parseBreak2) : [];
  const colBreaks = colBreaksEl ? getChildren(colBreaksEl, "brk").map(parseBreak2) : [];
  if (rowBreaks.length === 0 && colBreaks.length === 0) {
    return;
  }
  return { rowBreaks, colBreaks };
}
function parseSparklineGroups(worksheetElement) {
  const extLstEl = getChild(worksheetElement, "extLst");
  if (!extLstEl) {
    return;
  }
  const extElements = getChildren(extLstEl, "ext");
  for (const extEl of extElements) {
    const sparklineGroupsEl = extEl.children.find((child) => child.type === "element" && child.name.endsWith(":sparklineGroups"));
    if (!sparklineGroupsEl) {
      const altSparklineGroupsEl = getChild(extEl, "sparklineGroups");
      if (altSparklineGroupsEl) {
        return parseSparklineGroupsElement(altSparklineGroupsEl);
      }
      continue;
    }
    return parseSparklineGroupsElement(sparklineGroupsEl);
  }
  return;
}
function parseSparklineGroupsElement(sparklineGroupsEl) {
  const groups = [];
  const groupElements = sparklineGroupsEl.children.filter((child) => child.type === "element" && (child.name === "sparklineGroup" || child.name.endsWith(":sparklineGroup")));
  for (const groupEl of groupElements) {
    const group = parseSparklineGroup(groupEl);
    if (group) {
      groups.push(group);
    }
  }
  return groups.length > 0 ? groups : [];
}
function parseSparklineGroup(groupEl) {
  const typeAttr = getAttr(groupEl, "type");
  const type = typeAttr === "column" ? "column" : typeAttr === "stacked" ? "stacked" : "line";
  const sparklinesEl = groupEl.children.find((child) => child.type === "element" && (child.name === "sparklines" || child.name.endsWith(":sparklines")));
  if (!sparklinesEl) {
    return;
  }
  const sparklines = [];
  const sparklineElements = sparklinesEl.children.filter((child) => child.type === "element" && (child.name === "sparkline" || child.name.endsWith(":sparkline")));
  for (const sparklineEl of sparklineElements) {
    const fEl = sparklineEl.children.find((child) => child.type === "element" && (child.name === "f" || child.name.endsWith(":f")));
    const sqrefEl = sparklineEl.children.find((child) => child.type === "element" && (child.name === "sqref" || child.name.endsWith(":sqref")));
    const f = fEl ? getTextContent(fEl) : undefined;
    const sqref = sqrefEl ? getTextContent(sqrefEl) : undefined;
    if (f && sqref) {
      sparklines.push({ f, sqref });
    }
  }
  if (sparklines.length === 0) {
    return;
  }
  const colorSeries = parseSparklineColor(groupEl, "colorSeries");
  const colorNegative = parseSparklineColor(groupEl, "colorNegative");
  const colorAxis = parseSparklineColor(groupEl, "colorAxis");
  const colorMarkers = parseSparklineColor(groupEl, "colorMarkers");
  const colorFirst = parseSparklineColor(groupEl, "colorFirst");
  const colorLast = parseSparklineColor(groupEl, "colorLast");
  const colorHigh = parseSparklineColor(groupEl, "colorHigh");
  const colorLow = parseSparklineColor(groupEl, "colorLow");
  return {
    type,
    sparklines,
    colorSeries,
    colorNegative,
    colorAxis,
    colorMarkers,
    colorFirst,
    colorLast,
    colorHigh,
    colorLow,
    first: parseBooleanAttr(getAttr(groupEl, "first")),
    last: parseBooleanAttr(getAttr(groupEl, "last")),
    high: parseBooleanAttr(getAttr(groupEl, "high")),
    low: parseBooleanAttr(getAttr(groupEl, "low")),
    negative: parseBooleanAttr(getAttr(groupEl, "negative")),
    markers: parseBooleanAttr(getAttr(groupEl, "markers")),
    lineWeight: parseFloatAttr(getAttr(groupEl, "lineWeight")),
    displayEmptyCellsAs: getAttr(groupEl, "displayEmptyCellsAs"),
    displayHidden: parseBooleanAttr(getAttr(groupEl, "displayHidden")),
    dateAxis: getAttr(groupEl, "dateAxis") ?? undefined
  };
}
function parseSparklineColor(groupEl, colorName) {
  const colorEl = groupEl.children.find((child) => child.type === "element" && (child.name === colorName || child.name.endsWith(`:${colorName}`)));
  if (!colorEl) {
    return;
  }
  return parseColorElement(colorEl);
}
function parseColumn2(colElement) {
  const styleAttr = parseIntAttr2(getAttr(colElement, "style"));
  return {
    min: colIdx(parseIntAttr2(getAttr(colElement, "min")) ?? 1),
    max: colIdx(parseIntAttr2(getAttr(colElement, "max")) ?? 1),
    width: parseFloatAttr(getAttr(colElement, "width")),
    hidden: parseBooleanAttr(getAttr(colElement, "hidden")),
    bestFit: parseBooleanAttr(getAttr(colElement, "bestFit")),
    styleId: styleAttr !== undefined ? styleId(styleAttr) : undefined,
    outlineLevel: parseIntAttr2(getAttr(colElement, "outlineLevel")),
    collapsed: parseBooleanAttr(getAttr(colElement, "collapsed"))
  };
}
function parseCols(colsElement) {
  if (!colsElement) {
    return [];
  }
  return getChildren(colsElement, "col").map(parseColumn2);
}
function parseRow(params) {
  const { rowElement, context, options, fallbackRowNumber } = params;
  const rowNumberAttr = parseIntAttr2(getAttr(rowElement, "r"));
  const cellElements = getChildren(rowElement, "c");
  const firstCell = cellElements[0];
  const firstCellRef = firstCell ? getAttr(firstCell, "r") : undefined;
  const rowNumberFromCellRef = firstCellRef ? parseCellRef(firstCellRef).row : undefined;
  const r = rowNumberAttr ?? rowNumberFromCellRef ?? fallbackRowNumber ?? 1;
  const allowMissingCellRef = options?.compatibility?.allowMissingCellRef === true;
  const cells = [];
  for (let nextCol = 1, idx = 0;idx < cellElements.length; idx += 1) {
    const cellElement = cellElements[idx];
    if (!cellElement) {
      continue;
    }
    const explicitRef = getAttr(cellElement, "r");
    if (explicitRef) {
      const address2 = parseCellRef(explicitRef);
      cells.push(parseCellWithAddress(cellElement, context, address2));
      nextCol = address2.col + 1;
      continue;
    }
    if (!allowMissingCellRef) {
      throw new Error("Cell element missing 'r' attribute");
    }
    const address = { col: colIdx(nextCol), row: rowIdx(r), colAbsolute: false, rowAbsolute: false };
    cells.push(parseCellWithAddress(cellElement, context, address));
    nextCol += 1;
  }
  const styleAttr = parseIntAttr2(getAttr(rowElement, "s"));
  return {
    rowNumber: rowIdx(r),
    cells,
    height: parseFloatAttr(getAttr(rowElement, "ht")),
    hidden: parseBooleanAttr(getAttr(rowElement, "hidden")),
    customHeight: parseBooleanAttr(getAttr(rowElement, "customHeight")),
    styleId: styleAttr !== undefined ? styleId(styleAttr) : undefined,
    outlineLevel: parseIntAttr2(getAttr(rowElement, "outlineLevel")),
    collapsed: parseBooleanAttr(getAttr(rowElement, "collapsed"))
  };
}
function parseSheetData(sheetDataElement, context, options) {
  const rowElements = getChildren(sheetDataElement, "row");
  const rows = [];
  for (let idx = 0, nextRowNumber = 1;idx < rowElements.length; idx += 1) {
    const rowElement = rowElements[idx];
    if (!rowElement) {
      continue;
    }
    const explicitRowNumber = parseIntAttr2(getAttr(rowElement, "r"));
    const fallbackRowNumber = explicitRowNumber ?? nextRowNumber;
    const row = parseRow({ rowElement, context, options, fallbackRowNumber });
    rows.push(row);
    nextRowNumber = row.rowNumber + 1;
  }
  return rows;
}
function parseMergeCells(mergeCellsElement) {
  if (!mergeCellsElement) {
    return [];
  }
  return getChildren(mergeCellsElement, "mergeCell").map((mc) => getAttr(mc, "ref")).filter((ref) => ref !== undefined).map(parseRange);
}
function parseSqrefRanges(sqref) {
  const tokens = sqref.trim().split(/\s+/u).filter((token) => token.length > 0);
  return tokens.map(parseRange);
}
function parseCfvo(cfvoElement) {
  return {
    type: getAttr(cfvoElement, "type") ?? "num",
    val: getAttr(cfvoElement, "val") ?? undefined,
    gte: parseBooleanAttr(getAttr(cfvoElement, "gte"))
  };
}
function parseColorScaleRule(ruleElement) {
  const colorScaleEl = getChild(ruleElement, "colorScale");
  if (!colorScaleEl) {
    return;
  }
  const cfvoElements = getChildren(colorScaleEl, "cfvo");
  const colorElements = getChildren(colorScaleEl, "color");
  if (cfvoElements.length < 2 || colorElements.length < 2) {
    return;
  }
  return {
    type: "colorScale",
    priority: parseIntAttr2(getAttr(ruleElement, "priority")),
    stopIfTrue: parseBooleanAttr(getAttr(ruleElement, "stopIfTrue")),
    cfvo: cfvoElements.map(parseCfvo),
    colors: colorElements.map(parseColorElement).filter((c) => c !== undefined)
  };
}
function parseDataBarRule(ruleElement) {
  const dataBarEl = getChild(ruleElement, "dataBar");
  if (!dataBarEl) {
    return;
  }
  const cfvoElements = getChildren(dataBarEl, "cfvo");
  const colorEl = getChild(dataBarEl, "color");
  const fillColorEl = getChild(dataBarEl, "fillColor");
  const borderColorEl = getChild(dataBarEl, "borderColor");
  const negativeFillColorEl = getChild(dataBarEl, "negativeFillColor");
  const negativeBorderColorEl = getChild(dataBarEl, "negativeBorderColor");
  const axisColorEl = getChild(dataBarEl, "axisColor");
  return {
    type: "dataBar",
    priority: parseIntAttr2(getAttr(ruleElement, "priority")),
    stopIfTrue: parseBooleanAttr(getAttr(ruleElement, "stopIfTrue")),
    cfvo: cfvoElements.map(parseCfvo),
    color: colorEl ? parseColorElement(colorEl) : fillColorEl ? parseColorElement(fillColorEl) : undefined,
    showValue: parseBooleanAttr(getAttr(dataBarEl, "showValue")) ?? true,
    minLength: parseIntAttr2(getAttr(dataBarEl, "minLength")),
    maxLength: parseIntAttr2(getAttr(dataBarEl, "maxLength")),
    gradient: parseBooleanAttr(getAttr(dataBarEl, "gradient")),
    borderColor: borderColorEl ? parseColorElement(borderColorEl) : undefined,
    negativeFillColor: negativeFillColorEl ? parseColorElement(negativeFillColorEl) : undefined,
    negativeBorderColor: negativeBorderColorEl ? parseColorElement(negativeBorderColorEl) : undefined,
    axisColor: axisColorEl ? parseColorElement(axisColorEl) : undefined,
    axisPosition: getAttr(dataBarEl, "axisPosition"),
    direction: getAttr(dataBarEl, "direction")
  };
}
function parseIconSetRule(ruleElement) {
  const iconSetEl = getChild(ruleElement, "iconSet");
  if (!iconSetEl) {
    return;
  }
  const cfvoElements = getChildren(iconSetEl, "cfvo");
  const iconSetName = getAttr(iconSetEl, "iconSet") ?? "3TrafficLights1";
  const cfIconElements = getChildren(iconSetEl, "cfIcon");
  const customIcons = cfIconElements.map((iconEl) => ({
    iconSet: getAttr(iconEl, "iconSet") ?? iconSetName,
    iconId: parseIntAttr2(getAttr(iconEl, "iconId")) ?? 0
  }));
  return {
    type: "iconSet",
    priority: parseIntAttr2(getAttr(ruleElement, "priority")),
    stopIfTrue: parseBooleanAttr(getAttr(ruleElement, "stopIfTrue")),
    iconSet: iconSetName,
    cfvo: cfvoElements.map(parseCfvo),
    showValue: parseBooleanAttr(getAttr(iconSetEl, "showValue")),
    reverse: parseBooleanAttr(getAttr(iconSetEl, "reverse")),
    iconOnly: parseBooleanAttr(getAttr(iconSetEl, "iconOnly")),
    customIcons: customIcons.length > 0 ? customIcons : undefined
  };
}
function parseStandardRule(ruleElement) {
  return {
    type: getAttr(ruleElement, "type") ?? "expression",
    dxfId: parseIntAttr2(getAttr(ruleElement, "dxfId")),
    priority: parseIntAttr2(getAttr(ruleElement, "priority")),
    operator: getAttr(ruleElement, "operator") ?? undefined,
    stopIfTrue: parseBooleanAttr(getAttr(ruleElement, "stopIfTrue")),
    formulas: getChildren(ruleElement, "formula").map((el) => getTextContent(el)),
    text: getAttr(ruleElement, "text") ?? undefined,
    timePeriod: getAttr(ruleElement, "timePeriod") ?? undefined,
    rank: parseIntAttr2(getAttr(ruleElement, "rank")),
    percent: parseBooleanAttr(getAttr(ruleElement, "percent")),
    bottom: parseBooleanAttr(getAttr(ruleElement, "bottom")),
    stdDev: parseIntAttr2(getAttr(ruleElement, "stdDev")),
    equalAverage: parseBooleanAttr(getAttr(ruleElement, "equalAverage")),
    aboveAverage: parseBooleanAttr(getAttr(ruleElement, "aboveAverage"))
  };
}
function parseConditionalFormattingRule(ruleElement) {
  const type = getAttr(ruleElement, "type");
  if (type === "colorScale") {
    const colorScaleRule = parseColorScaleRule(ruleElement);
    if (colorScaleRule) {
      return colorScaleRule;
    }
  }
  if (type === "dataBar") {
    const dataBarRule = parseDataBarRule(ruleElement);
    if (dataBarRule) {
      return dataBarRule;
    }
  }
  if (type === "iconSet") {
    const iconSetRule = parseIconSetRule(ruleElement);
    if (iconSetRule) {
      return iconSetRule;
    }
  }
  return parseStandardRule(ruleElement);
}
function parseConditionalFormatting(element) {
  const sqref = getAttr(element, "sqref") ?? "";
  const ranges = sqref.length > 0 ? parseSqrefRanges(sqref) : [];
  const rules = getChildren(element, "cfRule").map(parseConditionalFormattingRule);
  return { sqref, ranges, rules };
}
function parseConditionalFormattings(worksheetElement) {
  return getChildren(worksheetElement, "conditionalFormatting").map(parseConditionalFormatting);
}
function parseDataValidation(dataValidationElement) {
  const sqref = getAttr(dataValidationElement, "sqref") ?? "";
  const ranges = sqref.length > 0 ? parseSqrefRanges(sqref) : [];
  const formula1El = getChild(dataValidationElement, "formula1");
  const formula2El = getChild(dataValidationElement, "formula2");
  const formula1 = formula1El ? getTextContent(formula1El) : undefined;
  const formula2 = formula2El ? getTextContent(formula2El) : undefined;
  return {
    type: getAttr(dataValidationElement, "type") ?? undefined,
    operator: getAttr(dataValidationElement, "operator") ?? undefined,
    allowBlank: parseBooleanAttr(getAttr(dataValidationElement, "allowBlank")),
    showInputMessage: parseBooleanAttr(getAttr(dataValidationElement, "showInputMessage")),
    showErrorMessage: parseBooleanAttr(getAttr(dataValidationElement, "showErrorMessage")),
    showDropDown: parseBooleanAttr(getAttr(dataValidationElement, "showDropDown")),
    errorStyle: getAttr(dataValidationElement, "errorStyle") ?? undefined,
    promptTitle: getAttr(dataValidationElement, "promptTitle") ?? undefined,
    prompt: getAttr(dataValidationElement, "prompt") ?? undefined,
    errorTitle: getAttr(dataValidationElement, "errorTitle") ?? undefined,
    error: getAttr(dataValidationElement, "error") ?? undefined,
    sqref,
    ranges,
    formula1: formula1 && formula1.length > 0 ? formula1 : undefined,
    formula2: formula2 && formula2.length > 0 ? formula2 : undefined
  };
}
function parseDataValidations(worksheetElement) {
  const dataValidationsEl = getChild(worksheetElement, "dataValidations");
  if (!dataValidationsEl) {
    return [];
  }
  return getChildren(dataValidationsEl, "dataValidation").map(parseDataValidation);
}
function parseHyperlink3(hyperlinkElement) {
  const ref = parseRange(getAttr(hyperlinkElement, "ref") ?? "A1");
  return {
    ref,
    relationshipId: getAttr(hyperlinkElement, "r:id") ?? getAttr(hyperlinkElement, "rId") ?? undefined,
    display: getAttr(hyperlinkElement, "display") ?? undefined,
    location: getAttr(hyperlinkElement, "location") ?? undefined,
    tooltip: getAttr(hyperlinkElement, "tooltip") ?? undefined
  };
}
function parseHyperlinks(worksheetElement) {
  const hyperlinksEl = getChild(worksheetElement, "hyperlinks");
  if (!hyperlinksEl) {
    return [];
  }
  return getChildren(hyperlinksEl, "hyperlink").map(parseHyperlink3);
}
function parsePane(paneElement) {
  if (!paneElement) {
    return;
  }
  return {
    xSplit: parseIntAttr2(getAttr(paneElement, "xSplit")),
    ySplit: parseIntAttr2(getAttr(paneElement, "ySplit")),
    topLeftCell: getAttr(paneElement, "topLeftCell"),
    activePane: getAttr(paneElement, "activePane"),
    state: getAttr(paneElement, "state")
  };
}
function parseSelection(selectionElement) {
  if (!selectionElement) {
    return;
  }
  return {
    pane: getAttr(selectionElement, "pane"),
    activeCell: getAttr(selectionElement, "activeCell"),
    sqref: getAttr(selectionElement, "sqref")
  };
}
function parseSheetView(sheetViewElement) {
  return {
    tabSelected: parseBooleanAttr(getAttr(sheetViewElement, "tabSelected")),
    showGridLines: parseBooleanAttr(getAttr(sheetViewElement, "showGridLines")),
    showRowColHeaders: parseBooleanAttr(getAttr(sheetViewElement, "showRowColHeaders")),
    zoomScale: parseIntAttr2(getAttr(sheetViewElement, "zoomScale")),
    pane: parsePane(getChild(sheetViewElement, "pane")),
    selection: parseSelection(getChild(sheetViewElement, "selection"))
  };
}
function parseDimension(dimensionEl) {
  if (!dimensionEl) {
    return;
  }
  return parseRange(getAttr(dimensionEl, "ref") ?? "A1");
}
function getFirstSheetView(sheetViewsEl) {
  if (!sheetViewsEl) {
    return;
  }
  return getChild(sheetViewsEl, "sheetView");
}
function parseOptionalSheetView(sheetViewEl) {
  if (!sheetViewEl) {
    return;
  }
  return parseSheetView(sheetViewEl);
}
function parseOptionalSheetData(sheetDataEl, context, options) {
  if (!sheetDataEl) {
    return [];
  }
  return parseSheetData(sheetDataEl, context, options);
}
function parseColorElement(colorElement) {
  if (!colorElement) {
    return;
  }
  const rgb = getAttr(colorElement, "rgb");
  if (rgb) {
    return { type: "rgb", value: rgb };
  }
  const theme = getAttr(colorElement, "theme");
  if (theme !== undefined) {
    return {
      type: "theme",
      theme: parseIntAttr2(theme) ?? 0,
      tint: parseFloatAttr(getAttr(colorElement, "tint"))
    };
  }
  const indexed = getAttr(colorElement, "indexed");
  if (indexed !== undefined) {
    return { type: "indexed", index: parseIntAttr2(indexed) ?? 0 };
  }
  const auto = getAttr(colorElement, "auto");
  if (auto !== undefined) {
    const parsed = parseBooleanAttr(auto);
    if (parsed !== false) {
      return { type: "auto" };
    }
  }
  return;
}
function parseFilterOperator(value) {
  switch (value) {
    case "equal":
    case "lessThan":
    case "lessThanOrEqual":
    case "notEqual":
    case "greaterThanOrEqual":
    case "greaterThan":
      return value;
    default:
      return;
  }
}
function parseDynamicFilterType(value) {
  const validTypes = [
    "null",
    "aboveAverage",
    "belowAverage",
    "tomorrow",
    "today",
    "yesterday",
    "nextWeek",
    "thisWeek",
    "lastWeek",
    "nextMonth",
    "thisMonth",
    "lastMonth",
    "nextQuarter",
    "thisQuarter",
    "lastQuarter",
    "nextYear",
    "thisYear",
    "lastYear",
    "yearToDate",
    "Q1",
    "Q2",
    "Q3",
    "Q4",
    "M1",
    "M2",
    "M3",
    "M4",
    "M5",
    "M6",
    "M7",
    "M8",
    "M9",
    "M10",
    "M11",
    "M12"
  ];
  if (value && validTypes.includes(value)) {
    return value;
  }
  return;
}
function parseFilters(filtersElement) {
  const blank = parseBooleanAttr(getAttr(filtersElement, "blank"));
  const filterElements = getChildren(filtersElement, "filter");
  const values = filterElements.map((el) => getAttr(el, "val")).filter((val) => val !== undefined).map((val) => ({ val }));
  return {
    type: "filters",
    ...blank !== undefined && { blank },
    ...values.length > 0 && { values }
  };
}
function parseCustomFilters(customFiltersElement) {
  const and = parseBooleanAttr(getAttr(customFiltersElement, "and"));
  const customFilterElements = getChildren(customFiltersElement, "customFilter");
  const conditions = customFilterElements.map((el) => ({
    operator: parseFilterOperator(getAttr(el, "operator")),
    val: getAttr(el, "val") ?? undefined
  }));
  return {
    type: "customFilters",
    ...and !== undefined && { and },
    conditions
  };
}
function parseTop10Filter(top10Element) {
  return {
    type: "top10",
    top: parseBooleanAttr(getAttr(top10Element, "top")),
    percent: parseBooleanAttr(getAttr(top10Element, "percent")),
    val: parseFloatAttr(getAttr(top10Element, "val")),
    filterVal: parseFloatAttr(getAttr(top10Element, "filterVal"))
  };
}
function parseDynamicFilter(dynamicFilterElement) {
  const filterType = parseDynamicFilterType(getAttr(dynamicFilterElement, "type"));
  if (!filterType)
    return;
  return {
    type: "dynamicFilter",
    filterType,
    val: parseFloatAttr(getAttr(dynamicFilterElement, "val")),
    maxVal: parseFloatAttr(getAttr(dynamicFilterElement, "maxVal"))
  };
}
function parseFilterColumn(filterColumnElement) {
  const colIdAttr = parseIntAttr2(getAttr(filterColumnElement, "colId"));
  const colId = colIdx(colIdAttr ?? 0);
  const hiddenButton = parseBooleanAttr(getAttr(filterColumnElement, "hiddenButton"));
  const showButton = parseBooleanAttr(getAttr(filterColumnElement, "showButton"));
  const filtersEl = getChild(filterColumnElement, "filters");
  const customFiltersEl = getChild(filterColumnElement, "customFilters");
  const top10El = getChild(filterColumnElement, "top10");
  const dynamicFilterEl = getChild(filterColumnElement, "dynamicFilter");
  let filter;
  if (filtersEl) {
    filter = parseFilters(filtersEl);
  } else if (customFiltersEl) {
    filter = parseCustomFilters(customFiltersEl);
  } else if (top10El) {
    filter = parseTop10Filter(top10El);
  } else if (dynamicFilterEl) {
    filter = parseDynamicFilter(dynamicFilterEl);
  }
  return {
    colId,
    ...hiddenButton !== undefined && { hiddenButton },
    ...showButton !== undefined && { showButton },
    ...filter && { filter }
  };
}
function parseAutoFilter(autoFilterElement) {
  if (!autoFilterElement) {
    return;
  }
  const refAttr = getAttr(autoFilterElement, "ref");
  if (!refAttr) {
    return;
  }
  const ref = parseRange(refAttr);
  const filterColumnElements = getChildren(autoFilterElement, "filterColumn");
  const filterColumns = filterColumnElements.map(parseFilterColumn);
  return {
    ref,
    ...filterColumns.length > 0 && { filterColumns }
  };
}
function parseWorksheet(params) {
  const { worksheetElement, context, options, sheetInfo } = params;
  const sheetPrEl = getChild(worksheetElement, "sheetPr");
  const tabColor = parseColorElement(sheetPrEl ? getChild(sheetPrEl, "tabColor") : undefined);
  const dimensionEl = getChild(worksheetElement, "dimension");
  const sheetViewsEl = getChild(worksheetElement, "sheetViews");
  const colsEl = getChild(worksheetElement, "cols");
  const sheetDataEl = getChild(worksheetElement, "sheetData");
  const mergeCellsEl = getChild(worksheetElement, "mergeCells");
  const sheetViewEl = getFirstSheetView(sheetViewsEl);
  const rows = expandSharedFormulas(parseOptionalSheetData(sheetDataEl, context, options));
  const conditionalFormattings = parseConditionalFormattings(worksheetElement);
  const dataValidations = parseDataValidations(worksheetElement);
  const hyperlinks = parseHyperlinks(worksheetElement);
  const autoFilterEl = getChild(worksheetElement, "autoFilter");
  const autoFilter = parseAutoFilter(autoFilterEl);
  const pageSetupEl = getChild(worksheetElement, "pageSetup");
  const pageMarginsEl = getChild(worksheetElement, "pageMargins");
  const headerFooterEl = getChild(worksheetElement, "headerFooter");
  const printOptionsEl = getChild(worksheetElement, "printOptions");
  const pageSetup = parsePageSetup2(pageSetupEl);
  const pageMargins = parsePageMargins3(pageMarginsEl);
  const headerFooter = parseHeaderFooter2(headerFooterEl);
  const printOptions = parsePrintOptions(printOptionsEl);
  const pageBreaks = parsePageBreaks(worksheetElement);
  const sparklineGroups = parseSparklineGroups(worksheetElement);
  const sheetProtectionEl = getChild(worksheetElement, "sheetProtection");
  const sheetProtection = parseSheetProtection(sheetProtectionEl);
  return {
    dateSystem: context.workbookInfo.dateSystem,
    name: sheetInfo.name,
    sheetId: sheetInfo.sheetId,
    state: sheetInfo.state,
    dimension: parseDimension(dimensionEl),
    sheetView: parseOptionalSheetView(sheetViewEl),
    tabColor,
    columns: parseCols(colsEl),
    rows,
    mergeCells: parseMergeCells(mergeCellsEl),
    conditionalFormattings: conditionalFormattings.length > 0 ? conditionalFormattings : undefined,
    dataValidations: dataValidations.length > 0 ? dataValidations : undefined,
    hyperlinks: hyperlinks.length > 0 ? hyperlinks : undefined,
    autoFilter,
    pageSetup,
    pageMargins,
    headerFooter,
    printOptions,
    pageBreaks,
    sparklineGroups,
    sheetProtection,
    xmlPath: sheetInfo.xmlPath
  };
}

// packages/@oxen-office/xlsx/src/parser/drawing.ts
function parseCellAnchorOffset(element) {
  const colEl = getChild(element, "xdr:col") ?? getChild(element, "col");
  const colOffEl = getChild(element, "xdr:colOff") ?? getChild(element, "colOff");
  const rowEl = getChild(element, "xdr:row") ?? getChild(element, "row");
  const rowOffEl = getChild(element, "xdr:rowOff") ?? getChild(element, "rowOff");
  return {
    col: colIdx(parseInt32(colEl ? getTextContent(colEl) : undefined) ?? 0),
    colOff: parseInt32(colOffEl ? getTextContent(colOffEl) : undefined) ?? 0,
    row: rowIdx(parseInt32(rowEl ? getTextContent(rowEl) : undefined) ?? 0),
    rowOff: parseInt32(rowOffEl ? getTextContent(rowOffEl) : undefined) ?? 0
  };
}
function parseAbsolutePosition(element) {
  return {
    x: parseInt32(getAttr(element, "x")) ?? 0,
    y: parseInt32(getAttr(element, "y")) ?? 0
  };
}
function parseExtent2(element) {
  return {
    cx: parseInt32(getAttr(element, "cx")) ?? 0,
    cy: parseInt32(getAttr(element, "cy")) ?? 0
  };
}
function parseNonVisualProperties2(cNvPrElement) {
  if (!cNvPrElement) {
    return { id: 0, name: "" };
  }
  return {
    id: parseInt32(getAttr(cNvPrElement, "id")) ?? 0,
    name: getAttr(cNvPrElement, "name") ?? "",
    descr: getAttr(cNvPrElement, "descr") ?? undefined,
    hidden: getAttr(cNvPrElement, "hidden") === "1" ? true : undefined
  };
}
function parsePicture2(picElement) {
  const nvPicPr = getChild(picElement, "xdr:nvPicPr") ?? getChild(picElement, "nvPicPr");
  const cNvPr = nvPicPr ? getChild(nvPicPr, "xdr:cNvPr") ?? getChild(nvPicPr, "cNvPr") : undefined;
  const blipFill = getChild(picElement, "xdr:blipFill") ?? getChild(picElement, "blipFill");
  const blip = blipFill ? getChild(blipFill, "a:blip") ?? getChild(blipFill, "blip") : undefined;
  const blipRelId = blip ? getAttr(blip, "r:embed") ?? getAttr(blip, "embed") : undefined;
  return {
    type: "picture",
    nvPicPr: parseNonVisualProperties2(cNvPr),
    ...blipRelId && { blipRelId }
  };
}
function parseShape(spElement) {
  const nvSpPr = getChild(spElement, "xdr:nvSpPr") ?? getChild(spElement, "nvSpPr");
  const cNvPr = nvSpPr ? getChild(nvSpPr, "xdr:cNvPr") ?? getChild(nvSpPr, "cNvPr") : undefined;
  const spPr = getChild(spElement, "xdr:spPr") ?? getChild(spElement, "spPr");
  const prstGeom = spPr ? getChild(spPr, "a:prstGeom") ?? getChild(spPr, "prstGeom") : undefined;
  const prstGeomType = prstGeom ? getAttr(prstGeom, "prst") : undefined;
  const txBody = getChild(spElement, "xdr:txBody") ?? getChild(spElement, "txBody");
  let txBodyText;
  if (txBody) {
    const paragraphs = getChildren(txBody, "a:p").concat(getChildren(txBody, "p"));
    const texts = paragraphs.flatMap((p) => {
      const runs = getChildren(p, "a:r").concat(getChildren(p, "r"));
      return runs.map((r) => {
        const tEl = getChild(r, "a:t") ?? getChild(r, "t");
        return tEl ? getTextContent(tEl) : "";
      });
    });
    txBodyText = texts.join("").trim() || undefined;
  }
  return {
    type: "shape",
    nvSpPr: parseNonVisualProperties2(cNvPr),
    ...prstGeomType && { prstGeom: prstGeomType },
    ...txBodyText && { txBody: txBodyText }
  };
}
function parseGraphicFrame2(graphicFrameElement) {
  const nvGraphicFramePr = getChild(graphicFrameElement, "xdr:nvGraphicFramePr") ?? getChild(graphicFrameElement, "nvGraphicFramePr");
  const cNvPr = nvGraphicFramePr ? getChild(nvGraphicFramePr, "xdr:cNvPr") ?? getChild(nvGraphicFramePr, "cNvPr") : undefined;
  const graphic = getChild(graphicFrameElement, "a:graphic") ?? getChild(graphicFrameElement, "graphic");
  const graphicData = graphic ? getChild(graphic, "a:graphicData") ?? getChild(graphic, "graphicData") : undefined;
  const chart = graphicData ? getChild(graphicData, "c:chart") ?? getChild(graphicData, "chart") : undefined;
  const chartRelId = chart ? getAttr(chart, "r:id") ?? getAttr(chart, "rId") : undefined;
  return {
    type: "chartFrame",
    nvGraphicFramePr: parseNonVisualProperties2(cNvPr),
    ...chartRelId && { chartRelId }
  };
}
function parseDrawingContent2(anchorElement) {
  const picEl = getChild(anchorElement, "xdr:pic") ?? getChild(anchorElement, "pic");
  if (picEl) {
    return parsePicture2(picEl);
  }
  const spEl = getChild(anchorElement, "xdr:sp") ?? getChild(anchorElement, "sp");
  if (spEl) {
    return parseShape(spEl);
  }
  const graphicFrameEl = getChild(anchorElement, "xdr:graphicFrame") ?? getChild(anchorElement, "graphicFrame");
  if (graphicFrameEl) {
    return parseGraphicFrame2(graphicFrameEl);
  }
  return;
}
function parseTwoCellAnchor(anchorElement) {
  const fromEl = getChild(anchorElement, "xdr:from") ?? getChild(anchorElement, "from");
  const toEl = getChild(anchorElement, "xdr:to") ?? getChild(anchorElement, "to");
  return {
    type: "twoCellAnchor",
    from: fromEl ? parseCellAnchorOffset(fromEl) : { col: colIdx(0), colOff: 0, row: rowIdx(0), rowOff: 0 },
    to: toEl ? parseCellAnchorOffset(toEl) : { col: colIdx(0), colOff: 0, row: rowIdx(0), rowOff: 0 },
    editAs: parseEditAs(getAttr(anchorElement, "editAs")),
    content: parseDrawingContent2(anchorElement)
  };
}
function parseOneCellAnchor(anchorElement) {
  const fromEl = getChild(anchorElement, "xdr:from") ?? getChild(anchorElement, "from");
  const extEl = getChild(anchorElement, "xdr:ext") ?? getChild(anchorElement, "ext");
  return {
    type: "oneCellAnchor",
    from: fromEl ? parseCellAnchorOffset(fromEl) : { col: colIdx(0), colOff: 0, row: rowIdx(0), rowOff: 0 },
    ext: extEl ? parseExtent2(extEl) : { cx: 0, cy: 0 },
    content: parseDrawingContent2(anchorElement)
  };
}
function parseAbsoluteAnchor(anchorElement) {
  const posEl = getChild(anchorElement, "xdr:pos") ?? getChild(anchorElement, "pos");
  const extEl = getChild(anchorElement, "xdr:ext") ?? getChild(anchorElement, "ext");
  return {
    type: "absoluteAnchor",
    pos: posEl ? parseAbsolutePosition(posEl) : { x: 0, y: 0 },
    ext: extEl ? parseExtent2(extEl) : { cx: 0, cy: 0 },
    content: parseDrawingContent2(anchorElement)
  };
}
function parseDrawing2(drawingElement) {
  const anchors = [];
  const twoCellAnchors = getChildren(drawingElement, "xdr:twoCellAnchor").concat(getChildren(drawingElement, "twoCellAnchor"));
  for (const anchor of twoCellAnchors) {
    anchors.push(parseTwoCellAnchor(anchor));
  }
  const oneCellAnchors = getChildren(drawingElement, "xdr:oneCellAnchor").concat(getChildren(drawingElement, "oneCellAnchor"));
  for (const anchor of oneCellAnchors) {
    anchors.push(parseOneCellAnchor(anchor));
  }
  const absoluteAnchors = getChildren(drawingElement, "xdr:absoluteAnchor").concat(getChildren(drawingElement, "absoluteAnchor"));
  for (const anchor of absoluteAnchors) {
    anchors.push(parseAbsoluteAnchor(anchor));
  }
  return { anchors };
}

// packages/@oxen-office/xlsx/src/parser/chart-resolver.ts
function getDocumentRoot2(doc) {
  const root = doc.children.find((c) => isXmlElement(c));
  if (!root) {
    throw new Error("No root element found in document");
  }
  return root;
}
function resolveTargetPath(basePath, target) {
  const baseDir = dirnamePosixPath(basePath);
  const resolved = normalizePosixPath(joinPosixPath(baseDir, target));
  return resolved.startsWith("/") ? resolved.slice(1) : resolved;
}
function collectChartRelIds(drawing) {
  if (!drawing) {
    return [];
  }
  const chartRelIds = [];
  for (const anchor of drawing.anchors) {
    if (anchor.content?.type === "chartFrame") {
      const chartFrame = anchor.content;
      if (chartFrame.chartRelId) {
        chartRelIds.push(chartFrame.chartRelId);
      }
    }
  }
  return chartRelIds;
}
async function resolveCharts(getFileContent, drawingPath, drawingRelationships, chartRelIds) {
  const charts = [];
  for (const relId of chartRelIds) {
    const target = drawingRelationships.get(relId);
    if (!target) {
      continue;
    }
    const chartPath = resolveTargetPath(drawingPath, target);
    const chartXml = await getFileContent(chartPath);
    if (!chartXml) {
      continue;
    }
    try {
      const chartRoot = getDocumentRoot2(parseXml(chartXml));
      const chart = parseChart(chartRoot);
      if (!chart) {
        continue;
      }
      charts.push({
        relId,
        chartPath,
        chart
      });
    } catch {
      continue;
    }
  }
  return charts;
}
function updateDrawingWithChartPaths(drawing, chartPathMap) {
  const updatedAnchors = drawing.anchors.map((anchor) => {
    if (anchor.content?.type !== "chartFrame") {
      return anchor;
    }
    const chartFrame = anchor.content;
    if (!chartFrame.chartRelId) {
      return anchor;
    }
    const chartPath = chartPathMap.get(chartFrame.chartRelId);
    if (!chartPath) {
      return anchor;
    }
    return {
      ...anchor,
      content: {
        ...chartFrame,
        chartPath
      }
    };
  });
  return {
    anchors: updatedAnchors
  };
}

// packages/@oxen-office/xlsx/src/parser/pivot/pivot-table.ts
function parsePivotItem(itemElement) {
  return {
    t: getAttr(itemElement, "t"),
    h: parseBooleanAttr(getAttr(itemElement, "h")),
    s: parseBooleanAttr(getAttr(itemElement, "s")),
    x: parseIntAttr2(getAttr(itemElement, "x"))
  };
}
function parsePivotField(fieldElement) {
  const itemsEl = getChild(fieldElement, "items");
  const items = itemsEl ? getChildren(itemsEl, "item").map(parsePivotItem) : undefined;
  return {
    name: getAttr(fieldElement, "name") ?? undefined,
    axis: getAttr(fieldElement, "axis"),
    showAll: parseBooleanAttr(getAttr(fieldElement, "showAll")),
    sortType: getAttr(fieldElement, "sortType"),
    includeNewItemsInFilter: parseBooleanAttr(getAttr(fieldElement, "includeNewItemsInFilter")),
    showDropDowns: parseBooleanAttr(getAttr(fieldElement, "showDropDowns")),
    compact: parseBooleanAttr(getAttr(fieldElement, "compact")),
    outline: parseBooleanAttr(getAttr(fieldElement, "outline")),
    subtotalTop: parseBooleanAttr(getAttr(fieldElement, "subtotalTop")),
    insertBlankRow: parseBooleanAttr(getAttr(fieldElement, "insertBlankRow")),
    insertPageBreak: parseBooleanAttr(getAttr(fieldElement, "insertPageBreak")),
    numFmtId: parseIntAttr2(getAttr(fieldElement, "numFmtId")),
    ...items && items.length > 0 && { items }
  };
}
function parseFieldReference(fieldElement) {
  return {
    x: parseIntAttr2(getAttr(fieldElement, "x")) ?? 0
  };
}
function parseDataField(dataFieldElement) {
  return {
    name: getAttr(dataFieldElement, "name") ?? undefined,
    fld: parseIntAttr2(getAttr(dataFieldElement, "fld")) ?? 0,
    subtotal: getAttr(dataFieldElement, "subtotal"),
    showDataAs: getAttr(dataFieldElement, "showDataAs"),
    numFmtId: parseIntAttr2(getAttr(dataFieldElement, "numFmtId"))
  };
}
function parseLocation(locationElement) {
  if (!locationElement) {
    return;
  }
  const ref = getAttr(locationElement, "ref");
  if (!ref) {
    return;
  }
  return {
    ref: parseRange(ref),
    firstHeaderRow: parseIntAttr2(getAttr(locationElement, "firstHeaderRow")),
    firstDataRow: parseIntAttr2(getAttr(locationElement, "firstDataRow")),
    firstDataCol: parseIntAttr2(getAttr(locationElement, "firstDataCol")),
    rowPageCount: parseIntAttr2(getAttr(locationElement, "rowPageCount")),
    colPageCount: parseIntAttr2(getAttr(locationElement, "colPageCount"))
  };
}
function parsePivotTableStyleInfo(styleInfoElement) {
  if (!styleInfoElement) {
    return;
  }
  return {
    name: getAttr(styleInfoElement, "name") ?? undefined,
    showRowHeaders: parseBooleanAttr(getAttr(styleInfoElement, "showRowHeaders")),
    showColHeaders: parseBooleanAttr(getAttr(styleInfoElement, "showColHeaders")),
    showRowStripes: parseBooleanAttr(getAttr(styleInfoElement, "showRowStripes")),
    showColStripes: parseBooleanAttr(getAttr(styleInfoElement, "showColStripes")),
    showLastColumn: parseBooleanAttr(getAttr(styleInfoElement, "showLastColumn"))
  };
}
function parsePivotTable(pivotTableElement, xmlPath) {
  const locationEl = getChild(pivotTableElement, "location");
  const location = parseLocation(locationEl);
  if (!location) {
    throw new Error("Pivot table location is required");
  }
  const pivotFieldsEl = getChild(pivotTableElement, "pivotFields");
  const pivotFields = pivotFieldsEl ? getChildren(pivotFieldsEl, "pivotField").map(parsePivotField) : undefined;
  const rowFieldsEl = getChild(pivotTableElement, "rowFields");
  const rowFields = rowFieldsEl ? getChildren(rowFieldsEl, "field").map(parseFieldReference) : undefined;
  const colFieldsEl = getChild(pivotTableElement, "colFields");
  const colFields = colFieldsEl ? getChildren(colFieldsEl, "field").map(parseFieldReference) : undefined;
  const pageFieldsEl = getChild(pivotTableElement, "pageFields");
  const pageFields = pageFieldsEl ? getChildren(pageFieldsEl, "pageField").map(parseFieldReference) : undefined;
  const dataFieldsEl = getChild(pivotTableElement, "dataFields");
  const dataFields = dataFieldsEl ? getChildren(dataFieldsEl, "dataField").map(parseDataField) : undefined;
  const styleInfoEl = getChild(pivotTableElement, "pivotTableStyleInfo");
  const pivotTableStyleInfo = parsePivotTableStyleInfo(styleInfoEl);
  return {
    name: getAttr(pivotTableElement, "name") ?? "PivotTable",
    cacheId: parseIntAttr2(getAttr(pivotTableElement, "cacheId")) ?? 0,
    location,
    dataOnRows: parseBooleanAttr(getAttr(pivotTableElement, "dataOnRows")),
    dataPosition: parseIntAttr2(getAttr(pivotTableElement, "dataPosition")),
    applyNumberFormats: parseBooleanAttr(getAttr(pivotTableElement, "applyNumberFormats")),
    applyBorderFormats: parseBooleanAttr(getAttr(pivotTableElement, "applyBorderFormats")),
    applyFontFormats: parseBooleanAttr(getAttr(pivotTableElement, "applyFontFormats")),
    applyPatternFormats: parseBooleanAttr(getAttr(pivotTableElement, "applyPatternFormats")),
    applyAlignmentFormats: parseBooleanAttr(getAttr(pivotTableElement, "applyAlignmentFormats")),
    applyWidthHeightFormats: parseBooleanAttr(getAttr(pivotTableElement, "applyWidthHeightFormats")),
    rowGrandTotals: parseBooleanAttr(getAttr(pivotTableElement, "rowGrandTotals")),
    colGrandTotals: parseBooleanAttr(getAttr(pivotTableElement, "colGrandTotals")),
    showError: parseBooleanAttr(getAttr(pivotTableElement, "showError")),
    errorCaption: getAttr(pivotTableElement, "errorCaption") ?? undefined,
    showDrill: parseBooleanAttr(getAttr(pivotTableElement, "showDrill")),
    showHeaders: parseBooleanAttr(getAttr(pivotTableElement, "showHeaders")),
    compact: parseBooleanAttr(getAttr(pivotTableElement, "compact")),
    outline: parseBooleanAttr(getAttr(pivotTableElement, "outline")),
    rowHeaderCaption: getAttr(pivotTableElement, "rowHeaderCaption") ?? undefined,
    colHeaderCaption: getAttr(pivotTableElement, "colHeaderCaption") ?? undefined,
    pivotTableStyleInfo,
    ...pivotFields && pivotFields.length > 0 && { pivotFields },
    ...rowFields && rowFields.length > 0 && { rowFields },
    ...colFields && colFields.length > 0 && { colFields },
    ...pageFields && pageFields.length > 0 && { pageFields },
    ...dataFields && dataFields.length > 0 && { dataFields },
    xmlPath
  };
}

// packages/@oxen-office/xlsx/src/parser/pivot/pivot-cache.ts
function parseCacheItem(itemElement) {
  const tagName = itemElement.name.split(":").pop() ?? itemElement.name;
  switch (tagName) {
    case "s":
      return { type: "s", v: getAttr(itemElement, "v") ?? undefined };
    case "n":
      return { type: "n", n: parseFloatAttr(getAttr(itemElement, "v")) };
    case "b":
      return { type: "b", b: parseBooleanAttr(getAttr(itemElement, "v")) };
    case "e":
      return { type: "e", e: getAttr(itemElement, "v") ?? undefined };
    case "d":
      return { type: "d", v: getAttr(itemElement, "v") ?? undefined };
    case "m":
      return { type: "m" };
    default:
      return { type: "s", v: getAttr(itemElement, "v") ?? undefined };
  }
}
function parseCacheField(fieldElement) {
  const sharedItemsEl = getChild(fieldElement, "sharedItems");
  let sharedItems;
  if (sharedItemsEl) {
    const items = [];
    for (const child of sharedItemsEl.children) {
      if (typeof child !== "object" || child.type !== "element")
        continue;
      items.push(parseCacheItem(child));
    }
    sharedItems = items.length > 0 ? items : undefined;
  }
  return {
    name: getAttr(fieldElement, "name") ?? "",
    numFmtId: parseIntAttr2(getAttr(fieldElement, "numFmtId")),
    databaseField: parseBooleanAttr(getAttr(fieldElement, "databaseField")),
    ...sharedItems && { sharedItems }
  };
}
function parseCacheSource(cacheSourceElement) {
  if (!cacheSourceElement) {
    return;
  }
  const worksheetSourceEl = getChild(cacheSourceElement, "worksheetSource");
  if (worksheetSourceEl) {
    return {
      type: "worksheet",
      ref: getAttr(worksheetSourceEl, "ref") ?? undefined,
      sheet: getAttr(worksheetSourceEl, "sheet") ?? undefined,
      name: getAttr(worksheetSourceEl, "name") ?? undefined
    };
  }
  const consolidationEl = getChild(cacheSourceElement, "consolidation");
  if (consolidationEl) {
    return {
      type: "consolidation",
      autoPage: parseBooleanAttr(getAttr(consolidationEl, "autoPage"))
    };
  }
  return;
}
function parsePivotCacheDefinition(cacheDefElement, cacheId, xmlPath) {
  const cacheSourceEl = getChild(cacheDefElement, "cacheSource");
  const cacheSource = parseCacheSource(cacheSourceEl);
  const cacheFieldsEl = getChild(cacheDefElement, "cacheFields");
  const cacheFields = cacheFieldsEl ? getChildren(cacheFieldsEl, "cacheField").map(parseCacheField) : undefined;
  return {
    cacheId,
    refreshOnLoad: parseBooleanAttr(getAttr(cacheDefElement, "refreshOnLoad")),
    recordCount: parseIntAttr2(getAttr(cacheDefElement, "recordCount")),
    upgradeOnRefresh: parseBooleanAttr(getAttr(cacheDefElement, "upgradeOnRefresh")),
    saveData: parseBooleanAttr(getAttr(cacheDefElement, "saveData")),
    backgroundQuery: parseBooleanAttr(getAttr(cacheDefElement, "backgroundQuery")),
    createdVersion: parseIntAttr2(getAttr(cacheDefElement, "createdVersion")),
    refreshedVersion: parseIntAttr2(getAttr(cacheDefElement, "refreshedVersion")),
    minRefreshableVersion: parseIntAttr2(getAttr(cacheDefElement, "minRefreshableVersion")),
    cacheSource,
    ...cacheFields && cacheFields.length > 0 && { cacheFields },
    xmlPath
  };
}

// packages/@oxen-office/xlsx/src/parser/theme.ts
function extractFontSpec2(fontElement) {
  if (fontElement === undefined) {
    return { latin: undefined, eastAsian: undefined, complexScript: undefined };
  }
  const latin = getChild(fontElement, "a:latin");
  const ea = getChild(fontElement, "a:ea");
  const cs = getChild(fontElement, "a:cs");
  return {
    latin: latin?.attrs?.typeface,
    eastAsian: ea?.attrs?.typeface,
    complexScript: cs?.attrs?.typeface
  };
}
function parseFontScheme2(themeDocument) {
  const fontScheme = getByPath(themeDocument, [
    "a:theme",
    "a:themeElements",
    "a:fontScheme"
  ]);
  const majorFont = fontScheme !== undefined ? getChild(fontScheme, "a:majorFont") : undefined;
  const minorFont = fontScheme !== undefined ? getChild(fontScheme, "a:minorFont") : undefined;
  return {
    majorFont: extractFontSpec2(majorFont),
    minorFont: extractFontSpec2(minorFont)
  };
}
function collectColorScheme2(clrScheme) {
  const colors = {};
  if (clrScheme === undefined) {
    return colors;
  }
  for (const child of clrScheme.children) {
    if (!isXmlElement(child)) {
      continue;
    }
    const colorElement = child;
    const colorName = colorElement.name.replace("a:", "");
    const srgbClr = getChild(colorElement, "a:srgbClr");
    if (srgbClr !== undefined) {
      colors[colorName] = srgbClr.attrs?.val ?? "";
    } else {
      const sysClr = getChild(colorElement, "a:sysClr");
      if (sysClr !== undefined) {
        colors[colorName] = sysClr.attrs?.lastClr ?? "";
      }
    }
  }
  return colors;
}
function parseColorScheme2(themeDocument) {
  const clrScheme = getByPath(themeDocument, [
    "a:theme",
    "a:themeElements",
    "a:clrScheme"
  ]);
  return collectColorScheme2(clrScheme);
}
function parseTheme2(themeDocument, xmlPath) {
  const themeElement = getByPath(themeDocument, ["a:theme"]);
  const name = themeElement ? getAttr(themeElement, "name") : undefined;
  return {
    name: name ?? undefined,
    colorScheme: parseColorScheme2(themeDocument),
    fontScheme: parseFontScheme2(themeDocument),
    xmlPath
  };
}

// packages/@oxen-office/xlsx/src/parser/index.ts
function getDocumentRoot3(doc) {
  const root = doc.children.find((c) => isXmlElement(c));
  if (!root) {
    throw new Error("No root element found in document");
  }
  return root;
}
function parseRelationships4(relsElement) {
  const map = new Map;
  const relationships = getChildren(relsElement, "Relationship");
  for (const rel of relationships) {
    const id = getAttr(rel, "Id");
    const target = getAttr(rel, "Target");
    if (id && target) {
      map.set(id, target);
    }
  }
  return map;
}
function parseRelationshipInfos(relsElement) {
  return getChildren(relsElement, "Relationship").flatMap((rel) => {
    const id = getAttr(rel, "Id");
    const target = getAttr(rel, "Target");
    const type = getAttr(rel, "Type");
    if (!id || !target || !type) {
      return [];
    }
    const targetMode = getAttr(rel, "TargetMode");
    return [{ id, target, type, targetMode }];
  });
}
function parseSheetElement(sheetElement) {
  const name = getAttr(sheetElement, "name") ?? "Sheet";
  const sheetId = parseInt(getAttr(sheetElement, "sheetId") ?? "1", 10);
  const rId = getAttr(sheetElement, "r:id") ?? getAttr(sheetElement, "rId") ?? "";
  const state = getAttr(sheetElement, "state") ?? "visible";
  return { name, sheetId, rId, state };
}
function parseSheets(sheetsElement) {
  if (!sheetsElement) {
    return [];
  }
  return getChildren(sheetsElement, "sheet").map(parseSheetElement);
}
function parseDefinedName(dnElement) {
  return {
    name: getAttr(dnElement, "name") ?? "",
    formula: getTextContent(dnElement),
    localSheetId: parseIntAttr2(getAttr(dnElement, "localSheetId")),
    hidden: parseBooleanAttr(getAttr(dnElement, "hidden"))
  };
}
function parseDefinedNames(definedNamesElement) {
  if (!definedNamesElement) {
    return [];
  }
  return getChildren(definedNamesElement, "definedName").map(parseDefinedName);
}
function parseWorkbookXml(workbookElement) {
  const workbookPrEl = getChild(workbookElement, "workbookPr");
  const sheetsEl = getChild(workbookElement, "sheets");
  const definedNamesEl = getChild(workbookElement, "definedNames");
  return {
    sheets: parseSheets(sheetsEl),
    definedNames: parseDefinedNames(definedNamesEl),
    dateSystem: resolveXlsxDateSystem(workbookPrEl ? parseBooleanAttr(getAttr(workbookPrEl, "date1904")) : undefined)
  };
}
function resolveSheetPath(rId, relationships) {
  const target = relationships.get(rId);
  if (!target) {
    throw new Error(`Relationship ${rId} not found`);
  }
  const normalizedTarget = target.startsWith("/") ? target.slice(1) : target;
  if (normalizedTarget.startsWith("xl/")) {
    return normalizedTarget;
  }
  return `xl/${normalizedTarget}`;
}
function parseRelsOrEmpty(relsXml) {
  if (!relsXml) {
    return new Map;
  }
  return parseRelationships4(getDocumentRoot3(parseXml(relsXml)));
}
function parseSharedStringsOrEmpty(xml) {
  if (!xml) {
    return [];
  }
  return parseSharedStrings(getDocumentRoot3(parseXml(xml)));
}
function parseSharedStringsRichOrEmpty(xml) {
  if (!xml) {
    return [];
  }
  return parseSharedStringsRich(getDocumentRoot3(parseXml(xml)));
}
function parseStylesOrDefault(xml) {
  if (!xml) {
    return createDefaultStyleSheet();
  }
  return parseStyleSheet(getDocumentRoot3(parseXml(xml)));
}
function resolveRelationshipsPathForPart(partPath) {
  const dir = dirnamePosixPath(partPath);
  const base = basenamePosixPath(partPath);
  return joinPosixPath(dir, "_rels", `${base}.rels`);
}
function resolveTargetPath2(partPath, target) {
  const baseDir = dirnamePosixPath(partPath);
  const resolved = normalizePosixPath(joinPosixPath(baseDir, target));
  return resolved.startsWith("/") ? resolved.slice(1) : resolved;
}
async function loadWorksheetComments(getFileContent, worksheetXmlPath, commentsTarget) {
  const commentsPath = resolveTargetPath2(worksheetXmlPath, commentsTarget);
  const commentsXml = await getFileContent(commentsPath);
  if (!commentsXml) {
    throw new Error(`Comments part not found: ${commentsPath}`);
  }
  return parseComments(getDocumentRoot3(parseXml(commentsXml)));
}
async function loadWorksheetCommentsFromRelationships(getFileContent, worksheetXmlPath, relationships) {
  const commentsTarget = relationships.find((rel) => rel.type.endsWith("/comments"))?.target;
  if (!commentsTarget) {
    return;
  }
  const comments = await loadWorksheetComments(getFileContent, worksheetXmlPath, commentsTarget);
  return comments.length > 0 ? comments : undefined;
}
function resolveHyperlinkTarget(worksheetXmlPath, rel) {
  const raw = rel.target;
  if (rel.targetMode === "External") {
    return { target: raw, targetMode: rel.targetMode };
  }
  return { target: resolveTargetPath2(worksheetXmlPath, raw), targetMode: rel.targetMode };
}
function resolveWorksheetHyperlinksFromRelationships(worksheetXmlPath, baseWorksheet, relationships) {
  const baseHyperlinks = baseWorksheet.hyperlinks;
  if (!baseHyperlinks || baseHyperlinks.length === 0) {
    return baseWorksheet;
  }
  const byId = new Map;
  for (const rel of relationships) {
    if (rel.type.endsWith("/hyperlink")) {
      byId.set(rel.id, rel);
    }
  }
  const resolved = baseHyperlinks.map((link) => {
    const rId = link.relationshipId;
    if (!rId) {
      return link;
    }
    const rel = byId.get(rId);
    if (!rel) {
      return link;
    }
    const { target, targetMode } = resolveHyperlinkTarget(worksheetXmlPath, rel);
    return { ...link, target, targetMode };
  });
  return { ...baseWorksheet, hyperlinks: resolved };
}
function collectTableRelationshipIds(worksheetRoot) {
  const tablePartsEl = getChild(worksheetRoot, "tableParts");
  if (!tablePartsEl) {
    return [];
  }
  const ids = [];
  for (const tablePartEl of getChildren(tablePartsEl, "tablePart")) {
    const relId = getAttr(tablePartEl, "r:id") ?? getAttr(tablePartEl, "rId");
    if (relId) {
      ids.push(relId);
    }
  }
  return ids;
}
async function loadWorksheetDrawingFromRelationships(getFileContent, worksheetXmlPath, relationships, sheetIndex) {
  const drawingRel = relationships.find((rel) => rel.type.endsWith("/drawing"));
  if (!drawingRel) {
    return { drawing: undefined, charts: [] };
  }
  const drawingPath = resolveTargetPath2(worksheetXmlPath, drawingRel.target);
  const drawingXml = await getFileContent(drawingPath);
  if (!drawingXml) {
    return { drawing: undefined, charts: [] };
  }
  let drawing = parseDrawing2(getDocumentRoot3(parseXml(drawingXml)));
  if (drawing.anchors.length === 0) {
    return { drawing: undefined, charts: [] };
  }
  const chartRelIds = collectChartRelIds(drawing);
  if (chartRelIds.length === 0) {
    return { drawing, charts: [], drawingPath };
  }
  const drawingRelsPath = resolveRelationshipsPathForPart(drawingPath);
  const drawingRelsXml = await getFileContent(drawingRelsPath);
  const drawingRels = parseRelsOrEmpty(drawingRelsXml);
  const resolvedCharts = await resolveCharts(getFileContent, drawingPath, drawingRels, chartRelIds);
  const charts = resolvedCharts.map((c) => ({
    sheetIndex,
    relId: c.relId,
    chartPath: c.chartPath,
    chart: c.chart
  }));
  const chartPathMap = new Map(resolvedCharts.map((c) => [c.relId, c.chartPath]));
  drawing = updateDrawingWithChartPaths(drawing, chartPathMap);
  return { drawing, charts, drawingPath };
}
async function loadWorksheetPivotTables(getFileContent, worksheetXmlPath, relationships) {
  const pivotTableRels = relationships.filter((rel) => rel.type.endsWith("/pivotTable"));
  if (pivotTableRels.length === 0) {
    return [];
  }
  const pivotTables = [];
  for (const rel of pivotTableRels) {
    const pivotTablePath = resolveTargetPath2(worksheetXmlPath, rel.target);
    const pivotTableXml = await getFileContent(pivotTablePath);
    if (!pivotTableXml) {
      continue;
    }
    try {
      const pivotTableRoot = getDocumentRoot3(parseXml(pivotTableXml));
      const pivotTable = parsePivotTable(pivotTableRoot, pivotTablePath);
      pivotTables.push(pivotTable);
    } catch {
      continue;
    }
  }
  return pivotTables;
}
async function loadPivotCaches(getFileContent, workbookRelationships) {
  const pivotCaches = [];
  for (const [relId, target] of workbookRelationships) {
    if (!target.includes("pivotCache") || !target.endsWith(".xml")) {
      continue;
    }
    const cachePath = target.startsWith("xl/") ? target : `xl/${target}`;
    const cacheXml = await getFileContent(cachePath);
    if (!cacheXml) {
      continue;
    }
    try {
      const cacheRoot = getDocumentRoot3(parseXml(cacheXml));
      const cacheIdMatch = relId.match(/\d+/u);
      const cacheId = cacheIdMatch ? parseInt(cacheIdMatch[0], 10) : 0;
      const pivotCache = parsePivotCacheDefinition(cacheRoot, cacheId, cachePath);
      pivotCaches.push(pivotCache);
    } catch {
      continue;
    }
  }
  return pivotCaches;
}
async function loadTheme(getFileContent) {
  const themePath = "xl/theme/theme1.xml";
  const themeXml = await getFileContent(themePath);
  if (!themeXml) {
    return;
  }
  try {
    const themeDoc = parseXml(themeXml);
    return parseTheme2(themeDoc, themePath);
  } catch {
    return;
  }
}
async function parseXlsxWorkbook(getFileContent, options) {
  const relsXml = await getFileContent("xl/_rels/workbook.xml.rels");
  const relationships = parseRelsOrEmpty(relsXml);
  const sharedStringsXml = await getFileContent("xl/sharedStrings.xml");
  const sharedStrings = parseSharedStringsOrEmpty(sharedStringsXml);
  const sharedStringsRich = options?.includeRichText ? parseSharedStringsRichOrEmpty(sharedStringsXml) : undefined;
  const stylesXml = await getFileContent("xl/styles.xml");
  const styleSheet = parseStylesOrDefault(stylesXml);
  const theme = await loadTheme(getFileContent);
  const workbookXml = await getFileContent("xl/workbook.xml");
  if (!workbookXml) {
    throw new Error("workbook.xml not found");
  }
  const workbookRoot = getDocumentRoot3(parseXml(workbookXml));
  const workbookInfo = parseWorkbookXml(workbookRoot);
  const workbookProtectionEl = getChild(workbookRoot, "workbookProtection");
  const workbookProtection = parseWorkbookProtection(workbookProtectionEl);
  const context = createParseContext3({ sharedStrings, styleSheet, workbookInfo, relationships });
  const sheets = [];
  const tables = [];
  const allCharts = [];
  const allPivotTables = [];
  for (const sheetInfo of workbookInfo.sheets) {
    const xmlPath = resolveSheetPath(sheetInfo.rId, relationships);
    const sheetXml = await getFileContent(xmlPath);
    if (sheetXml) {
      const sheetDoc = parseXml(sheetXml);
      const sheetRoot = getDocumentRoot3(sheetDoc);
      const tableRelIds = collectTableRelationshipIds(sheetRoot);
      const relsPath = resolveRelationshipsPathForPart(xmlPath);
      const sheetRelsXml = await getFileContent(relsPath);
      const rels = parseRelsOrEmpty(sheetRelsXml);
      const relInfos = sheetRelsXml ? parseRelationshipInfos(getDocumentRoot3(parseXml(sheetRelsXml))) : [];
      const sheetIndex = sheets.length;
      const baseWorksheet = parseWorksheet({
        worksheetElement: sheetRoot,
        context,
        options,
        sheetInfo: { ...sheetInfo, xmlPath }
      });
      const comments = await loadWorksheetCommentsFromRelationships(getFileContent, xmlPath, relInfos);
      const { drawing, charts } = await loadWorksheetDrawingFromRelationships(getFileContent, xmlPath, relInfos, sheetIndex);
      const sheetPivotTables = await loadWorksheetPivotTables(getFileContent, xmlPath, relInfos);
      allCharts.push(...charts);
      allPivotTables.push(...sheetPivotTables);
      const worksheetWithComments = comments ? { ...baseWorksheet, comments } : baseWorksheet;
      const worksheetWithDrawing = drawing ? { ...worksheetWithComments, drawing } : worksheetWithComments;
      const worksheet = resolveWorksheetHyperlinksFromRelationships(xmlPath, worksheetWithDrawing, relInfos);
      sheets.push(worksheet);
      if (tableRelIds.length > 0) {
        for (const relId of tableRelIds) {
          const target = rels.get(relId);
          if (!target) {
            throw new Error(`Missing relationship target for table rId "${relId}"`);
          }
          const tablePath = resolveTargetPath2(xmlPath, target);
          const tableXml = await getFileContent(tablePath);
          if (!tableXml) {
            throw new Error(`Table part not found: ${tablePath}`);
          }
          const tableRoot = getDocumentRoot3(parseXml(tableXml));
          tables.push(parseTable3(tableRoot, sheetIndex));
        }
      }
    }
  }
  const pivotCaches = await loadPivotCaches(getFileContent, relationships);
  return {
    dateSystem: workbookInfo.dateSystem,
    sheets,
    styles: styleSheet,
    sharedStrings,
    ...sharedStringsRich && { sharedStringsRich },
    definedNames: workbookInfo.definedNames,
    tables: tables.length > 0 ? tables : undefined,
    workbookProtection,
    charts: allCharts.length > 0 ? allCharts : undefined,
    pivotTables: allPivotTables.length > 0 ? allPivotTables : undefined,
    pivotCaches: pivotCaches.length > 0 ? pivotCaches : undefined,
    theme
  };
}

// packages/@oxen-cli/xlsx-cli/src/utils/xlsx-loader.ts
async function loadXlsxWorkbook(filePath, options) {
  const buffer = await fs19.readFile(filePath);
  const pkg = await loadZipPackage(buffer);
  const getFileContent = async (path8) => {
    return pkg.readText(path8) ?? undefined;
  };
  const parseOptions = {
    includeRichText: options?.includeRichText
  };
  return parseXlsxWorkbook(getFileContent, parseOptions);
}

// packages/@oxen-cli/xlsx-cli/src/commands/info.ts
async function runInfo3(filePath) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    const sheetNames = workbook.sheets.map((sheet) => sheet.name);
    const totalRows = workbook.sheets.reduce((sum, sheet) => sum + sheet.rows.length, 0);
    const totalCells = workbook.sheets.reduce((sum, sheet) => sum + sheet.rows.reduce((rowSum, row) => rowSum + row.cells.length, 0), 0);
    const mergedCellCount = workbook.sheets.reduce((sum, sheet) => sum + (sheet.mergeCells?.length ?? 0), 0);
    const styles = workbook.styles;
    const hasStyles = styles.cellXfs.length > 1 || styles.fonts.length > 1;
    return success({
      sheetCount: workbook.sheets.length,
      sheetNames,
      sharedStringCount: workbook.sharedStrings.length,
      totalRows,
      totalCells,
      hasStyles,
      fontCount: styles.fonts.length,
      fillCount: styles.fills.length,
      borderCount: styles.borders.length,
      numberFormatCount: styles.numberFormats.length,
      mergedCellCount
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-office/xlsx/src/domain/sheet-utils.ts
function getSheetRange(sheet) {
  if (sheet.rows.length === 0) {
    return;
  }
  if (sheet.dimension) {
    const startCol = indexToColumnLetter(sheet.dimension.start.col);
    const endCol = indexToColumnLetter(sheet.dimension.end.col);
    return {
      startRow: sheet.dimension.start.row,
      endRow: sheet.dimension.end.row,
      startCol,
      endCol
    };
  }
  const bounds = sheet.rows.reduce((acc, row) => {
    const rowNum = row.rowNumber;
    const rowBounds = row.cells.reduce((cellAcc, cell) => {
      const colNum = cell.address.col;
      return {
        minCol: Math.min(cellAcc.minCol, colNum),
        maxCol: Math.max(cellAcc.maxCol, colNum)
      };
    }, { minCol: acc.minCol, maxCol: acc.maxCol });
    return {
      minRow: Math.min(acc.minRow, rowNum),
      maxRow: Math.max(acc.maxRow, rowNum),
      minCol: rowBounds.minCol,
      maxCol: rowBounds.maxCol
    };
  }, {
    minRow: Number.MAX_SAFE_INTEGER,
    maxRow: 0,
    minCol: Number.MAX_SAFE_INTEGER,
    maxCol: 0
  });
  return {
    startRow: bounds.minRow,
    endRow: bounds.maxRow,
    startCol: indexToColumnLetter(colIdx(bounds.minCol)),
    endCol: indexToColumnLetter(colIdx(bounds.maxCol))
  };
}

// packages/@oxen-cli/xlsx-cli/src/commands/list.ts
function formatRangeString(range2) {
  if (!range2) {
    return;
  }
  return `${range2.startCol}${range2.startRow}:${range2.endCol}${range2.endRow}`;
}
async function runList3(filePath) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    const sheets = workbook.sheets.map((sheet) => {
      const cellCount = sheet.rows.reduce((sum, row) => sum + row.cells.length, 0);
      const formulaCount = sheet.rows.reduce((sum, row) => sum + row.cells.filter((cell) => cell.formula).length, 0);
      const rangeStr = formatRangeString(getSheetRange(sheet));
      return {
        name: sheet.name,
        rowCount: sheet.rows.length,
        cellCount,
        range: rangeStr,
        ...sheet.mergeCells && sheet.mergeCells.length > 0 && { mergedCellCount: sheet.mergeCells.length },
        ...formulaCount > 0 && { formulaCount },
        ...sheet.autoFilter && { hasAutoFilter: true }
      };
    });
    return success({ sheets });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/serializers/cell-serializer.ts
function cellValueToJson(value) {
  switch (value.type) {
    case "string":
      return { type: "string", value: value.value };
    case "number":
      return { type: "number", value: value.value };
    case "boolean":
      return { type: "boolean", value: value.value };
    case "date":
      return { type: "date", value: value.value.toISOString() };
    case "error":
      return { type: "error", value: value.value };
    case "empty":
      return { type: "empty", value: null };
  }
}
function serializeCell(cell) {
  const { type, value } = cellValueToJson(cell.value);
  return {
    ref: formatCellRef(cell.address),
    type,
    value,
    ...cell.formula && { formula: cell.formula.expression },
    ...cell.styleId !== undefined && { styleId: cell.styleId }
  };
}
function formatCellValue(value) {
  switch (value.type) {
    case "string":
      return value.value;
    case "number":
      return String(value.value);
    case "boolean":
      return value.value ? "TRUE" : "FALSE";
    case "date":
      return value.value.toISOString();
    case "error":
      return value.value;
    case "empty":
      return "";
  }
}

// packages/@oxen-cli/xlsx-cli/src/commands/show.ts
function parseRange2(range2) {
  const match = range2.match(/^([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?$/i);
  if (!match) {
    return;
  }
  const startCol = columnLetterToIndex(match[1].toUpperCase());
  const startRow = parseInt(match[2], 10);
  const endCol = match[3] ? columnLetterToIndex(match[3].toUpperCase()) : startCol;
  const endRow = match[4] ? parseInt(match[4], 10) : startRow;
  return { startCol, startRow, endCol, endRow };
}
function sheetRangeToParsedRange(sheetRange) {
  if (!sheetRange) {
    return;
  }
  return {
    startCol: columnLetterToIndex(sheetRange.startCol),
    startRow: sheetRange.startRow,
    endCol: columnLetterToIndex(sheetRange.endCol),
    endRow: sheetRange.endRow
  };
}
async function runShow3(filePath, sheetName, options = {}) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    const sheet = workbook.sheets.find((s) => s.name === sheetName);
    if (!sheet) {
      const availableSheets = workbook.sheets.map((s) => s.name).join(", ");
      return error("SHEET_NOT_FOUND", `Sheet "${sheetName}" not found. Available sheets: ${availableSheets}`);
    }
    const sheetRange = getSheetRange(sheet);
    const targetRange = options.range ? parseRange2(options.range) : sheetRangeToParsedRange(sheetRange);
    if (!targetRange) {
      return success({
        sheetName,
        rows: []
      });
    }
    const cellMap = new Map;
    for (const row of sheet.rows) {
      for (const cell of row.cells) {
        const serialized = serializeCell(cell);
        cellMap.set(serialized.ref, serialized);
      }
    }
    const rows = [];
    for (let rowNum = targetRange.startRow;rowNum <= targetRange.endRow; rowNum++) {
      const cells = [];
      for (let colNum = targetRange.startCol;colNum <= targetRange.endCol; colNum++) {
        const ref = formatCellRef({ col: colIdx(colNum), row: rowIdx(rowNum), colAbsolute: false, rowAbsolute: false });
        const cell = cellMap.get(ref);
        if (cell && cell.type !== "empty") {
          cells.push({
            ref,
            type: cell.type,
            value: cell.value,
            ...cell.formula && { formula: cell.formula }
          });
        }
      }
      if (cells.length > 0) {
        rows.push({ rowNumber: rowNum, cells });
      }
    }
    const startColLetter = indexToColumnLetter(colIdx(targetRange.startCol));
    const endColLetter = indexToColumnLetter(colIdx(targetRange.endCol));
    const rangeStr = `${startColLetter}${targetRange.startRow}:${endColLetter}${targetRange.endRow}`;
    const mergedCells = sheet.mergeCells?.map((range2) => {
      const start = formatCellRef(range2.start);
      const end = formatCellRef(range2.end);
      return `${start}:${end}`;
    });
    return success({
      sheetName,
      range: rangeStr,
      rows,
      ...mergedCells && mergedCells.length > 0 && { mergedCells }
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/commands/extract.ts
function escapeCSVValue(value) {
  const str = formatCellValue(value);
  if (str.includes(",") || str.includes('"') || str.includes(`
`)) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}
function formatAsCSV(data) {
  return data.map((row) => row.map(escapeCSVValue).join(",")).join(`
`);
}
function cellValueToJsonValue(value) {
  switch (value.type) {
    case "string":
      return value.value;
    case "number":
      return value.value;
    case "boolean":
      return value.value;
    case "date":
      return value.value.toISOString();
    case "error":
      return value.value;
    case "empty":
      return null;
  }
}
function formatAsJSON(data) {
  const jsonData = data.map((row) => row.map(cellValueToJsonValue));
  return JSON.stringify(jsonData, null, 2);
}
async function runExtract3(filePath, options = {}) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    const sheetName = options.sheet ?? workbook.sheets[0]?.name;
    if (!sheetName) {
      return error("NO_SHEETS", "Workbook has no sheets");
    }
    const sheet = workbook.sheets.find((s) => s.name === sheetName);
    if (!sheet) {
      const availableSheets = workbook.sheets.map((s) => s.name).join(", ");
      return error("SHEET_NOT_FOUND", `Sheet "${sheetName}" not found. Available sheets: ${availableSheets}`);
    }
    const range2 = getSheetRange(sheet);
    if (!range2) {
      const format2 = options.format ?? "csv";
      return success({
        format: format2,
        sheetName,
        content: format2 === "csv" ? "" : "[]"
      });
    }
    const cellMap = new Map;
    for (const row of sheet.rows) {
      for (const cell of row.cells) {
        const ref = formatCellRef(cell.address);
        cellMap.set(ref, cell.value);
      }
    }
    const startColIdx = columnLetterToIndex(range2.startCol);
    const endColIdx = columnLetterToIndex(range2.endCol);
    const data = [];
    for (let rowNum = range2.startRow;rowNum <= range2.endRow; rowNum++) {
      const row = [];
      for (let colNum = startColIdx;colNum <= endColIdx; colNum++) {
        const ref = formatCellRef({ col: colIdx(colNum), row: rowIdx(rowNum), colAbsolute: false, rowAbsolute: false });
        const value = cellMap.get(ref) ?? { type: "empty" };
        row.push(value);
      }
      data.push(row);
    }
    const format = options.format ?? "csv";
    const content = format === "csv" ? formatAsCSV(data) : formatAsJSON(data);
    return success({
      format,
      sheetName,
      content
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/commands/build.ts
import * as fs20 from "fs/promises";
import * as path8 from "path";
async function runBuild3(specPath) {
  try {
    const specJson = await fs20.readFile(specPath, "utf-8");
    const spec = JSON.parse(specJson);
    const specDir = path8.dirname(specPath);
    const templatePath = path8.resolve(specDir, spec.template);
    const outputPath = path8.resolve(specDir, spec.output);
    await fs20.access(templatePath);
    await fs20.mkdir(path8.dirname(outputPath), { recursive: true });
    await fs20.copyFile(templatePath, outputPath);
    return success({ outputPath: spec.output, success: true });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${err2.path}`);
    }
    if (err2 instanceof SyntaxError) {
      return error("INVALID_JSON", `Invalid JSON: ${err2.message}`);
    }
    return error("BUILD_ERROR", `Build failed: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/commands/verify.ts
import * as fs21 from "fs/promises";
import * as path9 from "path";
function createAssertion3(path10, expected, actual) {
  return {
    path: path10,
    expected,
    actual,
    passed: JSON.stringify(expected) === JSON.stringify(actual)
  };
}
async function runTestCase3(spec, specDir) {
  const assertions = [];
  const input = {
    ...spec.input,
    template: path9.resolve(specDir, spec.input.template),
    output: path9.resolve(specDir, spec.input.output)
  };
  await fs21.mkdir(path9.dirname(input.output), { recursive: true });
  const tempSpecPath = path9.join(path9.dirname(input.output), `${spec.name}.build.json`);
  await fs21.writeFile(tempSpecPath, JSON.stringify(input, null, 2));
  try {
    const buildResult = await runBuild3(tempSpecPath);
    if (!buildResult.success) {
      return {
        name: spec.name,
        passed: false,
        assertions: [createAssertion3("build", "success", buildResult.error.message)]
      };
    }
    const infoResult = await runInfo3(input.output);
    if (!infoResult.success) {
      return {
        name: spec.name,
        passed: false,
        assertions: [createAssertion3("info", "readable", infoResult.error.message)]
      };
    }
    const info = infoResult.data;
    if (spec.expected.sheetCount !== undefined) {
      assertions.push(createAssertion3("sheetCount", spec.expected.sheetCount, info.sheetCount));
    }
    if (spec.expected.sheetNames !== undefined) {
      assertions.push(createAssertion3("sheetNames", spec.expected.sheetNames, info.sheetNames));
    }
    if (spec.expected.totalRows !== undefined) {
      assertions.push(createAssertion3("totalRows", spec.expected.totalRows, info.totalRows));
    }
    if (spec.expected.totalCells !== undefined) {
      assertions.push(createAssertion3("totalCells", spec.expected.totalCells, info.totalCells));
    }
    const passed = assertions.every((a) => a.passed);
    return { name: spec.name, passed, assertions };
  } finally {
    await fs21.unlink(tempSpecPath).catch(() => {});
  }
}
async function findTestCaseFiles3(targetPath) {
  const stat4 = await fs21.stat(targetPath);
  if (stat4.isFile()) {
    return [targetPath];
  }
  const entries = await fs21.readdir(targetPath, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    if (entry.isFile() && entry.name.endsWith(".json") && !entry.name.includes(".build.")) {
      files.push(path9.join(targetPath, entry.name));
    } else if (entry.isDirectory() && !entry.name.startsWith("__") && !entry.name.startsWith(".")) {
      const subFiles = await findTestCaseFiles3(path9.join(targetPath, entry.name));
      files.push(...subFiles);
    }
  }
  return files.sort();
}
async function loadTestCase3(filePath) {
  const content = await fs21.readFile(filePath, "utf-8");
  return JSON.parse(content);
}
async function runVerify3(specPath, options = {}) {
  try {
    const absolutePath = path9.resolve(specPath);
    const files = await findTestCaseFiles3(absolutePath);
    if (files.length === 0) {
      return error("NO_TEST_CASES", `No test case files found in: ${specPath}`);
    }
    const results = [];
    for (const file of files) {
      const spec = await loadTestCase3(file);
      if (options.tag && !spec.tags?.includes(options.tag)) {
        continue;
      }
      const specDir = path9.dirname(file);
      const result = await runTestCase3(spec, specDir);
      results.push(result);
    }
    if (results.length === 0) {
      return error("NO_MATCHING_TESTS", `No test cases matched tag: ${options.tag}`);
    }
    const passed = results.filter((r) => r.passed).length;
    const failed = results.length - passed;
    return success({ passed, failed, results });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `Path not found: ${specPath}`);
    }
    if (err2 instanceof SyntaxError) {
      return error("INVALID_JSON", `Invalid JSON: ${err2.message}`);
    }
    return error("VERIFY_ERROR", `Verification failed: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/commands/strings.ts
function formatColor(color) {
  if (!color) {
    return;
  }
  switch (color.type) {
    case "rgb":
      return `#${color.value}`;
    case "theme":
      return `theme:${color.theme}${color.tint ? `:${color.tint}` : ""}`;
    case "indexed":
      return `indexed:${color.index}`;
    case "auto":
      return "auto";
  }
}
function serializeRun4(run) {
  const props = run.properties;
  return {
    text: run.text,
    ...props?.bold && { bold: true },
    ...props?.italic && { italic: true },
    ...props?.underline && { underline: true },
    ...props?.strike && { strike: true },
    ...props?.fontSize && { fontSize: props.fontSize },
    ...props?.fontName && { fontName: props.fontName },
    ...props?.color && { color: formatColor(props.color) }
  };
}
function serializeStringItem(item, index) {
  if (item.type === "plain") {
    return { index, type: "plain", text: item.text };
  }
  const text = item.runs.map((r) => r.text).join("");
  const runs = item.runs.map(serializeRun4);
  return { index, type: "rich", text, runs };
}
async function runStrings(filePath, options = {}) {
  try {
    const workbook = await loadXlsxWorkbook(filePath, { includeRichText: options.richText });
    if (options.richText && workbook.sharedStringsRich) {
      const strings2 = workbook.sharedStringsRich.map(serializeStringItem);
      return success({
        count: strings2.length,
        strings: strings2
      });
    }
    const strings = workbook.sharedStrings.map((text, index) => ({
      index,
      type: "plain",
      text
    }));
    return success({
      count: strings.length,
      strings
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-office/xlsx/src/formula/functions/helpers/isArrayResult.ts
var isArrayResult = (value) => Array.isArray(value);

// packages/@oxen-office/xlsx/src/formula/functions/helpers/flattenResult.ts
var flattenResult = (result) => {
  if (!isArrayResult(result)) {
    return [result];
  }
  return result.flatMap((value) => flattenResult(value));
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/flattenArguments.ts
var flattenArguments = (args) => {
  return args.flatMap((arg) => flattenResult(arg));
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/coerceScalar.ts
var coerceScalar = (result, description) => {
  const flattened = flattenResult(result);
  if (flattened.length === 0) {
    return null;
  }
  if (flattened.length === 1) {
    return flattened[0] ?? null;
  }
  throw new Error(`Range cannot be coerced to scalar for ${description}`);
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/requireNumber.ts
var requireNumber2 = (result, description) => {
  const scalar = coerceScalar(result, description);
  if (typeof scalar !== "number" || Number.isNaN(scalar)) {
    throw new Error(`Expected number for ${description}`);
  }
  return scalar;
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/requireBoolean.ts
var requireBoolean = (result, description) => {
  const scalar = coerceScalar(result, description);
  if (typeof scalar !== "boolean") {
    throw new Error(`Expected boolean for ${description}`);
  }
  return scalar;
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/comparePrimitiveEquality.ts
var comparePrimitiveEquality = (left, right) => {
  if (left === null || right === null) {
    return left === right;
  }
  if (typeof left !== typeof right) {
    return false;
  }
  if (typeof left === "number") {
    if (Number.isNaN(left) || Number.isNaN(right)) {
      return false;
    }
    return Object.is(left, right);
  }
  return left === right;
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/createCriteriaPredicate.ts
var COMPARATORS = ["<>", ">=", "<=", ">", "<", "="];
var NUMERIC_CRITERION_PATTERN = /^-?\d+(?:\.\d+)?$/u;
var parseNumericCriterion = (text, description) => {
  const normalized = text.trim();
  if (!NUMERIC_CRITERION_PATTERN.test(normalized)) {
    throw new Error(`${description} expects numeric operand`);
  }
  return Number.parseFloat(normalized);
};
var parseCriterionOperand = (text) => {
  const normalized = text.trim();
  if (normalized.length === 0) {
    return "";
  }
  if (NUMERIC_CRITERION_PATTERN.test(normalized)) {
    return Number.parseFloat(normalized);
  }
  const lowerCase = normalized.toLowerCase();
  if (lowerCase === "true") {
    return true;
  }
  if (lowerCase === "false") {
    return false;
  }
  return normalized;
};
var compareNumbers = (value, operand, comparator) => {
  switch (comparator) {
    case ">":
      return value > operand;
    case "<":
      return value < operand;
    case ">=":
      return value >= operand;
    case "<=":
      return value <= operand;
    case "=":
      return value === operand;
    case "<>":
      return value !== operand;
    default:
      throw new Error(`Unsupported numeric comparator "${comparator}"`);
  }
};
var createCriteriaPredicate = (criteria, comparePrimitiveEquality2, description) => {
  if (criteria === null) {
    return (value) => value === null;
  }
  if (criteria === "") {
    return (value) => comparePrimitiveEquality2(value, "");
  }
  if (typeof criteria === "number" || typeof criteria === "boolean") {
    return (value) => comparePrimitiveEquality2(value, criteria);
  }
  if (typeof criteria !== "string") {
    throw new Error(`${description} must be string, number, boolean, or null`);
  }
  const trimmed = criteria.trim();
  const comparator = COMPARATORS.find((symbol) => trimmed.startsWith(symbol)) ?? null;
  if (!comparator) {
    const operand2 = parseCriterionOperand(trimmed);
    return (value) => comparePrimitiveEquality2(value, operand2);
  }
  const operandText = trimmed.slice(comparator.length);
  if (operandText.length === 0) {
    throw new Error(`${description} comparator requires right-hand operand`);
  }
  if (comparator === ">" || comparator === "<" || comparator === ">=" || comparator === "<=") {
    const operandNumber = parseNumericCriterion(operandText, description);
    return (value) => typeof value === "number" && compareNumbers(value, operandNumber, comparator);
  }
  const operand = parseCriterionOperand(operandText);
  if (typeof operand === "number") {
    return (value) => typeof value === "number" && compareNumbers(value, operand, comparator);
  }
  if (comparator === "=") {
    return (value) => comparePrimitiveEquality2(value, operand);
  }
  if (comparator === "<>") {
    return (value) => !comparePrimitiveEquality2(value, operand);
  }
  throw new Error(`Unsupported comparator "${comparator}"`);
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/summarizeNumbers.ts
var summarizeNumbers = (values) => {
  const summary = values.reduce((state, value) => ({
    sum: state.sum + value,
    sumOfSquares: state.sumOfSquares + value * value
  }), {
    sum: 0,
    sumOfSquares: 0
  });
  return {
    count: values.length,
    sum: summary.sum,
    sumOfSquares: summary.sumOfSquares
  };
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/collectNumericArguments.ts
var collectNumericArguments = (args, helpers) => {
  return helpers.flattenArguments(args).filter((value) => typeof value === "number");
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/numeric.ts
var requireInteger = (value, errorMessage) => {
  if (!Number.isFinite(value) || !Number.isInteger(value)) {
    throw new Error(errorMessage);
  }
  return value;
};
var computePowerOfTen = (exponent, errorMessage) => {
  const result = 10 ** exponent;
  if (!Number.isFinite(result)) {
    throw new Error(errorMessage);
  }
  return result;
};
var normalizeZero = (value) => {
  return value === 0 ? 0 : value;
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/text.ts
var valueToText = (value) => {
  if (value === null) {
    return "";
  }
  if (typeof value === "string") {
    return value;
  }
  if (typeof value === "boolean") {
    return value ? "TRUE" : "FALSE";
  }
  if (typeof value === "number") {
    return Number.isFinite(value) ? `${value}` : String(value);
  }
  throw new Error("Unsupported value for text conversion");
};
var coerceText = (result, description) => {
  const scalar = coerceScalar(result, description);
  return valueToText(scalar);
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/coerceLogical.ts
var toBoolean = (value, description) => {
  if (value === null) {
    return false;
  }
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "number") {
    if (!Number.isFinite(value)) {
      throw new Error(`${description} expects finite numeric arguments`);
    }
    return value !== 0;
  }
  throw new Error(`${description} expects logical arguments`);
};
var coerceLogical = (result, description) => {
  const scalar = coerceScalar(result, description);
  return toBoolean(scalar, description);
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/finance.ts
var FINANCIAL_EPSILON = 0.0000000001;
var FINANCIAL_MAX_ITERATIONS = 200;
var validateInterestRate = (rate, description) => {
  if (!Number.isFinite(rate)) {
    throw new Error(`${description} must be finite`);
  }
  if (rate <= -1) {
    throw new Error(`${description} must be greater than -1`);
  }
  return rate;
};
var pow1p = (rate, periods) => {
  return (1 + rate) ** periods;
};
var discountSeries = (rate, cashflows) => {
  validateInterestRate(rate, "Discount rate");
  return cashflows.reduce((total, amount, index) => total + amount / pow1p(rate, index), 0);
};
var computeNPV = (rate, cashflows, initial = 0) => {
  validateInterestRate(rate, "NPV rate");
  return cashflows.reduce((total, amount, index) => total + amount / pow1p(rate, index + 1), initial);
};
var computeXNPV = (rate, cashflows, dayDifferences) => {
  validateInterestRate(rate, "XNPV rate");
  return cashflows.reduce((total, amount, index) => {
    const discount = (1 + rate) ** (dayDifferences[index] / 365);
    return total + amount / discount;
  }, 0);
};
var calculatePayment = (params) => {
  const { rate, periods, presentValue, futureValue, type } = params;
  if (periods <= 0 || !Number.isFinite(periods)) {
    throw new Error("Payment periods must be a finite positive number");
  }
  if (type !== 0 && type !== 1) {
    throw new Error("Payment type must be 0 or 1");
  }
  if (rate === 0) {
    return -(presentValue + futureValue) / periods;
  }
  validateInterestRate(rate, "Payment rate");
  const factor = pow1p(rate, periods);
  return -(presentValue * factor + futureValue) * rate / ((1 + rate * type) * (factor - 1));
};
var calculateInterestPayment = (params) => {
  const { rate, periods, payment, presentValue, type, targetPeriod } = params;
  if (targetPeriod < 1 || targetPeriod > periods) {
    throw new Error("Target period is out of range");
  }
  if (rate === 0) {
    return 0;
  }
  validateInterestRate(rate, "Interest rate");
  const state = { balance: presentValue };
  for (let period = 1;period <= targetPeriod; period += 1) {
    if (type === 1) {
      state.balance += payment;
    }
    const interestComponent = state.balance * rate;
    if (period === targetPeriod) {
      return -interestComponent;
    }
    state.balance += interestComponent;
    if (type === 0) {
      state.balance += payment;
    }
  }
  return 0;
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/errors.ts
var ERROR_TYPE_NUMBER_MAP = {
  "#NULL!": 1,
  "#DIV/0!": 2,
  "#VALUE!": 3,
  "#REF!": 4,
  "#NAME?": 5,
  "#NUM!": 6,
  "#N/A": 7,
  "#GETTING_DATA": 8
};

class FormulaError extends Error {
  code;
  constructor(code, message) {
    super(message ?? code);
    this.code = code;
    this.name = "FormulaError";
  }
}
var createFormulaError = (code, message) => {
  return new FormulaError(code, message);
};
var messagePatterns = [
  { pattern: /#null!?/iu, code: "#NULL!" },
  { pattern: /#div[^a-z0-9]*0!?/iu, code: "#DIV/0!" },
  { pattern: /#value!?/iu, code: "#VALUE!" },
  { pattern: /#ref!?/iu, code: "#REF!" },
  { pattern: /#name\??/iu, code: "#NAME?" },
  { pattern: /#num!?/iu, code: "#NUM!" },
  { pattern: /#n\/a/iu, code: "#N/A" },
  { pattern: /#getting_data!?/iu, code: "#GETTING_DATA" },
  { pattern: /division by zero/iu, code: "#DIV/0!" },
  { pattern: /(could not find|not find|no (exact )?match|not available|not found)/iu, code: "#N/A" },
  { pattern: /(unknown function|not implemented|undefined)/iu, code: "#NAME?" },
  { pattern: /(unknown sheet)/iu, code: "#REF!" },
  { pattern: /(out of bounds|invalid cell|cross-sheet range|dependency)/iu, code: "#REF!" },
  { pattern: /(must be greater than zero|must be positive|negative|converge)/iu, code: "#NUM!" },
  { pattern: /(circular dependency)/iu, code: "#REF!" }
];
var normaliseMessage = (error2) => {
  if (error2 instanceof Error) {
    return (error2.message ?? "").trim();
  }
  if (error2 === null || error2 === undefined) {
    return "";
  }
  return String(error2).trim();
};
var getErrorCodeFromError = (error2) => {
  if (error2 instanceof FormulaError) {
    return error2.code;
  }
  const message = normaliseMessage(error2);
  if (message.length === 0) {
    return "#VALUE!";
  }
  for (const { pattern, code } of messagePatterns) {
    if (pattern.test(message)) {
      return code;
    }
  }
  return "#VALUE!";
};
var getErrorTypeNumber = (code) => {
  return ERROR_TYPE_NUMBER_MAP[code];
};
var isNAError = (error2) => {
  return getErrorCodeFromError(error2) === "#N/A";
};
var isFormulaError2 = (error2) => {
  return error2 instanceof FormulaError;
};

// packages/@oxen-office/xlsx/src/formula/functions/helpers/index.ts
var isArrayResult2 = (value) => {
  return isArrayResult(value);
};
var flattenResult2 = (result) => {
  return flattenResult(result);
};
var flattenArguments2 = (args) => {
  return flattenArguments(args);
};
var coerceScalar2 = (result, description) => {
  return coerceScalar(result, description);
};
var requireNumber3 = (result, description) => {
  return requireNumber2(result, description);
};
var requireBoolean2 = (result, description) => {
  return requireBoolean(result, description);
};
var comparePrimitiveEquality2 = (left, right) => {
  return comparePrimitiveEquality(left, right);
};
var coerceLogical2 = (result, description) => {
  return coerceLogical(result, description);
};
var requireInteger2 = (value, errorMessage) => {
  return requireInteger(value, errorMessage);
};
var computePowerOfTen2 = (exponent, errorMessage) => {
  return computePowerOfTen(exponent, errorMessage);
};
var normalizeZero2 = (value) => {
  return normalizeZero(value);
};
var coerceText2 = (result, description) => {
  return coerceText(result, description);
};
var valueToText2 = (value) => {
  return valueToText(value);
};
var createCriteriaPredicate2 = (criteria, compare, description) => {
  return createCriteriaPredicate(criteria, compare, description);
};
var collectNumericArguments2 = (args, helpers) => {
  return collectNumericArguments(args, helpers);
};
var summarizeNumbers2 = (values) => {
  return summarizeNumbers(values);
};
var validateInterestRate2 = (rate, description) => {
  return validateInterestRate(rate, description);
};
var pow1p2 = (rate, periods) => {
  return pow1p(rate, periods);
};
var computeNPV2 = (rate, cashflows, initial = 0) => {
  return computeNPV(rate, cashflows, initial);
};
var FINANCE_EPSILON = FINANCIAL_EPSILON;
var FINANCE_MAX_ITERATIONS = FINANCIAL_MAX_ITERATIONS;
var computeXNPV2 = (rate, cashflows, dayDifferences) => {
  return computeXNPV(rate, cashflows, dayDifferences);
};
var discountSeries2 = (rate, cashflows) => {
  return discountSeries(rate, cashflows);
};
var calculatePayment2 = calculatePayment;
var calculateInterestPayment2 = calculateInterestPayment;
var createFormulaError2 = (code, message) => {
  return createFormulaError(code, message);
};
var getErrorCode = (error2) => {
  return getErrorCodeFromError(error2);
};
var getErrorTypeNumber2 = (code) => {
  return getErrorTypeNumber(code);
};
var isNAError2 = (error2) => {
  return isNAError(error2);
};
var isFormulaError3 = (error2) => {
  return isFormulaError2(error2);
};
var formulaFunctionHelpers = {
  flattenArguments: flattenArguments2,
  flattenResult: flattenResult2,
  coerceScalar: coerceScalar2,
  coerceLogical: coerceLogical2,
  requireNumber: requireNumber3,
  requireBoolean: requireBoolean2,
  comparePrimitiveEquality: comparePrimitiveEquality2,
  requireInteger: requireInteger2,
  computePowerOfTen: computePowerOfTen2,
  normalizeZero: normalizeZero2,
  coerceText: coerceText2,
  valueToText: valueToText2,
  createCriteriaPredicate: createCriteriaPredicate2,
  collectNumericArguments: collectNumericArguments2,
  summarizeNumbers: summarizeNumbers2,
  validateInterestRate: validateInterestRate2,
  pow1p: pow1p2,
  computeNPV: computeNPV2,
  discountSeries: discountSeries2,
  calculatePayment: calculatePayment2,
  calculateInterestPayment: calculateInterestPayment2,
  computeXNPV: computeXNPV2,
  createFormulaError: createFormulaError2,
  getErrorCode,
  getErrorTypeNumber: getErrorTypeNumber2,
  isNAError: isNAError2,
  isFormulaError: isFormulaError3
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/sum.ts
var sumFunction = {
  name: "SUM",
  category: "aggregate",
  description: {
    en: "Adds all numeric arguments, ignoring empty cells and null values.",
    ja: "\u7A7A\u306E\u30BB\u30EB\u3084null\u3092\u7121\u8996\u3057\u3066\u6570\u5024\u5F15\u6570\u3092\u5408\u8A08\u3057\u307E\u3059\u3002"
  },
  examples: ["SUM(1, 2, 3)", "SUM(A1:A10)"],
  samples: [
    {
      input: "SUM(1, 2, 3)",
      output: 6,
      description: {
        en: "Sum of three numbers",
        ja: "3\u3064\u306E\u6570\u5024\u306E\u5408\u8A08"
      }
    },
    {
      input: "SUM(10, 20, 30, 40)",
      output: 100,
      description: {
        en: "Sum of four numbers",
        ja: "4\u3064\u306E\u6570\u5024\u306E\u5408\u8A08"
      }
    },
    {
      input: "SUM(-5, 5, 10)",
      output: 10,
      description: {
        en: "Sum with negative numbers",
        ja: "\u8CA0\u306E\u6570\u3092\u542B\u3080\u5408\u8A08"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const values = helpers.flattenArguments(args);
    return values.reduce((total, value) => {
      if (value === null) {
        return total;
      }
      if (typeof value !== "number") {
        throw new Error("SUM expects numeric arguments");
      }
      return total + value;
    }, 0);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/product.ts
var productFunction = {
  name: "PRODUCT",
  category: "aggregate",
  description: {
    en: "Multiplies numeric arguments while skipping empty cells and null values.",
    ja: "\u7A7A\u306E\u30BB\u30EB\u3068null\u3092\u7121\u8996\u3057\u3066\u6570\u5024\u5F15\u6570\u3092\u639B\u3051\u5408\u308F\u305B\u307E\u3059\u3002"
  },
  examples: ["PRODUCT(2, 3, 4)", "PRODUCT(A1:A3)"],
  samples: [
    {
      input: "PRODUCT(2, 3, 4)",
      output: 24,
      description: {
        en: "Product of three numbers",
        ja: "3\u3064\u306E\u6570\u5024\u306E\u7A4D"
      }
    },
    {
      input: "PRODUCT(5, 10)",
      output: 50,
      description: {
        en: "Product of two numbers",
        ja: "2\u3064\u306E\u6570\u5024\u306E\u7A4D"
      }
    },
    {
      input: "PRODUCT(-2, 3, -1)",
      output: 6,
      description: {
        en: "Product with negative numbers",
        ja: "\u8CA0\u306E\u6570\u3092\u542B\u3080\u7A4D"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const values = helpers.flattenArguments(args);
    return values.reduce((product, value) => {
      if (value === null) {
        return product;
      }
      if (typeof value !== "number") {
        throw new Error("PRODUCT expects numeric arguments");
      }
      return product * value;
    }, 1);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/power.ts
var powerFunction = {
  name: "POWER",
  category: "aggregate",
  description: {
    en: "Raises a base number to a given exponent.",
    ja: "\u6307\u5B9A\u3057\u305F\u6307\u6570\u3067\u5E95\u3068\u306A\u308B\u6570\u5024\u3092\u3079\u304D\u4E57\u3057\u307E\u3059\u3002"
  },
  examples: ["POWER(2, 3)", "POWER(A1, 0.5)"],
  samples: [
    {
      input: "POWER(2, 3)",
      output: 8,
      description: {
        en: "Two raised to the power of three",
        ja: "2\u306E3\u4E57"
      }
    },
    {
      input: "POWER(5, 2)",
      output: 25,
      description: {
        en: "Five squared",
        ja: "5\u306E2\u4E57"
      }
    },
    {
      input: "POWER(4, 0.5)",
      output: 2,
      description: {
        en: "Square root using fractional exponent",
        ja: "\u5C0F\u6570\u6307\u6570\u3092\u4F7F\u7528\u3057\u305F\u5E73\u65B9\u6839"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2) {
      throw new Error("POWER expects exactly two arguments");
    }
    const [baseArg, exponentArg] = args;
    const base = helpers.requireNumber(baseArg, "POWER base");
    const exponent = helpers.requireNumber(exponentArg, "POWER exponent");
    return base ** exponent;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/round.ts
var roundHalfAwayFromZero = (value) => {
  if (value === 0) {
    return 0;
  }
  if (value > 0) {
    return Math.floor(value + 0.5);
  }
  return Math.ceil(value - 0.5);
};
var roundToDigits = (value, digits) => {
  if (digits === 0) {
    return roundHalfAwayFromZero(value);
  }
  if (digits > 0) {
    const factor = computePowerOfTen2(digits, "ROUND digits magnitude is too large");
    return roundHalfAwayFromZero(value * factor) / factor;
  }
  const divisor = computePowerOfTen2(-digits, "ROUND digits magnitude is too large");
  return roundHalfAwayFromZero(value / divisor) * divisor;
};
var roundFunction = {
  name: "ROUND",
  category: "aggregate",
  description: {
    en: "Rounds a number to a specified number of digits using half-away-from-zero rounding.",
    ja: "\u6570\u5024\u3092\u6307\u5B9A\u3057\u305F\u6841\u6570\u306B\u3001\u30BC\u30ED\u304B\u3089\u96E2\u308C\u308B\u4E38\u3081\u898F\u5247\u3067\u4E38\u3081\u307E\u3059\u3002"
  },
  examples: ["ROUND(1.235, 2)", "ROUND(A1, -1)"],
  samples: [
    {
      input: "ROUND(1.235, 2)",
      output: 1.24,
      description: {
        en: "Round to two decimal places",
        ja: "\u5C0F\u6570\u7B2C2\u4F4D\u306B\u56DB\u6368\u4E94\u5165"
      }
    },
    {
      input: "ROUND(15.5, 0)",
      output: 16,
      description: {
        en: "Round to nearest integer",
        ja: "\u6700\u3082\u8FD1\u3044\u6574\u6570\u306B\u56DB\u6368\u4E94\u5165"
      }
    },
    {
      input: "ROUND(1234.567, -2)",
      output: 1200,
      description: {
        en: "Round to hundreds place",
        ja: "\u767E\u306E\u4F4D\u306B\u56DB\u6368\u4E94\u5165"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2) {
      throw new Error("ROUND expects exactly two arguments");
    }
    const [valueArg, digitsArg] = args;
    const value = helpers.requireNumber(valueArg, "ROUND number");
    const digits = helpers.requireNumber(digitsArg, "ROUND digits");
    const normalizedDigits = requireInteger2(digits, "ROUND digits must be an integer");
    const rounded = roundToDigits(value, normalizedDigits);
    return normalizeZero2(rounded);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/roundup.ts
var roundUpToDigits = (value, digits) => {
  if (value === 0) {
    return 0;
  }
  if (digits === 0) {
    return value > 0 ? Math.ceil(value) : Math.floor(value);
  }
  if (digits > 0) {
    const factor = computePowerOfTen2(digits, "ROUNDUP digits magnitude is too large");
    const scaled2 = value * factor;
    const rounded2 = value > 0 ? Math.ceil(scaled2) : Math.floor(scaled2);
    return rounded2 / factor;
  }
  const divisor = computePowerOfTen2(-digits, "ROUNDUP digits magnitude is too large");
  const scaled = value / divisor;
  const rounded = value > 0 ? Math.ceil(scaled) : Math.floor(scaled);
  return rounded * divisor;
};
var roundUpFunction = {
  name: "ROUNDUP",
  category: "aggregate",
  description: {
    en: "Rounds a number away from zero to the specified number of digits.",
    ja: "\u6570\u5024\u3092\u30BC\u30ED\u304B\u3089\u9060\u3056\u304B\u308B\u65B9\u5411\u306B\u6307\u5B9A\u6841\u3078\u5207\u308A\u4E0A\u3052\u307E\u3059\u3002"
  },
  examples: ["ROUNDUP(1.21, 1)", "ROUNDUP(A1, -2)"],
  samples: [
    {
      input: "ROUNDUP(1.21, 1)",
      output: 1.3,
      description: {
        en: "Round up to one decimal place",
        ja: "\u5C0F\u6570\u7B2C1\u4F4D\u3078\u5207\u308A\u4E0A\u3052"
      }
    },
    {
      input: "ROUNDUP(3.14, 0)",
      output: 4,
      description: {
        en: "Round up to nearest integer",
        ja: "\u6700\u3082\u8FD1\u3044\u6574\u6570\u3078\u5207\u308A\u4E0A\u3052"
      }
    },
    {
      input: "ROUNDUP(-2.5, 0)",
      output: -3,
      description: {
        en: "Round negative number away from zero",
        ja: "\u8CA0\u306E\u6570\u3092\u30BC\u30ED\u304B\u3089\u9060\u3056\u3051\u308B\u65B9\u5411\u3078"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2) {
      throw new Error("ROUNDUP expects exactly two arguments");
    }
    const [valueArg, digitsArg] = args;
    const value = helpers.requireNumber(valueArg, "ROUNDUP number");
    const digits = helpers.requireNumber(digitsArg, "ROUNDUP digits");
    const normalizedDigits = requireInteger2(digits, "ROUNDUP digits must be an integer");
    const rounded = roundUpToDigits(value, normalizedDigits);
    return normalizeZero2(rounded);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/rounddown.ts
var roundDownToDigits = (value, digits) => {
  if (value === 0) {
    return 0;
  }
  if (digits === 0) {
    return value > 0 ? Math.floor(value) : Math.ceil(value);
  }
  if (digits > 0) {
    const factor = computePowerOfTen2(digits, "ROUNDDOWN digits magnitude is too large");
    const scaled2 = value * factor;
    const rounded2 = value > 0 ? Math.floor(scaled2) : Math.ceil(scaled2);
    return rounded2 / factor;
  }
  const divisor = computePowerOfTen2(-digits, "ROUNDDOWN digits magnitude is too large");
  const scaled = value / divisor;
  const rounded = value > 0 ? Math.floor(scaled) : Math.ceil(scaled);
  return rounded * divisor;
};
var roundDownFunction = {
  name: "ROUNDDOWN",
  category: "aggregate",
  description: {
    en: "Rounds a number toward zero to the specified number of digits.",
    ja: "\u6570\u5024\u3092\u30BC\u30ED\u65B9\u5411\u3078\u5207\u308A\u4E0B\u3052\u3066\u6307\u5B9A\u6841\u306B\u63C3\u3048\u307E\u3059\u3002"
  },
  examples: ["ROUNDDOWN(1.29, 1)", "ROUNDDOWN(A1, -1)"],
  samples: [
    {
      input: "ROUNDDOWN(1.29, 1)",
      output: 1.2,
      description: {
        en: "Round down to one decimal place",
        ja: "\u5C0F\u6570\u7B2C1\u4F4D\u3078\u5207\u308A\u4E0B\u3052"
      }
    },
    {
      input: "ROUNDDOWN(3.99, 0)",
      output: 3,
      description: {
        en: "Round down to nearest integer",
        ja: "\u6700\u3082\u8FD1\u3044\u6574\u6570\u3078\u5207\u308A\u4E0B\u3052"
      }
    },
    {
      input: "ROUNDDOWN(-2.7, 0)",
      output: -2,
      description: {
        en: "Round negative number toward zero",
        ja: "\u8CA0\u306E\u6570\u3092\u30BC\u30ED\u65B9\u5411\u3078"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2) {
      throw new Error("ROUNDDOWN expects exactly two arguments");
    }
    const [valueArg, digitsArg] = args;
    const value = helpers.requireNumber(valueArg, "ROUNDDOWN number");
    const digits = helpers.requireNumber(digitsArg, "ROUNDDOWN digits");
    const normalizedDigits = requireInteger2(digits, "ROUNDDOWN digits must be an integer");
    const rounded = roundDownToDigits(value, normalizedDigits);
    return normalizeZero2(rounded);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/abs.ts
var absFunction = {
  name: "ABS",
  category: "aggregate",
  description: {
    en: "Returns the absolute value of a number.",
    ja: "\u6570\u5024\u306E\u7D76\u5BFE\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ABS(-5)", "ABS(A1)"],
  samples: [
    {
      input: "ABS(-5)",
      output: 5,
      description: {
        en: "Absolute value of a negative number",
        ja: "\u8CA0\u306E\u6570\u306E\u7D76\u5BFE\u5024"
      }
    },
    {
      input: "ABS(3.14)",
      output: 3.14,
      description: {
        en: "Absolute value of a positive number",
        ja: "\u6B63\u306E\u6570\u306E\u7D76\u5BFE\u5024"
      }
    },
    {
      input: "ABS(0)",
      output: 0,
      description: {
        en: "Absolute value of zero",
        ja: "\u30BC\u30ED\u306E\u7D76\u5BFE\u5024"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("ABS expects exactly one argument");
    }
    const [valueArg] = args;
    const value = helpers.requireNumber(valueArg, "ABS number");
    const result = Math.abs(value);
    return normalizeZero2(result);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/iseven.ts
var isEvenFunction = {
  name: "ISEVEN",
  category: "aggregate",
  description: {
    en: "Returns TRUE if the number is even.",
    ja: "\u6570\u5024\u304C\u5076\u6570\u306A\u3089TRUE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ISEVEN(2)", "ISEVEN(A1)"],
  samples: [
    {
      input: "ISEVEN(2)",
      output: true,
      description: {
        en: "2 is even",
        ja: "2 \u306F\u5076\u6570"
      }
    },
    {
      input: "ISEVEN(3)",
      output: false,
      description: {
        en: "3 is odd",
        ja: "3 \u306F\u5947\u6570"
      }
    },
    {
      input: "ISEVEN(2.9)",
      output: true,
      description: {
        en: "Fractional numbers are truncated before parity check",
        ja: "\u5C0F\u6570\u306F\u5207\u308A\u6368\u3066\u305F\u6574\u6570\u90E8\u3067\u5224\u5B9A"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("ISEVEN expects exactly one argument");
    }
    const value = helpers.requireNumber(args[0], "ISEVEN number");
    const truncated = Math.trunc(value);
    return truncated % 2 === 0;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/int.ts
var intFunction = {
  name: "INT",
  category: "aggregate",
  description: {
    en: "Rounds a number down to the nearest integer less than or equal to it.",
    ja: "\u6570\u5024\u3092\u8D85\u3048\u306A\u3044\u6700\u5927\u306E\u6574\u6570\u306B\u5207\u308A\u4E0B\u3052\u307E\u3059\u3002"
  },
  examples: ["INT(5.9)", "INT(A1)"],
  samples: [
    {
      input: "INT(5.9)",
      output: 5,
      description: {
        en: "Round down positive decimal to integer",
        ja: "\u6B63\u306E\u5C0F\u6570\u3092\u6574\u6570\u306B\u5207\u308A\u4E0B\u3052"
      }
    },
    {
      input: "INT(-3.2)",
      output: -4,
      description: {
        en: "Round down negative number to lower integer",
        ja: "\u8CA0\u306E\u6570\u3092\u4E0B\u306E\u6574\u6570\u306B\u5207\u308A\u4E0B\u3052"
      }
    },
    {
      input: "INT(8)",
      output: 8,
      description: {
        en: "Integer value remains unchanged",
        ja: "\u6574\u6570\u5024\u306F\u305D\u306E\u307E\u307E"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("INT expects exactly one argument");
    }
    const [valueArg] = args;
    const value = helpers.requireNumber(valueArg, "INT number");
    const floored = Math.floor(value);
    return normalizeZero2(floored);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/mod.ts
var modFunction = {
  name: "MOD",
  category: "aggregate",
  description: {
    en: "Returns the remainder after division, aligned with the sign of the divisor.",
    ja: "\u9664\u7B97\u306E\u4F59\u308A\u3092\u8FD4\u3057\u3001\u9664\u6570\u306E\u7B26\u53F7\u306B\u63C3\u3048\u307E\u3059\u3002"
  },
  examples: ["MOD(10, 3)", "MOD(A1, B1)"],
  samples: [
    {
      input: "MOD(10, 3)",
      output: 1,
      description: {
        en: "Remainder of positive numbers",
        ja: "\u6B63\u306E\u6570\u306E\u5270\u4F59"
      }
    },
    {
      input: "MOD(-10, 3)",
      output: 2,
      description: {
        en: "Remainder aligned with positive divisor",
        ja: "\u6B63\u306E\u9664\u6570\u306B\u63C3\u3048\u305F\u5270\u4F59"
      }
    },
    {
      input: "MOD(10, -3)",
      output: -2,
      description: {
        en: "Remainder aligned with negative divisor",
        ja: "\u8CA0\u306E\u9664\u6570\u306B\u63C3\u3048\u305F\u5270\u4F59"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2) {
      throw new Error("MOD expects exactly two arguments");
    }
    const [dividendArg, divisorArg] = args;
    const dividend = helpers.requireNumber(dividendArg, "MOD dividend");
    const divisor = helpers.requireNumber(divisorArg, "MOD divisor");
    if (!Number.isFinite(dividend) || !Number.isFinite(divisor)) {
      throw new Error("MOD expects finite numeric arguments");
    }
    if (divisor === 0) {
      throw new Error("MOD divisor must be non-zero");
    }
    const remainder = dividend % divisor;
    if (remainder === 0) {
      return 0;
    }
    if (remainder > 0 && divisor > 0 || remainder < 0 && divisor < 0) {
      return normalizeZero2(remainder);
    }
    const adjusted = remainder + divisor;
    return normalizeZero2(adjusted);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/quotient.ts
var truncateTowardZero = (value) => {
  const truncated = value < 0 ? Math.ceil(value) : Math.floor(value);
  return truncated;
};
var quotientFunction = {
  name: "QUOTIENT",
  category: "aggregate",
  description: {
    en: "Returns the integer portion of a division, truncating toward zero.",
    ja: "\u9664\u7B97\u306E\u7D50\u679C\u3092\u30BC\u30ED\u65B9\u5411\u306B\u5207\u308A\u6368\u3066\u305F\u6574\u6570\u90E8\u5206\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["QUOTIENT(10, 3)", "QUOTIENT(A1, B1)"],
  samples: [
    {
      input: "QUOTIENT(10, 3)",
      output: 3,
      description: {
        en: "Integer quotient of positive numbers",
        ja: "\u6B63\u306E\u6570\u306E\u6574\u6570\u5546"
      }
    },
    {
      input: "QUOTIENT(15, 4)",
      output: 3,
      description: {
        en: "Division result truncated to integer",
        ja: "\u9664\u7B97\u7D50\u679C\u3092\u6574\u6570\u306B\u5207\u308A\u6368\u3066"
      }
    },
    {
      input: "QUOTIENT(-10, 3)",
      output: -3,
      description: {
        en: "Negative division truncated toward zero",
        ja: "\u8CA0\u306E\u9664\u7B97\u3092\u30BC\u30ED\u65B9\u5411\u3078\u5207\u308A\u6368\u3066"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2) {
      throw new Error("QUOTIENT expects exactly two arguments");
    }
    const [dividendArg, divisorArg] = args;
    const dividend = helpers.requireNumber(dividendArg, "QUOTIENT dividend");
    const divisor = helpers.requireNumber(divisorArg, "QUOTIENT divisor");
    if (!Number.isFinite(dividend) || !Number.isFinite(divisor)) {
      throw new Error("QUOTIENT expects finite numeric arguments");
    }
    if (divisor === 0) {
      throw new Error("QUOTIENT divisor must be non-zero");
    }
    const quotient = truncateTowardZero(dividend / divisor);
    return normalizeZero2(quotient);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/sign.ts
var signFunction = {
  name: "SIGN",
  category: "aggregate",
  description: {
    en: "Returns 1 for positive numbers, -1 for negative numbers, and 0 otherwise.",
    ja: "\u6570\u5024\u304C\u6B63\u306A\u30891\u3001\u8CA0\u306A\u3089-1\u3001\u305D\u308C\u4EE5\u5916\u306F0\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["SIGN(-3)", "SIGN(A1)"],
  samples: [
    {
      input: "SIGN(10)",
      output: 1,
      description: {
        en: "Sign of positive number",
        ja: "\u6B63\u306E\u6570\u306E\u7B26\u53F7"
      }
    },
    {
      input: "SIGN(-5)",
      output: -1,
      description: {
        en: "Sign of negative number",
        ja: "\u8CA0\u306E\u6570\u306E\u7B26\u53F7"
      }
    },
    {
      input: "SIGN(0)",
      output: 0,
      description: {
        en: "Sign of zero",
        ja: "\u30BC\u30ED\u306E\u7B26\u53F7"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("SIGN expects exactly one argument");
    }
    const [valueArg] = args;
    const value = helpers.requireNumber(valueArg, "SIGN number");
    if (value > 0) {
      return 1;
    }
    if (value < 0) {
      return -1;
    }
    return 0;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/sumif.ts
var sumIfFunction = {
  name: "SUMIF",
  category: "aggregate",
  description: {
    en: "Sums values that meet a single condition across a range.",
    ja: "\u7BC4\u56F2\u5185\u3067\u6761\u4EF6\u3092\u6E80\u305F\u3059\u5024\u3092\u5408\u8A08\u3057\u307E\u3059\u3002"
  },
  examples: ['SUMIF(A1:A10, ">0")', 'SUMIF(A1:A10, "=East", B1:B10)'],
  samples: [
    {
      input: 'SUMIF({1, 2, 3, 4, 5}, ">2")',
      output: 12,
      description: {
        en: "Sum values greater than 2",
        ja: "2\u3088\u308A\u5927\u304D\u3044\u5024\u306E\u5408\u8A08"
      }
    },
    {
      input: 'SUMIF({10, -5, 20, -3}, ">=0")',
      output: 30,
      description: {
        en: "Sum non-negative values",
        ja: "\u975E\u8CA0\u306E\u5024\u306E\u5408\u8A08"
      }
    },
    {
      input: 'SUMIF({5, 10, 15}, "=10")',
      output: 10,
      description: {
        en: "Sum values equal to 10",
        ja: "10\u306B\u7B49\u3057\u3044\u5024\u306E\u5408\u8A08"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 2 || args.length > 3) {
      throw new Error("SUMIF expects two or three arguments");
    }
    const [rangeArg, criteriaArg, sumRangeArg] = args;
    const rangeValues = helpers.flattenResult(rangeArg);
    const criteria = helpers.coerceScalar(criteriaArg, "SUMIF criteria");
    const predicate = helpers.createCriteriaPredicate(criteria, helpers.comparePrimitiveEquality, "SUMIF criteria");
    const sumValues = sumRangeArg === undefined ? rangeValues : helpers.flattenResult(sumRangeArg);
    if (sumRangeArg !== undefined && sumValues.length !== rangeValues.length) {
      throw new Error("SUMIF sum_range must match criteria range size");
    }
    return rangeValues.reduce((total, value, index) => {
      if (!predicate(value)) {
        return total;
      }
      const sumValue = sumValues[index];
      if (typeof sumValue !== "number" || Number.isNaN(sumValue)) {
        return total;
      }
      return total + sumValue;
    }, 0);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/sumifs.ts
var sumIfsFunction = {
  name: "SUMIFS",
  category: "aggregate",
  description: {
    en: "Sums values that satisfy multiple range/criteria pairs.",
    ja: "\u8907\u6570\u306E\u7BC4\u56F2\u3068\u6761\u4EF6\u3092\u3059\u3079\u3066\u6E80\u305F\u3059\u5024\u3092\u5408\u8A08\u3057\u307E\u3059\u3002"
  },
  examples: ['SUMIFS(C1:C10, A1:A10, "East", B1:B10, ">=2024")', "SUMIFS(A1:A5, B1:B5, 1)"],
  samples: [
    {
      input: 'SUMIFS({100, 200, 300}, {1, 2, 3}, ">1", {10, 20, 30}, ">=20")',
      output: 500,
      description: {
        en: "Sum with multiple criteria",
        ja: "\u8907\u6570\u306E\u6761\u4EF6\u3067\u306E\u5408\u8A08"
      }
    },
    {
      input: 'SUMIFS({50, 60, 70}, {5, 10, 15}, ">=10")',
      output: 130,
      description: {
        en: "Sum with single criterion",
        ja: "\u5358\u4E00\u6761\u4EF6\u3067\u306E\u5408\u8A08"
      }
    },
    {
      input: 'SUMIFS({10, 20, 30, 40}, {1, 2, 1, 2}, "=1", {5, 5, 10, 10}, ">=10")',
      output: 30,
      description: {
        en: "Sum matching both conditions",
        ja: "\u4E21\u65B9\u306E\u6761\u4EF6\u306B\u4E00\u81F4\u3059\u308B\u5408\u8A08"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 3 || args.length % 2 === 0) {
      throw new Error("SUMIFS expects a sum range followed by range/criteria pairs");
    }
    const [sumRangeArg, ...criteriaArgs] = args;
    const sumValues = helpers.flattenResult(sumRangeArg);
    if (sumValues.length === 0) {
      return 0;
    }
    const criteriaRanges = [];
    for (let index = 0;index < criteriaArgs.length; index += 2) {
      const rangeArg = criteriaArgs[index];
      const criteriaArg = criteriaArgs[index + 1];
      const rangeValues = helpers.flattenResult(rangeArg);
      if (rangeValues.length !== sumValues.length) {
        throw new Error("SUMIFS criteria ranges must match the sum range size");
      }
      const criteriaValue = helpers.coerceScalar(criteriaArg, `SUMIFS criteria ${index / 2 + 1}`);
      const predicate = helpers.createCriteriaPredicate(criteriaValue, helpers.comparePrimitiveEquality, `SUMIFS criteria ${index / 2 + 1}`);
      criteriaRanges.push({
        values: rangeValues,
        predicate
      });
    }
    return sumValues.reduce((total, value, valueIndex) => {
      if (typeof value !== "number" || Number.isNaN(value)) {
        return total;
      }
      const matchesAll = criteriaRanges.every(({ values, predicate }) => predicate(values[valueIndex]));
      if (!matchesAll) {
        return total;
      }
      return total + value;
    }, 0);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/aggregationHelpers.ts
var getNumericValues = (values) => {
  return values.filter((value) => typeof value === "number");
};
var NUMERIC_AGGREGATIONS = new Set([1, 4, 5, 6, 7, 8, 9, 10, 11]);
var sanitizeValues = (functionNumber, values, options) => {
  if (!NUMERIC_AGGREGATIONS.has(functionNumber)) {
    return values;
  }
  if (options.ignoreErrors) {
    return values.filter((value) => value === null || typeof value === "number");
  }
  const invalid = values.find((value) => value !== null && typeof value !== "number");
  if (invalid !== undefined) {
    throw new Error("AGGREGATE encountered a non-numeric value that cannot be ignored");
  }
  return values;
};
var computeAverage = (values) => {
  const numbers = getNumericValues(values);
  if (numbers.length === 0) {
    throw new Error("SUBTOTAL AVERAGE expects at least one numeric value");
  }
  const { sum } = summarizeNumbers2(numbers);
  return sum / numbers.length;
};
var computeCount = (values) => {
  return getNumericValues(values).length;
};
var computeCountA = (values) => {
  return values.filter((value) => value !== null).length;
};
var computeMax = (values) => {
  const numbers = getNumericValues(values);
  if (numbers.length === 0) {
    throw new Error("SUBTOTAL MAX expects at least one numeric value");
  }
  return Math.max(...numbers);
};
var computeMin = (values) => {
  const numbers = getNumericValues(values);
  if (numbers.length === 0) {
    throw new Error("SUBTOTAL MIN expects at least one numeric value");
  }
  return Math.min(...numbers);
};
var computeProduct = (values) => {
  const numbers = getNumericValues(values);
  return numbers.reduce((product, value) => product * value, 1);
};
var computeSum = (values) => {
  const numbers = getNumericValues(values);
  return numbers.reduce((total, value) => total + value, 0);
};
var computeSampleVariance = (values) => {
  const numbers = getNumericValues(values);
  if (numbers.length < 2) {
    throw new Error("SUBTOTAL VAR expects at least two numeric values");
  }
  const { count, sum, sumOfSquares } = summarizeNumbers2(numbers);
  const varianceNumerator = sumOfSquares - sum * sum / count;
  const variance = varianceNumerator / (count - 1);
  return variance < 0 ? 0 : variance;
};
var computePopulationVariance = (values) => {
  const numbers = getNumericValues(values);
  if (numbers.length === 0) {
    throw new Error("SUBTOTAL VARP expects at least one numeric value");
  }
  const { count, sum, sumOfSquares } = summarizeNumbers2(numbers);
  const varianceNumerator = sumOfSquares - sum * sum / count;
  const variance = varianceNumerator / count;
  return variance < 0 ? 0 : variance;
};
var aggregationMap = {
  1: computeAverage,
  2: computeCount,
  3: computeCountA,
  4: computeMax,
  5: computeMin,
  6: computeProduct,
  7: (values) => Math.sqrt(computeSampleVariance(values)),
  8: (values) => Math.sqrt(computePopulationVariance(values)),
  9: computeSum,
  10: computeSampleVariance,
  11: computePopulationVariance
};
var isSupportedAggregationFunction = (functionNumber) => {
  return functionNumber in aggregationMap;
};
var aggregateValues = (functionNumber, values, options) => {
  const sanitized = sanitizeValues(functionNumber, values, options);
  return aggregationMap[functionNumber](sanitized);
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/subtotal.ts
var collectValues = (args) => {
  return args.flat();
};
var subtotalFunction = {
  name: "SUBTOTAL",
  category: "aggregate",
  description: {
    en: "Calculates a subtotal using a selected aggregation and one or more ranges.",
    ja: "\u6307\u5B9A\u3057\u305F\u96C6\u8A08\u65B9\u6CD5\u30671\u3064\u4EE5\u4E0A\u306E\u7BC4\u56F2\u3092\u96C6\u8A08\u3057\u305F\u5C0F\u8A08\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["SUBTOTAL(9, A1:A10)", "SUBTOTAL(1, A1:A5, B1:B5)"],
  samples: [
    {
      input: "SUBTOTAL(9, 10, 20, 30)",
      output: 60,
      description: {
        en: "Sum (function 9) of values",
        ja: "\u5024\u306E\u5408\u8A08\uFF08\u95A2\u65709\uFF09"
      }
    },
    {
      input: "SUBTOTAL(1, 5, 10, 15)",
      output: 10,
      description: {
        en: "Average (function 1) of values",
        ja: "\u5024\u306E\u5E73\u5747\uFF08\u95A2\u65701\uFF09"
      }
    },
    {
      input: "SUBTOTAL(4, 3, 7, 2, 8)",
      output: 8,
      description: {
        en: "Maximum (function 4) of values",
        ja: "\u5024\u306E\u6700\u5927\uFF08\u95A2\u65704\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 2) {
      throw new Error("SUBTOTAL expects a function number and at least one range");
    }
    const [functionNumberArg, ...rangeArgs] = args;
    const functionNumberValue = helpers.requireNumber(functionNumberArg, "SUBTOTAL function number");
    const functionNumber = helpers.requireInteger(functionNumberValue, "SUBTOTAL function number must be an integer");
    const normalizedFunctionNumber = functionNumber >= 101 && functionNumber <= 111 ? functionNumber - 100 : functionNumber;
    if (!isSupportedAggregationFunction(normalizedFunctionNumber)) {
      throw new Error("SUBTOTAL function number is not supported");
    }
    const rangeValues = rangeArgs.map((rangeArg) => helpers.flattenResult(rangeArg));
    const collected = collectValues(rangeValues);
    return aggregateValues(normalizedFunctionNumber, collected, { ignoreErrors: true });
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/aggregate/aggregate.ts
var collectValues2 = (args) => {
  return args.flat();
};
var SUPPORTED_OPTION_VALUES = new Set([0, 6]);
var aggregateFunction = {
  name: "AGGREGATE",
  category: "aggregate",
  description: {
    en: "Performs a selected aggregation with options for skipping hidden or error cells.",
    ja: "\u975E\u8868\u793A\u30BB\u30EB\u3084\u30A8\u30E9\u30FC\u3092\u9664\u5916\u3059\u308B\u30AA\u30D7\u30B7\u30E7\u30F3\u4ED8\u304D\u3067\u96C6\u8A08\u3092\u5B9F\u884C\u3057\u307E\u3059\u3002"
  },
  examples: ["AGGREGATE(9, 0, A1:A10)", "AGGREGATE(1, 6, A1:A5, B1:B5)"],
  samples: [
    {
      input: "AGGREGATE(9, 0, 5, 10, 15)",
      output: 30,
      description: {
        en: "Sum (function 9) with default options",
        ja: "\u30C7\u30D5\u30A9\u30EB\u30C8\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u5408\u8A08\uFF08\u95A2\u65709\uFF09"
      }
    },
    {
      input: "AGGREGATE(1, 6, 2, 4, 6, 8)",
      output: 5,
      description: {
        en: "Average (function 1) ignoring errors",
        ja: "\u30A8\u30E9\u30FC\u3092\u7121\u8996\u3057\u3066\u5E73\u5747\uFF08\u95A2\u65701\uFF09"
      }
    },
    {
      input: "AGGREGATE(4, 0, 12, 45, 23, 67)",
      output: 67,
      description: {
        en: "Maximum (function 4) of values",
        ja: "\u5024\u306E\u6700\u5927\uFF08\u95A2\u65704\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 3) {
      throw new Error("AGGREGATE expects a function number, options, and at least one range");
    }
    const [functionNumberArg, optionsArg, ...rangeArgs] = args;
    const fnNumberValue = helpers.requireNumber(functionNumberArg, "AGGREGATE function number");
    const fnNumber = helpers.requireInteger(fnNumberValue, "AGGREGATE function number must be an integer");
    if (!isSupportedAggregationFunction(fnNumber)) {
      throw new Error("AGGREGATE function number is not supported");
    }
    const optionsValue = helpers.requireNumber(optionsArg, "AGGREGATE options");
    const options = helpers.requireInteger(optionsValue, "AGGREGATE options must be an integer");
    if (!SUPPORTED_OPTION_VALUES.has(options)) {
      throw new Error("AGGREGATE options value is not supported");
    }
    if (rangeArgs.length === 0) {
      throw new Error("AGGREGATE expects at least one range argument");
    }
    const rangeValues = rangeArgs.map((rangeArg) => helpers.flattenResult(rangeArg));
    const collected = collectValues2(rangeValues);
    const ignoreErrors = options === 6;
    return aggregateValues(fnNumber, collected, { ignoreErrors });
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/serialDate.ts
var MILLISECONDS_PER_DAY = 86400000;
var SPREADSHEET_EPOCH_MS = Date.UTC(1899, 11, 30);
var toUtcDate = (year, monthIndex, day) => {
  const milliseconds = Date.UTC(year, monthIndex, day);
  if (!Number.isFinite(milliseconds)) {
    throw new Error("DATE produced an invalid calendar date");
  }
  return new Date(milliseconds);
};
var datePartsToSerial = (year, month, day) => {
  const utcDate = toUtcDate(year, month - 1, day);
  return (utcDate.getTime() - SPREADSHEET_EPOCH_MS) / MILLISECONDS_PER_DAY;
};
var dateTimeToSerial = (date) => {
  return (date.getTime() - SPREADSHEET_EPOCH_MS) / MILLISECONDS_PER_DAY;
};
var serialToDate = (serial) => {
  if (!Number.isFinite(serial)) {
    throw new Error("Date serial must be finite");
  }
  const millisecondsOffset = Math.round(serial * MILLISECONDS_PER_DAY);
  return new Date(SPREADSHEET_EPOCH_MS + millisecondsOffset);
};
var serialToUTCComponents = (serial) => {
  const date = serialToDate(serial);
  return {
    year: date.getUTCFullYear(),
    month: date.getUTCMonth() + 1,
    day: date.getUTCDate(),
    hours: date.getUTCHours(),
    minutes: date.getUTCMinutes(),
    seconds: date.getUTCSeconds(),
    milliseconds: date.getUTCMilliseconds()
  };
};
var normalizeTimeToFraction = (hours, minutes, seconds) => {
  const totalSeconds = hours * 3600 + minutes * 60 + seconds;
  if (!Number.isFinite(totalSeconds)) {
    throw new Error("TIME arguments must be finite");
  }
  if (totalSeconds < 0) {
    throw new Error("TIME arguments must not produce negative durations");
  }
  return totalSeconds / 86400;
};
var daysInMonth = (year, month) => {
  const boundary = toUtcDate(year, month, 0);
  return boundary.getUTCDate();
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/date.ts
var dateFunction = {
  name: "DATE",
  category: "datetime",
  description: {
    en: "Returns the serial number for a specific date, normalising overflowed months and days.",
    ja: "\u6708\u3084\u65E5\u304C\u30AA\u30FC\u30D0\u30FC\u30D5\u30ED\u30FC\u3057\u3066\u3044\u3066\u3082\u6B63\u898F\u5316\u3057\u305F\u65E5\u4ED8\u306E\u30B7\u30EA\u30A2\u30EB\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["DATE(2024, 1, 31)", "DATE(A1, B1, C1)"],
  samples: [
    {
      input: "DATE(2024, 1, 15)",
      output: 45307,
      description: {
        en: "Serial number for January 15, 2024",
        ja: "2024\u5E741\u670815\u65E5\u306E\u30B7\u30EA\u30A2\u30EB\u5024"
      }
    },
    {
      input: "DATE(2024, 13, 1)",
      output: 45658,
      description: {
        en: "Overflowed month normalizes to January 1, 2025",
        ja: "\u30AA\u30FC\u30D0\u30FC\u30D5\u30ED\u30FC\u3057\u305F\u6708\u304C2025\u5E741\u67081\u65E5\u306B\u6B63\u898F\u5316"
      }
    },
    {
      input: "DATE(2024, 2, 30)",
      output: 45351,
      description: {
        en: "Overflowed day normalizes to March 1, 2024",
        ja: "\u30AA\u30FC\u30D0\u30FC\u30D5\u30ED\u30FC\u3057\u305F\u65E5\u304C2024\u5E743\u67081\u65E5\u306B\u6B63\u898F\u5316"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 3) {
      throw new Error("DATE expects exactly three arguments");
    }
    const yearNumber = helpers.requireNumber(args[0], "DATE year");
    const monthNumber = helpers.requireNumber(args[1], "DATE month");
    const dayNumber = helpers.requireNumber(args[2], "DATE day");
    const year = helpers.requireInteger(yearNumber, "DATE year must be integer");
    const month = helpers.requireInteger(monthNumber, "DATE month must be integer");
    const day = helpers.requireInteger(dayNumber, "DATE day must be integer");
    return datePartsToSerial(year, month, day);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/time.ts
var timeFunction = {
  name: "TIME",
  category: "datetime",
  description: {
    en: "Converts hour, minute, and second arguments into a fractional-day time serial.",
    ja: "\u6642\u30FB\u5206\u30FB\u79D2\u30921\u65E5\u3092\u57FA\u6E96\u3068\u3057\u305F\u6642\u9593\u30B7\u30EA\u30A2\u30EB\u5024\u306B\u5909\u63DB\u3057\u307E\u3059\u3002"
  },
  examples: ["TIME(14, 30, 0)", "TIME(A1, B1, C1)"],
  samples: [
    {
      input: "TIME(12, 0, 0)",
      output: 0.5,
      description: {
        en: "Noon as fractional day (0.5)",
        ja: "\u6B63\u5348\u3092\u65E5\u306E\u5C0F\u6570\u5024(0.5)\u3068\u3057\u3066\u8868\u73FE"
      }
    },
    {
      input: "TIME(14, 30, 0)",
      output: 0.6041666666666666,
      description: {
        en: "2:30 PM as fractional day",
        ja: "\u5348\u5F8C2\u664230\u5206\u3092\u65E5\u306E\u5C0F\u6570\u5024\u3068\u3057\u3066\u8868\u73FE"
      }
    },
    {
      input: "TIME(6, 15, 30)",
      output: 0.26041666666666663,
      description: {
        en: "6:15:30 AM as fractional day",
        ja: "\u5348\u524D6\u664215\u520630\u79D2\u3092\u65E5\u306E\u5C0F\u6570\u5024\u3068\u3057\u3066\u8868\u73FE"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 3) {
      throw new Error("TIME expects exactly three arguments");
    }
    const hours = helpers.requireNumber(args[0], "TIME hour");
    const minutes = helpers.requireNumber(args[1], "TIME minute");
    const seconds = helpers.requireNumber(args[2], "TIME second");
    if (minutes < 0 || seconds < 0) {
      throw new Error("TIME arguments must not be negative");
    }
    return normalizeTimeToFraction(hours, minutes, seconds);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/parseDateText.ts
var DATE_PATTERN = /^([+-]?\d{1,4})[-/](\d{1,2})[-/](\d{1,2})$/u;
var TIME_PATTERN = /^([+-]?\d+(?:\.\d+)?):(\d{1,2})(?::(\d{1,2}(?:\.\d+)?))?$/u;
var parseDateText = (text, description) => {
  const trimmed = text.trim();
  const match = DATE_PATTERN.exec(trimmed);
  if (!match) {
    throw new Error(`${description} expects date in YYYY-MM-DD or YYYY/MM/DD format`);
  }
  const [, yearText, monthText, dayText] = match;
  const year = Number.parseInt(yearText, 10);
  const month = Number.parseInt(monthText, 10);
  const day = Number.parseInt(dayText, 10);
  if (!Number.isInteger(year) || !Number.isInteger(month) || !Number.isInteger(day)) {
    throw new Error(`${description} could not parse calendar components`);
  }
  return datePartsToSerial(year, month, day);
};
var parseTimeText = (text, description) => {
  const trimmed = text.trim();
  const match = TIME_PATTERN.exec(trimmed);
  if (!match) {
    throw new Error(`${description} expects time in HH:MM or HH:MM:SS format`);
  }
  const [, hourText, minuteText, secondText] = match;
  const hours = Number.parseFloat(hourText);
  const minutes = Number.parseFloat(minuteText);
  const seconds = secondText ? Number.parseFloat(secondText) : 0;
  if (!Number.isFinite(hours) || !Number.isFinite(minutes) || !Number.isFinite(seconds)) {
    throw new Error(`${description} could not parse time components`);
  }
  if (minutes < 0 || minutes >= 60 || seconds < 0 || seconds >= 60) {
    throw new Error(`${description} minutes and seconds must be within [0, 60)`);
  }
  if (hours < 0) {
    throw new Error(`${description} hours must be non-negative`);
  }
  return normalizeTimeToFraction(hours, minutes, seconds);
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/datevalue.ts
var dateValueFunction = {
  name: "DATEVALUE",
  category: "datetime",
  description: {
    en: "Converts a date string or serial into a serial number representing the date.",
    ja: "\u65E5\u4ED8\u6587\u5B57\u5217\u307E\u305F\u306F\u30B7\u30EA\u30A2\u30EB\u5024\u3092\u65E5\u4ED8\u30B7\u30EA\u30A2\u30EB\u306B\u5909\u63DB\u3057\u307E\u3059\u3002"
  },
  examples: ['DATEVALUE("2024-05-10")', "DATEVALUE(A1)"],
  samples: [
    {
      input: 'DATEVALUE("2024-05-10")',
      output: 45421,
      description: {
        en: "Convert date string to serial number",
        ja: "\u65E5\u4ED8\u6587\u5B57\u5217\u3092\u30B7\u30EA\u30A2\u30EB\u5024\u306B\u5909\u63DB"
      }
    },
    {
      input: 'DATEVALUE("2024-12-31")',
      output: 45657,
      description: {
        en: "Convert year-end date to serial",
        ja: "\u5E74\u672B\u65E5\u4ED8\u3092\u30B7\u30EA\u30A2\u30EB\u5024\u306B\u5909\u63DB"
      }
    },
    {
      input: "DATEVALUE(45307.5)",
      output: 45307,
      description: {
        en: "Extract integer date part from serial",
        ja: "\u30B7\u30EA\u30A2\u30EB\u5024\u304B\u3089\u6574\u6570\u306E\u65E5\u4ED8\u90E8\u5206\u3092\u62BD\u51FA"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("DATEVALUE expects exactly one argument");
    }
    const value = helpers.coerceScalar(args[0], "DATEVALUE input");
    if (typeof value === "number") {
      return Math.floor(value);
    }
    if (typeof value === "string") {
      return parseDateText(value, "DATEVALUE input");
    }
    throw new Error("DATEVALUE expects a date serial or text representation");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/timevalue.ts
var timeValueFunction = {
  name: "TIMEVALUE",
  category: "datetime",
  description: {
    en: "Converts a time string or serial into the fractional-day time component.",
    ja: "\u6642\u9593\u6587\u5B57\u5217\u307E\u305F\u306F\u30B7\u30EA\u30A2\u30EB\u5024\u3092\u65E5\u5185\u6642\u9593\u306E\u5C0F\u6570\u90E8\u306B\u5909\u63DB\u3057\u307E\u3059\u3002"
  },
  examples: ['TIMEVALUE("12:30:00")', "TIMEVALUE(A1)"],
  samples: [
    {
      input: 'TIMEVALUE("12:30:00")',
      output: 0.5208333333333334,
      description: {
        en: "Convert time string to fractional day",
        ja: "\u6642\u9593\u6587\u5B57\u5217\u3092\u65E5\u306E\u5C0F\u6570\u5024\u306B\u5909\u63DB"
      }
    },
    {
      input: 'TIMEVALUE("18:45:30")',
      output: 0.78125,
      description: {
        en: "Convert evening time to fractional day",
        ja: "\u5915\u65B9\u306E\u6642\u523B\u3092\u65E5\u306E\u5C0F\u6570\u5024\u306B\u5909\u63DB"
      }
    },
    {
      input: "TIMEVALUE(45307.75)",
      output: 0.75,
      description: {
        en: "Extract fractional time from serial",
        ja: "\u30B7\u30EA\u30A2\u30EB\u5024\u304B\u3089\u6642\u9593\u306E\u5C0F\u6570\u90E8\u3092\u62BD\u51FA"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("TIMEVALUE expects exactly one argument");
    }
    const value = helpers.coerceScalar(args[0], "TIMEVALUE input");
    if (typeof value === "number") {
      const fraction = value - Math.floor(value);
      return fraction >= 0 ? fraction : fraction + 1;
    }
    if (typeof value === "string") {
      return parseTimeText(value, "TIMEVALUE input");
    }
    throw new Error("TIMEVALUE expects a time serial or text representation");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/today.ts
var todayFunction = {
  name: "TODAY",
  category: "datetime",
  description: {
    en: "Returns the current date as a serial number without a time component.",
    ja: "\u73FE\u5728\u306E\u65E5\u4ED8\u3092\u6642\u9593\u6210\u5206\u306A\u3057\u306E\u30B7\u30EA\u30A2\u30EB\u5024\u3067\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["TODAY()"],
  samples: [
    {
      input: "TODAY()",
      output: 45307,
      description: {
        en: "Returns current date serial (example shows January 15, 2024)",
        ja: "\u73FE\u5728\u306E\u65E5\u4ED8\u306E\u30B7\u30EA\u30A2\u30EB\u5024\u3092\u8FD4\u3059\uFF08\u4F8B\u306F2024\u5E741\u670815\u65E5\uFF09"
      }
    }
  ],
  evaluate: (args) => {
    if (args.length !== 0) {
      throw new Error("TODAY expects no arguments");
    }
    const now = new Date;
    return Math.floor(dateTimeToSerial(now));
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/now.ts
var nowFunction = {
  name: "NOW",
  category: "datetime",
  description: {
    en: "Returns the current date and time as a serial number.",
    ja: "\u73FE\u5728\u306E\u65E5\u4ED8\u3068\u6642\u523B\u3092\u30B7\u30EA\u30A2\u30EB\u5024\u3067\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["NOW()"],
  samples: [
    {
      input: "NOW()",
      output: 45307.604166666664,
      description: {
        en: "Returns current date and time serial (example shows January 15, 2024 at 2:30 PM)",
        ja: "\u73FE\u5728\u306E\u65E5\u4ED8\u3068\u6642\u523B\u306E\u30B7\u30EA\u30A2\u30EB\u5024\u3092\u8FD4\u3059\uFF08\u4F8B\u306F2024\u5E741\u670815\u65E5\u5348\u5F8C2\u664230\u5206\uFF09"
      }
    }
  ],
  evaluate: (args) => {
    if (args.length !== 0) {
      throw new Error("NOW expects no arguments");
    }
    return dateTimeToSerial(new Date);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/coerceDateSerial.ts
var coerceDateSerial = (value, helpers, description) => {
  if (Array.isArray(value)) {
    const scalar = helpers.coerceScalar(value, description);
    return coerceDateSerial(scalar, helpers, description);
  }
  if (typeof value === "number") {
    return Math.floor(value);
  }
  if (typeof value === "string") {
    return parseDateText(value, description);
  }
  throw new Error(`${description} expects a date serial or text`);
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/edate.ts
var eDateFunction = {
  name: "EDATE",
  category: "datetime",
  description: {
    en: "Returns the serial number of the date that is the indicated number of months before or after a start date.",
    ja: "\u958B\u59CB\u65E5\u304B\u3089\u6307\u5B9A\u3057\u305F\u6708\u6570\u3060\u3051\u524D\u5F8C\u3057\u305F\u65E5\u4ED8\u306E\u30B7\u30EA\u30A2\u30EB\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['EDATE("2024-01-31", 1)', "EDATE(A1, -6)"],
  samples: [
    {
      input: 'EDATE("2024-01-31", 1)',
      output: 45351,
      description: {
        en: "One month after January 31, 2024 (February 29, 2024)",
        ja: "2024\u5E741\u670831\u65E5\u306E1\u30F6\u6708\u5F8C\uFF082024\u5E742\u670829\u65E5\uFF09"
      }
    },
    {
      input: 'EDATE("2024-06-15", 3)',
      output: 45557,
      description: {
        en: "Three months after June 15, 2024 (September 15, 2024)",
        ja: "2024\u5E746\u670815\u65E5\u306E3\u30F6\u6708\u5F8C\uFF082024\u5E749\u670815\u65E5\uFF09"
      }
    },
    {
      input: 'EDATE("2024-03-31", -1)',
      output: 45351,
      description: {
        en: "One month before March 31, 2024 (February 29, 2024)",
        ja: "2024\u5E743\u670831\u65E5\u306E1\u30F6\u6708\u524D\uFF082024\u5E742\u670829\u65E5\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2) {
      throw new Error("EDATE expects exactly two arguments");
    }
    const baseSerial = coerceDateSerial(args[0], helpers, "EDATE start_date");
    const monthsRaw = helpers.requireNumber(args[1], "EDATE months");
    const monthsOffset = helpers.requireInteger(monthsRaw, "EDATE months must be integer");
    const { year: baseYear, month: baseMonth, day: baseDay } = serialToUTCComponents(baseSerial);
    const totalMonths = baseYear * 12 + (baseMonth - 1) + monthsOffset;
    const targetYear = Math.floor(totalMonths / 12);
    const targetMonthIndex = totalMonths - targetYear * 12;
    const targetMonth = targetMonthIndex + 1;
    const clampedDay = Math.min(baseDay, daysInMonth(targetYear, targetMonth));
    return datePartsToSerial(targetYear, targetMonth, clampedDay);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/eomonth.ts
var eoMonthFunction = {
  name: "EOMONTH",
  category: "datetime",
  description: {
    en: "Returns the serial number of the last day of the month a given number of months away.",
    ja: "\u6307\u5B9A\u3057\u305F\u6708\u6570\u3060\u3051\u524D\u5F8C\u3057\u305F\u6708\u306E\u6708\u672B\u65E5\u30B7\u30EA\u30A2\u30EB\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['EOMONTH("2024-01-15", 1)', "EOMONTH(A1, 0)"],
  samples: [
    {
      input: 'EOMONTH("2024-01-15", 0)',
      output: 45322,
      description: {
        en: "Last day of current month (January 31, 2024)",
        ja: "\u5F53\u6708\u306E\u6708\u672B\uFF082024\u5E741\u670831\u65E5\uFF09"
      }
    },
    {
      input: 'EOMONTH("2024-01-15", 1)',
      output: 45351,
      description: {
        en: "Last day one month later (February 29, 2024)",
        ja: "1\u30F6\u6708\u5F8C\u306E\u6708\u672B\uFF082024\u5E742\u670829\u65E5\uFF09"
      }
    },
    {
      input: 'EOMONTH("2024-03-15", -1)',
      output: 45351,
      description: {
        en: "Last day one month earlier (February 29, 2024)",
        ja: "1\u30F6\u6708\u524D\u306E\u6708\u672B\uFF082024\u5E742\u670829\u65E5\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2) {
      throw new Error("EOMONTH expects exactly two arguments");
    }
    const baseSerial = coerceDateSerial(args[0], helpers, "EOMONTH start_date");
    const monthsRaw = helpers.requireNumber(args[1], "EOMONTH months");
    const monthsOffset = helpers.requireInteger(monthsRaw, "EOMONTH months must be integer");
    const baseDate = serialToDate(baseSerial);
    const endOfMonth = new Date(Date.UTC(baseDate.getUTCFullYear(), baseDate.getUTCMonth() + monthsOffset + 1, 0));
    return datePartsToSerial(endOfMonth.getUTCFullYear(), endOfMonth.getUTCMonth() + 1, endOfMonth.getUTCDate());
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/day.ts
var dayFunction = {
  name: "DAY",
  category: "datetime",
  description: {
    en: "Returns the day of the month from a serial date.",
    ja: "\u30B7\u30EA\u30A2\u30EB\u65E5\u4ED8\u304B\u3089\u6708\u5185\u306E\u65E5\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['DAY("2024-05-10")', "DAY(A1)"],
  samples: [
    {
      input: 'DAY("2024-05-10")',
      output: 10,
      description: {
        en: "Extract day from date (10)",
        ja: "\u65E5\u4ED8\u304B\u3089\u65E5\u3092\u62BD\u51FA\uFF0810\u65E5\uFF09"
      }
    },
    {
      input: "DAY(45322)",
      output: 31,
      description: {
        en: "Day from serial (January 31, 2024)",
        ja: "\u30B7\u30EA\u30A2\u30EB\u5024\u304B\u3089\u65E5\u3092\u62BD\u51FA\uFF082024\u5E741\u670831\u65E5\uFF09"
      }
    },
    {
      input: 'DAY("2024-12-25")',
      output: 25,
      description: {
        en: "Extract day from Christmas date (25)",
        ja: "\u30AF\u30EA\u30B9\u30DE\u30B9\u306E\u65E5\u4ED8\u304B\u3089\u65E5\u3092\u62BD\u51FA\uFF0825\u65E5\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("DAY expects exactly one argument");
    }
    const serial = helpers.requireNumber(args[0], "DAY serial");
    return serialToUTCComponents(Math.floor(serial)).day;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/month.ts
var monthFunction = {
  name: "MONTH",
  category: "datetime",
  description: {
    en: "Returns the month number from a serial date (1\u201312).",
    ja: "\u30B7\u30EA\u30A2\u30EB\u65E5\u4ED8\u304B\u3089\u6708\u756A\u53F7(1\u301C12)\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['MONTH("2024-05-10")', "MONTH(A1)"],
  samples: [
    {
      input: 'MONTH("2024-05-10")',
      output: 5,
      description: {
        en: "Extract month from date (May = 5)",
        ja: "\u65E5\u4ED8\u304B\u3089\u6708\u3092\u62BD\u51FA\uFF085\u6708 = 5\uFF09"
      }
    },
    {
      input: "MONTH(45322)",
      output: 1,
      description: {
        en: "Month from serial (January = 1)",
        ja: "\u30B7\u30EA\u30A2\u30EB\u5024\u304B\u3089\u6708\u3092\u62BD\u51FA\uFF081\u6708 = 1\uFF09"
      }
    },
    {
      input: 'MONTH("2024-12-25")',
      output: 12,
      description: {
        en: "Extract month from Christmas date (December = 12)",
        ja: "\u30AF\u30EA\u30B9\u30DE\u30B9\u306E\u65E5\u4ED8\u304B\u3089\u6708\u3092\u62BD\u51FA\uFF0812\u6708 = 12\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("MONTH expects exactly one argument");
    }
    const serial = helpers.requireNumber(args[0], "MONTH serial");
    return serialToUTCComponents(Math.floor(serial)).month;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/year.ts
var yearFunction = {
  name: "YEAR",
  category: "datetime",
  description: {
    en: "Returns the year component from a serial date.",
    ja: "\u30B7\u30EA\u30A2\u30EB\u65E5\u4ED8\u304B\u3089\u5E74\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['YEAR("2024-05-10")', "YEAR(A1)"],
  samples: [
    {
      input: 'YEAR("2024-05-10")',
      output: 2024,
      description: {
        en: "Extract year from date (2024)",
        ja: "\u65E5\u4ED8\u304B\u3089\u5E74\u3092\u62BD\u51FA\uFF082024\u5E74\uFF09"
      }
    },
    {
      input: "YEAR(45322)",
      output: 2024,
      description: {
        en: "Year from serial (2024)",
        ja: "\u30B7\u30EA\u30A2\u30EB\u5024\u304B\u3089\u5E74\u3092\u62BD\u51FA\uFF082024\u5E74\uFF09"
      }
    },
    {
      input: 'YEAR("2025-12-31")',
      output: 2025,
      description: {
        en: "Extract year from future date (2025)",
        ja: "\u672A\u6765\u306E\u65E5\u4ED8\u304B\u3089\u5E74\u3092\u62BD\u51FA\uFF082025\u5E74\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("YEAR expects exactly one argument");
    }
    const serial = helpers.requireNumber(args[0], "YEAR serial");
    return serialToUTCComponents(Math.floor(serial)).year;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/weekday.ts
var normalizeWeekday = (weekday, returnType) => {
  if (returnType === 1) {
    return weekday === 0 ? 1 : weekday + 1;
  }
  if (returnType === 2) {
    return weekday === 0 ? 7 : weekday;
  }
  if (returnType === 3) {
    return (weekday + 6) % 7;
  }
  throw new Error("WEEKDAY return_type must be 1, 2, or 3");
};
var weekDayFunction = {
  name: "WEEKDAY",
  category: "datetime",
  description: {
    en: "Returns the day of the week for a date, with configurable numbering schemes.",
    ja: "\u65E5\u4ED8\u306E\u66DC\u65E5\u3092\u53D6\u5F97\u3057\u3001\u756A\u53F7\u4ED8\u3051\u65B9\u5F0F\u3092\u6307\u5B9A\u3067\u304D\u307E\u3059\u3002"
  },
  examples: ['WEEKDAY("2024-01-07")', "WEEKDAY(A1, 2)"],
  samples: [
    {
      input: 'WEEKDAY("2024-01-07")',
      output: 1,
      description: {
        en: "Sunday returns 1 (default numbering)",
        ja: "\u65E5\u66DC\u65E5\u306F1\u3092\u8FD4\u3059\uFF08\u30C7\u30D5\u30A9\u30EB\u30C8\u306E\u756A\u53F7\u4ED8\u3051\uFF09"
      }
    },
    {
      input: 'WEEKDAY("2024-01-08", 2)',
      output: 1,
      description: {
        en: "Monday returns 1 (Monday-based numbering)",
        ja: "\u6708\u66DC\u65E5\u306F1\u3092\u8FD4\u3059\uFF08\u6708\u66DC\u59CB\u307E\u308A\u306E\u756A\u53F7\u4ED8\u3051\uFF09"
      }
    },
    {
      input: 'WEEKDAY("2024-01-08", 3)',
      output: 0,
      description: {
        en: "Monday returns 0 (0-indexed from Monday)",
        ja: "\u6708\u66DC\u65E5\u306F0\u3092\u8FD4\u3059\uFF08\u6708\u66DC\u304B\u30890\u59CB\u307E\u308A\u306E\u756A\u53F7\u4ED8\u3051\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 1 || args.length > 2) {
      throw new Error("WEEKDAY expects one or two arguments");
    }
    const serial = helpers.requireNumber(args[0], "WEEKDAY serial");
    const resolveReturnType = () => {
      if (args.length !== 2) {
        return 1;
      }
      return helpers.requireInteger(helpers.requireNumber(args[1], "WEEKDAY return_type"), "WEEKDAY return_type must be integer");
    };
    const returnType = resolveReturnType();
    const date = serialToDate(Math.floor(serial));
    const weekday = date.getUTCDay();
    return normalizeWeekday(weekday, returnType);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/weeknum.ts
var computeWeekNumber = (serial, returnType) => {
  const date = serialToDate(Math.floor(serial));
  const year = date.getUTCFullYear();
  const startOfYearSerial = datePartsToSerial(year, 1, 1);
  const startOfYearDate = serialToDate(startOfYearSerial);
  if (returnType === 1) {
    const startWeekday = startOfYearDate.getUTCDay();
    const startOfFirstWeek = startOfYearSerial - startWeekday;
    const week = Math.floor((Math.floor(serial) - startOfFirstWeek) / 7) + 1;
    return week <= 0 ? 1 : week;
  }
  if (returnType === 2) {
    const startWeekday = startOfYearDate.getUTCDay();
    const normalized = startWeekday === 0 ? 6 : startWeekday - 1;
    const startOfFirstWeek = startOfYearSerial - normalized;
    const week = Math.floor((Math.floor(serial) - startOfFirstWeek) / 7) + 1;
    return week <= 0 ? 1 : week;
  }
  throw new Error("WEEKNUM return_type must be 1 or 2");
};
var weekNumFunction = {
  name: "WEEKNUM",
  category: "datetime",
  description: {
    en: "Returns the week number of a date using Sunday or Monday as the first day of the week.",
    ja: "\u9031\u306E\u958B\u59CB\u66DC\u65E5(\u65E5\u66DC\u307E\u305F\u306F\u6708\u66DC)\u3092\u6307\u5B9A\u3057\u3066\u65E5\u4ED8\u306E\u9031\u756A\u53F7\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['WEEKNUM("2024-01-06")', "WEEKNUM(A1, 2)"],
  samples: [
    {
      input: 'WEEKNUM("2024-01-06")',
      output: 1,
      description: {
        en: "Week number with Sunday as first day",
        ja: "\u65E5\u66DC\u59CB\u307E\u308A\u3067\u306E\u9031\u756A\u53F7"
      }
    },
    {
      input: 'WEEKNUM("2024-01-15", 2)',
      output: 3,
      description: {
        en: "Week number with Monday as first day",
        ja: "\u6708\u66DC\u59CB\u307E\u308A\u3067\u306E\u9031\u756A\u53F7"
      }
    },
    {
      input: 'WEEKNUM("2024-12-31")',
      output: 53,
      description: {
        en: "Last week of the year (Sunday-based)",
        ja: "\u5E74\u306E\u6700\u7D42\u9031\uFF08\u65E5\u66DC\u59CB\u307E\u308A\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 1 || args.length > 2) {
      throw new Error("WEEKNUM expects one or two arguments");
    }
    const serial = helpers.requireNumber(args[0], "WEEKNUM serial");
    const resolveReturnType = () => {
      if (args.length !== 2) {
        return 1;
      }
      return helpers.requireInteger(helpers.requireNumber(args[1], "WEEKNUM return_type"), "WEEKNUM return_type must be integer");
    };
    const returnType = resolveReturnType();
    return computeWeekNumber(serial, returnType);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/datetime/workday.ts
function isWeekend(dateSerial) {
  const date = serialToDate(dateSerial);
  const day = date.getUTCDay();
  return day === 0 || day === 6;
}
function collectHolidaySerials(value, helpers) {
  if (value === undefined) {
    return new Set;
  }
  const flattened = helpers.flattenResult(value);
  const holidaySerials = [];
  for (const entry of flattened) {
    if (entry === null || entry === "") {
      continue;
    }
    holidaySerials.push(coerceDateSerial(entry, helpers, "WORKDAY holidays"));
  }
  return new Set(holidaySerials);
}
function advanceToWorkday(startSerial, direction, holidays) {
  for (let current = startSerial;; current += direction) {
    if (isWeekend(current)) {
      continue;
    }
    if (holidays.has(current)) {
      continue;
    }
    return current;
  }
}
function shiftWorkdays(params) {
  const { startSerial, workdays, direction, holidays } = params;
  if (workdays === 0) {
    return startSerial;
  }
  for (let moved = 0, current = startSerial;moved < workdays; moved += 1) {
    const next = advanceToWorkday(current + direction, direction, holidays);
    if (moved + 1 === workdays) {
      return next;
    }
    current = next;
  }
  throw new Error("Unexpected WORKDAY shift state");
}
var workdayFunction = {
  name: "WORKDAY",
  category: "datetime",
  description: {
    en: "Returns a date serial offset by the specified number of workdays.",
    ja: "\u6307\u5B9A\u3057\u305F\u55B6\u696D\u65E5\u6570\u3060\u3051\u524D\u5F8C\u3057\u305F\u65E5\u4ED8\u30B7\u30EA\u30A2\u30EB\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["WORKDAY(A1,5)", "WORKDAY(A1,-5)", "WORKDAY(A1,5,holidays)"],
  evaluate: (args, helpers) => {
    if (args.length < 2 || args.length > 3) {
      throw new Error("WORKDAY expects 2 or 3 arguments");
    }
    const startSerial = coerceDateSerial(args[0], helpers, "WORKDAY start_date");
    const days = helpers.requireNumber(args[1], "WORKDAY days");
    const dayCount = Math.trunc(days);
    const holidays = collectHolidaySerials(args[2], helpers);
    const direction = dayCount >= 0 ? 1 : -1;
    const remaining = Math.abs(dayCount);
    const alignedStart = advanceToWorkday(startSerial, direction, holidays);
    return shiftWorkdays({ startSerial: alignedStart, workdays: remaining, direction, holidays });
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/financial/pmt.ts
var pmtFunction = {
  name: "PMT",
  category: "financial",
  description: {
    en: "Returns the periodic payment amount for a loan or investment.",
    ja: "\u30ED\u30FC\u30F3\u3084\u6295\u8CC7\u306E\u5404\u671F\u652F\u6255\u984D\u3092\u8A08\u7B97\u3057\u307E\u3059\u3002"
  },
  examples: ["PMT(0.05/12, 60, 10000)", "PMT(rate, nper, pv, fv, type)"],
  samples: [
    {
      input: "PMT(0.05/12, 60, 10000)",
      output: -188.71233644010877,
      description: {
        en: "Monthly payment for $10,000 loan at 5% annual rate over 5 years",
        ja: "\u5E74\u52295%\u30675\u5E74\u9593\u306E10,000\u30C9\u30EB\u306E\u30ED\u30FC\u30F3\u306E\u6708\u6B21\u652F\u6255\u984D"
      }
    },
    {
      input: "PMT(0.08/12, 120, 50000)",
      output: -606.6379717767879,
      description: {
        en: "Monthly payment for $50,000 loan at 8% annual rate over 10 years",
        ja: "\u5E74\u52298%\u306710\u5E74\u9593\u306E50,000\u30C9\u30EB\u306E\u30ED\u30FC\u30F3\u306E\u6708\u6B21\u652F\u6255\u984D"
      }
    },
    {
      input: "PMT(0.1/12, 36, 20000, 0, 1)",
      output: -640.0103245058702,
      description: {
        en: "Monthly payment with payment at beginning of period",
        ja: "\u671F\u521D\u6255\u3044\u306E\u6708\u6B21\u652F\u6255\u984D"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 3 || args.length > 5) {
      throw new Error("PMT expects rate, nper, pv, and optional fv and type");
    }
    const [rateArg, nperArg, pvArg, fvArg, typeArg] = args;
    const rate = helpers.requireNumber(rateArg, "PMT rate");
    const periodsRaw = helpers.requireNumber(nperArg, "PMT nper");
    const pv = helpers.requireNumber(pvArg, "PMT pv");
    const fv = fvArg ? helpers.requireNumber(fvArg, "PMT fv") : 0;
    const typeValue = typeArg ? helpers.requireNumber(typeArg, "PMT type") : 0;
    const periods = helpers.requireInteger(periodsRaw, "PMT nper must be integer");
    const type = helpers.requireInteger(typeValue, "PMT type must be integer");
    return helpers.calculatePayment({ rate, periods, presentValue: pv, futureValue: fv, type });
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/financial/ipmt.ts
var ipmtFunction = {
  name: "IPMT",
  category: "financial",
  description: {
    en: "Returns the interest payment for a given period.",
    ja: "\u6307\u5B9A\u671F\u306E\u5229\u606F\u652F\u6255\u984D\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["IPMT(0.05/12, 1, 60, 10000)", "IPMT(rate, per, nper, pv, fv, type)"],
  samples: [
    {
      input: "IPMT(0.05/12, 1, 60, 10000)",
      output: -41.666666666666664,
      description: {
        en: "Interest portion of first payment on $10,000 loan",
        ja: "10,000\u30C9\u30EB\u306E\u30ED\u30FC\u30F3\u306E\u521D\u56DE\u652F\u6255\u3044\u306E\u5229\u606F\u90E8\u5206"
      }
    },
    {
      input: "IPMT(0.08/12, 12, 120, 50000)",
      output: -312.60937378758314,
      description: {
        en: "Interest portion of 12th payment",
        ja: "12\u56DE\u76EE\u306E\u652F\u6255\u3044\u306E\u5229\u606F\u90E8\u5206"
      }
    },
    {
      input: "IPMT(0.06/12, 6, 36, 20000)",
      output: -87.16128444806796,
      description: {
        en: "Interest portion of 6th payment",
        ja: "6\u56DE\u76EE\u306E\u652F\u6255\u3044\u306E\u5229\u606F\u90E8\u5206"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 4 || args.length > 6) {
      throw new Error("IPMT expects rate, period, nper, pv, and optional fv and type");
    }
    const [rateArg, periodArg, nperArg, pvArg, fvArg, typeArg] = args;
    const rate = helpers.requireNumber(rateArg, "IPMT rate");
    const periodRaw = helpers.requireNumber(periodArg, "IPMT period");
    const periodsRaw = helpers.requireNumber(nperArg, "IPMT nper");
    const pv = helpers.requireNumber(pvArg, "IPMT pv");
    const fv = fvArg ? helpers.requireNumber(fvArg, "IPMT fv") : 0;
    const typeNumber = typeArg ? helpers.requireNumber(typeArg, "IPMT type") : 0;
    const period = helpers.requireInteger(periodRaw, "IPMT period must be integer");
    const periods = helpers.requireInteger(periodsRaw, "IPMT nper must be integer");
    const type = helpers.requireInteger(typeNumber, "IPMT type must be integer");
    if (periods <= 0) {
      throw new Error("IPMT nper must be greater than zero");
    }
    if (period < 1 || period > periods) {
      throw new Error("IPMT period must be between 1 and nper");
    }
    if (type !== 0 && type !== 1) {
      throw new Error("IPMT type must be 0 or 1");
    }
    if (rate === 0) {
      return 0;
    }
    helpers.validateInterestRate(rate, "IPMT rate");
    const payment = helpers.calculatePayment({ rate, periods, presentValue: pv, futureValue: fv, type });
    return helpers.calculateInterestPayment({ rate, periods, payment, presentValue: pv, futureValue: fv, type, targetPeriod: period });
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/financial/ppmt.ts
function calculateInterest({
  helpers,
  rate,
  periods,
  payment,
  pv,
  fv,
  type,
  period
}) {
  if (rate === 0) {
    return 0;
  }
  return helpers.calculateInterestPayment({
    rate,
    periods,
    payment,
    presentValue: pv,
    futureValue: fv,
    type,
    targetPeriod: period
  });
}
var ppmtFunction = {
  name: "PPMT",
  category: "financial",
  description: {
    en: "Returns the principal component of a payment for a given period.",
    ja: "\u6307\u5B9A\u671F\u306B\u652F\u6255\u3046\u5143\u672C\u90E8\u5206\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["PPMT(0.05/12, 1, 60, 10000)", "PPMT(rate, per, nper, pv, fv, type)"],
  samples: [
    {
      input: "PPMT(0.05/12, 1, 60, 10000)",
      output: -147.0456697734421,
      description: {
        en: "Principal portion of first payment on $10,000 loan",
        ja: "10,000\u30C9\u30EB\u306E\u30ED\u30FC\u30F3\u306E\u521D\u56DE\u652F\u6255\u3044\u306E\u5143\u672C\u90E8\u5206"
      }
    },
    {
      input: "PPMT(0.08/12, 12, 120, 50000)",
      output: -294.0285979892048,
      description: {
        en: "Principal portion of 12th payment",
        ja: "12\u56DE\u76EE\u306E\u652F\u6255\u3044\u306E\u5143\u672C\u90E8\u5206"
      }
    },
    {
      input: "PPMT(0.06/12, 36, 36, 20000)",
      output: -605.4116905782319,
      description: {
        en: "Principal portion of final payment",
        ja: "\u6700\u7D42\u652F\u6255\u3044\u306E\u5143\u672C\u90E8\u5206"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 4 || args.length > 6) {
      throw new Error("PPMT expects rate, period, nper, pv, and optional fv and type");
    }
    const [rateArg, periodArg, nperArg, pvArg, fvArg, typeArg] = args;
    const rate = helpers.requireNumber(rateArg, "PPMT rate");
    const periodRaw = helpers.requireNumber(periodArg, "PPMT period");
    const periodsRaw = helpers.requireNumber(nperArg, "PPMT nper");
    const pv = helpers.requireNumber(pvArg, "PPMT pv");
    const fv = fvArg ? helpers.requireNumber(fvArg, "PPMT fv") : 0;
    const typeNumber = typeArg ? helpers.requireNumber(typeArg, "PPMT type") : 0;
    const period = helpers.requireInteger(periodRaw, "PPMT period must be integer");
    const periods = helpers.requireInteger(periodsRaw, "PPMT nper must be integer");
    const type = helpers.requireInteger(typeNumber, "PPMT type must be integer");
    if (periods <= 0) {
      throw new Error("PPMT nper must be greater than zero");
    }
    if (period < 1 || period > periods) {
      throw new Error("PPMT period must be between 1 and nper");
    }
    if (type !== 0 && type !== 1) {
      throw new Error("PPMT type must be 0 or 1");
    }
    const payment = helpers.calculatePayment({ rate, periods, presentValue: pv, futureValue: fv, type });
    const interest = calculateInterest({ helpers, rate, periods, payment, pv, fv, type, period });
    return payment - interest;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/financial/pv.ts
var pvFunction = {
  name: "PV",
  category: "financial",
  description: {
    en: "Returns the present value of an investment given rate, periods, and payment details.",
    ja: "\u5229\u7387\u30FB\u671F\u9593\u30FB\u652F\u6255\u6761\u4EF6\u304B\u3089\u6295\u8CC7\u306E\u73FE\u5728\u4FA1\u5024\u3092\u8A08\u7B97\u3057\u307E\u3059\u3002"
  },
  examples: ["PV(0.05/12, 60, -200)", "PV(rate, nper, pmt, fv, type)"],
  samples: [
    {
      input: "PV(0.05/12, 60, -200)",
      output: 10598.141264785496,
      description: {
        en: "Present value of $200 monthly payments at 5% for 5 years",
        ja: "\u5E74\u52295%\u30675\u5E74\u9593\u3001\u6708\u984D200\u30C9\u30EB\u306E\u73FE\u5728\u4FA1\u5024"
      }
    },
    {
      input: "PV(0.08/12, 120, -500, 10000)",
      output: 31210.74044669055,
      description: {
        en: "Present value with future value target",
        ja: "\u5C06\u6765\u4FA1\u5024\u76EE\u6A19\u3092\u542B\u3080\u73FE\u5728\u4FA1\u5024"
      }
    },
    {
      input: "PV(0.06/12, 36, -300, 0, 1)",
      output: 9910.611396138389,
      description: {
        en: "Present value with payments at beginning of period",
        ja: "\u671F\u521D\u6255\u3044\u306E\u73FE\u5728\u4FA1\u5024"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 3 || args.length > 5) {
      throw new Error("PV expects rate, nper, payment, and optional future value and type");
    }
    const [rateArg, nperArg, paymentArg, futureValueArg, typeArg] = args;
    const rate = helpers.requireNumber(rateArg, "PV rate");
    const periodsNumber = helpers.requireNumber(nperArg, "PV nper");
    const payment = helpers.requireNumber(paymentArg, "PV payment");
    const futureValue = futureValueArg ? helpers.requireNumber(futureValueArg, "PV future_value") : 0;
    const typeNumber = typeArg ? helpers.requireNumber(typeArg, "PV type") : 0;
    const periods = helpers.requireInteger(periodsNumber, "PV nper must be integer");
    const type = helpers.requireInteger(typeNumber, "PV type must be integer");
    if (periods <= 0) {
      throw new Error("PV nper must be greater than zero");
    }
    if (type !== 0 && type !== 1) {
      throw new Error("PV type must be 0 or 1");
    }
    if (rate === 0) {
      return -(payment * periods + futureValue);
    }
    helpers.validateInterestRate(rate, "PV rate");
    const rateFactor = helpers.pow1p(rate, periods);
    return -(payment * (1 + rate * type) * (rateFactor - 1) / rate + futureValue * rateFactor) / rateFactor;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/financial/fv.ts
var fvFunction = {
  name: "FV",
  category: "financial",
  description: {
    en: "Returns the future value of an investment given rate, periods, and payments.",
    ja: "\u5229\u7387\u30FB\u671F\u9593\u30FB\u652F\u6255\u984D\u3092\u57FA\u306B\u5C06\u6765\u4FA1\u5024\u3092\u8A08\u7B97\u3057\u307E\u3059\u3002"
  },
  examples: ["FV(0.05/12, 60, -200)", "FV(rate, nper, pmt, pv, type)"],
  samples: [
    {
      input: "FV(0.05/12, 60, -200)",
      output: 13601.216568168675,
      description: {
        en: "Future value of $200 monthly payments at 5% annual rate for 5 years",
        ja: "\u5E74\u52295%\u30675\u5E74\u9593\u3001\u6708\u984D200\u30C9\u30EB\u652F\u6255\u3063\u305F\u5834\u5408\u306E\u5C06\u6765\u4FA1\u5024"
      }
    },
    {
      input: "FV(0.06/12, 120, -100, -1000)",
      output: 18207.331414677887,
      description: {
        en: "Future value with initial investment and monthly payments",
        ja: "\u521D\u671F\u6295\u8CC7\u3068\u6708\u6B21\u652F\u6255\u3044\u306E\u5C06\u6765\u4FA1\u5024"
      }
    },
    {
      input: "FV(0.08/12, 36, -300, 0, 1)",
      output: 12241.738438415496,
      description: {
        en: "Future value with payments at beginning of period",
        ja: "\u671F\u521D\u6255\u3044\u306E\u5C06\u6765\u4FA1\u5024"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 3 || args.length > 5) {
      throw new Error("FV expects rate, nper, payment, and optional pv and type");
    }
    const [rateArg, nperArg, paymentArg, pvArg, typeArg] = args;
    const rate = helpers.requireNumber(rateArg, "FV rate");
    const periodsRaw = helpers.requireNumber(nperArg, "FV nper");
    const payment = helpers.requireNumber(paymentArg, "FV payment");
    const pv = pvArg ? helpers.requireNumber(pvArg, "FV pv") : 0;
    const typeValue = typeArg ? helpers.requireNumber(typeArg, "FV type") : 0;
    const periods = helpers.requireInteger(periodsRaw, "FV nper must be integer");
    const type = helpers.requireInteger(typeValue, "FV type must be integer");
    if (periods <= 0) {
      throw new Error("FV nper must be greater than zero");
    }
    if (type !== 0 && type !== 1) {
      throw new Error("FV type must be 0 or 1");
    }
    if (rate === 0) {
      return -(pv + payment * periods);
    }
    helpers.validateInterestRate(rate, "FV rate");
    const factor = helpers.pow1p(rate, periods);
    return -(pv * factor + payment * (1 + rate * type) * (factor - 1) / rate);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/financial/npv.ts
var npvFunction = {
  name: "NPV",
  category: "financial",
  description: {
    en: "Returns the net present value of cash flows given a discount rate.",
    ja: "\u6307\u5B9A\u3057\u305F\u5272\u5F15\u7387\u3067\u30AD\u30E3\u30C3\u30B7\u30E5\u30D5\u30ED\u30FC\u306E\u6B63\u5473\u73FE\u5728\u4FA1\u5024\u3092\u8A08\u7B97\u3057\u307E\u3059\u3002"
  },
  examples: ["NPV(0.1, -10000, 3000, 4200, 6800)", "NPV(rate, values)"],
  samples: [
    {
      input: "NPV(0.1, 3000, 4200, 6800)",
      output: 11307.29,
      description: {
        en: "NPV of three positive cash flows at 10% discount rate",
        ja: "\u5272\u5F15\u738710%\u3067\u306E3\u3064\u306E\u6B63\u306E\u30AD\u30E3\u30C3\u30B7\u30E5\u30D5\u30ED\u30FC\u306ENPV"
      }
    },
    {
      input: "NPV(0.08, -10000, 3000, 4000, 5000)",
      output: 163.24,
      description: {
        en: "NPV including initial investment",
        ja: "\u521D\u671F\u6295\u8CC7\u3092\u542B\u3080NPV"
      }
    },
    {
      input: "NPV(0.15, 1000, 2000, 3000, 4000)",
      output: 6641.41,
      description: {
        en: "NPV at higher discount rate",
        ja: "\u9AD8\u3044\u5272\u5F15\u7387\u3067\u306ENPV"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 2) {
      throw new Error("NPV expects at least a rate and one cash flow");
    }
    const [rateArg, ...cashflowArgs] = args;
    const rate = helpers.requireNumber(rateArg, "NPV rate");
    const flattened = cashflowArgs.flatMap((arg, index) => {
      return helpers.flattenResult(arg).map((value) => {
        if (typeof value !== "number") {
          throw new Error(`NPV cash flow ${index + 1} must be numeric`);
        }
        return value;
      });
    });
    if (flattened.length === 0) {
      throw new Error("NPV requires at least one numeric cash flow");
    }
    return helpers.computeNPV(rate, flattened);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/financial/irr.ts
var hasOpposingSigns = (values) => {
  const state = { hasPositive: false, hasNegative: false };
  for (const value of values) {
    if (value > 0) {
      state.hasPositive = true;
    } else if (value < 0) {
      state.hasNegative = true;
    }
    if (state.hasPositive && state.hasNegative) {
      return true;
    }
  }
  return false;
};
var evaluateDiscountedSeries = (helpers, rate, values) => {
  return helpers.discountSeries(rate, values);
};
var irrFunction = {
  name: "IRR",
  category: "financial",
  description: {
    en: "Returns the internal rate of return for a series of cash flows.",
    ja: "\u30AD\u30E3\u30C3\u30B7\u30E5\u30D5\u30ED\u30FC\u5217\u306E\u5185\u90E8\u53CE\u76CA\u7387\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["IRR({-10000,3000,4200,6800})", "IRR(values, guess)"],
  samples: [
    {
      input: "IRR({-10000, 3000, 4200, 6800})",
      output: 0.1634056006889892,
      description: {
        en: "IRR for investment with initial outlay and three returns",
        ja: "\u521D\u671F\u652F\u51FA\u30683\u56DE\u306E\u30EA\u30BF\u30FC\u30F3\u304C\u3042\u308B\u6295\u8CC7\u306EIRR"
      }
    },
    {
      input: "IRR({-50000, 10000, 15000, 20000, 25000})",
      output: 0.12825726900167392,
      description: {
        en: "IRR for multi-period investment",
        ja: "\u8907\u6570\u671F\u9593\u306E\u6295\u8CC7\u306EIRR"
      }
    },
    {
      input: "IRR({-100, 50, 60, 70}, 0.1)",
      output: 0.3387497097016258,
      description: {
        en: "IRR with initial guess",
        ja: "\u521D\u671F\u63A8\u5B9A\u5024\u3092\u6307\u5B9A\u3057\u305FIRR"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 1 || args.length > 2) {
      throw new Error("IRR expects values and an optional guess");
    }
    const valuesArg = args[0];
    const values = helpers.flattenResult(valuesArg).map((value, index) => {
      if (typeof value !== "number") {
        throw new Error(`IRR cash flow ${index + 1} must be numeric`);
      }
      return value;
    });
    if (values.length < 2) {
      throw new Error("IRR requires at least two cash flows");
    }
    if (!hasOpposingSigns(values)) {
      throw new Error("IRR requires cash flows with opposing signs");
    }
    const guess = args.length === 2 ? helpers.requireNumber(args[1], "IRR guess") : 0.1;
    const clampRate = (value) => value <= -0.9999999999 ? -0.9999999999 : value;
    const rateState = { rate: guess <= -0.999999 ? -0.999999 : guess };
    const delta = 0.000001;
    for (let iteration = 0;iteration < FINANCE_MAX_ITERATIONS; iteration += 1) {
      const npv = evaluateDiscountedSeries(helpers, rateState.rate, values);
      if (Math.abs(npv) <= FINANCE_EPSILON) {
        return rateState.rate;
      }
      const forward = evaluateDiscountedSeries(helpers, rateState.rate + delta, values);
      const backward = evaluateDiscountedSeries(helpers, rateState.rate - delta, values);
      const derivative = (forward - backward) / (2 * delta);
      if (!Number.isFinite(derivative) || Math.abs(derivative) <= FINANCE_EPSILON) {
        break;
      }
      const nextRate = clampRate(rateState.rate - npv / derivative);
      if (Math.abs(nextRate - rateState.rate) <= FINANCE_EPSILON) {
        return nextRate;
      }
      rateState.rate = nextRate;
    }
    throw new Error("IRR did not converge");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/financial/xnpv.ts
var xnpvFunction = {
  name: "XNPV",
  category: "financial",
  description: {
    en: "Returns the net present value for irregular cash flows.",
    ja: "\u4E0D\u898F\u5247\u306A\u30AD\u30E3\u30C3\u30B7\u30E5\u30D5\u30ED\u30FC\u306E\u6B63\u5473\u73FE\u5728\u4FA1\u5024\u3092\u7B97\u51FA\u3057\u307E\u3059\u3002"
  },
  examples: ["XNPV(0.1, values, dates)"],
  samples: [
    {
      input: 'XNPV(0.09, {-10000, 2750, 4250, 3250, 2750}, {"2008-01-01", "2008-03-01", "2008-10-30", "2009-02-15", "2009-04-01"})',
      output: 2086.647602031535,
      description: {
        en: "NPV for irregular cash flow dates",
        ja: "\u4E0D\u898F\u5247\u306A\u65E5\u4ED8\u306E\u30AD\u30E3\u30C3\u30B7\u30E5\u30D5\u30ED\u30FC\u306ENPV"
      }
    },
    {
      input: "XNPV(0.08, {-50000, 20000, 25000}, {45000, 45180, 45365})",
      output: -7596.695574984427,
      description: {
        en: "NPV for investment with irregular returns",
        ja: "\u4E0D\u898F\u5247\u306A\u30EA\u30BF\u30FC\u30F3\u3092\u6301\u3064\u6295\u8CC7\u306ENPV"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 3) {
      throw new Error("XNPV expects rate, values, and dates");
    }
    const [rateArg, valuesArg, datesArg] = args;
    const rate = helpers.requireNumber(rateArg, "XNPV rate");
    const values = helpers.flattenResult(valuesArg).map((value, index) => {
      if (typeof value !== "number") {
        throw new Error(`XNPV cash flow ${index + 1} must be numeric`);
      }
      return value;
    });
    const dateSerials = helpers.flattenResult(datesArg).map((value, index) => {
      return coerceDateSerial(value, helpers, `XNPV date ${index + 1}`);
    });
    if (values.length !== dateSerials.length) {
      throw new Error("XNPV values and dates must have the same length");
    }
    if (values.length === 0) {
      throw new Error("XNPV requires at least one cash flow");
    }
    const baseDate = serialToDate(dateSerials[0]);
    const baseMs = baseDate.getTime();
    const dayDifferences = dateSerials.map((serial) => {
      return (serialToDate(serial).getTime() - baseMs) / 86400000;
    });
    return helpers.computeXNPV(rate, values, dayDifferences);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/financial/xirr.ts
var hasOpposingSigns2 = (values) => {
  const state = { hasPositive: false, hasNegative: false };
  for (const value of values) {
    if (value > 0) {
      state.hasPositive = true;
    } else if (value < 0) {
      state.hasNegative = true;
    }
    if (state.hasPositive && state.hasNegative) {
      return true;
    }
  }
  return false;
};
var xirrFunction = {
  name: "XIRR",
  category: "financial",
  description: {
    en: "Returns the internal rate of return for irregular cash flows.",
    ja: "\u4E0D\u898F\u5247\u306A\u30AD\u30E3\u30C3\u30B7\u30E5\u30D5\u30ED\u30FC\u5217\u306E\u5185\u90E8\u53CE\u76CA\u7387\u3092\u8A08\u7B97\u3057\u307E\u3059\u3002"
  },
  examples: ["XIRR(values, dates)", "XIRR(values, dates, guess)"],
  samples: [
    {
      input: 'XIRR({-10000, 2750, 4250, 3250, 2750}, {"2008-01-01", "2008-03-01", "2008-10-30", "2009-02-15", "2009-04-01"})',
      output: 0.3733625335188315,
      description: {
        en: "IRR for irregular cash flow dates",
        ja: "\u4E0D\u898F\u5247\u306A\u65E5\u4ED8\u306E\u30AD\u30E3\u30C3\u30B7\u30E5\u30D5\u30ED\u30FC\u306EIRR"
      }
    },
    {
      input: "XIRR({-1000, 500, 600}, {45000, 45100, 45200}, 0.1)",
      output: 0.2538601048765094,
      description: {
        en: "IRR with initial guess",
        ja: "\u521D\u671F\u63A8\u5B9A\u5024\u3092\u6307\u5B9A\u3057\u305FIRR"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 2 || args.length > 3) {
      throw new Error("XIRR expects values, dates, and optional guess");
    }
    const [valuesArg, datesArg, guessArg] = args;
    const values = helpers.flattenResult(valuesArg).map((value, index) => {
      if (typeof value !== "number") {
        throw new Error(`XIRR cash flow ${index + 1} must be numeric`);
      }
      return value;
    });
    if (values.length < 2) {
      throw new Error("XIRR requires at least two cash flows");
    }
    if (!hasOpposingSigns2(values)) {
      throw new Error("XIRR requires cash flows with opposing signs");
    }
    const dateSerials = helpers.flattenResult(datesArg).map((value, index) => {
      return coerceDateSerial(value, helpers, `XIRR date ${index + 1}`);
    });
    if (dateSerials.length !== values.length) {
      throw new Error("XIRR values and dates must have the same length");
    }
    const baseDate = serialToDate(dateSerials[0]);
    const baseMs = baseDate.getTime();
    const dayDifferences = dateSerials.map((serial) => {
      return (serialToDate(serial).getTime() - baseMs) / 86400000;
    });
    const guess = guessArg ? helpers.requireNumber(guessArg, "XIRR guess") : 0.1;
    const clampRate = (value) => value <= -0.9999999999 ? -0.9999999999 : value;
    const rateState = { rate: guess <= -0.999999 ? -0.999999 : guess };
    const delta = 0.000001;
    for (let iteration = 0;iteration < FINANCE_MAX_ITERATIONS; iteration += 1) {
      const value = helpers.computeXNPV(rateState.rate, values, dayDifferences);
      if (Math.abs(value) <= FINANCE_EPSILON) {
        return rateState.rate;
      }
      const forward = helpers.computeXNPV(rateState.rate + delta, values, dayDifferences);
      const backward = helpers.computeXNPV(rateState.rate - delta, values, dayDifferences);
      const derivative = (forward - backward) / (2 * delta);
      if (!Number.isFinite(derivative) || Math.abs(derivative) <= FINANCE_EPSILON) {
        break;
      }
      const nextRate = clampRate(rateState.rate - value / derivative);
      if (Math.abs(nextRate - rateState.rate) <= FINANCE_EPSILON) {
        return nextRate;
      }
      rateState.rate = nextRate;
    }
    throw new Error("XIRR did not converge");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/financial/rate.ts
var evaluateBalance = (params) => {
  const { rate, periods, payment, pv, fv, type } = params;
  if (rate === 0) {
    return pv + payment * periods + fv;
  }
  const factor = (1 + rate) ** periods;
  return pv * factor + payment * (1 + rate * type) * (factor - 1) / rate + fv;
};
var rateFunction = {
  name: "RATE",
  category: "financial",
  description: {
    en: "Returns the interest rate per period for an annuity.",
    ja: "\u5E74\u91D1\u306E\u5404\u671F\u5229\u7387\u3092\u7B97\u51FA\u3057\u307E\u3059\u3002"
  },
  examples: ["RATE(60, -188.71, 10000)", "RATE(nper, pmt, pv, fv, type, guess)"],
  samples: [
    {
      input: "RATE(60, PMT(0.05/12, 60, 10000), 10000)",
      output: 0.004166666666666963,
      description: {
        en: "Monthly interest rate for a loan (approximately 5% annual)",
        ja: "\u30ED\u30FC\u30F3\u306E\u6708\u5229\uFF08\u5E74\u5229\u7D045%\uFF09"
      }
    },
    {
      input: "RATE(120, PMT(0.08/12, 120, 50000), 50000)",
      output: 0.006666666666666771,
      description: {
        en: "Monthly rate for 10-year loan",
        ja: "10\u5E74\u30ED\u30FC\u30F3\u306E\u6708\u5229"
      }
    },
    {
      input: "RATE(36, PMT(0.06/12, 36, 10000), 10000, 0, 0, 0.01)",
      output: 0.005000000000000832,
      description: {
        en: "Rate with initial guess",
        ja: "\u521D\u671F\u63A8\u5B9A\u5024\u3092\u6307\u5B9A\u3057\u305F\u5229\u7387\u8A08\u7B97"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 3 || args.length > 6) {
      throw new Error("RATE expects nper, payment, pv, and optional fv, type, guess");
    }
    const [nperArg, paymentArg, pvArg, fvArg, typeArg, guessArg] = args;
    const periodsRaw = helpers.requireNumber(nperArg, "RATE nper");
    const payment = helpers.requireNumber(paymentArg, "RATE payment");
    const pv = helpers.requireNumber(pvArg, "RATE pv");
    const fv = fvArg ? helpers.requireNumber(fvArg, "RATE fv") : 0;
    const typeNumber = typeArg ? helpers.requireNumber(typeArg, "RATE type") : 0;
    const guess = guessArg ? helpers.requireNumber(guessArg, "RATE guess") : 0.1;
    const periods = helpers.requireInteger(periodsRaw, "RATE nper must be integer");
    const type = helpers.requireInteger(typeNumber, "RATE type must be integer");
    if (periods <= 0) {
      throw new Error("RATE nper must be greater than zero");
    }
    if (type !== 0 && type !== 1) {
      throw new Error("RATE type must be 0 or 1");
    }
    const clampRate = (value) => value <= -0.9999999999 ? -0.9999999999 : value;
    const rateState = { rate: guess <= -0.999999 ? -0.999999 : guess };
    const delta = 0.000001;
    for (let iteration = 0;iteration < FINANCE_MAX_ITERATIONS; iteration += 1) {
      const value = evaluateBalance({ rate: rateState.rate, periods, payment, pv, fv, type });
      if (Math.abs(value) <= FINANCE_EPSILON) {
        return rateState.rate;
      }
      const forward = evaluateBalance({ rate: rateState.rate + delta, periods, payment, pv, fv, type });
      const backward = evaluateBalance({ rate: rateState.rate - delta, periods, payment, pv, fv, type });
      const derivative = (forward - backward) / (2 * delta);
      if (!Number.isFinite(derivative) || Math.abs(derivative) <= FINANCE_EPSILON) {
        break;
      }
      const nextRate = clampRate(rateState.rate - value / derivative);
      if (Math.abs(nextRate - rateState.rate) <= FINANCE_EPSILON) {
        return nextRate;
      }
      rateState.rate = nextRate;
    }
    throw new Error("RATE did not converge");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/info/utils.ts
var extractSingleValue = (value, helpers, description) => {
  if (!Array.isArray(value)) {
    return value;
  }
  const flattened = helpers.flattenResult(value);
  if (flattened.length !== 1) {
    throw new Error(`${description} expects a single value`);
  }
  return flattened[0] ?? null;
};

// packages/@oxen-office/xlsx/src/formula/functions/info/isblank.ts
var isBlankFunction = {
  name: "ISBLANK",
  category: "info",
  description: {
    en: "Returns TRUE if the value is empty (null).",
    ja: "\u5024\u304C\u7A7A(null)\u306E\u5834\u5408\u306BTRUE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ISBLANK(A1)", 'ISBLANK("")'],
  samples: [
    {
      input: 'ISBLANK("")',
      output: false,
      description: {
        en: "Empty string is not blank (null)",
        ja: "\u7A7A\u6587\u5B57\u5217\u306Fblank\uFF08null\uFF09\u3067\u306F\u306A\u3044"
      }
    },
    {
      input: "ISBLANK(0)",
      output: false,
      description: {
        en: "Zero is not blank",
        ja: "\u30BC\u30ED\u306Fblank\u3067\u306F\u306A\u3044"
      }
    }
  ],
  evaluateLazy: (nodes, context) => {
    if (nodes.length !== 1) {
      throw new Error("ISBLANK expects exactly one argument");
    }
    try {
      const value = context.evaluate(nodes[0]);
      const scalar = extractSingleValue(value, context.helpers, "ISBLANK argument");
      return scalar === null;
    } catch (error2) {
      if (!(error2 instanceof Error)) {
        throw error2;
      }
      return false;
    }
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/info/isnumber.ts
var isNumberFunction = {
  name: "ISNUMBER",
  category: "info",
  description: {
    en: "Returns TRUE if the value is a finite number.",
    ja: "\u5024\u304C\u6709\u9650\u306E\u6570\u5024\u3067\u3042\u308C\u3070TRUE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ISNUMBER(A1)", "ISNUMBER(42)"],
  samples: [
    {
      input: "ISNUMBER(42)",
      output: true,
      description: {
        en: "Check if value is a number",
        ja: "\u5024\u304C\u6570\u5024\u304B\u3069\u3046\u304B\u3092\u30C1\u30A7\u30C3\u30AF"
      }
    },
    {
      input: 'ISNUMBER("text")',
      output: false,
      description: {
        en: "Text is not a number",
        ja: "\u30C6\u30AD\u30B9\u30C8\u306F\u6570\u5024\u3067\u306F\u306A\u3044"
      }
    },
    {
      input: "ISNUMBER(3.14)",
      output: true,
      description: {
        en: "Decimal numbers are valid",
        ja: "\u5C0F\u6570\u3082\u6709\u52B9\u306A\u6570\u5024"
      }
    }
  ],
  evaluateLazy: (nodes, context) => {
    if (nodes.length !== 1) {
      throw new Error("ISNUMBER expects exactly one argument");
    }
    try {
      const value = context.evaluate(nodes[0]);
      const scalar = extractSingleValue(value, context.helpers, "ISNUMBER argument");
      return typeof scalar === "number" && Number.isFinite(scalar);
    } catch (error2) {
      if (!(error2 instanceof Error)) {
        throw error2;
      }
      return false;
    }
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/info/isttext.ts
var isTextFunction = {
  name: "ISTEXT",
  category: "info",
  description: {
    en: "Returns TRUE if the value is text.",
    ja: "\u5024\u304C\u6587\u5B57\u5217\u306E\u5834\u5408\u306BTRUE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ISTEXT(A1)", 'ISTEXT("hello")'],
  samples: [
    {
      input: 'ISTEXT("hello")',
      output: true,
      description: {
        en: "Check if value is text",
        ja: "\u5024\u304C\u30C6\u30AD\u30B9\u30C8\u304B\u3069\u3046\u304B\u3092\u30C1\u30A7\u30C3\u30AF"
      }
    },
    {
      input: "ISTEXT(123)",
      output: false,
      description: {
        en: "Numbers are not text",
        ja: "\u6570\u5024\u306F\u30C6\u30AD\u30B9\u30C8\u3067\u306F\u306A\u3044"
      }
    },
    {
      input: 'ISTEXT("")',
      output: true,
      description: {
        en: "Empty string is text",
        ja: "\u7A7A\u6587\u5B57\u5217\u3082\u30C6\u30AD\u30B9\u30C8"
      }
    }
  ],
  evaluateLazy: (nodes, context) => {
    if (nodes.length !== 1) {
      throw new Error("ISTEXT expects exactly one argument");
    }
    try {
      const value = context.evaluate(nodes[0]);
      const scalar = extractSingleValue(value, context.helpers, "ISTEXT argument");
      return typeof scalar === "string";
    } catch (error2) {
      if (!(error2 instanceof Error)) {
        throw error2;
      }
      return false;
    }
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/info/islogical.ts
var isLogicalFunction = {
  name: "ISLOGICAL",
  category: "info",
  description: {
    en: "Returns TRUE if the value is a boolean.",
    ja: "\u5024\u304C\u8AD6\u7406\u5024\u3067\u3042\u308C\u3070TRUE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ISLOGICAL(A1)", "ISLOGICAL(TRUE)"],
  samples: [
    {
      input: "ISLOGICAL(TRUE)",
      output: true,
      description: {
        en: "Check if value is boolean",
        ja: "\u5024\u304C\u8AD6\u7406\u5024\u304B\u3069\u3046\u304B\u3092\u30C1\u30A7\u30C3\u30AF"
      }
    },
    {
      input: "ISLOGICAL(FALSE)",
      output: true,
      description: {
        en: "FALSE is also a boolean",
        ja: "FALSE\u3082\u8AD6\u7406\u5024"
      }
    },
    {
      input: "ISLOGICAL(1)",
      output: false,
      description: {
        en: "Numbers are not boolean",
        ja: "\u6570\u5024\u306F\u8AD6\u7406\u5024\u3067\u306F\u306A\u3044"
      }
    }
  ],
  evaluateLazy: (nodes, context) => {
    if (nodes.length !== 1) {
      throw new Error("ISLOGICAL expects exactly one argument");
    }
    try {
      const value = context.evaluate(nodes[0]);
      const scalar = extractSingleValue(value, context.helpers, "ISLOGICAL argument");
      return typeof scalar === "boolean";
    } catch (error2) {
      if (!(error2 instanceof Error)) {
        throw error2;
      }
      return false;
    }
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/info/iserr.ts
var isErrFunction = {
  name: "ISERR",
  category: "info",
  description: {
    en: "Returns TRUE if evaluating the value results in an error other than #N/A.",
    ja: "\u5024\u306E\u8A55\u4FA1\u3067#N/A\u4EE5\u5916\u306E\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u305F\u5834\u5408\u306BTRUE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ISERR(1/0)", "ISERR(NOT(A1))"],
  samples: [
    {
      input: "ISERR(1/0)",
      output: true,
      description: {
        en: "Division by zero is an error (not #N/A)",
        ja: "\u30BC\u30ED\u9664\u7B97\u306F\u30A8\u30E9\u30FC\uFF08#N/A\u3067\u306F\u306A\u3044\uFF09"
      }
    },
    {
      input: "ISERR(100)",
      output: false,
      description: {
        en: "Valid values are not errors",
        ja: "\u6709\u52B9\u306A\u5024\u306F\u30A8\u30E9\u30FC\u3067\u306F\u306A\u3044"
      }
    }
  ],
  evaluateLazy: (nodes, context) => {
    if (nodes.length !== 1) {
      throw new Error("ISERR expects exactly one argument");
    }
    try {
      context.evaluate(nodes[0]);
      return false;
    } catch (error2) {
      const code = context.helpers.getErrorCode(error2);
      return code !== "#N/A";
    }
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/info/isna.ts
var isNaFunction = {
  name: "ISNA",
  category: "info",
  description: {
    en: "Returns TRUE if evaluating the value results in a #N/A error.",
    ja: "\u5024\u306E\u8A55\u4FA1\u3067#N/A\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u305F\u5834\u5408\u306BTRUE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['ISNA(VLOOKUP("x", A1:B2, 2, FALSE))', "ISNA(NA())"],
  samples: [
    {
      input: "ISNA(1/0)",
      output: false,
      description: {
        en: "Division by zero is not #N/A",
        ja: "\u30BC\u30ED\u9664\u7B97\u306F#N/A\u3067\u306F\u306A\u3044"
      }
    }
  ],
  evaluateLazy: (nodes, context) => {
    if (nodes.length !== 1) {
      throw new Error("ISNA expects exactly one argument");
    }
    try {
      context.evaluate(nodes[0]);
      return false;
    } catch (error2) {
      const code = context.helpers.getErrorCode(error2);
      return code === "#N/A";
    }
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/info/iserror.ts
var isErrorFunction = {
  name: "ISERROR",
  category: "info",
  description: {
    en: "Returns TRUE if evaluating the value results in an error.",
    ja: "\u5024\u306E\u8A55\u4FA1\u3067\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u305F\u5834\u5408\u306BTRUE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ISERROR(1/0)", 'ISERROR(VLOOKUP("=", A1:B2, 2, FALSE))'],
  samples: [
    {
      input: "ISERROR(1/0)",
      output: true,
      description: {
        en: "Division by zero is an error",
        ja: "\u30BC\u30ED\u9664\u7B97\u306F\u30A8\u30E9\u30FC"
      }
    },
    {
      input: "ISERROR(42)",
      output: false,
      description: {
        en: "Valid values are not errors",
        ja: "\u6709\u52B9\u306A\u5024\u306F\u30A8\u30E9\u30FC\u3067\u306F\u306A\u3044"
      }
    }
  ],
  evaluateLazy: (nodes, context) => {
    if (nodes.length !== 1) {
      throw new Error("ISERROR expects exactly one argument");
    }
    try {
      context.evaluate(nodes[0]);
      return false;
    } catch (error2) {
      context.helpers.getErrorCode(error2);
      return true;
    }
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/info/iferror.ts
var ifErrorFunction = {
  name: "IFERROR",
  category: "info",
  description: {
    en: "Returns an alternative value if an error occurs; otherwise returns the original result.",
    ja: "\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u305F\u5834\u5408\u306F\u4EE3\u66FF\u5024\u3092\u8FD4\u3057\u3001\u305D\u3046\u3067\u306A\u3051\u308C\u3070\u5143\u306E\u7D50\u679C\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["IFERROR(1/0, 0)", 'IFERROR(VLOOKUP("x", A1:B2, 2, FALSE), "Not found")'],
  samples: [
    {
      input: "IFERROR(1/0, 0)",
      output: 0,
      description: {
        en: "Return fallback value on error",
        ja: "\u30A8\u30E9\u30FC\u6642\u306B\u4EE3\u66FF\u5024\u3092\u8FD4\u3059"
      }
    },
    {
      input: "IFERROR(10/2, 0)",
      output: 5,
      description: {
        en: "Return original value if no error",
        ja: "\u30A8\u30E9\u30FC\u304C\u306A\u3051\u308C\u3070\u5143\u306E\u5024\u3092\u8FD4\u3059"
      }
    },
    {
      input: 'IFERROR(100, "error")',
      output: 100,
      description: {
        en: "Valid value is returned as-is",
        ja: "\u6709\u52B9\u306A\u5024\u306F\u305D\u306E\u307E\u307E\u8FD4\u3055\u308C\u308B"
      }
    }
  ],
  evaluateLazy: (nodes, context) => {
    if (nodes.length < 1 || nodes.length > 2) {
      throw new Error("IFERROR expects one or two arguments");
    }
    try {
      return context.evaluate(nodes[0]);
    } catch (error2) {
      if (!(error2 instanceof Error)) {
        throw error2;
      }
      if (nodes.length === 1) {
        return null;
      }
      return context.evaluate(nodes[1]);
    }
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/info/ifna.ts
var ifNaFunction = {
  name: "IFNA",
  category: "info",
  description: {
    en: "Returns an alternative value if the original evaluation results in #N/A; otherwise returns the original result.",
    ja: "\u5143\u306E\u8A55\u4FA1\u304C#N/A\u30A8\u30E9\u30FC\u3068\u306A\u3063\u305F\u5834\u5408\u306B\u4EE3\u66FF\u5024\u3092\u8FD4\u3057\u3001\u305D\u3046\u3067\u306A\u3051\u308C\u3070\u5143\u306E\u7D50\u679C\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['IFNA(VLOOKUP("x", A1:B2, 2, FALSE), "Not found")'],
  samples: [
    {
      input: 'IFNA(100, "N/A")',
      output: 100,
      description: {
        en: "Return original value if not #N/A",
        ja: "#N/A\u3067\u306A\u3051\u308C\u3070\u5143\u306E\u5024\u3092\u8FD4\u3059"
      }
    },
    {
      input: 'IFNA("result", "fallback")',
      output: "result",
      description: {
        en: "Valid result is returned",
        ja: "\u6709\u52B9\u306A\u7D50\u679C\u304C\u8FD4\u3055\u308C\u308B"
      }
    }
  ],
  evaluateLazy: (nodes, context) => {
    if (nodes.length < 1 || nodes.length > 2) {
      throw new Error("IFNA expects one or two arguments");
    }
    try {
      return context.evaluate(nodes[0]);
    } catch (error2) {
      if (!context.helpers.isNAError(error2)) {
        throw error2;
      }
      if (nodes.length === 1) {
        return null;
      }
      return context.evaluate(nodes[1]);
    }
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/info/errorType.ts
var errorTypeFunction = {
  name: "ERROR.TYPE",
  category: "info",
  description: {
    en: "Returns a number corresponding to an error value.",
    ja: "\u30A8\u30E9\u30FC\u5024\u306B\u5BFE\u5FDC\u3059\u308B\u756A\u53F7\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ERROR.TYPE(1/0)", 'ERROR.TYPE(IFNA(A1, "Fallback"))'],
  samples: [
    {
      input: "ERROR.TYPE(1/0)",
      output: 2,
      description: {
        en: "Division by zero error type",
        ja: "\u30BC\u30ED\u9664\u7B97\u30A8\u30E9\u30FC\u306E\u30BF\u30A4\u30D7"
      }
    }
  ],
  evaluateLazy: (nodes, context) => {
    if (nodes.length !== 1) {
      throw new Error("ERROR.TYPE expects exactly one argument");
    }
    try {
      context.evaluate(nodes[0]);
    } catch (error2) {
      const code = context.helpers.getErrorCode(error2);
      return context.helpers.getErrorTypeNumber(code);
    }
    throw context.helpers.createFormulaError("#N/A", "ERROR.TYPE expects an error value");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/info/type.ts
var TYPE_NUMBER = 1;
var TYPE_TEXT = 2;
var TYPE_LOGICAL = 4;
var TYPE_ERROR = 16;
var TYPE_ARRAY = 64;
var determineType = (value) => {
  if (Array.isArray(value)) {
    return TYPE_ARRAY;
  }
  if (value === null) {
    return TYPE_NUMBER;
  }
  if (typeof value === "number") {
    return TYPE_NUMBER;
  }
  if (typeof value === "string") {
    return TYPE_TEXT;
  }
  if (typeof value === "boolean") {
    return TYPE_LOGICAL;
  }
  return TYPE_TEXT;
};
var typeFunction = {
  name: "TYPE",
  category: "info",
  description: {
    en: "Returns a number representing the type of a value.",
    ja: "\u5024\u306E\u7A2E\u985E\u3092\u8868\u3059\u756A\u53F7\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["TYPE(42)", 'TYPE("text")', "TYPE(TRUE)", "TYPE(1/0)"],
  samples: [
    {
      input: "TYPE(42)",
      output: 1,
      description: {
        en: "Number type is 1",
        ja: "\u6570\u5024\u578B\u306F1"
      }
    },
    {
      input: 'TYPE("text")',
      output: 2,
      description: {
        en: "Text type is 2",
        ja: "\u30C6\u30AD\u30B9\u30C8\u578B\u306F2"
      }
    },
    {
      input: "TYPE(TRUE)",
      output: 4,
      description: {
        en: "Boolean type is 4",
        ja: "\u8AD6\u7406\u5024\u578B\u306F4"
      }
    }
  ],
  evaluateLazy: (nodes, context) => {
    if (nodes.length !== 1) {
      throw new Error("TYPE expects exactly one argument");
    }
    try {
      const value = context.evaluate(nodes[0]);
      return determineType(value);
    } catch (error2) {
      context.helpers.getErrorCode(error2);
      return TYPE_ERROR;
    }
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/average.ts
var averageFunction = {
  name: "AVERAGE",
  category: "statistical",
  description: {
    en: "Returns the arithmetic mean of numeric arguments, ignoring non-numeric values.",
    ja: "\u6570\u5024\u4EE5\u5916\u3092\u7121\u8996\u3057\u3066\u5F15\u6570\u306E\u7B97\u8853\u5E73\u5747\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["AVERAGE(1, 2, 3)", "AVERAGE(A1:A10)"],
  samples: [
    {
      input: "AVERAGE(1, 2, 3, 4, 5)",
      output: 3,
      description: {
        en: "Average of five numbers",
        ja: "5\u3064\u306E\u6570\u5024\u306E\u5E73\u5747"
      }
    },
    {
      input: "AVERAGE(10, 20, 30)",
      output: 20,
      description: {
        en: "Simple average",
        ja: "\u5358\u7D14\u306A\u5E73\u5747"
      }
    },
    {
      input: "AVERAGE(5, 15, 25, 35)",
      output: 20,
      description: {
        en: "Average of evenly spaced numbers",
        ja: "\u7B49\u9593\u9694\u306E\u6570\u5024\u306E\u5E73\u5747"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const values = helpers.flattenArguments(args).filter((value) => typeof value === "number");
    if (values.length === 0) {
      throw new Error("AVERAGE expects at least one numeric argument");
    }
    const total = values.reduce((sum, value) => sum + value, 0);
    return total / values.length;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/averageif.ts
var averageIfFunction = {
  name: "AVERAGEIF",
  category: "statistical",
  description: {
    en: "Returns the mean of values that satisfy a single condition.",
    ja: "\u5358\u4E00\u6761\u4EF6\u3092\u6E80\u305F\u3059\u5024\u306E\u5E73\u5747\u3092\u8A08\u7B97\u3057\u307E\u3059\u3002"
  },
  examples: ['AVERAGEIF(A1:A10, ">0")', 'AVERAGEIF(A1:A10, "=East", B1:B10)'],
  samples: [
    {
      input: 'AVERAGEIF({5, 10, 15, 20}, ">10")',
      output: 17.5,
      description: {
        en: "Average of values greater than 10",
        ja: "10\u3088\u308A\u5927\u304D\u3044\u5024\u306E\u5E73\u5747"
      }
    },
    {
      input: 'AVERAGEIF({10, 20, 30, 40}, ">=20")',
      output: 30,
      description: {
        en: "Average with condition",
        ja: "\u6761\u4EF6\u4ED8\u304D\u306E\u5E73\u5747"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 2 || args.length > 3) {
      throw new Error("AVERAGEIF expects two or three arguments");
    }
    const [rangeArg, criteriaArg, averageRangeArg] = args;
    const rangeValues = helpers.flattenResult(rangeArg);
    const averageValues = averageRangeArg ? helpers.flattenResult(averageRangeArg) : rangeValues;
    if (averageValues.length !== rangeValues.length) {
      throw new Error("AVERAGEIF requires average_range to match range size");
    }
    const criteria = helpers.coerceScalar(criteriaArg, "AVERAGEIF criteria");
    const predicate = createCriteriaPredicate2(criteria, helpers.comparePrimitiveEquality, "AVERAGEIF criteria");
    const aggregate = rangeValues.reduce((state, rangeValue, index) => {
      if (!predicate(rangeValue)) {
        return state;
      }
      const candidate = averageValues[index];
      if (typeof candidate !== "number") {
        return state;
      }
      return {
        sum: state.sum + candidate,
        count: state.count + 1
      };
    }, {
      sum: 0,
      count: 0
    });
    if (aggregate.count === 0) {
      throw new Error("AVERAGEIF found no numeric values matching criteria");
    }
    return aggregate.sum / aggregate.count;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/averageifs.ts
var averageIfsFunction = {
  name: "AVERAGEIFS",
  category: "statistical",
  description: {
    en: "Returns the mean of values that satisfy multiple criteria across ranges.",
    ja: "\u8907\u6570\u306E\u7BC4\u56F2\u3068\u6761\u4EF6\u3092\u6E80\u305F\u3059\u5024\u306E\u5E73\u5747\u3092\u8A08\u7B97\u3057\u307E\u3059\u3002"
  },
  examples: ['AVERAGEIFS(C1:C10, A1:A10, "East", B1:B10, ">=2024")', "AVERAGEIFS(A1:A5, B1:B5, 1)"],
  samples: [
    {
      input: 'AVERAGEIFS({10, 20, 30}, {1, 2, 3}, ">1", {5, 10, 15}, ">=10")',
      output: 25,
      description: {
        en: "Average with multiple criteria",
        ja: "\u8907\u6570\u6761\u4EF6\u3067\u306E\u5E73\u5747"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 3 || (args.length - 1) % 2 !== 0) {
      throw new Error("AVERAGEIFS expects average_range followed by range/criteria pairs");
    }
    const averageRange = helpers.flattenResult(args[0]);
    const pairCount = (args.length - 1) / 2;
    const criteriaPairs = Array.from({ length: pairCount }, (_, pairIndex) => {
      const rangeArg = args[pairIndex * 2 + 1];
      const criteriaArg = args[pairIndex * 2 + 2];
      const rangeValues = helpers.flattenResult(rangeArg);
      if (rangeValues.length !== averageRange.length) {
        throw new Error(`AVERAGEIFS criteria range ${pairIndex + 1} must match average_range size`);
      }
      const criteria = helpers.coerceScalar(criteriaArg, `AVERAGEIFS criteria ${pairIndex + 1}`);
      const predicate = createCriteriaPredicate2(criteria, helpers.comparePrimitiveEquality, `AVERAGEIFS criteria ${pairIndex + 1}`);
      return {
        rangeValues,
        predicate
      };
    });
    const aggregate = averageRange.reduce((state, candidate, index) => {
      if (!criteriaPairs.every(({ rangeValues, predicate }) => predicate(rangeValues[index]))) {
        return state;
      }
      if (typeof candidate !== "number") {
        return state;
      }
      return {
        sum: state.sum + candidate,
        count: state.count + 1
      };
    }, {
      sum: 0,
      count: 0
    });
    if (aggregate.count === 0) {
      throw new Error("AVERAGEIFS found no numeric values matching criteria");
    }
    return aggregate.sum / aggregate.count;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/max.ts
var maxFunction = {
  name: "MAX",
  category: "statistical",
  description: {
    en: "Returns the largest numeric value from the arguments.",
    ja: "\u5F15\u6570\u306E\u4E2D\u3067\u6700\u5927\u306E\u6570\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["MAX(1, 5, 3)", "MAX(A1:A10)"],
  samples: [
    {
      input: "MAX(1, 5, 3, 9, 2)",
      output: 9,
      description: {
        en: "Maximum of five numbers",
        ja: "5\u3064\u306E\u6570\u5024\u306E\u6700\u5927\u5024"
      }
    },
    {
      input: "MAX(-10, -5, -20)",
      output: -5,
      description: {
        en: "Maximum of negative numbers",
        ja: "\u8CA0\u306E\u6570\u306E\u6700\u5927\u5024"
      }
    },
    {
      input: "MAX(100, 200, 50)",
      output: 200,
      description: {
        en: "Largest value",
        ja: "\u6700\u5927\u306E\u5024"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const values = helpers.flattenArguments(args).filter((value) => typeof value === "number");
    if (values.length === 0) {
      throw new Error("MAX expects at least one numeric argument");
    }
    return Math.max(...values);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/min.ts
var minFunction = {
  name: "MIN",
  category: "statistical",
  description: {
    en: "Returns the smallest numeric value from the arguments.",
    ja: "\u5F15\u6570\u306E\u4E2D\u3067\u6700\u5C0F\u306E\u6570\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["MIN(1, 5, 3)", "MIN(A1:A10)"],
  samples: [
    {
      input: "MIN(1, 5, 3, 9, 2)",
      output: 1,
      description: {
        en: "Minimum of five numbers",
        ja: "5\u3064\u306E\u6570\u5024\u306E\u6700\u5C0F\u5024"
      }
    },
    {
      input: "MIN(-10, -5, -20)",
      output: -20,
      description: {
        en: "Minimum of negative numbers",
        ja: "\u8CA0\u306E\u6570\u306E\u6700\u5C0F\u5024"
      }
    },
    {
      input: "MIN(100, 200, 50)",
      output: 50,
      description: {
        en: "Smallest value",
        ja: "\u6700\u5C0F\u306E\u5024"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const values = helpers.flattenArguments(args).filter((value) => typeof value === "number");
    if (values.length === 0) {
      throw new Error("MIN expects at least one numeric argument");
    }
    return Math.min(...values);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/count.ts
var countFunction = {
  name: "COUNT",
  category: "statistical",
  description: {
    en: "Counts numeric values in the arguments, ignoring non-numeric entries.",
    ja: "\u6570\u5024\u4EE5\u5916\u3092\u7121\u8996\u3057\u3066\u5F15\u6570\u5185\u306E\u6570\u5024\u3092\u6570\u3048\u307E\u3059\u3002"
  },
  examples: ['COUNT(1, 2, "x")', "COUNT(A1:A10)"],
  samples: [
    {
      input: 'COUNT(1, 2, 3, "text", 4)',
      output: 4,
      description: {
        en: "Count only numeric values",
        ja: "\u6570\u5024\u306E\u307F\u3092\u30AB\u30A6\u30F3\u30C8"
      }
    },
    {
      input: "COUNT(10, 20, 30)",
      output: 3,
      description: {
        en: "Count all numbers",
        ja: "\u3059\u3079\u3066\u306E\u6570\u5024\u3092\u30AB\u30A6\u30F3\u30C8"
      }
    },
    {
      input: 'COUNT("a", "b", "c")',
      output: 0,
      description: {
        en: "No numeric values",
        ja: "\u6570\u5024\u304C\u306A\u3044"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const values = helpers.flattenArguments(args);
    return values.reduce((count, value) => typeof value === "number" ? count + 1 : count, 0);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/countif.ts
var countIfFunction = {
  name: "COUNTIF",
  category: "statistical",
  description: {
    en: "Counts the number of values in a range that meet a single condition.",
    ja: "\u7BC4\u56F2\u5185\u3067\u6761\u4EF6\u3092\u6E80\u305F\u3059\u5024\u306E\u4EF6\u6570\u3092\u6570\u3048\u307E\u3059\u3002"
  },
  examples: ['COUNTIF(A1:A10, ">10")', 'COUNTIF(A1:A10, "=Yes")'],
  samples: [
    {
      input: 'COUNTIF({5, 10, 15, 20}, ">10")',
      output: 2,
      description: {
        en: "Count values greater than 10",
        ja: "10\u3088\u308A\u5927\u304D\u3044\u5024\u3092\u30AB\u30A6\u30F3\u30C8"
      }
    },
    {
      input: 'COUNTIF({"Yes", "No", "Yes"}, "Yes")',
      output: 2,
      description: {
        en: "Count matching text values",
        ja: "\u4E00\u81F4\u3059\u308B\u30C6\u30AD\u30B9\u30C8\u5024\u3092\u30AB\u30A6\u30F3\u30C8"
      }
    },
    {
      input: 'COUNTIF({1, 2, 3, 4, 5}, ">=3")',
      output: 3,
      description: {
        en: "Count with greater-than-or-equal condition",
        ja: "\u4EE5\u4E0A\u306E\u6761\u4EF6\u3067\u30AB\u30A6\u30F3\u30C8"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2) {
      throw new Error("COUNTIF expects exactly two arguments");
    }
    const [rangeArg, criteriaArg] = args;
    const values = helpers.flattenResult(rangeArg);
    const criteria = helpers.coerceScalar(criteriaArg, "COUNTIF criteria");
    const predicate = createCriteriaPredicate2(criteria, helpers.comparePrimitiveEquality, "COUNTIF criteria");
    return values.reduce((count, value) => predicate(value) ? count + 1 : count, 0);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/countifs.ts
var countIfsFunction = {
  name: "COUNTIFS",
  category: "statistical",
  description: {
    en: "Counts values that satisfy multiple range/criteria pairs.",
    ja: "\u8907\u6570\u306E\u7BC4\u56F2\u3068\u6761\u4EF6\u3092\u3059\u3079\u3066\u6E80\u305F\u3059\u4EF6\u6570\u3092\u6570\u3048\u307E\u3059\u3002"
  },
  examples: ['COUNTIFS(A1:A10, "East", B1:B10, ">=2024")', "COUNTIFS(A1:A5, B1:B5, 1)"],
  samples: [
    {
      input: 'COUNTIFS({1, 2, 3, 4}, ">1", {10, 20, 30, 40}, ">=20")',
      output: 2,
      description: {
        en: "Count with multiple criteria",
        ja: "\u8907\u6570\u6761\u4EF6\u3067\u306E\u30AB\u30A6\u30F3\u30C8"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 2 || args.length % 2 !== 0) {
      throw new Error("COUNTIFS expects range/criteria pairs");
    }
    const pairCount = args.length / 2;
    const pairs = Array.from({ length: pairCount }, (_, pairIndex) => {
      const rangeArg = args[pairIndex * 2];
      const criteriaArg = args[pairIndex * 2 + 1];
      const rangeValues = helpers.flattenResult(rangeArg);
      const criteria = helpers.coerceScalar(criteriaArg, `COUNTIFS criteria ${pairIndex + 1}`);
      const predicate = createCriteriaPredicate2(criteria, helpers.comparePrimitiveEquality, `COUNTIFS criteria ${pairIndex + 1}`);
      return {
        rangeValues,
        predicate
      };
    });
    const referenceLength = pairs[0]?.rangeValues.length ?? 0;
    if (pairs.some(({ rangeValues }) => rangeValues.length !== referenceLength)) {
      throw new Error("COUNTIFS requires all ranges to be the same size");
    }
    return Array.from({ length: referenceLength }, (_, index) => index).reduce((count, index) => pairs.every(({ rangeValues, predicate }) => predicate(rangeValues[index])) ? count + 1 : count, 0);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/counta.ts
var countAFunction = {
  name: "COUNTA",
  category: "statistical",
  description: {
    en: "Counts non-empty values, including text and booleans.",
    ja: "\u6587\u5B57\u5217\u3084\u771F\u507D\u5024\u3092\u542B\u3080\u7A7A\u3067\u306A\u3044\u5024\u306E\u4EF6\u6570\u3092\u6570\u3048\u307E\u3059\u3002"
  },
  examples: ["COUNTA(A1:A10)", 'COUNTA(1, "text", TRUE, null)'],
  samples: [
    {
      input: 'COUNTA(1, "text", TRUE)',
      output: 3,
      description: {
        en: "Count all non-empty values",
        ja: "\u3059\u3079\u3066\u306E\u7A7A\u3067\u306A\u3044\u5024\u3092\u30AB\u30A6\u30F3\u30C8"
      }
    },
    {
      input: 'COUNTA(1, 2, "", 3)',
      output: 4,
      description: {
        en: "Empty string counts as non-empty",
        ja: "\u7A7A\u6587\u5B57\u5217\u3082\u7A7A\u3067\u306A\u3044\u3068\u3057\u3066\u30AB\u30A6\u30F3\u30C8"
      }
    },
    {
      input: "COUNTA(10, 20, 30)",
      output: 3,
      description: {
        en: "Count numbers",
        ja: "\u6570\u5024\u3092\u30AB\u30A6\u30F3\u30C8"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const values = helpers.flattenArguments(args);
    return values.reduce((count, value) => value === null ? count : count + 1, 0);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/countblank.ts
var countBlankFunction = {
  name: "COUNTBLANK",
  category: "statistical",
  description: {
    en: "Counts empty cells within the provided ranges.",
    ja: "\u6307\u5B9A\u3057\u305F\u7BC4\u56F2\u5185\u306E\u7A7A\u30BB\u30EB\u3092\u6570\u3048\u307E\u3059\u3002"
  },
  examples: ["COUNTBLANK(A1:A10)", "COUNTBLANK(A1:C3)"],
  samples: [
    {
      input: 'COUNTBLANK({null, "", 1, 2})',
      output: 2,
      description: {
        en: "Count null and empty string",
        ja: "null\u3068\u7A7A\u6587\u5B57\u5217\u3092\u30AB\u30A6\u30F3\u30C8"
      }
    },
    {
      input: "COUNTBLANK({1, 2, 3})",
      output: 0,
      description: {
        en: "No blank values",
        ja: "\u7A7A\u306E\u5024\u306A\u3057"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const values = helpers.flattenArguments(args);
    return values.reduce((count, value) => value === null || value === "" ? count + 1 : count, 0);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/median.ts
var medianFunction = {
  name: "MEDIAN",
  category: "statistical",
  description: {
    en: "Returns the median of numeric arguments, ignoring non-numeric values.",
    ja: "\u6570\u5024\u4EE5\u5916\u3092\u7121\u8996\u3057\u3066\u5F15\u6570\u306E\u4E2D\u592E\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["MEDIAN(1, 3, 5)", "MEDIAN(A1:A9)"],
  samples: [
    {
      input: "MEDIAN(1, 3, 5)",
      output: 3,
      description: {
        en: "Median of odd count of numbers",
        ja: "\u5947\u6570\u500B\u306E\u6570\u5024\u306E\u4E2D\u592E\u5024"
      }
    },
    {
      input: "MEDIAN(1, 2, 3, 4)",
      output: 2.5,
      description: {
        en: "Median of even count (average of middle two)",
        ja: "\u5076\u6570\u500B\u306E\u4E2D\u592E\u5024\uFF08\u4E2D\u592E2\u3064\u306E\u5E73\u5747\uFF09"
      }
    },
    {
      input: "MEDIAN(10, 20, 15, 25, 30)",
      output: 20,
      description: {
        en: "Median of unsorted values",
        ja: "\u672A\u30BD\u30FC\u30C8\u5024\u306E\u4E2D\u592E\u5024"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const numericValues = helpers.flattenArguments(args).filter((value) => typeof value === "number");
    if (numericValues.length === 0) {
      throw new Error("MEDIAN expects at least one numeric argument");
    }
    const sorted = [...numericValues].sort((left, right) => left - right);
    const midIndex = Math.floor(sorted.length / 2);
    if (sorted.length % 2 !== 0) {
      return sorted[midIndex];
    }
    return (sorted[midIndex - 1] + sorted[midIndex]) / 2;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/mode.ts
var modeFunction = {
  name: "MODE",
  category: "statistical",
  description: {
    en: "Returns the most frequently occurring numeric value, preferring the smallest on ties.",
    ja: "\u6700\u3082\u983B\u51FA\u3059\u308B\u6570\u5024\u3092\u8FD4\u3057\u3001\u540C\u6570\u306E\u5834\u5408\u306F\u6700\u5C0F\u5024\u3092\u9078\u629E\u3057\u307E\u3059\u3002"
  },
  examples: ["MODE(1, 2, 2, 3)", "MODE(A1:A10)"],
  samples: [
    {
      input: "MODE(1, 2, 2, 3, 3, 3)",
      output: 3,
      description: {
        en: "Most frequent value",
        ja: "\u6700\u3082\u983B\u7E41\u306B\u51FA\u73FE\u3059\u308B\u5024"
      }
    },
    {
      input: "MODE(5, 5, 10, 10, 15)",
      output: 5,
      description: {
        en: "Smallest value when tied",
        ja: "\u540C\u6570\u306E\u5834\u5408\u306F\u6700\u5C0F\u5024"
      }
    },
    {
      input: "MODE(7, 7, 7, 8, 9)",
      output: 7,
      description: {
        en: "Clear mode",
        ja: "\u660E\u78BA\u306A\u6700\u983B\u5024"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const numericValues = helpers.flattenArguments(args).filter((value) => typeof value === "number");
    if (numericValues.length === 0) {
      throw new Error("MODE expects at least one numeric argument");
    }
    const frequency = numericValues.reduce((map, value) => {
      const current = map.get(value) ?? 0;
      map.set(value, current + 1);
      return map;
    }, new Map);
    const entries = Array.from(frequency.entries());
    const primaryEntry = entries[0] ?? null;
    if (!primaryEntry) {
      throw new Error("MODE could not determine a frequency distribution");
    }
    const [modeCandidate, occurrence] = entries.reduce((best, [value, count]) => {
      if (count > best[1]) {
        return [value, count];
      }
      if (count === best[1] && value < best[0]) {
        return [value, count];
      }
      return best;
    }, primaryEntry);
    if (occurrence < 2) {
      throw new Error("MODE requires at least one repeating numeric value");
    }
    return modeCandidate;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/var.ts
var varianceFunction = {
  name: "VAR",
  category: "statistical",
  description: {
    en: "Calculates the sample variance of numeric arguments.",
    ja: "\u6570\u5024\u5F15\u6570\u306E\u6A19\u672C\u5206\u6563\u3092\u8A08\u7B97\u3057\u307E\u3059\u3002"
  },
  examples: ["VAR(1, 3, 5)", "VAR(A1:A10)"],
  samples: [
    {
      input: "VAR(2, 4, 6, 8)",
      output: 6.67,
      description: {
        en: "Sample variance",
        ja: "\u6A19\u672C\u5206\u6563"
      }
    },
    {
      input: "VAR(10, 20, 30)",
      output: 100,
      description: {
        en: "Variance of evenly spaced values",
        ja: "\u7B49\u9593\u9694\u306E\u5024\u306E\u5206\u6563"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const numericValues = collectNumericArguments2(args, helpers);
    if (numericValues.length < 2) {
      throw new Error("VAR expects at least two numeric arguments");
    }
    const summary = summarizeNumbers2(numericValues);
    const meanSquare = summary.sum * summary.sum / summary.count;
    return (summary.sumOfSquares - meanSquare) / (summary.count - 1);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/varp.ts
var variancePopulationFunction = {
  name: "VARP",
  category: "statistical",
  description: {
    en: "Calculates the population variance of numeric arguments.",
    ja: "\u6570\u5024\u5F15\u6570\u306E\u6BCD\u5206\u6563\u3092\u8A08\u7B97\u3057\u307E\u3059\u3002"
  },
  examples: ["VARP(1, 3, 5)", "VARP(A1:A10)"],
  samples: [
    {
      input: "VARP(2, 4, 6, 8)",
      output: 5,
      description: {
        en: "Population variance",
        ja: "\u6BCD\u5206\u6563"
      }
    },
    {
      input: "VARP(10, 20, 30)",
      output: 66.67,
      description: {
        en: "Population variance of evenly spaced values",
        ja: "\u7B49\u9593\u9694\u306E\u5024\u306E\u6BCD\u5206\u6563"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const numericValues = collectNumericArguments2(args, helpers);
    if (numericValues.length === 0) {
      throw new Error("VARP expects at least one numeric argument");
    }
    const summary = summarizeNumbers2(numericValues);
    const meanSquare = summary.sum * summary.sum / summary.count;
    return (summary.sumOfSquares - meanSquare) / summary.count;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/stdev.ts
var standardDeviationFunction = {
  name: "STDEV",
  category: "statistical",
  description: {
    en: "Calculates the sample standard deviation of numeric arguments.",
    ja: "\u6570\u5024\u5F15\u6570\u306E\u6A19\u672C\u6A19\u6E96\u504F\u5DEE\u3092\u8A08\u7B97\u3057\u307E\u3059\u3002"
  },
  examples: ["STDEV(1, 3, 5)", "STDEV(A1:A10)"],
  samples: [
    {
      input: "STDEV(2, 4, 6, 8)",
      output: 2.58,
      description: {
        en: "Sample standard deviation",
        ja: "\u6A19\u672C\u6A19\u6E96\u504F\u5DEE"
      }
    },
    {
      input: "STDEV(10, 20, 30)",
      output: 10,
      description: {
        en: "Standard deviation of evenly spaced values",
        ja: "\u7B49\u9593\u9694\u306E\u5024\u306E\u6A19\u6E96\u504F\u5DEE"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const numericValues = collectNumericArguments2(args, helpers);
    if (numericValues.length < 2) {
      throw new Error("STDEV expects at least two numeric arguments");
    }
    const summary = summarizeNumbers2(numericValues);
    const meanSquare = summary.sum * summary.sum / summary.count;
    const variance = (summary.sumOfSquares - meanSquare) / (summary.count - 1);
    return Math.sqrt(variance);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/statistical/stdevp.ts
var standardDeviationPopulationFunction = {
  name: "STDEVP",
  category: "statistical",
  description: {
    en: "Calculates the population standard deviation of numeric arguments.",
    ja: "\u6570\u5024\u5F15\u6570\u306E\u6BCD\u6A19\u6E96\u504F\u5DEE\u3092\u8A08\u7B97\u3057\u307E\u3059\u3002"
  },
  examples: ["STDEVP(1, 3, 5)", "STDEVP(A1:A10)"],
  samples: [
    {
      input: "STDEVP(2, 4, 6, 8)",
      output: 2.24,
      description: {
        en: "Population standard deviation",
        ja: "\u6BCD\u6A19\u6E96\u504F\u5DEE"
      }
    },
    {
      input: "STDEVP(10, 20, 30)",
      output: 8.16,
      description: {
        en: "Population SD of evenly spaced values",
        ja: "\u7B49\u9593\u9694\u306E\u5024\u306E\u6BCD\u6A19\u6E96\u504F\u5DEE"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const numericValues = collectNumericArguments2(args, helpers);
    if (numericValues.length === 0) {
      throw new Error("STDEVP expects at least one numeric argument");
    }
    const summary = summarizeNumbers2(numericValues);
    const meanSquare = summary.sum * summary.sum / summary.count;
    const variance = (summary.sumOfSquares - meanSquare) / summary.count;
    return Math.sqrt(variance);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/lookup/table.ts
var normalizeRow = (row, description) => {
  if (!isArrayResult2(row)) {
    return [row ?? null];
  }
  return row.map((value) => {
    if (isArrayResult2(value)) {
      throw new Error(`${description} does not support nested ranges`);
    }
    return value ?? null;
  });
};
var toLookupTable = (range2, description) => {
  if (!isArrayResult2(range2)) {
    throw new Error(`${description} requires a range argument`);
  }
  if (range2.length === 0) {
    throw new Error(`${description} range cannot be empty`);
  }
  const rows = range2.map((row) => normalizeRow(row, description));
  const columnCount = rows[0]?.length ?? 0;
  if (columnCount === 0) {
    throw new Error(`${description} range cannot be empty`);
  }
  rows.forEach((row) => {
    if (row.length !== columnCount) {
      throw new Error(`${description} requires rectangular ranges`);
    }
  });
  return rows;
};
var readTableCell = (params) => {
  const { table, rowIndex, columnIndex, description } = params;
  const row = table[rowIndex];
  if (!row) {
    throw new Error(`${description} failed: missing row in range`);
  }
  const value = row[columnIndex];
  if (value === undefined) {
    throw new Error(`${description} failed: missing column in range`);
  }
  return value;
};

// packages/@oxen-office/xlsx/src/formula/functions/database/common.ts
var normalizeHeaderLabel = (value, description, columnIndex) => {
  if (typeof value !== "string") {
    throw new Error(`${description} header at column ${columnIndex + 1} must be text`);
  }
  const trimmed = value.trim();
  if (trimmed.length === 0) {
    throw new Error(`${description} header at column ${columnIndex + 1} cannot be empty`);
  }
  return trimmed;
};
var parseDatabaseArgument = (databaseArg, functionName) => {
  const table = toLookupTable(databaseArg, `${functionName} database`);
  const headerRow = table[0];
  if (!headerRow) {
    throw new Error(`${functionName} database must include a header row`);
  }
  const headers = headerRow.map((cell, columnIndex) => normalizeHeaderLabel(cell, `${functionName} database`, columnIndex));
  const headerMap = headers.reduce((map, header, index) => {
    const key = header.toUpperCase();
    if (map.has(key)) {
      throw new Error(`${functionName} database header "${header}" must be unique`);
    }
    map.set(key, index);
    return map;
  }, new Map);
  return {
    headers,
    headerMap,
    rows: table.slice(1)
  };
};
var resolveFieldIndex = (fieldValue, database, functionName) => {
  if (typeof fieldValue === "number") {
    if (!Number.isInteger(fieldValue)) {
      throw new Error(`${functionName} field index must be an integer`);
    }
    if (fieldValue < 1 || fieldValue > database.headers.length) {
      throw new Error(`${functionName} field index is out of range`);
    }
    return fieldValue - 1;
  }
  if (typeof fieldValue === "string") {
    const trimmed = fieldValue.trim();
    if (trimmed.length === 0) {
      throw new Error(`${functionName} field name cannot be empty`);
    }
    const columnIndex = database.headerMap.get(trimmed.toUpperCase());
    if (columnIndex === undefined) {
      throw new Error(`${functionName} could not find field "${trimmed}"`);
    }
    return columnIndex;
  }
  throw new Error(`${functionName} field must be a column label or index`);
};
var buildCriteriaColumns = (headers, database, functionName) => {
  return headers.map((header, columnIndex) => {
    const label = normalizeHeaderLabel(header, `${functionName} criteria`, columnIndex);
    const databaseColumnIndex = database.headerMap.get(label.toUpperCase());
    if (databaseColumnIndex === undefined) {
      throw new Error(`${functionName} criteria header "${label}" does not match a database field`);
    }
    return {
      databaseColumnIndex,
      label
    };
  });
};
var buildCriteriaGroups = (params) => {
  const { rows, criteriaColumns, helpers, functionName } = params;
  const conditionsByRow = rows.map((row, rowIndex) => {
    return criteriaColumns.reduce((conditions, column, columnIndex) => {
      const cellValue = row[columnIndex];
      if (cellValue === null) {
        return conditions;
      }
      const predicate = helpers.createCriteriaPredicate(cellValue, helpers.comparePrimitiveEquality, `${functionName} criteria for "${column.label}" (row ${rowIndex + 2})`);
      conditions.push({
        columnIndex: column.databaseColumnIndex,
        predicate
      });
      return conditions;
    }, []);
  });
  const hasUnconditionalRow = conditionsByRow.some((conditions) => conditions.length === 0);
  const groups = conditionsByRow.filter((conditions) => conditions.length > 0);
  return {
    groups,
    hasUnconditionalRow
  };
};
var createCriteriaFilter = (params) => {
  const { criteriaArg, database, helpers, functionName } = params;
  const criteriaTable = toLookupTable(criteriaArg, `${functionName} criteria`);
  const headerRow = criteriaTable[0];
  if (!headerRow) {
    throw new Error(`${functionName} criteria must include a header row`);
  }
  const criteriaColumns = buildCriteriaColumns(headerRow, database, functionName);
  const dataRows = criteriaTable.slice(1);
  const { groups, hasUnconditionalRow } = buildCriteriaGroups({ rows: dataRows, criteriaColumns, helpers, functionName });
  if (hasUnconditionalRow || groups.length === 0) {
    return () => true;
  }
  return (row) => {
    return groups.some((conditions) => conditions.every((condition) => {
      const value = row[condition.columnIndex] ?? null;
      return condition.predicate(value);
    }));
  };
};
var filterDatabaseRows = (params) => {
  const { database, criteriaArg, helpers, functionName } = params;
  const predicate = createCriteriaFilter({ criteriaArg, database, helpers, functionName });
  return database.rows.filter((row) => predicate(row));
};
var collectNumericFieldValues = (rows, fieldIndex) => {
  return rows.reduce((numbers, row) => {
    const value = row[fieldIndex] ?? null;
    if (typeof value === "number" && !Number.isNaN(value)) {
      numbers.push(value);
    }
    return numbers;
  }, []);
};

// packages/@oxen-office/xlsx/src/formula/functions/database/daggregate.ts
var prepareNumericValues = (args, helpers, functionName) => {
  if (args.length !== 3) {
    throw new Error(`${functionName} expects exactly three arguments`);
  }
  const [databaseArg, fieldArg, criteriaArg] = args;
  const database = parseDatabaseArgument(databaseArg, functionName);
  const fieldValue = helpers.coerceScalar(fieldArg, `${functionName} field`);
  const fieldIndex = resolveFieldIndex(fieldValue, database, functionName);
  const matchingRows = filterDatabaseRows({ database, criteriaArg, helpers, functionName });
  return collectNumericFieldValues(matchingRows, fieldIndex);
};
var dSumFunction = {
  name: "DSUM",
  category: "database",
  description: {
    en: "Sums numeric entries in a database column that satisfy the criteria.",
    ja: "\u6761\u4EF6\u3092\u6E80\u305F\u3059\u30C7\u30FC\u30BF\u30D9\u30FC\u30B9\u5217\u306E\u6570\u5024\u3092\u5408\u8A08\u3057\u307E\u3059\u3002"
  },
  examples: ['DSUM(A1:C10, "Sales", E1:F2)'],
  samples: [
    {
      input: 'DSUM({{"Name", "Amount"}; {"Alice", 100}; {"Bob", 200}; {"Carol", 150}}, "Amount", {{"Amount"}; {">100"}})',
      output: 350,
      description: {
        en: "Sum amounts where Amount > 100 (200 + 150 = 350)",
        ja: "\u91D1\u984D\u304C100\u3088\u308A\u5927\u304D\u3044\u5408\u8A08\uFF08200 + 150 = 350\uFF09"
      }
    },
    {
      input: 'DSUM({{"Product", "Sales"}; {"A", 50}; {"B", 100}; {"C", 75}}, "Sales", {{"Sales"}; {">=50"}})',
      output: 225,
      description: {
        en: "Sum all sales >= 50 (50 + 100 + 75 = 225)",
        ja: "50\u4EE5\u4E0A\u306E\u58F2\u4E0A\u306E\u5408\u8A08\uFF0850 + 100 + 75 = 225\uFF09"
      }
    },
    {
      input: 'DSUM({{"Item", "Price"}; {"X", 10}; {"Y", 20}; {"Z", 30}}, "Price", {{"Price"}; {"<30"}})',
      output: 30,
      description: {
        en: "Sum prices where Price < 30 (10 + 20 = 30)",
        ja: "\u4FA1\u683C\u304C30\u672A\u6E80\u306E\u5408\u8A08\uFF0810 + 20 = 30\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const values = prepareNumericValues(args, helpers, "DSUM");
    return values.reduce((total, value) => total + value, 0);
  }
};
var dProductFunction = {
  name: "DPRODUCT",
  category: "database",
  description: {
    en: "Multiplies numeric entries in a database column that satisfy the criteria.",
    ja: "\u6761\u4EF6\u3092\u6E80\u305F\u3059\u30C7\u30FC\u30BF\u30D9\u30FC\u30B9\u5217\u306E\u6570\u5024\u3092\u639B\u3051\u5408\u308F\u305B\u307E\u3059\u3002"
  },
  examples: ['DPRODUCT(A1:C10, "Sales", E1:F2)'],
  samples: [
    {
      input: 'DPRODUCT({{"Name", "Factor"}; {"Alice", 2}; {"Bob", 3}; {"Carol", 4}}, "Factor", {{"Factor"}; {">2"}})',
      output: 12,
      description: {
        en: "Product of factors where Factor > 2 (3 * 4 = 12)",
        ja: "\u56E0\u6570\u304C2\u3088\u308A\u5927\u304D\u3044\u7A4D\uFF083 * 4 = 12\uFF09"
      }
    },
    {
      input: 'DPRODUCT({{"Product", "Multiplier"}; {"A", 2}; {"B", 5}; {"C", 10}}, "Multiplier", {{"Multiplier"}; {"<=5"}})',
      output: 10,
      description: {
        en: "Product of multipliers <= 5 (2 * 5 = 10)",
        ja: "\u4E57\u6570\u304C5\u4EE5\u4E0B\u306E\u7A4D\uFF082 * 5 = 10\uFF09"
      }
    },
    {
      input: 'DPRODUCT({{"Item", "Value"}; {"X", 1}; {"Y", 2}; {"Z", 3}}, "Value", {{"Value"}; {">=1"}})',
      output: 6,
      description: {
        en: "Product of all values >= 1 (1 * 2 * 3 = 6)",
        ja: "1\u4EE5\u4E0A\u306E\u3059\u3079\u3066\u306E\u5024\u306E\u7A4D\uFF081 * 2 * 3 = 6\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const values = prepareNumericValues(args, helpers, "DPRODUCT");
    return values.reduce((product, value) => product * value, 1);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/database/daverage.ts
var dAverageFunction = {
  name: "DAVERAGE",
  category: "database",
  description: {
    en: "Returns the mean of numeric entries in a database column that satisfy the criteria.",
    ja: "\u6761\u4EF6\u3092\u6E80\u305F\u3059\u30C7\u30FC\u30BF\u30D9\u30FC\u30B9\u5217\u306E\u6570\u5024\u306E\u5E73\u5747\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['DAVERAGE(A1:C10, "Sales", E1:F2)'],
  samples: [
    {
      input: 'DAVERAGE({{"Name", "Age"}; {"Alice", 25}; {"Bob", 30}; {"Carol", 35}}, "Age", {{"Age"}; {">25"}})',
      output: 32.5,
      description: {
        en: "Average age where Age > 25 (30 and 35, average is 32.5)",
        ja: "\u5E74\u9F62\u304C25\u3088\u308A\u5927\u304D\u3044\u5E73\u5747\uFF0830\u306835\u3001\u5E73\u5747\u306F32.5\uFF09"
      }
    },
    {
      input: 'DAVERAGE({{"Product", "Price"}; {"A", 100}; {"B", 200}; {"C", 150}}, "Price", {{"Product"}; {"A"}})',
      output: 100,
      description: {
        en: "Average price where Product is A",
        ja: "\u88FD\u54C1\u304CA\u306E\u4FA1\u683C\u306E\u5E73\u5747"
      }
    },
    {
      input: 'DAVERAGE({{"Item", "Qty"}; {"X", 10}; {"Y", 20}; {"Z", 30}}, "Qty", {{"Qty"}; {">=20"}})',
      output: 25,
      description: {
        en: "Average quantity where Qty >= 20 (20 and 30, average is 25)",
        ja: "\u6570\u91CF\u304C20\u4EE5\u4E0A\u306E\u5E73\u5747\uFF0820\u306830\u3001\u5E73\u5747\u306F25\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 3) {
      throw new Error("DAVERAGE expects exactly three arguments");
    }
    const [databaseArg, fieldArg, criteriaArg] = args;
    const database = parseDatabaseArgument(databaseArg, "DAVERAGE");
    const fieldValue = helpers.coerceScalar(fieldArg, "DAVERAGE field");
    const fieldIndex = resolveFieldIndex(fieldValue, database, "DAVERAGE");
    const matchingRows = filterDatabaseRows({ database, criteriaArg, helpers, functionName: "DAVERAGE" });
    const numericValues = collectNumericFieldValues(matchingRows, fieldIndex);
    if (numericValues.length === 0) {
      throw new Error("DAVERAGE found no numeric values matching criteria");
    }
    const total = numericValues.reduce((sum, value) => sum + value, 0);
    return total / numericValues.length;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/database/dcount.ts
var dCountFunction = {
  name: "DCOUNT",
  category: "database",
  description: {
    en: "Counts numeric entries in a database column that satisfy the criteria.",
    ja: "\u6761\u4EF6\u3092\u6E80\u305F\u3059\u30C7\u30FC\u30BF\u30D9\u30FC\u30B9\u5217\u306E\u6570\u5024\u306E\u4EF6\u6570\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['DCOUNT(A1:C10, "Sales", E1:F2)'],
  samples: [
    {
      input: 'DCOUNT({{"Name", "Age"}; {"Alice", 25}; {"Bob", 30}; {"Carol", 35}}, "Age", {{"Age"}; {">25"}})',
      output: 2,
      description: {
        en: "Count ages greater than 25 (30 and 35, count is 2)",
        ja: "25\u3088\u308A\u5927\u304D\u3044\u5E74\u9F62\u3092\u30AB\u30A6\u30F3\u30C8\uFF0830\u306835\u3001\u30AB\u30A6\u30F3\u30C8\u306F2\uFF09"
      }
    },
    {
      input: 'DCOUNT({{"Product", "Price"}; {"A", 100}; {"B", 200}; {"C", 150}}, "Price", {{"Price"}; {">=150"}})',
      output: 2,
      description: {
        en: "Count prices >= 150 (150 and 200, count is 2)",
        ja: "150\u4EE5\u4E0A\u306E\u4FA1\u683C\u3092\u30AB\u30A6\u30F3\u30C8\uFF08150\u3068200\u3001\u30AB\u30A6\u30F3\u30C8\u306F2\uFF09"
      }
    },
    {
      input: 'DCOUNT({{"Item", "Qty"}; {"X", 10}; {"Y", 20}; {"Z", 30}}, "Qty", {{"Qty"}; {"<50"}})',
      output: 3,
      description: {
        en: "Count all quantities less than 50 (all 3 match)",
        ja: "50\u672A\u6E80\u306E\u6570\u91CF\u3092\u3059\u3079\u3066\u30AB\u30A6\u30F3\u30C8\uFF083\u3064\u3059\u3079\u3066\u4E00\u81F4\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 3) {
      throw new Error("DCOUNT expects exactly three arguments");
    }
    const [databaseArg, fieldArg, criteriaArg] = args;
    const database = parseDatabaseArgument(databaseArg, "DCOUNT");
    const fieldValue = helpers.coerceScalar(fieldArg, "DCOUNT field");
    const fieldIndex = resolveFieldIndex(fieldValue, database, "DCOUNT");
    const matchingRows = filterDatabaseRows({ database, criteriaArg, helpers, functionName: "DCOUNT" });
    const numericValues = collectNumericFieldValues(matchingRows, fieldIndex);
    return numericValues.length;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/database/dextrema.ts
var evaluateExtremum = (params) => {
  const { formulaArgs, helpers, functionName, reducer, emptyErrorMessage } = params;
  if (formulaArgs.length !== 3) {
    throw new Error(`${functionName} expects exactly three arguments`);
  }
  const [databaseArg, fieldArg, criteriaArg] = formulaArgs;
  const database = parseDatabaseArgument(databaseArg, functionName);
  const fieldValue = helpers.coerceScalar(fieldArg, `${functionName} field`);
  const fieldIndex = resolveFieldIndex(fieldValue, database, functionName);
  const matchingRows = filterDatabaseRows({ database, criteriaArg, helpers, functionName });
  const numericValues = collectNumericFieldValues(matchingRows, fieldIndex);
  if (numericValues.length === 0) {
    throw new Error(emptyErrorMessage);
  }
  return reducer(numericValues);
};
var dMaxFunction = {
  name: "DMAX",
  category: "database",
  description: {
    en: "Returns the largest numeric entry in a database column that satisfies the criteria.",
    ja: "\u6761\u4EF6\u3092\u6E80\u305F\u3059\u30C7\u30FC\u30BF\u30D9\u30FC\u30B9\u5217\u3067\u6700\u5927\u306E\u6570\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['DMAX(A1:C10, "Sales", E1:F2)'],
  samples: [
    {
      input: 'DMAX(A1:B4, "Age", D1:E2)',
      output: "Descriptive",
      description: {
        en: "Find maximum age from database A1:B4 where criteria in D1:E2 match",
        ja: "\u30C7\u30FC\u30BF\u30D9\u30FC\u30B9A1:B4\u304B\u3089\u6761\u4EF6D1:E2\u306B\u4E00\u81F4\u3059\u308B\u5E74\u9F62\u306E\u6700\u5927\u5024\u3092\u691C\u7D22"
      }
    },
    {
      input: "DMAX(A1:B10, 2, D1:D2)",
      output: "Descriptive",
      description: {
        en: "Find maximum value in column 2 matching criteria",
        ja: "\u6761\u4EF6\u306B\u4E00\u81F4\u3059\u308B2\u5217\u76EE\u306E\u6700\u5927\u5024\u3092\u691C\u7D22"
      }
    },
    {
      input: 'DMAX(A1:C100, "Sales", F1:G3)',
      output: "Descriptive",
      description: {
        en: "Find maximum sales value matching multiple criteria",
        ja: "\u8907\u6570\u6761\u4EF6\u306B\u4E00\u81F4\u3059\u308B\u58F2\u4E0A\u306E\u6700\u5927\u5024\u3092\u691C\u7D22"
      }
    }
  ],
  evaluate: (args, helpers) => {
    return evaluateExtremum({
      formulaArgs: args,
      helpers,
      functionName: "DMAX",
      reducer: (values) => Math.max(...values),
      emptyErrorMessage: "DMAX found no numeric values matching criteria"
    });
  }
};
var dMinFunction = {
  name: "DMIN",
  category: "database",
  description: {
    en: "Returns the smallest numeric entry in a database column that satisfies the criteria.",
    ja: "\u6761\u4EF6\u3092\u6E80\u305F\u3059\u30C7\u30FC\u30BF\u30D9\u30FC\u30B9\u5217\u3067\u6700\u5C0F\u306E\u6570\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['DMIN(A1:C10, "Sales", E1:F2)'],
  samples: [
    {
      input: 'DMIN(A1:B4, "Age", D1:E2)',
      output: "Descriptive",
      description: {
        en: "Find minimum age from database A1:B4 where criteria in D1:E2 match",
        ja: "\u30C7\u30FC\u30BF\u30D9\u30FC\u30B9A1:B4\u304B\u3089\u6761\u4EF6D1:E2\u306B\u4E00\u81F4\u3059\u308B\u5E74\u9F62\u306E\u6700\u5C0F\u5024\u3092\u691C\u7D22"
      }
    },
    {
      input: "DMIN(A1:B10, 2, D1:D2)",
      output: "Descriptive",
      description: {
        en: "Find minimum value in column 2 matching criteria",
        ja: "\u6761\u4EF6\u306B\u4E00\u81F4\u3059\u308B2\u5217\u76EE\u306E\u6700\u5C0F\u5024\u3092\u691C\u7D22"
      }
    },
    {
      input: 'DMIN(A1:C100, "Sales", F1:G3)',
      output: "Descriptive",
      description: {
        en: "Find minimum sales value matching multiple criteria",
        ja: "\u8907\u6570\u6761\u4EF6\u306B\u4E00\u81F4\u3059\u308B\u58F2\u4E0A\u306E\u6700\u5C0F\u5024\u3092\u691C\u7D22"
      }
    }
  ],
  evaluate: (args, helpers) => {
    return evaluateExtremum({
      formulaArgs: args,
      helpers,
      functionName: "DMIN",
      reducer: (values) => Math.min(...values),
      emptyErrorMessage: "DMIN found no numeric values matching criteria"
    });
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/database/dstatistics.ts
var prepareNumericSummary = (args, helpers, functionName) => {
  if (args.length !== 3) {
    throw new Error(`${functionName} expects exactly three arguments`);
  }
  const [databaseArg, fieldArg, criteriaArg] = args;
  const database = parseDatabaseArgument(databaseArg, functionName);
  const fieldValue = helpers.coerceScalar(fieldArg, `${functionName} field`);
  const fieldIndex = resolveFieldIndex(fieldValue, database, functionName);
  const matchingRows = filterDatabaseRows({ database, criteriaArg, helpers, functionName });
  const numericValues = collectNumericFieldValues(matchingRows, fieldIndex);
  const summary = helpers.summarizeNumbers(numericValues);
  return {
    numericValues,
    summary
  };
};
var computeVarianceComponents = (sum, sumOfSquares, count) => {
  if (count === 0) {
    return {
      sampleVariance: 0,
      populationVariance: 0
    };
  }
  const meanSquare = sum * sum / count;
  const squaredDifferenceSum = Math.max(sumOfSquares - meanSquare, 0);
  const populationVariance = squaredDifferenceSum / count;
  const sampleVariance = count > 1 ? squaredDifferenceSum / (count - 1) : 0;
  return {
    sampleVariance,
    populationVariance
  };
};
var dStdevFunction = {
  name: "DSTDEV",
  category: "database",
  description: {
    en: "Returns the sample standard deviation of numeric entries matching the criteria.",
    ja: "\u6761\u4EF6\u3092\u6E80\u305F\u3059\u6570\u5024\u306E\u6A19\u672C\u6A19\u6E96\u504F\u5DEE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['DSTDEV(A1:C10, "Sales", E1:F2)'],
  samples: [
    {
      input: 'DSTDEV({{"Name", "Score"}; {"Alice", 80}; {"Bob", 90}; {"Carol", 100}}, "Score", {{"Score"}; {">=80"}})',
      output: 10,
      description: {
        en: "Sample standard deviation of scores >= 80 (80, 90, 100)",
        ja: "80\u4EE5\u4E0A\u306E\u30B9\u30B3\u30A2\u306E\u6A19\u672C\u6A19\u6E96\u504F\u5DEE\uFF0880\u300190\u3001100\uFF09"
      }
    },
    {
      input: 'DSTDEV({{"Product", "Value"}; {"A", 10}; {"B", 20}; {"C", 30}}, "Value", {{"Value"}; {">10"}})',
      output: 7.071,
      description: {
        en: "Sample standard deviation where Value > 10 (20, 30)",
        ja: "\u5024\u304C10\u3088\u308A\u5927\u304D\u3044\u6A19\u672C\u6A19\u6E96\u504F\u5DEE\uFF0820\u300130\uFF09"
      }
    },
    {
      input: 'DSTDEV({{"Item", "Measure"}; {"X", 5}; {"Y", 10}; {"Z", 15}}, "Measure", {{"Measure"}; {">=5"}})',
      output: 5,
      description: {
        en: "Sample standard deviation of all measures >= 5",
        ja: "5\u4EE5\u4E0A\u306E\u3059\u3079\u3066\u306E\u6E2C\u5B9A\u5024\u306E\u6A19\u672C\u6A19\u6E96\u504F\u5DEE"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const { numericValues, summary } = prepareNumericSummary(args, helpers, "DSTDEV");
    if (numericValues.length < 2) {
      throw new Error("DSTDEV requires at least two numeric values matching criteria");
    }
    const { sampleVariance } = computeVarianceComponents(summary.sum, summary.sumOfSquares, summary.count);
    return Math.sqrt(sampleVariance);
  }
};
var dStdevpFunction = {
  name: "DSTDEVP",
  category: "database",
  description: {
    en: "Returns the population standard deviation of numeric entries matching the criteria.",
    ja: "\u6761\u4EF6\u3092\u6E80\u305F\u3059\u6570\u5024\u306E\u6BCD\u96C6\u56E3\u6A19\u6E96\u504F\u5DEE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['DSTDEVP(A1:C10, "Sales", E1:F2)'],
  samples: [
    {
      input: 'DSTDEVP({{"Name", "Score"}; {"Alice", 80}; {"Bob", 90}; {"Carol", 100}}, "Score", {{"Score"}; {">=80"}})',
      output: 8.165,
      description: {
        en: "Population standard deviation of scores >= 80 (80, 90, 100)",
        ja: "80\u4EE5\u4E0A\u306E\u30B9\u30B3\u30A2\u306E\u6BCD\u96C6\u56E3\u6A19\u6E96\u504F\u5DEE\uFF0880\u300190\u3001100\uFF09"
      }
    },
    {
      input: 'DSTDEVP({{"Product", "Value"}; {"A", 10}; {"B", 20}; {"C", 30}}, "Value", {{"Value"}; {">10"}})',
      output: 5,
      description: {
        en: "Population standard deviation where Value > 10 (20, 30)",
        ja: "\u5024\u304C10\u3088\u308A\u5927\u304D\u3044\u6BCD\u96C6\u56E3\u6A19\u6E96\u504F\u5DEE\uFF0820\u300130\uFF09"
      }
    },
    {
      input: 'DSTDEVP({{"Item", "Measure"}; {"X", 2}; {"Y", 4}; {"Z", 6}}, "Measure", {{"Measure"}; {">=2"}})',
      output: 1.633,
      description: {
        en: "Population standard deviation of all measures >= 2",
        ja: "2\u4EE5\u4E0A\u306E\u3059\u3079\u3066\u306E\u6E2C\u5B9A\u5024\u306E\u6BCD\u96C6\u56E3\u6A19\u6E96\u504F\u5DEE"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const { numericValues, summary } = prepareNumericSummary(args, helpers, "DSTDEVP");
    if (numericValues.length === 0) {
      throw new Error("DSTDEVP requires at least one numeric value matching criteria");
    }
    const { populationVariance } = computeVarianceComponents(summary.sum, summary.sumOfSquares, summary.count);
    return Math.sqrt(populationVariance);
  }
};
var dVarFunction = {
  name: "DVAR",
  category: "database",
  description: {
    en: "Returns the sample variance of numeric entries matching the criteria.",
    ja: "\u6761\u4EF6\u3092\u6E80\u305F\u3059\u6570\u5024\u306E\u6A19\u672C\u5206\u6563\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['DVAR(A1:C10, "Sales", E1:F2)'],
  samples: [
    {
      input: 'DVAR({{"Name", "Score"}; {"Alice", 80}; {"Bob", 90}; {"Carol", 100}}, "Score", {{"Score"}; {">=80"}})',
      output: 100,
      description: {
        en: "Sample variance of scores >= 80 (80, 90, 100)",
        ja: "80\u4EE5\u4E0A\u306E\u30B9\u30B3\u30A2\u306E\u6A19\u672C\u5206\u6563\uFF0880\u300190\u3001100\uFF09"
      }
    },
    {
      input: 'DVAR({{"Product", "Value"}; {"A", 10}; {"B", 20}; {"C", 30}}, "Value", {{"Value"}; {">10"}})',
      output: 50,
      description: {
        en: "Sample variance where Value > 10 (20, 30)",
        ja: "\u5024\u304C10\u3088\u308A\u5927\u304D\u3044\u6A19\u672C\u5206\u6563\uFF0820\u300130\uFF09"
      }
    },
    {
      input: 'DVAR({{"Item", "Measure"}; {"X", 5}; {"Y", 10}; {"Z", 15}}, "Measure", {{"Measure"}; {">=5"}})',
      output: 25,
      description: {
        en: "Sample variance of all measures >= 5 (5, 10, 15)",
        ja: "5\u4EE5\u4E0A\u306E\u3059\u3079\u3066\u306E\u6E2C\u5B9A\u5024\u306E\u6A19\u672C\u5206\u6563\uFF085\u300110\u300115\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const { numericValues, summary } = prepareNumericSummary(args, helpers, "DVAR");
    if (numericValues.length < 2) {
      throw new Error("DVAR requires at least two numeric values matching criteria");
    }
    const { sampleVariance } = computeVarianceComponents(summary.sum, summary.sumOfSquares, summary.count);
    return sampleVariance;
  }
};
var dVarpFunction = {
  name: "DVARP",
  category: "database",
  description: {
    en: "Returns the population variance of numeric entries matching the criteria.",
    ja: "\u6761\u4EF6\u3092\u6E80\u305F\u3059\u6570\u5024\u306E\u6BCD\u96C6\u56E3\u5206\u6563\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['DVARP(A1:C10, "Sales", E1:F2)'],
  samples: [
    {
      input: 'DVARP({{"Name", "Score"}; {"Alice", 80}; {"Bob", 90}; {"Carol", 100}}, "Score", {{"Score"}; {">=80"}})',
      output: 66.667,
      description: {
        en: "Population variance of scores >= 80 (80, 90, 100)",
        ja: "80\u4EE5\u4E0A\u306E\u30B9\u30B3\u30A2\u306E\u6BCD\u96C6\u56E3\u5206\u6563\uFF0880\u300190\u3001100\uFF09"
      }
    },
    {
      input: 'DVARP({{"Product", "Value"}; {"A", 10}; {"B", 20}; {"C", 30}}, "Value", {{"Value"}; {">10"}})',
      output: 25,
      description: {
        en: "Population variance where Value > 10 (20, 30)",
        ja: "\u5024\u304C10\u3088\u308A\u5927\u304D\u3044\u6BCD\u96C6\u56E3\u5206\u6563\uFF0820\u300130\uFF09"
      }
    },
    {
      input: 'DVARP({{"Item", "Measure"}; {"X", 2}; {"Y", 4}; {"Z", 6}}, "Measure", {{"Measure"}; {">=2"}})',
      output: 2.667,
      description: {
        en: "Population variance of all measures >= 2 (2, 4, 6)",
        ja: "2\u4EE5\u4E0A\u306E\u3059\u3079\u3066\u306E\u6E2C\u5B9A\u5024\u306E\u6BCD\u96C6\u56E3\u5206\u6563\uFF082\u30014\u30016\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const { numericValues, summary } = prepareNumericSummary(args, helpers, "DVARP");
    if (numericValues.length === 0) {
      throw new Error("DVARP requires at least one numeric value matching criteria");
    }
    const { populationVariance } = computeVarianceComponents(summary.sum, summary.sumOfSquares, summary.count);
    return populationVariance;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/lookup/vlookup.ts
var vlookupFunction = {
  name: "VLOOKUP",
  category: "lookup",
  description: {
    en: "Searches the first column of a table for a value and returns data from another column.",
    ja: "\u8868\u306E\u6700\u521D\u306E\u5217\u3067\u5024\u3092\u691C\u7D22\u3057\u3001\u5225\u306E\u5217\u306E\u30C7\u30FC\u30BF\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["VLOOKUP(A2, Table1, 3, FALSE)", "VLOOKUP(5, A1:B10, 2)"],
  samples: [
    {
      input: 'VLOOKUP(2, {{1, "A"}; {2, "B"}; {3, "C"}}, 2, FALSE)',
      output: "B",
      description: {
        en: "Exact match lookup in a 3x2 table",
        ja: "3x2\u30C6\u30FC\u30D6\u30EB\u3067\u306E\u5B8C\u5168\u4E00\u81F4\u691C\u7D22"
      }
    },
    {
      input: "VLOOKUP(2.5, {{1, 10}; {2, 20}; {3, 30}}, 2, TRUE)",
      output: 20,
      description: {
        en: "Approximate match returns largest value less than or equal to lookup",
        ja: "\u8FD1\u4F3C\u4E00\u81F4\u306F\u691C\u7D22\u5024\u4EE5\u4E0B\u306E\u6700\u5927\u5024\u3092\u8FD4\u3059"
      }
    },
    {
      input: 'VLOOKUP("Cat", {{"Apple", 5}; {"Cat", 10}; {"Dog", 15}}, 2, FALSE)',
      output: 10,
      description: {
        en: "Text lookup with exact match",
        ja: "\u30C6\u30AD\u30B9\u30C8\u691C\u7D22\u3067\u306E\u5B8C\u5168\u4E00\u81F4"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 3 || args.length > 4) {
      throw new Error("VLOOKUP expects three or four arguments");
    }
    const lookupValue = helpers.coerceScalar(args[0], "VLOOKUP lookup value");
    const table = toLookupTable(args[1], "VLOOKUP");
    const columnIndexRaw = helpers.requireNumber(args[2], "VLOOKUP column index");
    if (!Number.isInteger(columnIndexRaw)) {
      throw new Error("VLOOKUP column index must be an integer");
    }
    const columnIndex = columnIndexRaw;
    if (columnIndex < 1) {
      throw new Error("VLOOKUP column index must be greater than or equal to 1");
    }
    const resolveApproximateMatch = () => {
      if (args.length !== 4) {
        return true;
      }
      return helpers.coerceLogical(args[3], "VLOOKUP range lookup");
    };
    const approximateMatch = resolveApproximateMatch();
    if (!approximateMatch) {
      const matchIndex = table.findIndex((_, rowIndex) => {
        const firstColumn = readTableCell({ table, rowIndex, columnIndex: 0, description: "VLOOKUP" });
        return helpers.comparePrimitiveEquality(firstColumn, lookupValue);
      });
      if (matchIndex === -1) {
        throw new Error("VLOOKUP could not find an exact match");
      }
      return readTableCell({ table, rowIndex: matchIndex, columnIndex: columnIndex - 1, description: "VLOOKUP" });
    }
    if (typeof lookupValue !== "number") {
      throw new Error("VLOOKUP approximate match requires numeric lookup value");
    }
    const state = { candidateIndex: null };
    for (let rowIndex = 0;rowIndex < table.length; rowIndex += 1) {
      const firstColumn = readTableCell({ table, rowIndex, columnIndex: 0, description: "VLOOKUP" });
      if (typeof firstColumn !== "number") {
        throw new Error("VLOOKUP approximate match requires numeric table rows");
      }
      if (firstColumn > lookupValue) {
        break;
      }
      state.candidateIndex = rowIndex;
    }
    if (state.candidateIndex === null) {
      throw new Error("VLOOKUP could not find an approximate match");
    }
    return readTableCell({ table, rowIndex: state.candidateIndex, columnIndex: columnIndex - 1, description: "VLOOKUP" });
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/lookup/hlookup.ts
var hlookupFunction = {
  name: "HLOOKUP",
  category: "lookup",
  description: {
    en: "Searches the first row of a table for a value and returns data from another row.",
    ja: "\u8868\u306E\u6700\u521D\u306E\u884C\u3067\u5024\u3092\u691C\u7D22\u3057\u3001\u5225\u306E\u884C\u306E\u30C7\u30FC\u30BF\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["HLOOKUP(A1, Table1, 2, FALSE)", "HLOOKUP(5, A1:J2, 2)"],
  samples: [
    {
      input: 'HLOOKUP("B", {{"A", "B", "C"}; {10, 20, 30}}, 2, FALSE)',
      output: 20,
      description: {
        en: "Exact match in horizontal table",
        ja: "\u6A2A\u65B9\u5411\u30C6\u30FC\u30D6\u30EB\u3067\u306E\u5B8C\u5168\u4E00\u81F4"
      }
    },
    {
      input: 'HLOOKUP(2.5, {{1, 2, 3}; {"X", "Y", "Z"}}, 2, TRUE)',
      output: "Y",
      description: {
        en: "Approximate match in first row",
        ja: "\u6700\u521D\u306E\u884C\u3067\u306E\u8FD1\u4F3C\u4E00\u81F4"
      }
    },
    {
      input: 'HLOOKUP("Cat", {{"Apple", "Cat", "Dog"}; {5, 10, 15}}, 2, FALSE)',
      output: 10,
      description: {
        en: "Text lookup in horizontal header",
        ja: "\u6A2A\u65B9\u5411\u30D8\u30C3\u30C0\u30FC\u3067\u306E\u30C6\u30AD\u30B9\u30C8\u691C\u7D22"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 3 || args.length > 4) {
      throw new Error("HLOOKUP expects three or four arguments");
    }
    const lookupValue = helpers.coerceScalar(args[0], "HLOOKUP lookup value");
    const table = toLookupTable(args[1], "HLOOKUP");
    const rowIndexRaw = helpers.requireNumber(args[2], "HLOOKUP row index");
    if (!Number.isInteger(rowIndexRaw)) {
      throw new Error("HLOOKUP row index must be an integer");
    }
    const rowIndex = rowIndexRaw;
    if (rowIndex < 1 || rowIndex > table.length) {
      throw new Error("HLOOKUP row index is out of bounds");
    }
    const resolveApproximateMatch = () => {
      if (args.length !== 4) {
        return true;
      }
      const rangeLookup = helpers.coerceScalar(args[3], "HLOOKUP range lookup");
      if (typeof rangeLookup !== "boolean") {
        throw new Error("HLOOKUP range lookup flag must be boolean");
      }
      return rangeLookup;
    };
    const approximateMatch = resolveApproximateMatch();
    const targetRowIndex = rowIndex - 1;
    if (!approximateMatch) {
      const columnIndex = table[0].findIndex((_, column) => helpers.comparePrimitiveEquality(readTableCell({ table, rowIndex: 0, columnIndex: column, description: "HLOOKUP" }), lookupValue));
      if (columnIndex === -1) {
        throw new Error("HLOOKUP could not find an exact match");
      }
      return readTableCell({ table, rowIndex: targetRowIndex, columnIndex, description: "HLOOKUP" });
    }
    if (typeof lookupValue !== "number") {
      throw new Error("HLOOKUP approximate match requires numeric lookup value");
    }
    const state = { candidateColumn: null };
    const columnCount = table[0].length;
    for (let columnIndex = 0;columnIndex < columnCount; columnIndex += 1) {
      const firstRowValue = readTableCell({ table, rowIndex: 0, columnIndex, description: "HLOOKUP" });
      if (typeof firstRowValue !== "number") {
        throw new Error("HLOOKUP approximate match requires numeric table columns");
      }
      if (firstRowValue > lookupValue) {
        break;
      }
      state.candidateColumn = columnIndex;
    }
    if (state.candidateColumn === null) {
      throw new Error("HLOOKUP could not find an approximate match");
    }
    return readTableCell({ table, rowIndex: targetRowIndex, columnIndex: state.candidateColumn, description: "HLOOKUP" });
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/lookup/lookup.ts
var ensureVector = (values, description) => {
  if (values.length === 0) {
    throw new Error(`${description} vector cannot be empty`);
  }
  return values;
};
var lookupFunction = {
  name: "LOOKUP",
  category: "lookup",
  description: {
    en: "Searches for a value in a vector or array and returns the corresponding result.",
    ja: "\u30D9\u30AF\u30BF\u30FC\u307E\u305F\u306F\u914D\u5217\u304B\u3089\u5024\u3092\u691C\u7D22\u3057\u3001\u5BFE\u5FDC\u3059\u308B\u7D50\u679C\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["LOOKUP(5, A1:A10, B1:B10)", 'LOOKUP("Key", A1:B2)'],
  samples: [
    {
      input: 'LOOKUP("B", {"A", "B", "C"}, {10, 20, 30})',
      output: 20,
      description: {
        en: "Exact match with separate lookup and result vectors",
        ja: "\u691C\u7D22\u30D9\u30AF\u30BF\u30FC\u3068\u7D50\u679C\u30D9\u30AF\u30BF\u30FC\u304C\u5225\u306E\u5B8C\u5168\u4E00\u81F4"
      }
    },
    {
      input: "LOOKUP(2.5, {1, 2, 3}, {10, 20, 30})",
      output: 20,
      description: {
        en: "Approximate match finds largest value <= lookup",
        ja: "\u8FD1\u4F3C\u4E00\u81F4\u306F\u691C\u7D22\u5024\u4EE5\u4E0B\u306E\u6700\u5927\u5024\u3092\u898B\u3064\u3051\u308B"
      }
    },
    {
      input: 'LOOKUP("Cat", {{"Apple", 5}; {"Cat", 10}; {"Dog", 15}})',
      output: 10,
      description: {
        en: "Lookup in a 2-column array",
        ja: "2\u5217\u914D\u5217\u3067\u306E\u691C\u7D22"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2 && args.length !== 3) {
      throw new Error("LOOKUP expects two or three arguments");
    }
    const lookupValue = helpers.coerceScalar(args[0], "LOOKUP lookup value");
    const lookupVector = ensureVector(helpers.flattenResult(args[1]).map((value) => value ?? null), "LOOKUP lookup");
    const resolveResultVector = () => {
      if (args.length !== 3) {
        return lookupVector;
      }
      return ensureVector(helpers.flattenResult(args[2]).map((value) => value ?? null), "LOOKUP result");
    };
    const resultVector = resolveResultVector();
    if (resultVector.length !== lookupVector.length) {
      throw new Error("LOOKUP result vector must match lookup vector length");
    }
    const exactIndex = lookupVector.findIndex((candidate) => helpers.comparePrimitiveEquality(candidate, lookupValue));
    if (exactIndex !== -1) {
      return resultVector[exactIndex] ?? null;
    }
    if (typeof lookupValue !== "number") {
      throw new Error("LOOKUP requires numeric lookup value when no exact match is found");
    }
    const state = { candidateIndex: null };
    for (let index = 0;index < lookupVector.length; index += 1) {
      const candidate = lookupVector[index];
      if (typeof candidate !== "number") {
        throw new Error("LOOKUP requires numeric lookup vector when performing approximate match");
      }
      if (candidate > lookupValue) {
        break;
      }
      state.candidateIndex = index;
    }
    if (state.candidateIndex === null) {
      throw new Error("LOOKUP could not find an approximate match");
    }
    return resultVector[state.candidateIndex] ?? null;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/lookup/referenceBounds.ts
var resolveReferenceBounds = (node, description) => {
  if (node.type === "Reference") {
    return {
      sheetName: node.sheetName,
      topRow: node.reference.row,
      leftColumn: node.reference.col,
      height: 1,
      width: 1
    };
  }
  if (node.type === "Range") {
    const range2 = node.range;
    const minRow = Math.min(range2.start.row, range2.end.row);
    const maxRow = Math.max(range2.start.row, range2.end.row);
    const minColumn = Math.min(range2.start.col, range2.end.col);
    const maxColumn = Math.max(range2.start.col, range2.end.col);
    return {
      sheetName: range2.sheetName,
      topRow: minRow,
      leftColumn: minColumn,
      height: maxRow - minRow + 1,
      width: maxColumn - minColumn + 1
    };
  }
  throw new Error(`${description} requires a cell reference or range as the first argument`);
};

// packages/@oxen-office/xlsx/src/formula/functions/lookup/row.ts
var rowFunction = {
  name: "ROW",
  category: "lookup",
  description: {
    en: "Returns the row number of a reference, or the current row when omitted.",
    ja: "\u53C2\u7167\u306E\u884C\u756A\u53F7\u3001\u307E\u305F\u306F\u5F15\u6570\u7701\u7565\u6642\u306F\u73FE\u5728\u306E\u884C\u756A\u53F7\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ROW()", "ROW(A1)", "ROW(B3:C4)"],
  samples: [
    {
      input: "ROW()",
      output: 1,
      description: {
        en: "Returns the row of the formula cell (in this evaluator, origin row=1 for samples)",
        ja: "\u5F0F\u30BB\u30EB\u306E\u884C\u756A\u53F7\u3092\u8FD4\u3057\u307E\u3059\uFF08samples \u3067\u306F origin \u304C 1 \u884C\u76EE\uFF09"
      }
    },
    {
      input: "ROW(A10)",
      output: 10,
      description: {
        en: "Returns the referenced row number",
        ja: "\u53C2\u7167\u5148\u306E\u884C\u756A\u53F7\u3092\u8FD4\u3057\u307E\u3059"
      }
    }
  ],
  evaluateLazy: (nodes, context) => {
    if (nodes.length === 0) {
      return context.origin.address.row;
    }
    if (nodes.length !== 1) {
      throw new Error("ROW expects zero or one argument");
    }
    const bounds = resolveReferenceBounds(nodes[0], "ROW");
    return bounds.topRow;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/lookup/match.ts
var ensureVector2 = (values, description) => {
  if (values.length === 0) {
    throw new Error(`${description} vector cannot be empty`);
  }
  return values;
};
var matchFunction = {
  name: "MATCH",
  category: "lookup",
  description: {
    en: "Returns the position of a lookup value within a vector, supporting exact or approximate matches.",
    ja: "\u691C\u7D22\u5024\u304C\u30D9\u30AF\u30BF\u30FC\u5185\u306E\u3069\u3053\u306B\u4F4D\u7F6E\u3059\u308B\u304B\u3092\u3001\u5B8C\u5168\u4E00\u81F4\u307E\u305F\u306F\u8FD1\u4F3C\u4E00\u81F4\u3067\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['MATCH("Key", A1:A10, 0)', "MATCH(5, A1:A10, 1)"],
  samples: [
    {
      input: 'MATCH("B", {"A", "B", "C"}, 0)',
      output: 2,
      description: {
        en: "Exact match returns position (1-based index)",
        ja: "\u5B8C\u5168\u4E00\u81F4\u306F\u4F4D\u7F6E\u3092\u8FD4\u3059\uFF081\u59CB\u307E\u308A\u306E\u30A4\u30F3\u30C7\u30C3\u30AF\u30B9\uFF09"
      }
    },
    {
      input: "MATCH(25, {10, 20, 30, 40}, 1)",
      output: 2,
      description: {
        en: "Match type 1 finds largest value less than or equal to lookup",
        ja: "\u30DE\u30C3\u30C1\u30BF\u30A4\u30D71\u306F\u691C\u7D22\u5024\u4EE5\u4E0B\u306E\u6700\u5927\u5024\u3092\u898B\u3064\u3051\u308B"
      }
    },
    {
      input: "MATCH(25, {40, 30, 20, 10}, -1)",
      output: 3,
      description: {
        en: "Match type -1 finds smallest value greater than or equal to lookup",
        ja: "\u30DE\u30C3\u30C1\u30BF\u30A4\u30D7-1\u306F\u691C\u7D22\u5024\u4EE5\u4E0A\u306E\u6700\u5C0F\u5024\u3092\u898B\u3064\u3051\u308B"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2 && args.length !== 3) {
      throw new Error("MATCH expects two or three arguments");
    }
    const lookupValue = helpers.coerceScalar(args[0], "MATCH lookup value");
    const lookupVector = ensureVector2(helpers.flattenResult(args[1]).map((value) => value ?? null), "MATCH lookup");
    const matchType = args.length === 3 ? helpers.requireNumber(args[2], "MATCH match type") : 1;
    if (!Number.isFinite(matchType)) {
      throw new Error("MATCH match type must be finite");
    }
    if (matchType === 0) {
      const index = lookupVector.findIndex((candidate) => helpers.comparePrimitiveEquality(candidate, lookupValue));
      if (index === -1) {
        throw new Error("MATCH could not find an exact match");
      }
      return index + 1;
    }
    if (typeof lookupValue !== "number") {
      throw new Error("MATCH approximate match requires numeric lookup value");
    }
    if (matchType === 1) {
      const state = { candidateIndex: null };
      for (let index = 0;index < lookupVector.length; index += 1) {
        const candidate = lookupVector[index];
        if (typeof candidate !== "number") {
          throw new Error("MATCH with match type 1 requires numeric lookup vector");
        }
        if (candidate > lookupValue) {
          break;
        }
        state.candidateIndex = index;
      }
      if (state.candidateIndex === null) {
        throw new Error("MATCH could not find an approximate match for match type 1");
      }
      return state.candidateIndex + 1;
    }
    if (matchType === -1) {
      const state = { candidateIndex: null };
      for (let index = 0;index < lookupVector.length; index += 1) {
        const candidate = lookupVector[index];
        if (typeof candidate !== "number") {
          throw new Error("MATCH with match type -1 requires numeric lookup vector");
        }
        if (candidate >= lookupValue) {
          state.candidateIndex = index;
        }
      }
      if (state.candidateIndex === null) {
        throw new Error("MATCH could not find an approximate match for match type -1");
      }
      return state.candidateIndex + 1;
    }
    throw new Error("MATCH match type must be -1, 0, or 1");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/lookup/index.ts
var indexFunction = {
  name: "INDEX",
  description: {
    en: "Returns the value at a given row and column position within a range or array.",
    ja: "\u7BC4\u56F2\u307E\u305F\u306F\u914D\u5217\u5185\u306E\u6307\u5B9A\u3057\u305F\u884C\u5217\u4F4D\u7F6E\u306E\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["INDEX(A1:C3, 2, 3)", "INDEX(Table1, 1, 2)"],
  evaluate: (args, helpers) => {
    if (args.length < 2 || args.length > 3) {
      throw new Error("INDEX expects two or three arguments");
    }
    const source = args[0];
    if (!isArrayResult2(source)) {
      const rowIndex2 = helpers.requireNumber(args[1], "INDEX row index");
      if (rowIndex2 !== 1) {
        throw new Error("INDEX row index must be 1 when referencing a scalar value");
      }
      if (args.length === 3) {
        const columnIndex2 = helpers.requireNumber(args[2], "INDEX column index");
        if (columnIndex2 !== 1) {
          throw new Error("INDEX column index must be 1 when referencing a scalar value");
        }
      }
      return helpers.coerceScalar(source, "INDEX value");
    }
    const table = toLookupTable(source, "INDEX");
    const rowIndexRaw = helpers.requireNumber(args[1], "INDEX row index");
    if (!Number.isInteger(rowIndexRaw)) {
      throw new Error("INDEX row index must be an integer");
    }
    const rowIndex = rowIndexRaw;
    if (rowIndex < 1 || rowIndex > table.length) {
      throw new Error("INDEX row index is out of bounds");
    }
    const columnIndexRaw = args.length === 3 ? helpers.requireNumber(args[2], "INDEX column index") : 1;
    if (!Number.isInteger(columnIndexRaw)) {
      throw new Error("INDEX column index must be an integer");
    }
    const columnIndex = columnIndexRaw;
    if (columnIndex < 1 || columnIndex > table[0].length) {
      throw new Error("INDEX column index is out of bounds");
    }
    return readTableCell({ table, rowIndex: rowIndex - 1, columnIndex: columnIndex - 1, description: "INDEX" });
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/lookup/offset.ts
var normalizeMatrix = (value, description) => {
  if (!isArrayResult2(value)) {
    return [[value ?? null]];
  }
  if (value.length === 0) {
    throw new Error(`${description} cannot operate on an empty range`);
  }
  const is2d = value.some((row) => isArrayResult2(row));
  const rows = [];
  if (!is2d) {
    rows.push(value.map((v) => {
      if (isArrayResult2(v)) {
        throw new Error(`${description} does not support nested ranges`);
      }
      return v ?? null;
    }));
  } else {
    for (const row of value) {
      if (!isArrayResult2(row)) {
        rows.push([row ?? null]);
        continue;
      }
      rows.push(row.map((v) => {
        if (isArrayResult2(v)) {
          throw new Error(`${description} does not support nested ranges`);
        }
        return v ?? null;
      }));
    }
  }
  const width = rows[0]?.length ?? 0;
  if (width === 0) {
    throw new Error(`${description} cannot operate on an empty range`);
  }
  for (const row of rows) {
    if (row.length !== width) {
      throw new Error(`${description} requires rectangular ranges`);
    }
  }
  return rows;
};
var offsetFunction = {
  name: "OFFSET",
  category: "lookup",
  description: {
    en: "Returns a range displaced from a starting reference by row and column offsets.",
    ja: "\u57FA\u6E96\u30BB\u30EB\u304B\u3089\u884C\u3068\u5217\u306E\u30AA\u30D5\u30BB\u30C3\u30C8\u3067\u305A\u3089\u3057\u305F\u7BC4\u56F2\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["OFFSET(A1, 1, 2, 2, 1)", "OFFSET(Table1, 0, 1)"],
  samples: [
    {
      input: "OFFSET({{10, 20, 30}; {40, 50, 60}}, 0, 1)",
      output: [[20, 30], [50, 60]],
      description: {
        en: "Offset by 1 column, same size",
        ja: "1\u5217\u30AA\u30D5\u30BB\u30C3\u30C8\u3001\u540C\u3058\u30B5\u30A4\u30BA"
      }
    },
    {
      input: "OFFSET({{10, 20}; {30, 40}; {50, 60}}, 1, 0, 2, 2)",
      output: [[30, 40], [50, 60]],
      description: {
        en: "Offset by 1 row, specify 2x2 size",
        ja: "1\u884C\u30AA\u30D5\u30BB\u30C3\u30C8\u30012x2\u30B5\u30A4\u30BA\u3092\u6307\u5B9A"
      }
    },
    {
      input: "OFFSET({{1, 2, 3}; {4, 5, 6}}, 0, 1, 1, 2)",
      output: [[2, 3]],
      description: {
        en: "Offset to get subset of array",
        ja: "\u914D\u5217\u306E\u90E8\u5206\u96C6\u5408\u3092\u53D6\u5F97\u3059\u308B\u30AA\u30D5\u30BB\u30C3\u30C8"
      }
    }
  ],
  evaluateLazy: (args, context) => {
    if (args.length < 3 || args.length > 5) {
      throw new Error("OFFSET expects between three and five arguments");
    }
    const [referenceNode, rowsNode, columnsNode, heightNode, widthNode] = args;
    const rowOffsetValue = context.helpers.requireNumber(context.evaluate(rowsNode), "OFFSET rows");
    const columnOffsetValue = context.helpers.requireNumber(context.evaluate(columnsNode), "OFFSET columns");
    const rowOffset = context.helpers.requireInteger(rowOffsetValue, "OFFSET rows must be an integer");
    const columnOffset = context.helpers.requireInteger(columnOffsetValue, "OFFSET columns must be an integer");
    const resolveOptionalNumber = (node, fallback, label) => {
      if (!node) {
        return fallback;
      }
      return context.helpers.requireNumber(context.evaluate(node), label);
    };
    if (referenceNode.type !== "Reference" && referenceNode.type !== "Range") {
      const base = normalizeMatrix(context.evaluate(referenceNode), "OFFSET");
      const baseHeight = base.length;
      const baseWidth = base[0]?.length ?? 0;
      const heightValue2 = resolveOptionalNumber(heightNode, baseHeight, "OFFSET height");
      const widthValue2 = resolveOptionalNumber(widthNode, baseWidth, "OFFSET width");
      const height2 = context.helpers.requireInteger(heightValue2, "OFFSET height must be an integer");
      const width2 = context.helpers.requireInteger(widthValue2, "OFFSET width must be an integer");
      if (height2 <= 0 || width2 <= 0) {
        throw new Error("OFFSET height and width must be greater than zero");
      }
      const startRow2 = rowOffset;
      const startColumn2 = columnOffset;
      if (startRow2 < 0 || startColumn2 < 0) {
        throw new Error("OFFSET cannot reference cells with negative coordinates");
      }
      const result2 = [];
      for (let rowIndex = 0;rowIndex < height2; rowIndex += 1) {
        const sourceRow = base[startRow2 + rowIndex];
        if (!sourceRow) {
          throw new Error("OFFSET result is out of bounds");
        }
        const rowValues = [];
        for (let columnIndex = 0;columnIndex < width2; columnIndex += 1) {
          const v = sourceRow[startColumn2 + columnIndex];
          if (v === undefined) {
            throw new Error("OFFSET result is out of bounds");
          }
          rowValues.push(v);
        }
        result2.push(rowValues);
      }
      return result2;
    }
    const bounds = resolveReferenceBounds(referenceNode, "OFFSET");
    const sheetName = bounds.sheetName ?? context.origin.sheetName;
    const heightValue = resolveOptionalNumber(heightNode, bounds.height, "OFFSET height");
    const widthValue = resolveOptionalNumber(widthNode, bounds.width, "OFFSET width");
    const height = context.helpers.requireInteger(heightValue, "OFFSET height must be an integer");
    const width = context.helpers.requireInteger(widthValue, "OFFSET width must be an integer");
    if (height <= 0 || width <= 0) {
      throw new Error("OFFSET height and width must be greater than zero");
    }
    const startRow = bounds.topRow + rowOffset;
    const startColumn = bounds.leftColumn + columnOffset;
    if (startRow < 1 || startColumn < 1) {
      throw new Error("OFFSET cannot reference cells with non-positive coordinates");
    }
    const result = [];
    for (let rowIndex = 0;rowIndex < height; rowIndex += 1) {
      const rowValues = [];
      for (let columnIndex = 0;columnIndex < width; columnIndex += 1) {
        const reference = {
          type: "Reference",
          reference: {
            col: colIdx(startColumn + columnIndex),
            row: rowIdx(startRow + rowIndex),
            colAbsolute: false,
            rowAbsolute: false
          },
          sheetName
        };
        const cellValue = context.helpers.coerceScalar(context.evaluate(reference), "OFFSET result");
        rowValues.push(cellValue);
      }
      result.push(rowValues);
    }
    return result;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/lookup/indirect.ts
var splitRangeReference = (text) => {
  const state = { inQuote: false };
  for (let index = 0;index < text.length; index += 1) {
    const character = text[index];
    if (character === "'") {
      const next = text[index + 1];
      if (next === "'") {
        index += 1;
        continue;
      }
      state.inQuote = !state.inQuote;
      continue;
    }
    if (character === ":" && !state.inQuote) {
      return {
        start: text.slice(0, index).trim(),
        end: text.slice(index + 1).trim()
      };
    }
  }
  return {
    start: text.trim(),
    end: null
  };
};
var resolveReferenceText = (referenceText, context) => {
  const { start, end } = splitRangeReference(referenceText);
  if (!start) {
    throw new Error("INDIRECT reference_text cannot be empty");
  }
  if (!end) {
    const parsed = context.parseReference(start);
    return {
      type: "Reference",
      reference: parsed.address,
      sheetName: parsed.sheetName
    };
  }
  const marker = start.lastIndexOf("!");
  const sheetPrefix = marker === -1 ? null : start.slice(0, marker + 1);
  const endReferenceText = end.includes("!") ? end : sheetPrefix ? `${sheetPrefix}${end}` : end;
  const startParsed = context.parseReference(start);
  const endParsed = context.parseReference(endReferenceText);
  if (startParsed.sheetName !== endParsed.sheetName) {
    throw new Error("INDIRECT does not support cross-sheet ranges");
  }
  return {
    type: "Range",
    range: {
      start: startParsed.address,
      end: endParsed.address,
      sheetName: startParsed.sheetName
    }
  };
};
var indirectFunction = {
  name: "INDIRECT",
  category: "lookup",
  description: {
    en: "Returns a reference specified by text, allowing dynamic ranges.",
    ja: "\u6587\u5B57\u5217\u3067\u6307\u5B9A\u3057\u305F\u53C2\u7167\u3092\u8FD4\u3057\u3001\u52D5\u7684\u306A\u7BC4\u56F2\u6307\u5B9A\u3092\u53EF\u80FD\u306B\u3057\u307E\u3059\u3002"
  },
  examples: ['INDIRECT("A1")', 'INDIRECT("Sheet2!B3")'],
  samples: [
    {
      input: 'INDIRECT("A1")',
      output: "Reference to cell A1",
      description: {
        en: "Returns reference to cell A1",
        ja: "\u30BB\u30EBA1\u3078\u306E\u53C2\u7167\u3092\u8FD4\u3059"
      }
    },
    {
      input: 'INDIRECT("Sheet2!B3")',
      output: "Reference to Sheet2, cell B3",
      description: {
        en: "Returns reference to cell B3 on Sheet2",
        ja: "Sheet2\u306E\u30BB\u30EBB3\u3078\u306E\u53C2\u7167\u3092\u8FD4\u3059"
      }
    },
    {
      input: 'INDIRECT("A1:C3")',
      output: "Range reference A1:C3",
      description: {
        en: "Returns range reference from text",
        ja: "\u30C6\u30AD\u30B9\u30C8\u304B\u3089\u7BC4\u56F2\u53C2\u7167\u3092\u8FD4\u3059"
      }
    }
  ],
  evaluateLazy: (args, context) => {
    if (args.length !== 1 && args.length !== 2) {
      throw new Error("INDIRECT expects one or two arguments");
    }
    const referenceValue = context.helpers.coerceScalar(context.evaluate(args[0]), "INDIRECT reference_text");
    if (typeof referenceValue !== "string") {
      throw new Error("INDIRECT reference_text must be a string");
    }
    if (args.length === 2) {
      const a1Flag = context.helpers.coerceScalar(context.evaluate(args[1]), "INDIRECT a1");
      if (typeof a1Flag !== "boolean") {
        throw new Error("INDIRECT a1 flag must be boolean");
      }
      if (!a1Flag) {
        throw new Error("INDIRECT currently supports only A1 reference style");
      }
    }
    const referenceNode = resolveReferenceText(referenceValue.trim(), context);
    return context.evaluate(referenceNode);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/lookup/choose.ts
var chooseFunction = {
  name: "CHOOSE",
  category: "lookup",
  description: {
    en: "Returns a value from a list by index.",
    ja: "\u30A4\u30F3\u30C7\u30C3\u30AF\u30B9\u3067\u6307\u5B9A\u3057\u305F\u30EA\u30B9\u30C8\u306E\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['CHOOSE(2, "A", "B", "C")', "CHOOSE(A1, B1:B3)"],
  samples: [
    {
      input: 'CHOOSE(2, "Apple", "Banana", "Cherry")',
      output: "Banana",
      description: {
        en: "Returns the second value from the list",
        ja: "\u30EA\u30B9\u30C8\u304B\u30892\u756A\u76EE\u306E\u5024\u3092\u8FD4\u3059"
      }
    },
    {
      input: "CHOOSE(1, 100, 200, 300)",
      output: 100,
      description: {
        en: "Returns the first numeric value",
        ja: "\u6700\u521D\u306E\u6570\u5024\u3092\u8FD4\u3059"
      }
    },
    {
      input: 'CHOOSE(3, "X", "Y", "Z")',
      output: "Z",
      description: {
        en: "Returns the third and last value",
        ja: "3\u756A\u76EE\u306E\u6700\u5F8C\u306E\u5024\u3092\u8FD4\u3059"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 2) {
      throw new Error("CHOOSE expects at least two arguments");
    }
    const indexRaw = helpers.requireNumber(args[0], "CHOOSE index");
    if (!Number.isInteger(indexRaw)) {
      throw new Error("CHOOSE index must be an integer");
    }
    const index = indexRaw;
    if (index < 1 || index >= args.length) {
      throw new Error("CHOOSE index is out of bounds");
    }
    const chosen = args[index];
    if (chosen === undefined) {
      throw new Error("CHOOSE could not resolve the requested value");
    }
    return chosen ?? null;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/logical/and.ts
var andFunction = {
  name: "AND",
  category: "logical",
  description: {
    en: "Returns TRUE if all arguments evaluate to TRUE; otherwise FALSE.",
    ja: "\u3059\u3079\u3066\u306E\u5F15\u6570\u304CTRUE\u306E\u5834\u5408\u306BTRUE\u3092\u8FD4\u3057\u3001\u305D\u308C\u4EE5\u5916\u306FFALSE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["AND(TRUE, FALSE)", "AND(A1:A3)"],
  samples: [
    {
      input: "AND(TRUE, TRUE, TRUE)",
      output: true,
      description: {
        en: "All values are TRUE",
        ja: "\u3059\u3079\u3066\u306E\u5024\u304CTRUE"
      }
    },
    {
      input: "AND(TRUE, FALSE, TRUE)",
      output: false,
      description: {
        en: "At least one FALSE",
        ja: "\u5C11\u306A\u304F\u3068\u30821\u3064\u304CFALSE"
      }
    },
    {
      input: "AND(1, 1, 1)",
      output: true,
      description: {
        en: "Non-zero numbers coerce to TRUE",
        ja: "\u30BC\u30ED\u4EE5\u5916\u306E\u6570\u5024\u306FTRUE\u306B\u5909\u63DB\u3055\u308C\u308B"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const values = helpers.flattenArguments(args);
    if (values.length === 0) {
      throw new Error("AND expects at least one argument");
    }
    return values.reduce((accumulator, value, index) => {
      if (!accumulator) {
        return false;
      }
      const booleanValue = helpers.coerceLogical(value, `AND argument ${index + 1}`);
      return accumulator && booleanValue;
    }, true);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/logical/or.ts
var orFunction = {
  name: "OR",
  category: "logical",
  description: {
    en: "Returns TRUE if any argument evaluates to TRUE; otherwise FALSE.",
    ja: "\u5F15\u6570\u306E\u3044\u305A\u308C\u304B\u304CTRUE\u3067\u3042\u308C\u3070TRUE\u3092\u8FD4\u3057\u3001\u305D\u308C\u4EE5\u5916\u306FFALSE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["OR(TRUE, FALSE)", "OR(A1:A3)"],
  samples: [
    {
      input: "OR(FALSE, FALSE, TRUE)",
      output: true,
      description: {
        en: "At least one TRUE",
        ja: "\u5C11\u306A\u304F\u3068\u30821\u3064\u304CTRUE"
      }
    },
    {
      input: "OR(FALSE, FALSE, FALSE)",
      output: false,
      description: {
        en: "All values are FALSE",
        ja: "\u3059\u3079\u3066\u306E\u5024\u304CFALSE"
      }
    },
    {
      input: "OR(0, 0, 1)",
      output: true,
      description: {
        en: "Non-zero number is TRUE",
        ja: "\u30BC\u30ED\u4EE5\u5916\u306E\u6570\u5024\u306FTRUE"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const values = helpers.flattenArguments(args);
    if (values.length === 0) {
      throw new Error("OR expects at least one argument");
    }
    return values.reduce((accumulator, value, index) => {
      if (accumulator) {
        return true;
      }
      const booleanValue = helpers.coerceLogical(value, `OR argument ${index + 1}`);
      return booleanValue;
    }, false);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/logical/not.ts
var notFunction = {
  name: "NOT",
  category: "logical",
  description: {
    en: "Returns the logical negation of a boolean value.",
    ja: "\u771F\u507D\u5024\u3092\u53CD\u8EE2\u3055\u305B\u305F\u7D50\u679C\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["NOT(TRUE)", "NOT(A1)"],
  samples: [
    {
      input: "NOT(TRUE)",
      output: false,
      description: {
        en: "Negate TRUE to FALSE",
        ja: "TRUE\u3092FALSE\u306B\u53CD\u8EE2"
      }
    },
    {
      input: "NOT(FALSE)",
      output: true,
      description: {
        en: "Negate FALSE to TRUE",
        ja: "FALSE\u3092TRUE\u306B\u53CD\u8EE2"
      }
    },
    {
      input: "NOT(0)",
      output: true,
      description: {
        en: "Zero is FALSE, so NOT returns TRUE",
        ja: "\u30BC\u30ED\u306FFALSE\u306A\u306E\u3067NOT\u306FTRUE\u3092\u8FD4\u3059"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("NOT expects exactly one argument");
    }
    const booleanValue = helpers.coerceLogical(args[0], "NOT argument");
    return !booleanValue;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/logical/xor.ts
var xorFunction = {
  name: "XOR",
  category: "logical",
  description: {
    en: "Returns TRUE when an odd number of arguments evaluate to TRUE.",
    ja: "TRUE\u3068\u306A\u308B\u5F15\u6570\u306E\u6570\u304C\u5947\u6570\u306E\u5834\u5408\u306BTRUE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["XOR(TRUE, FALSE, TRUE)", "XOR(A1:A4)"],
  samples: [
    {
      input: "XOR(TRUE, FALSE)",
      output: true,
      description: {
        en: "Odd number (1) of TRUE values",
        ja: "TRUE\u5024\u304C\u5947\u6570\u500B\uFF081\u500B\uFF09"
      }
    },
    {
      input: "XOR(TRUE, TRUE)",
      output: false,
      description: {
        en: "Even number (2) of TRUE values",
        ja: "TRUE\u5024\u304C\u5076\u6570\u500B\uFF082\u500B\uFF09"
      }
    },
    {
      input: "XOR(TRUE, FALSE, TRUE)",
      output: false,
      description: {
        en: "Even number (2) of TRUE values",
        ja: "TRUE\u5024\u304C\u5076\u6570\u500B\uFF082\u500B\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    const values = helpers.flattenArguments(args);
    if (values.length === 0) {
      throw new Error("XOR expects at least one argument");
    }
    const truthyCount = values.reduce((count, value, index) => {
      const booleanValue = helpers.coerceLogical(value, `XOR argument ${index + 1}`);
      return booleanValue ? count + 1 : count;
    }, 0);
    return truthyCount % 2 === 1;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/logical/true.ts
var trueFunction = {
  name: "TRUE",
  category: "logical",
  description: {
    en: "Returns the logical constant TRUE.",
    ja: "\u8AD6\u7406\u5024TRUE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["TRUE()"],
  samples: [
    {
      input: "TRUE()",
      output: true,
      description: {
        en: "Return logical TRUE",
        ja: "\u8AD6\u7406\u5024TRUE\u3092\u8FD4\u3059"
      }
    }
  ],
  evaluate: (args) => {
    if (args.length !== 0) {
      throw new Error("TRUE expects no arguments");
    }
    return true;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/logical/false.ts
var falseFunction = {
  name: "FALSE",
  category: "logical",
  description: {
    en: "Returns the logical constant FALSE.",
    ja: "\u8AD6\u7406\u5024FALSE\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["FALSE()"],
  samples: [
    {
      input: "FALSE()",
      output: false,
      description: {
        en: "Return logical FALSE",
        ja: "\u8AD6\u7406\u5024FALSE\u3092\u8FD4\u3059"
      }
    }
  ],
  evaluate: (args) => {
    if (args.length !== 0) {
      throw new Error("FALSE expects no arguments");
    }
    return false;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/logical/if.ts
var ifFunction = {
  name: "IF",
  category: "logical",
  description: {
    en: "Evaluates a condition and returns one value if TRUE, another if FALSE.",
    ja: "\u6761\u4EF6\u3092\u8A55\u4FA1\u3057\u3066TRUE\u306A\u30891\u3064\u306E\u5024\u3001FALSE\u306A\u3089\u5225\u306E\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['IF(A1>0, "Positive", "Negative")', "IF(ISBLANK(A1), 0, A1)"],
  samples: [
    {
      input: 'IF(10 > 5, "Yes", "No")',
      output: "Yes",
      description: {
        en: "Condition is TRUE, return first value",
        ja: "\u6761\u4EF6\u304CTRUE\u306A\u306E\u3067\u6700\u521D\u306E\u5024\u3092\u8FD4\u3059"
      }
    },
    {
      input: 'IF(3 > 5, "Yes", "No")',
      output: "No",
      description: {
        en: "Condition is FALSE, return second value",
        ja: "\u6761\u4EF6\u304CFALSE\u306A\u306E\u30672\u756A\u76EE\u306E\u5024\u3092\u8FD4\u3059"
      }
    },
    {
      input: "IF(TRUE, 100, 200)",
      output: 100,
      description: {
        en: "Return value for TRUE condition",
        ja: "TRUE\u6761\u4EF6\u306E\u5024\u3092\u8FD4\u3059"
      }
    }
  ],
  evaluateLazy: (argNodes, context) => {
    if (argNodes.length < 2 || argNodes.length > 3) {
      throw new Error("IF expects two or three arguments");
    }
    const conditionResult = context.evaluate(argNodes[0]);
    const condition = context.helpers.requireBoolean(conditionResult, "IF condition");
    if (condition) {
      return context.evaluate(argNodes[1]);
    }
    if (argNodes.length === 3) {
      return context.evaluate(argNodes[2]);
    }
    return null;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/logical/ifs.ts
var ifsFunction = {
  name: "IFS",
  category: "logical",
  description: {
    en: "Evaluates multiple condition/value pairs and returns the first match.",
    ja: "\u8907\u6570\u306E\u6761\u4EF6\u3068\u7D50\u679C\u306E\u7D44\u3092\u9806\u306B\u8A55\u4FA1\u3057\u3001\u6700\u521D\u306B\u6210\u308A\u7ACB\u3063\u305F\u7D50\u679C\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['IFS(A1>0, "Positive", A1<0, "Negative", TRUE, "Zero")'],
  samples: [
    {
      input: 'IFS(10 > 5, "First", 10 > 3, "Second")',
      output: "First",
      description: {
        en: "Return first matching condition",
        ja: "\u6700\u521D\u306B\u4E00\u81F4\u3059\u308B\u6761\u4EF6\u3092\u8FD4\u3059"
      }
    },
    {
      input: 'IFS(FALSE, "A", TRUE, "B")',
      output: "B",
      description: {
        en: "Skip FALSE, return TRUE result",
        ja: "FALSE\u3092\u30B9\u30AD\u30C3\u30D7\u3057\u3066TRUE\u306E\u7D50\u679C\u3092\u8FD4\u3059"
      }
    }
  ],
  evaluateLazy: (argNodes, context) => {
    if (argNodes.length < 2 || argNodes.length % 2 !== 0) {
      throw new Error("IFS expects condition/value pairs");
    }
    for (let index = 0;index < argNodes.length; index += 2) {
      const conditionNode = argNodes[index];
      const valueNode = argNodes[index + 1];
      const conditionResult = context.evaluate(conditionNode);
      const condition = context.helpers.requireBoolean(conditionResult, `IFS condition ${index / 2 + 1}`);
      if (condition) {
        return context.evaluate(valueNode);
      }
    }
    throw new Error("IFS requires at least one matching condition");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/logical/switch.ts
var switchFunction = {
  name: "SWITCH",
  category: "logical",
  description: {
    en: "Matches an expression against value/result pairs and returns the first match or default.",
    ja: "\u5F0F\u3092\u5024\u3068\u7D50\u679C\u306E\u30DA\u30A2\u3068\u6BD4\u8F03\u3057\u3001\u6700\u521D\u306B\u4E00\u81F4\u3057\u305F\u7D50\u679C\u307E\u305F\u306F\u65E2\u5B9A\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['SWITCH(A1, 1, "One", 2, "Two", "Other")'],
  samples: [
    {
      input: 'SWITCH(2, 1, "One", 2, "Two", 3, "Three")',
      output: "Two",
      description: {
        en: "Match value and return result",
        ja: "\u5024\u304C\u4E00\u81F4\u3057\u3066\u7D50\u679C\u3092\u8FD4\u3059"
      }
    },
    {
      input: 'SWITCH(5, 1, "One", 2, "Two", "Default")',
      output: "Default",
      description: {
        en: "No match, return default",
        ja: "\u4E00\u81F4\u306A\u3057\u3001\u30C7\u30D5\u30A9\u30EB\u30C8\u3092\u8FD4\u3059"
      }
    }
  ],
  evaluateLazy: (argNodes, context) => {
    if (argNodes.length < 3) {
      throw new Error("SWITCH expects at least three arguments");
    }
    const expressionResult = context.evaluate(argNodes[0]);
    const expressionValue = context.helpers.coerceScalar(expressionResult, "SWITCH expression");
    const remainingCount = argNodes.length - 1;
    const hasTrailing = remainingCount % 2 === 1;
    const pairCount = Math.floor(remainingCount / 2);
    if (pairCount === 0) {
      throw new Error("SWITCH requires at least one value/result pair");
    }
    if (hasTrailing && pairCount < 2) {
      throw new Error("SWITCH requires at least one value/result pair");
    }
    const includeDefault = hasTrailing && pairCount >= 2;
    for (let pairIndex = 0;pairIndex < pairCount; pairIndex += 1) {
      const valueNode = argNodes[1 + pairIndex * 2];
      const resultNode = argNodes[1 + pairIndex * 2 + 1];
      const caseResult = context.evaluate(valueNode);
      const caseValue = context.helpers.coerceScalar(caseResult, `SWITCH value ${pairIndex + 1}`);
      if (context.helpers.comparePrimitiveEquality(expressionValue, caseValue)) {
        return context.evaluate(resultNode);
      }
    }
    if (includeDefault) {
      const defaultNode = argNodes[argNodes.length - 1];
      return context.evaluate(defaultNode);
    }
    throw new Error("SWITCH could not find a matching case");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/concat.ts
var concatFunction = {
  name: "CONCAT",
  category: "text",
  description: {
    en: "Concatenates text values, numbers, and booleans into a single string.",
    ja: "\u6587\u5B57\u5217\u3084\u6570\u5024\u3001\u771F\u507D\u5024\u3092\u9023\u7D50\u3057\u30661\u3064\u306E\u6587\u5B57\u5217\u306B\u3057\u307E\u3059\u3002"
  },
  examples: ['CONCAT("Hello", " ", "World")', "CONCAT(A1:A3)"],
  samples: [
    {
      input: 'CONCAT("Hello", " ", "World")',
      output: "Hello World",
      description: {
        en: "Concatenates three text strings with a space",
        ja: "3\u3064\u306E\u6587\u5B57\u5217\u3092\u30B9\u30DA\u30FC\u30B9\u3067\u9023\u7D50"
      }
    },
    {
      input: 'CONCAT("Year: ", 2024)',
      output: "Year: 2024",
      description: {
        en: "Concatenates text and number",
        ja: "\u6587\u5B57\u5217\u3068\u6570\u5024\u3092\u9023\u7D50"
      }
    },
    {
      input: 'CONCAT("Status: ", TRUE)',
      output: "Status: TRUE",
      description: {
        en: "Concatenates text and boolean value",
        ja: "\u6587\u5B57\u5217\u3068\u771F\u507D\u5024\u3092\u9023\u7D50"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length === 0) {
      return "";
    }
    const values = helpers.flattenArguments(args);
    return values.reduce((accumulator, value) => {
      return `${accumulator}${valueToText2(value)}`;
    }, "");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/concatenate.ts
var concatenateFunction = {
  name: "CONCATENATE",
  category: "text",
  description: {
    en: "Concatenates text values into a single string (legacy alias of CONCAT).",
    ja: "\u6587\u5B57\u5217\u3092\u9023\u7D50\u3057\u30661\u3064\u306E\u6587\u5B57\u5217\u306B\u3057\u307E\u3059\uFF08CONCAT \u306E\u4E92\u63DB\u30FB\u65E7\u540D\uFF09\u3002"
  },
  examples: ['CONCATENATE("Hello", " ", "World")', "CONCATENATE(A1, B1)"],
  evaluate: (args, helpers) => {
    if (args.length === 0) {
      return "";
    }
    const values = helpers.flattenArguments(args);
    return values.reduce((accumulator, value) => {
      return `${accumulator}${valueToText2(value)}`;
    }, "");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/textjoin.ts
var textJoinFunction = {
  name: "TEXTJOIN",
  category: "text",
  description: {
    en: "Concatenates text items using a delimiter, optionally skipping empty strings.",
    ja: "\u533A\u5207\u308A\u6587\u5B57\u3067\u9805\u76EE\u3092\u9023\u7D50\u3057\u3001\u7A7A\u6587\u5B57\u3092\u7701\u7565\u3059\u308B\u3053\u3068\u3082\u3067\u304D\u307E\u3059\u3002"
  },
  examples: ['TEXTJOIN(",", true, A1:A5)', 'TEXTJOIN("-", false, "A", "B")'],
  samples: [
    {
      input: 'TEXTJOIN(", ", TRUE, "Apple", "Banana", "Cherry")',
      output: "Apple, Banana, Cherry",
      description: {
        en: "Joins three words with comma and space delimiter",
        ja: "3\u3064\u306E\u5358\u8A9E\u3092\u30AB\u30F3\u30DE\u3068\u30B9\u30DA\u30FC\u30B9\u3067\u9023\u7D50"
      }
    },
    {
      input: 'TEXTJOIN("-", TRUE, "2024", "", "01", "15")',
      output: "2024-01-15",
      description: {
        en: "Joins date parts with hyphen, skipping empty string",
        ja: "\u30CF\u30A4\u30D5\u30F3\u3067\u65E5\u4ED8\u3092\u9023\u7D50\u3057\u3001\u7A7A\u6587\u5B57\u5217\u3092\u30B9\u30AD\u30C3\u30D7"
      }
    },
    {
      input: 'TEXTJOIN("|", FALSE, "A", "", "B")',
      output: "A||B",
      description: {
        en: "Joins with pipe delimiter, keeping empty string",
        ja: "\u30D1\u30A4\u30D7\u3067\u9023\u7D50\u3057\u3001\u7A7A\u6587\u5B57\u5217\u3092\u4FDD\u6301"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 3) {
      throw new Error("TEXTJOIN expects at least three arguments");
    }
    const [delimiterArg, ignoreEmptyArg, ...valueArgs] = args;
    const delimiter = helpers.coerceText(delimiterArg, "TEXTJOIN delimiter");
    const ignoreEmpty = helpers.requireBoolean(ignoreEmptyArg, "TEXTJOIN ignore_empty");
    const segments = valueArgs.flatMap((valueArg) => {
      const flattened = helpers.flattenResult(valueArg);
      return flattened.map((value) => valueToText2(value));
    });
    const filtered = ignoreEmpty ? segments.filter((segment) => segment.length > 0) : segments;
    return filtered.join(delimiter);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/left.ts
var leftFunction = {
  name: "LEFT",
  category: "text",
  description: {
    en: "Returns the leftmost characters from a text value.",
    ja: "\u6587\u5B57\u5217\u306E\u5DE6\u7AEF\u304B\u3089\u6307\u5B9A\u3057\u305F\u6587\u5B57\u6570\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['LEFT("Spreadsheet", 5)', "LEFT(A1)"],
  samples: [
    {
      input: 'LEFT("Spreadsheet", 6)',
      output: "Spread",
      description: {
        en: "Extracts first 6 characters from the left",
        ja: "\u5DE6\u304B\u3089\u6700\u521D\u306E6\u6587\u5B57\u3092\u62BD\u51FA"
      }
    },
    {
      input: 'LEFT("Hello World", 5)',
      output: "Hello",
      description: {
        en: "Extracts first 5 characters",
        ja: "\u6700\u521D\u306E5\u6587\u5B57\u3092\u62BD\u51FA"
      }
    },
    {
      input: 'LEFT("Data")',
      output: "D",
      description: {
        en: "Defaults to 1 character when count is omitted",
        ja: "\u6587\u5B57\u6570\u7701\u7565\u6642\u306F1\u6587\u5B57\u3092\u8FD4\u3059"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length === 0 || args.length > 2) {
      throw new Error("LEFT expects one or two arguments");
    }
    const [textArg, countArg] = args;
    const text = helpers.coerceText(textArg, "LEFT text");
    const countValue = countArg === undefined ? 1 : helpers.requireNumber(countArg, "LEFT number");
    const requestedCount = helpers.requireInteger(countValue, "LEFT number must be an integer");
    if (requestedCount < 0) {
      throw new Error("LEFT number must be non-negative");
    }
    if (requestedCount === 0) {
      return "";
    }
    const characters = Array.from(text);
    const sliceEnd = Math.min(requestedCount, characters.length);
    return characters.slice(0, sliceEnd).join("");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/right.ts
var rightFunction = {
  name: "RIGHT",
  category: "text",
  description: {
    en: "Returns the rightmost characters from a text value.",
    ja: "\u6587\u5B57\u5217\u306E\u53F3\u7AEF\u304B\u3089\u6307\u5B9A\u3057\u305F\u6587\u5B57\u6570\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['RIGHT("Spreadsheet", 4)', "RIGHT(A1, 2)"],
  samples: [
    {
      input: 'RIGHT("Spreadsheet", 5)',
      output: "sheet",
      description: {
        en: "Extracts last 5 characters from the right",
        ja: "\u53F3\u304B\u3089\u6700\u5F8C\u306E5\u6587\u5B57\u3092\u62BD\u51FA"
      }
    },
    {
      input: 'RIGHT("Hello World", 5)',
      output: "World",
      description: {
        en: "Extracts last 5 characters",
        ja: "\u6700\u5F8C\u306E5\u6587\u5B57\u3092\u62BD\u51FA"
      }
    },
    {
      input: 'RIGHT("Data")',
      output: "a",
      description: {
        en: "Defaults to 1 character when count is omitted",
        ja: "\u6587\u5B57\u6570\u7701\u7565\u6642\u306F1\u6587\u5B57\u3092\u8FD4\u3059"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length === 0 || args.length > 2) {
      throw new Error("RIGHT expects one or two arguments");
    }
    const [textArg, countArg] = args;
    const text = helpers.coerceText(textArg, "RIGHT text");
    const countValue = countArg === undefined ? 1 : helpers.requireNumber(countArg, "RIGHT number");
    const requestedCount = helpers.requireInteger(countValue, "RIGHT number must be an integer");
    if (requestedCount < 0) {
      throw new Error("RIGHT number must be non-negative");
    }
    if (requestedCount === 0) {
      return "";
    }
    const characters = Array.from(text);
    const sliceStart = Math.max(characters.length - requestedCount, 0);
    return characters.slice(sliceStart).join("");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/mid.ts
var midFunction = {
  name: "MID",
  category: "text",
  description: {
    en: "Returns a substring starting at a given position for a specified length.",
    ja: "\u6307\u5B9A\u3057\u305F\u4F4D\u7F6E\u304B\u3089\u6307\u5B9A\u3057\u305F\u9577\u3055\u306E\u90E8\u5206\u6587\u5B57\u5217\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['MID("Spreadsheet", 2, 5)', "MID(A1, 3, 4)"],
  samples: [
    {
      input: 'MID("Spreadsheet", 7, 5)',
      output: "sheet",
      description: {
        en: "Extracts 5 characters starting at position 7",
        ja: "7\u6587\u5B57\u76EE\u304B\u30895\u6587\u5B57\u3092\u62BD\u51FA"
      }
    },
    {
      input: 'MID("Hello World", 7, 5)',
      output: "World",
      description: {
        en: "Extracts 5 characters starting at position 7",
        ja: "7\u6587\u5B57\u76EE\u304B\u30895\u6587\u5B57\u3092\u62BD\u51FA"
      }
    },
    {
      input: 'MID("2024-01-15", 6, 2)',
      output: "01",
      description: {
        en: "Extracts month portion from date string",
        ja: "\u65E5\u4ED8\u6587\u5B57\u5217\u304B\u3089\u6708\u90E8\u5206\u3092\u62BD\u51FA"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 3) {
      throw new Error("MID expects exactly three arguments");
    }
    const [textArg, startArg, lengthArg] = args;
    const text = helpers.coerceText(textArg, "MID text");
    const startValue = helpers.requireNumber(startArg, "MID start");
    const lengthValue = helpers.requireNumber(lengthArg, "MID length");
    const startPosition = helpers.requireInteger(startValue, "MID start must be an integer");
    const requestedLength = helpers.requireInteger(lengthValue, "MID length must be an integer");
    if (startPosition < 1) {
      throw new Error("MID start must be greater than or equal to 1");
    }
    if (requestedLength < 0) {
      throw new Error("MID length must be non-negative");
    }
    if (requestedLength === 0) {
      return "";
    }
    const characters = Array.from(text);
    const zeroBasedStart = startPosition - 1;
    if (zeroBasedStart >= characters.length) {
      return "";
    }
    const sliceEnd = Math.min(zeroBasedStart + requestedLength, characters.length);
    return characters.slice(zeroBasedStart, sliceEnd).join("");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/len.ts
var lenFunction = {
  name: "LEN",
  category: "text",
  description: {
    en: "Counts the number of Unicode characters in a text value.",
    ja: "\u6587\u5B57\u5217\u5185\u306EUnicode\u6587\u5B57\u6570\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ['LEN("Spreadsheet")', "LEN(A1)"],
  samples: [
    {
      input: 'LEN("Spreadsheet")',
      output: 11,
      description: {
        en: "Counts 11 characters in the text",
        ja: "\u6587\u5B57\u5217\u306E11\u6587\u5B57\u3092\u30AB\u30A6\u30F3\u30C8"
      }
    },
    {
      input: 'LEN("Hello World")',
      output: 11,
      description: {
        en: "Counts characters including space",
        ja: "\u30B9\u30DA\u30FC\u30B9\u3092\u542B\u3081\u3066\u6587\u5B57\u6570\u3092\u30AB\u30A6\u30F3\u30C8"
      }
    },
    {
      input: 'LEN("")',
      output: 0,
      description: {
        en: "Empty string has length 0",
        ja: "\u7A7A\u6587\u5B57\u5217\u306E\u9577\u3055\u306F0"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("LEN expects exactly one argument");
    }
    const [textArg] = args;
    const text = helpers.coerceText(textArg, "LEN text");
    return Array.from(text).length;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/trim.ts
var trimFunction = {
  name: "TRIM",
  category: "text",
  description: {
    en: "Removes leading/trailing whitespace and collapses internal spaces to a single space.",
    ja: "\u524D\u5F8C\u306E\u7A7A\u767D\u3092\u524A\u9664\u3057\u3001\u5185\u90E8\u306E\u7A7A\u767D\u9023\u7D9A\u30921\u3064\u306E\u30B9\u30DA\u30FC\u30B9\u306B\u7E2E\u3081\u307E\u3059\u3002"
  },
  examples: ['TRIM("  data  ")', "TRIM(A1)"],
  samples: [
    {
      input: 'TRIM("  Hello World  ")',
      output: "Hello World",
      description: {
        en: "Removes leading and trailing spaces",
        ja: "\u524D\u5F8C\u306E\u30B9\u30DA\u30FC\u30B9\u3092\u524A\u9664"
      }
    },
    {
      input: 'TRIM("Data   Analysis")',
      output: "Data Analysis",
      description: {
        en: "Collapses multiple internal spaces to one",
        ja: "\u5185\u90E8\u306E\u8907\u6570\u30B9\u30DA\u30FC\u30B9\u30921\u3064\u306B\u7E2E\u5C0F"
      }
    },
    {
      input: 'TRIM("  Multiple   Spaces   Everywhere  ")',
      output: "Multiple Spaces Everywhere",
      description: {
        en: "Removes extra spaces from all positions",
        ja: "\u5168\u3066\u306E\u4F59\u5206\u306A\u30B9\u30DA\u30FC\u30B9\u3092\u524A\u9664"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("TRIM expects exactly one argument");
    }
    const [textArg] = args;
    const text = helpers.coerceText(textArg, "TRIM text");
    return text.replace(/\s+/gu, " ").trim();
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/upper.ts
var upperFunction = {
  name: "UPPER",
  category: "text",
  description: {
    en: "Converts text to uppercase using locale-aware rules.",
    ja: "\u30ED\u30B1\u30FC\u30EB\u306B\u5FDC\u3058\u305F\u898F\u5247\u3067\u6587\u5B57\u5217\u3092\u5927\u6587\u5B57\u306B\u5909\u63DB\u3057\u307E\u3059\u3002"
  },
  examples: ['UPPER("Spreadsheet")', "UPPER(A1)"],
  samples: [
    {
      input: 'UPPER("Spreadsheet")',
      output: "SPREADSHEET",
      description: {
        en: "Converts all letters to uppercase",
        ja: "\u5168\u3066\u306E\u6587\u5B57\u3092\u5927\u6587\u5B57\u306B\u5909\u63DB"
      }
    },
    {
      input: 'UPPER("hello world")',
      output: "HELLO WORLD",
      description: {
        en: "Converts lowercase text to uppercase",
        ja: "\u5C0F\u6587\u5B57\u30C6\u30AD\u30B9\u30C8\u3092\u5927\u6587\u5B57\u306B\u5909\u63DB"
      }
    },
    {
      input: 'UPPER("MixedCase123")',
      output: "MIXEDCASE123",
      description: {
        en: "Converts letters while preserving numbers",
        ja: "\u6570\u5B57\u3092\u4FDD\u6301\u3057\u3066\u6587\u5B57\u3092\u5927\u6587\u5B57\u5316"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("UPPER expects exactly one argument");
    }
    const [textArg] = args;
    const text = helpers.coerceText(textArg, "UPPER text");
    return text.toLocaleUpperCase();
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/lower.ts
var lowerFunction = {
  name: "LOWER",
  category: "text",
  description: {
    en: "Converts text to lowercase using locale-aware rules.",
    ja: "\u30ED\u30B1\u30FC\u30EB\u306B\u5FDC\u3058\u305F\u898F\u5247\u3067\u6587\u5B57\u5217\u3092\u5C0F\u6587\u5B57\u306B\u5909\u63DB\u3057\u307E\u3059\u3002"
  },
  examples: ['LOWER("SpreadSheet")', "LOWER(A1)"],
  samples: [
    {
      input: 'LOWER("SPREADSHEET")',
      output: "spreadsheet",
      description: {
        en: "Converts all letters to lowercase",
        ja: "\u5168\u3066\u306E\u6587\u5B57\u3092\u5C0F\u6587\u5B57\u306B\u5909\u63DB"
      }
    },
    {
      input: 'LOWER("Hello World")',
      output: "hello world",
      description: {
        en: "Converts uppercase text to lowercase",
        ja: "\u5927\u6587\u5B57\u30C6\u30AD\u30B9\u30C8\u3092\u5C0F\u6587\u5B57\u306B\u5909\u63DB"
      }
    },
    {
      input: 'LOWER("MixedCase123")',
      output: "mixedcase123",
      description: {
        en: "Converts letters while preserving numbers",
        ja: "\u6570\u5B57\u3092\u4FDD\u6301\u3057\u3066\u6587\u5B57\u3092\u5C0F\u6587\u5B57\u5316"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("LOWER expects exactly one argument");
    }
    const [textArg] = args;
    const text = helpers.coerceText(textArg, "LOWER text");
    return text.toLocaleLowerCase();
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/proper.ts
var LETTER_PATTERN = /\p{L}/u;
var isLetter2 = (character) => LETTER_PATTERN.test(character);
var properFunction = {
  name: "PROPER",
  category: "text",
  description: {
    en: "Capitalizes the first letter of each word and lowercases the rest.",
    ja: "\u5404\u5358\u8A9E\u306E\u5148\u982D\u6587\u5B57\u3092\u5927\u6587\u5B57\u306B\u3057\u3001\u6B8B\u308A\u3092\u5C0F\u6587\u5B57\u306B\u5909\u63DB\u3057\u307E\u3059\u3002"
  },
  examples: ['PROPER("hello WORLD")', "PROPER(A1)"],
  samples: [
    {
      input: 'PROPER("hello world")',
      output: "Hello World",
      description: {
        en: "Capitalizes first letter of each word",
        ja: "\u5404\u5358\u8A9E\u306E\u5148\u982D\u6587\u5B57\u3092\u5927\u6587\u5B57\u5316"
      }
    },
    {
      input: 'PROPER("SPREADSHEET DATA")',
      output: "Spreadsheet Data",
      description: {
        en: "Converts to proper case from uppercase",
        ja: "\u5927\u6587\u5B57\u304B\u3089\u9069\u5207\u306A\u5927\u6587\u5B57\u5C0F\u6587\u5B57\u306B\u5909\u63DB"
      }
    },
    {
      input: 'PROPER("john DOE")',
      output: "John Doe",
      description: {
        en: "Normalizes mixed case names",
        ja: "\u6DF7\u5408\u30B1\u30FC\u30B9\u306E\u540D\u524D\u3092\u6B63\u898F\u5316"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("PROPER expects exactly one argument");
    }
    const [textArg] = args;
    const text = helpers.coerceText(textArg, "PROPER text");
    const state = { shouldCapitalize: true };
    const result = Array.from(text).map((character) => {
      const lower = character.toLocaleLowerCase();
      if (isLetter2(lower)) {
        const next = state.shouldCapitalize ? lower.toLocaleUpperCase() : lower;
        state.shouldCapitalize = false;
        return next;
      }
      state.shouldCapitalize = true;
      return character;
    });
    return result.join("");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/replace.ts
var replaceFunction = {
  name: "REPLACE",
  category: "text",
  description: {
    en: "Replaces part of a text string with new text based on position and length.",
    ja: "\u6587\u5B57\u5217\u306E\u6307\u5B9A\u4F4D\u7F6E\u3068\u9577\u3055\u306B\u57FA\u3065\u3044\u3066\u65B0\u3057\u3044\u6587\u5B57\u5217\u306B\u7F6E\u304D\u63DB\u3048\u307E\u3059\u3002"
  },
  examples: ['REPLACE("Spreadsheet", 7, 4, "book")', 'REPLACE(A1, 1, 2, "X")'],
  samples: [
    {
      input: 'REPLACE("Spreadsheet", 7, 5, "book")',
      output: "Spreadbook",
      description: {
        en: "Replaces 5 characters at position 7 with 'book'",
        ja: "7\u6587\u5B57\u76EE\u304B\u30895\u6587\u5B57\u3092'book'\u306B\u7F6E\u63DB"
      }
    },
    {
      input: 'REPLACE("2024-01-15", 6, 2, "12")',
      output: "2024-12-15",
      description: {
        en: "Replaces month in date string",
        ja: "\u65E5\u4ED8\u6587\u5B57\u5217\u306E\u6708\u90E8\u5206\u3092\u7F6E\u63DB"
      }
    },
    {
      input: 'REPLACE("Hello World", 1, 5, "Hi")',
      output: "Hi World",
      description: {
        en: "Replaces first word with shorter text",
        ja: "\u6700\u521D\u306E\u5358\u8A9E\u3092\u3088\u308A\u77ED\u3044\u30C6\u30AD\u30B9\u30C8\u306B\u7F6E\u63DB"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 4) {
      throw new Error("REPLACE expects exactly four arguments");
    }
    const [textArg, startArg, lengthArg, newTextArg] = args;
    const text = helpers.coerceText(textArg, "REPLACE text");
    const startValue = helpers.requireNumber(startArg, "REPLACE position");
    const lengthValue = helpers.requireNumber(lengthArg, "REPLACE length");
    const startPosition = helpers.requireInteger(startValue, "REPLACE position must be an integer");
    const replaceLength = helpers.requireInteger(lengthValue, "REPLACE length must be an integer");
    if (startPosition < 1) {
      throw new Error("REPLACE position must be greater than or equal to 1");
    }
    if (replaceLength < 0) {
      throw new Error("REPLACE length must be non-negative");
    }
    const newText = helpers.coerceText(newTextArg, "REPLACE new_text");
    const characters = Array.from(text);
    const zeroBasedStart = startPosition - 1;
    const zeroBasedEnd = zeroBasedStart + replaceLength;
    const prefix = characters.slice(0, zeroBasedStart).join("");
    const suffix = characters.slice(Math.min(zeroBasedEnd, characters.length)).join("");
    return `${prefix}${newText}${suffix}`;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/substitute.ts
var substituteFunction = {
  name: "SUBSTITUTE",
  category: "text",
  description: {
    en: "Replaces occurrences of text with new text, optionally targeting a specific instance.",
    ja: "\u6587\u5B57\u5217\u306E\u51FA\u73FE\u7B87\u6240\u3092\u65B0\u3057\u3044\u6587\u5B57\u5217\u306B\u7F6E\u304D\u63DB\u3048\u3001\u6307\u5B9A\u56DE\u306E\u307F\u7F6E\u63DB\u3059\u308B\u3053\u3068\u3082\u53EF\u80FD\u3067\u3059\u3002"
  },
  examples: ['SUBSTITUTE("banana", "a", "o")', 'SUBSTITUTE(A1, ".", "-", 1)'],
  samples: [
    {
      input: 'SUBSTITUTE("banana", "a", "o")',
      output: "bonono",
      description: {
        en: "Replaces all occurrences of 'a' with 'o'",
        ja: "\u5168\u3066\u306E'a'\u3092'o'\u306B\u7F6E\u63DB"
      }
    },
    {
      input: 'SUBSTITUTE("banana", "a", "o", 2)',
      output: "banona",
      description: {
        en: "Replaces only the second occurrence of 'a'",
        ja: "2\u756A\u76EE\u306E'a'\u306E\u307F\u3092\u7F6E\u63DB"
      }
    },
    {
      input: 'SUBSTITUTE("2024.01.15", ".", "-")',
      output: "2024-01-15",
      description: {
        en: "Replaces all dots with hyphens",
        ja: "\u5168\u3066\u306E\u30C9\u30C3\u30C8\u3092\u30CF\u30A4\u30D5\u30F3\u306B\u7F6E\u63DB"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 3 || args.length > 4) {
      throw new Error("SUBSTITUTE expects three or four arguments");
    }
    const [textArg, oldTextArg, newTextArg, instanceArg] = args;
    const text = helpers.coerceText(textArg, "SUBSTITUTE text");
    const oldText = helpers.coerceText(oldTextArg, "SUBSTITUTE old_text");
    const newText = helpers.coerceText(newTextArg, "SUBSTITUTE new_text");
    if (oldText.length === 0) {
      throw new Error("SUBSTITUTE old_text must be non-empty");
    }
    if (instanceArg === undefined) {
      return text.split(oldText).join(newText);
    }
    const rawInstance = helpers.requireNumber(instanceArg, "SUBSTITUTE instance");
    const instanceNumber = helpers.requireInteger(rawInstance, "SUBSTITUTE instance must be an integer");
    if (instanceNumber <= 0) {
      throw new Error("SUBSTITUTE instance must be greater than or equal to 1");
    }
    const state = { searchIndex: 0, occurrence: 0 };
    while (state.searchIndex <= text.length) {
      const foundIndex = text.indexOf(oldText, state.searchIndex);
      if (foundIndex === -1) {
        return text;
      }
      state.occurrence += 1;
      if (state.occurrence === instanceNumber) {
        const prefix = text.slice(0, foundIndex);
        const suffix = text.slice(foundIndex + oldText.length);
        return `${prefix}${newText}${suffix}`;
      }
      state.searchIndex = foundIndex + oldText.length;
    }
    return text;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/find.ts
var toCharacters = (text) => Array.from(text);
var isMatchAt = (haystack, needle, startIndex) => {
  for (let index = 0;index < needle.length; index += 1) {
    if (haystack[startIndex + index] !== needle[index]) {
      return false;
    }
  }
  return true;
};
var findFunction = {
  name: "FIND",
  category: "text",
  description: {
    en: "Locates one text value within another, matching case and returning the position.",
    ja: "\u5927\u6587\u5B57\u5C0F\u6587\u5B57\u3092\u533A\u5225\u3057\u3066\u6587\u5B57\u5217\u5185\u306E\u4F4D\u7F6E\u3092\u691C\u7D22\u3057\u307E\u3059\u3002"
  },
  examples: ['FIND("sheet", "Spreadsheet")', 'FIND("-", A1, 3)'],
  samples: [
    {
      input: 'FIND("sheet", "Spreadsheet")',
      output: 7,
      description: {
        en: "Finds 'sheet' starting at position 7 (case-sensitive)",
        ja: "'sheet'\u304C7\u6587\u5B57\u76EE\u304B\u3089\u59CB\u307E\u308B\uFF08\u5927\u6587\u5B57\u5C0F\u6587\u5B57\u533A\u5225\uFF09"
      }
    },
    {
      input: 'FIND("-", "2024-01-15")',
      output: 5,
      description: {
        en: "Finds first hyphen at position 5",
        ja: "\u6700\u521D\u306E\u30CF\u30A4\u30D5\u30F3\u304C5\u6587\u5B57\u76EE"
      }
    },
    {
      input: 'FIND("-", "2024-01-15", 6)',
      output: 8,
      description: {
        en: "Finds next hyphen starting from position 6",
        ja: "6\u6587\u5B57\u76EE\u4EE5\u964D\u306E\u6B21\u306E\u30CF\u30A4\u30D5\u30F3\u3092\u691C\u7D22"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 2 || args.length > 3) {
      throw new Error("FIND expects two or three arguments");
    }
    const [needleArg, haystackArg, startArg] = args;
    const haystack = helpers.coerceText(haystackArg, "FIND within_text");
    const needle = helpers.coerceText(needleArg, "FIND find_text");
    const startValue = startArg === undefined ? 1 : helpers.requireNumber(startArg, "FIND start");
    const startPosition = helpers.requireInteger(startValue, "FIND start must be an integer");
    if (startPosition < 1) {
      throw new Error("FIND start must be greater than or equal to 1");
    }
    const haystackChars = toCharacters(haystack);
    const needleChars = toCharacters(needle);
    if (needleChars.length === 0) {
      if (startPosition > haystackChars.length + 1) {
        throw new Error("FIND start is beyond the length of within_text");
      }
      return startPosition;
    }
    if (startPosition > haystackChars.length) {
      throw new Error("FIND start is beyond the length of within_text");
    }
    const zeroBasedStart = startPosition - 1;
    const maxStart = haystackChars.length - needleChars.length;
    for (let index = zeroBasedStart;index <= maxStart; index += 1) {
      if (isMatchAt(haystackChars, needleChars, index)) {
        return index + 1;
      }
    }
    throw new Error("FIND could not locate the specified text");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/text/search.ts
var toCharacters2 = (text) => Array.from(text);
var isMatchAt2 = (haystack, needle, startIndex) => {
  for (let index = 0;index < needle.length; index += 1) {
    if (haystack[startIndex + index] !== needle[index]) {
      return false;
    }
  }
  return true;
};
var searchFunction = {
  name: "SEARCH",
  category: "text",
  description: {
    en: "Locates one text value within another without matching case.",
    ja: "\u5927\u6587\u5B57\u5C0F\u6587\u5B57\u3092\u533A\u5225\u305B\u305A\u306B\u6587\u5B57\u5217\u306E\u4F4D\u7F6E\u3092\u691C\u7D22\u3057\u307E\u3059\u3002"
  },
  examples: ['SEARCH("SHEET", "Spreadsheet")', 'SEARCH("-", A1, 2)'],
  samples: [
    {
      input: 'SEARCH("SHEET", "Spreadsheet")',
      output: 7,
      description: {
        en: "Finds 'sheet' at position 7 (case-insensitive)",
        ja: "'sheet'\u304C7\u6587\u5B57\u76EE\u304B\u3089\u59CB\u307E\u308B\uFF08\u5927\u6587\u5B57\u5C0F\u6587\u5B57\u533A\u5225\u306A\u3057\uFF09"
      }
    },
    {
      input: 'SEARCH("data", "Database")',
      output: 1,
      description: {
        en: "Finds 'data' at position 1 ignoring case",
        ja: "\u5927\u6587\u5B57\u5C0F\u6587\u5B57\u3092\u7121\u8996\u3057\u3066'data'\u30921\u6587\u5B57\u76EE\u306B\u767A\u898B"
      }
    },
    {
      input: 'SEARCH("-", "2024-01-15", 6)',
      output: 8,
      description: {
        en: "Finds hyphen starting from position 6",
        ja: "6\u6587\u5B57\u76EE\u4EE5\u964D\u306E\u30CF\u30A4\u30D5\u30F3\u3092\u691C\u7D22"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length < 2 || args.length > 3) {
      throw new Error("SEARCH expects two or three arguments");
    }
    const [needleArg, haystackArg, startArg] = args;
    const haystack = helpers.coerceText(haystackArg, "SEARCH within_text");
    const needle = helpers.coerceText(needleArg, "SEARCH find_text");
    const startValue = startArg === undefined ? 1 : helpers.requireNumber(startArg, "SEARCH start");
    const startPosition = helpers.requireInteger(startValue, "SEARCH start must be an integer");
    if (startPosition < 1) {
      throw new Error("SEARCH start must be greater than or equal to 1");
    }
    const haystackChars = toCharacters2(haystack.toLocaleLowerCase());
    const needleChars = toCharacters2(needle.toLocaleLowerCase());
    if (needleChars.length === 0) {
      if (startPosition > haystackChars.length + 1) {
        throw new Error("SEARCH start is beyond the length of within_text");
      }
      return startPosition;
    }
    if (startPosition > haystackChars.length) {
      throw new Error("SEARCH start is beyond the length of within_text");
    }
    const zeroBasedStart = startPosition - 1;
    const maxStart = haystackChars.length - needleChars.length;
    for (let index = zeroBasedStart;index <= maxStart; index += 1) {
      if (isMatchAt2(haystackChars, needleChars, index)) {
        return index + 1;
      }
    }
    throw new Error("SEARCH could not locate the specified text");
  }
};

// packages/@oxen-office/xlsx/src/domain/style/format-code/scan.ts
function scanFormatCodeSection(section, handlers) {
  const state = { inQuoted: false };
  for (let i2 = 0;i2 < section.length; i2 += 1) {
    const ch = section[i2];
    if (ch === "\\" && i2 + 1 < section.length) {
      const escaped = section[i2 + 1];
      handlers.onEscape?.(escaped, i2, i2 + 1, state);
      i2 += 1;
      continue;
    }
    if (ch === '"') {
      if (state.inQuoted && section[i2 + 1] === '"') {
        handlers.onQuotedChar?.('"', i2);
        i2 += 1;
        continue;
      }
      state.inQuoted = !state.inQuoted;
      continue;
    }
    if (state.inQuoted) {
      handlers.onQuotedChar?.(ch, i2);
      continue;
    }
    if (ch === "[") {
      const end = section.indexOf("]", i2 + 1);
      if (end !== -1) {
        handlers.onBracketCode?.(section.slice(i2, end + 1), i2, end);
        i2 = end;
        continue;
      }
    }
    handlers.onChar?.(ch, i2, state);
  }
}

// packages/@oxen-office/xlsx/src/domain/style/format-code/normalize.ts
function stripQuotedStrings(formatCode) {
  return formatCode.replace(/"[^"]*"/gu, "");
}
function removeEscapes(section) {
  return section.replace(/\\./gu, "");
}
function removeBracketCodes(section) {
  return section.replace(/\[[^\]]+\]/gu, "");
}
function removeFillAndPadding(section) {
  return section.replace(/_.?/gu, "").replace(/\*.?/gu, "");
}
function removeLiteralsForPattern(section) {
  return removeFillAndPadding(removeBracketCodes(removeEscapes(stripQuotedStrings(section))));
}

// packages/@oxen-office/xlsx/src/domain/style/format-code/affix.ts
function findNumberPlaceholderIndices(section) {
  const state = { first: -1, last: -1 };
  scanFormatCodeSection(section, {
    onChar: (ch, index) => {
      if (ch !== "0" && ch !== "#") {
        return;
      }
      if (state.first === -1) {
        state.first = index;
      }
      state.last = index;
    }
  });
  return { first: state.first, last: state.last };
}
function unescapeAffix(text) {
  const noBrackets = removeBracketCodes(text);
  const noPadding = removeFillAndPadding(noBrackets);
  const unescaped = noPadding.replace(/\\(.)/gu, "$1");
  return unescaped.replace(/"([^"]*)"/gu, "$1");
}
function extractAffixes(section) {
  const { first, last } = findNumberPlaceholderIndices(section);
  if (first === -1) {
    return { prefix: unescapeAffix(section), suffix: "" };
  }
  const prefixRaw = section.slice(0, first);
  const suffixRaw = last === -1 ? "" : section.slice(last + 1);
  return { prefix: unescapeAffix(prefixRaw), suffix: unescapeAffix(suffixRaw) };
}

// packages/@oxen-office/xlsx/src/domain/style/format-code/number-section.ts
function countTrailingCommas(pattern) {
  const match = /,+$/u.exec(pattern);
  return match ? match[0].length : 0;
}
function stripTrailingCommas(pattern) {
  return pattern.replace(/,+$/u, "");
}
function splitIntegerAndFractionPatterns(cleanedPattern) {
  const dot = cleanedPattern.indexOf(".");
  if (dot === -1) {
    return { integer: cleanedPattern, fraction: "" };
  }
  return { integer: cleanedPattern.slice(0, dot), fraction: cleanedPattern.slice(dot + 1) };
}
function countPercentSigns(section) {
  const state = { count: 0 };
  scanFormatCodeSection(section, {
    onChar: (ch) => {
      if (ch === "%") {
        state.count += 1;
      }
    }
  });
  return state.count;
}
function parseNumberFormatSection(section) {
  const placeholders = findNumberPlaceholderIndices(section);
  if (placeholders.first === -1) {
    return { kind: "literal", literal: unescapeAffix(section) };
  }
  const cleaned = removeLiteralsForPattern(section);
  const cleanedTrimmed = cleaned.replace(/\s+$/u, "");
  const scaleCommas = countTrailingCommas(cleanedTrimmed);
  const cleanedNoScale = stripTrailingCommas(cleanedTrimmed);
  const { integer: integerPattern, fraction: fractionPattern } = splitIntegerAndFractionPatterns(cleanedNoScale);
  const { prefix, suffix } = extractAffixes(section);
  return {
    kind: "number",
    percentCount: countPercentSigns(section),
    scaleCommas,
    integerPattern,
    fractionPattern,
    prefix,
    suffix
  };
}

// packages/@oxen-office/xlsx/src/domain/style/format-code/sections.ts
function splitFormatSections(formatCode) {
  const sections = [];
  const state = { inQuoted: false, bufferParts: [] };
  for (let i2 = 0;i2 < formatCode.length; i2 += 1) {
    const ch = formatCode[i2];
    if (ch === "\\" && i2 + 1 < formatCode.length) {
      state.bufferParts.push(ch, formatCode[i2 + 1]);
      i2 += 1;
      continue;
    }
    if (ch === '"') {
      if (state.inQuoted && formatCode[i2 + 1] === '"') {
        state.bufferParts.push('""');
        i2 += 1;
        continue;
      }
      state.inQuoted = !state.inQuoted;
      state.bufferParts.push(ch);
      continue;
    }
    if (!state.inQuoted && ch === ";") {
      sections.push(state.bufferParts.join(""));
      state.bufferParts.length = 0;
      continue;
    }
    state.bufferParts.push(ch);
  }
  sections.push(state.bufferParts.join(""));
  return sections;
}

// packages/@oxen-office/xlsx/src/domain/style/format-code/section-picker.ts
function parseLeadingNumericCondition(section) {
  const trimmedStart = section.trimStart();
  const state = { index: 0 };
  while (state.index < trimmedStart.length) {
    const ch = trimmedStart[state.index];
    if (ch !== "[") {
      return null;
    }
    const end = trimmedStart.indexOf("]", state.index + 1);
    if (end === -1) {
      return null;
    }
    const inner = trimmedStart.slice(state.index + 1, end);
    const match = /^\s*(<=|>=|<>|<|>|=)\s*([-+]?(?:\d+(?:\.\d+)?|\.\d+))\s*$/u.exec(inner);
    if (match) {
      const op = match[1];
      const compareTo = Number(match[2]);
      if (!Number.isFinite(compareTo)) {
        return null;
      }
      return { op, compareTo };
    }
    state.index = end + 1;
  }
  return null;
}
function isNumericConditionMet(value, condition) {
  switch (condition.op) {
    case "<":
      return value < condition.compareTo;
    case "<=":
      return value <= condition.compareTo;
    case ">":
      return value > condition.compareTo;
    case ">=":
      return value >= condition.compareTo;
    case "=":
      return value === condition.compareTo;
    case "<>":
      return value !== condition.compareTo;
  }
}
function pickFormatSection(formatCode, value) {
  const sections = splitFormatSections(formatCode);
  const hasNegativeSection = sections.length > 1;
  if (sections.length <= 1) {
    const condition = parseLeadingNumericCondition(formatCode);
    if (condition && !isNumericConditionMet(value, condition)) {
      return { section: "General", hasNegativeSection: false };
    }
    return { section: formatCode, hasNegativeSection: false };
  }
  const parsedSections = sections.map((section) => ({ section, condition: parseLeadingNumericCondition(section) }));
  const hasCondition = parsedSections.some(({ condition }) => condition !== null);
  if (hasCondition) {
    for (const candidate of parsedSections) {
      if (candidate.condition && isNumericConditionMet(value, candidate.condition)) {
        return { section: candidate.section, hasNegativeSection };
      }
    }
    for (let i2 = parsedSections.length - 1;i2 >= 0; i2 -= 1) {
      const candidate = parsedSections[i2];
      if (candidate && candidate.condition === null) {
        return { section: candidate.section, hasNegativeSection };
      }
    }
    return { section: "General", hasNegativeSection };
  }
  if (value > 0) {
    return { section: sections[0], hasNegativeSection };
  }
  if (value < 0) {
    return { section: sections[1] ?? sections[0], hasNegativeSection };
  }
  return { section: sections[2] ?? sections[0], hasNegativeSection };
}

// packages/@oxen-office/xlsx/src/domain/style/formatters/date.ts
var MS_IN_DAY = 86400000;
function excelSerialToUtcDate1900(serial) {
  const days = Math.floor(serial);
  const fraction = serial - days;
  const timeMs = Math.round(fraction * MS_IN_DAY);
  const adjustedDays = days >= 60 ? days - 1 : days;
  const baseUtcMs = Date.UTC(1899, 11, 31);
  const dateUtcMs = baseUtcMs + adjustedDays * MS_IN_DAY + timeMs;
  return new Date(dateUtcMs);
}
function excelSerialToUtcDate(serial, dateSystem) {
  const normalizedSerial = dateSystem === "1904" ? serial + EXCEL_1904_TO_1900_DAY_OFFSET : serial;
  return excelSerialToUtcDate1900(normalizedSerial);
}
var WEEKDAY_SHORT = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
var WEEKDAY_LONG = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
var MONTH_SHORT = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var MONTH_LONG = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
function pad2(n) {
  return String(n).padStart(2, "0");
}
function looksLikeTimeMinutesContext(section, index) {
  const prev = index > 0 ? section[index - 1] : undefined;
  const next = index + 1 < section.length ? section[index + 1] : undefined;
  return prev === ":" || next === ":";
}
function formatAmPmToken(tokenRaw, hours24) {
  const lower = tokenRaw.toLowerCase();
  const isPm = hours24 >= 12;
  if (lower === "a/p") {
    const letter = isPm ? "P" : "A";
    return tokenRaw[0] === tokenRaw[0]?.toLowerCase() ? letter.toLowerCase() : letter.toUpperCase();
  }
  return isPm ? "PM" : "AM";
}
function removeNonTimeBracketCodes(section) {
  const parts = [];
  const quoteState = { inQuoted: false };
  for (let i2 = 0;i2 < section.length; i2 += 1) {
    const ch = section[i2];
    if (ch === "\\" && i2 + 1 < section.length) {
      parts.push(ch + section[i2 + 1]);
      i2 += 1;
      continue;
    }
    if (ch === '"') {
      quoteState.inQuoted = !quoteState.inQuoted;
      parts.push(ch);
      continue;
    }
    if (!quoteState.inQuoted && ch === "[") {
      const end = section.indexOf("]", i2 + 1);
      if (end !== -1) {
        const inner = section.slice(i2 + 1, end).toLowerCase();
        if (inner === "h" || inner === "hh" || inner === "m" || inner === "mm" || inner === "s" || inner === "ss") {
          parts.push(section.slice(i2, end + 1));
        }
        i2 = end;
        continue;
      }
    }
    parts.push(ch);
  }
  return parts.join("");
}
function buildDateTimeDetectionPattern(section) {
  return removeFillAndPadding(removeEscapes(stripQuotedStrings(removeNonTimeBracketCodes(section))));
}
function resolveTimeRoundingUnitMs(section) {
  const pattern = buildDateTimeDetectionPattern(section).toLowerCase();
  const maxFractionDigits = Math.min(3, Math.max(0, [...pattern.matchAll(/\.0+/gu)].reduce((acc, match) => Math.max(acc, match[0].length - 1), 0)));
  if (maxFractionDigits > 0) {
    return 10 ** (3 - maxFractionDigits);
  }
  if (pattern.includes("s")) {
    return 1000;
  }
  return 1;
}
function roundSerialByUnitMs(serial, unitMs) {
  if (unitMs <= 0) {
    throw new Error(`Expected unitMs > 0, got: ${unitMs}`);
  }
  return Math.round(serial * MS_IN_DAY / unitMs) * unitMs / MS_IN_DAY;
}
function parseDateFormatSection(section) {
  const raw = removeNonTimeBracketCodes(section);
  const rawLower = raw.toLowerCase();
  const usesElapsedTime = /\[(?:h+|m+|s+)\]/iu.test(rawLower);
  const hasElapsedHoursToken = /\[(?:h|hh)\]/iu.test(rawLower);
  const hasElapsedMinutesToken = /\[(?:m|mm)\]/iu.test(rawLower);
  const hasElapsedSecondsToken = /\[(?:s|ss)\]/iu.test(rawLower);
  const usesAmPm = rawLower.includes("am/pm") || rawLower.includes("a/p");
  const roundingUnitMs = resolveTimeRoundingUnitMs(raw);
  const tokens = [];
  const literalBuffer = [];
  const quoteState = { inQuoted: false };
  const flushLiteral = () => {
    if (literalBuffer.length === 0) {
      return;
    }
    tokens.push({ kind: "literal", text: literalBuffer.join("") });
    literalBuffer.length = 0;
  };
  for (let i2 = 0;i2 < raw.length; i2 += 1) {
    const ch = raw[i2];
    if (ch === "\\" && i2 + 1 < raw.length) {
      const next = raw[i2 + 1];
      if (next === '"') {
        quoteState.inQuoted = !quoteState.inQuoted;
      } else {
        literalBuffer.push(next);
      }
      i2 += 1;
      continue;
    }
    if (ch === '"') {
      quoteState.inQuoted = !quoteState.inQuoted;
      continue;
    }
    if (quoteState.inQuoted) {
      literalBuffer.push(ch);
      continue;
    }
    if (ch === "[" && i2 + 1 < raw.length) {
      const end = raw.indexOf("]", i2 + 1);
      if (end !== -1) {
        const innerRaw = raw.slice(i2 + 1, end);
        const inner = innerRaw.toLowerCase();
        if (inner === "h" || inner === "hh") {
          flushLiteral();
          tokens.push({ kind: "elapsedBracket", unit: "h", digits: inner === "hh" ? 2 : 1 });
          i2 = end;
          continue;
        }
        if (inner === "m" || inner === "mm") {
          flushLiteral();
          tokens.push({ kind: "elapsedBracket", unit: "m", digits: inner === "mm" ? 2 : 1 });
          i2 = end;
          continue;
        }
        if (inner === "s" || inner === "ss") {
          flushLiteral();
          tokens.push({ kind: "elapsedBracket", unit: "s", digits: inner === "ss" ? 2 : 1 });
          i2 = end;
          continue;
        }
      }
    }
    if (ch === "." && i2 + 1 < raw.length) {
      const zeroRun = /^[0]+/u.exec(raw.slice(i2 + 1));
      if (zeroRun) {
        flushLiteral();
        tokens.push({ kind: "fraction", digits: zeroRun[0].length });
        i2 += zeroRun[0].length;
        continue;
      }
    }
    const token = rawLower.slice(i2);
    if (token.startsWith("am/pm")) {
      flushLiteral();
      tokens.push({ kind: "ampm", raw: raw.slice(i2, i2 + "AM/PM".length) });
      i2 += "AM/PM".length - 1;
      continue;
    }
    if (token.startsWith("a/p")) {
      flushLiteral();
      tokens.push({ kind: "ampm", raw: raw.slice(i2, i2 + "A/P".length) });
      i2 += "A/P".length - 1;
      continue;
    }
    if (token.startsWith("dddd")) {
      flushLiteral();
      tokens.push({ kind: "weekday", long: true });
      i2 += 3;
      continue;
    }
    if (token.startsWith("ddd")) {
      flushLiteral();
      tokens.push({ kind: "weekday", long: false });
      i2 += 2;
      continue;
    }
    if (token.startsWith("yyyy")) {
      flushLiteral();
      tokens.push({ kind: "year", digits: 4 });
      i2 += 3;
      continue;
    }
    if (token.startsWith("yyy")) {
      flushLiteral();
      tokens.push({ kind: "year", digits: 3 });
      i2 += 2;
      continue;
    }
    if (token.startsWith("yy")) {
      flushLiteral();
      tokens.push({ kind: "year", digits: 2 });
      i2 += 1;
      continue;
    }
    if (token.startsWith("y")) {
      flushLiteral();
      tokens.push({ kind: "year", digits: 1 });
      continue;
    }
    if (token.startsWith("mmmm")) {
      flushLiteral();
      tokens.push({ kind: "monthName", long: true });
      i2 += 3;
      continue;
    }
    if (token.startsWith("mmm")) {
      flushLiteral();
      tokens.push({ kind: "monthName", long: false });
      i2 += 2;
      continue;
    }
    if (token.startsWith("mm")) {
      flushLiteral();
      tokens.push({ kind: "monthOrMinute", digits: 2, minuteContext: looksLikeTimeMinutesContext(rawLower, i2) });
      i2 += 1;
      continue;
    }
    if (token.startsWith("m")) {
      flushLiteral();
      tokens.push({ kind: "monthOrMinute", digits: 1, minuteContext: looksLikeTimeMinutesContext(rawLower, i2) });
      continue;
    }
    if (token.startsWith("dd")) {
      flushLiteral();
      tokens.push({ kind: "day", digits: 2 });
      i2 += 1;
      continue;
    }
    if (token.startsWith("d")) {
      flushLiteral();
      tokens.push({ kind: "day", digits: 1 });
      continue;
    }
    if (token.startsWith("hh")) {
      flushLiteral();
      tokens.push({ kind: "hour", digits: 2 });
      i2 += 1;
      continue;
    }
    if (token.startsWith("h")) {
      flushLiteral();
      tokens.push({ kind: "hour", digits: 1 });
      continue;
    }
    if (token.startsWith("ss")) {
      flushLiteral();
      tokens.push({ kind: "second", digits: 2 });
      i2 += 1;
      continue;
    }
    if (token.startsWith("s")) {
      flushLiteral();
      tokens.push({ kind: "second", digits: 1 });
      continue;
    }
    literalBuffer.push(ch);
  }
  flushLiteral();
  return {
    raw,
    tokens,
    usesElapsedTime,
    hasElapsedHoursToken,
    hasElapsedMinutesToken,
    hasElapsedSecondsToken,
    usesAmPm,
    roundingUnitMs
  };
}
function renderDateFormatSection(args) {
  const { parsed } = args;
  const roundedSerial = roundSerialByUnitMs(args.serial, parsed.roundingUnitMs);
  const date = parsed.usesElapsedTime ? undefined : excelSerialToUtcDate(roundedSerial, args.dateSystem);
  const y = date?.getUTCFullYear() ?? 0;
  const m = (date?.getUTCMonth() ?? 0) + 1;
  const d = date?.getUTCDate() ?? 0;
  const weekday = date?.getUTCDay() ?? 0;
  const hh = date?.getUTCHours() ?? 0;
  const mm = date?.getUTCMinutes() ?? 0;
  const ss = date?.getUTCSeconds() ?? 0;
  const ms = date?.getUTCMilliseconds() ?? 0;
  const elapsedTotalMs = parsed.usesElapsedTime ? Math.round(roundedSerial * MS_IN_DAY) : 0;
  const elapsedTotalSeconds = parsed.usesElapsedTime ? Math.floor(elapsedTotalMs / 1000) : 0;
  const elapsedMilliseconds = parsed.usesElapsedTime ? (elapsedTotalMs % 1000 + 1000) % 1000 : 0;
  const elapsedTotalMinutes = parsed.usesElapsedTime ? Math.floor(elapsedTotalSeconds / 60) : 0;
  const elapsedTotalHours = parsed.usesElapsedTime ? Math.floor(elapsedTotalMinutes / 60) : 0;
  const elapsedSecondsWithinMinute = parsed.usesElapsedTime ? (elapsedTotalSeconds % 60 + 60) % 60 : 0;
  const elapsedMinutesWithinHour = parsed.usesElapsedTime ? (elapsedTotalMinutes % 60 + 60) % 60 : 0;
  const elapsedHoursWithinDay = parsed.usesElapsedTime ? (elapsedTotalHours % 24 + 24) % 24 : 0;
  const resolveHourValue = () => {
    if (!parsed.usesElapsedTime) {
      return hh;
    }
    return parsed.hasElapsedHoursToken ? elapsedTotalHours : elapsedHoursWithinDay;
  };
  const parts = [];
  for (const token of parsed.tokens) {
    if (token.kind === "literal") {
      parts.push(token.text);
      continue;
    }
    if (token.kind === "elapsedBracket") {
      if (token.unit === "h") {
        const value2 = elapsedTotalHours;
        parts.push(token.digits === 2 ? String(value2).padStart(2, "0") : String(value2));
        continue;
      }
      if (token.unit === "m") {
        const value2 = elapsedTotalMinutes;
        parts.push(token.digits === 2 ? String(value2).padStart(2, "0") : String(value2));
        continue;
      }
      const value = elapsedTotalSeconds;
      parts.push(token.digits === 2 ? String(value).padStart(2, "0") : String(value));
      continue;
    }
    if (token.kind === "fraction") {
      const digits = token.digits;
      if (digits <= 3) {
        const divisor = 10 ** (3 - digits);
        const fractionDigits2 = parsed.usesElapsedTime ? elapsedMilliseconds : ms;
        const fraction = Math.floor(fractionDigits2 / divisor);
        parts.push(`.${String(fraction).padStart(digits, "0")}`);
        continue;
      }
      const fractionDigits = parsed.usesElapsedTime ? elapsedMilliseconds : ms;
      parts.push(`.${String(fractionDigits).padStart(3, "0")}${"0".repeat(digits - 3)}`);
      continue;
    }
    if (token.kind === "ampm") {
      parts.push(formatAmPmToken(token.raw, hh));
      continue;
    }
    if (token.kind === "weekday") {
      parts.push(token.long ? WEEKDAY_LONG[weekday] ?? "" : WEEKDAY_SHORT[weekday] ?? "");
      continue;
    }
    if (token.kind === "year") {
      if (token.digits >= 3) {
        parts.push(String(y));
        continue;
      }
      parts.push(pad2(y % 100));
      continue;
    }
    if (token.kind === "monthName") {
      parts.push(token.long ? MONTH_LONG[m - 1] ?? "" : MONTH_SHORT[m - 1] ?? "");
      continue;
    }
    if (token.kind === "monthOrMinute") {
      if (parsed.usesElapsedTime) {
        const value = parsed.hasElapsedMinutesToken ? elapsedTotalMinutes : elapsedMinutesWithinHour;
        parts.push(token.digits === 2 ? String(value).padStart(2, "0") : String(value));
        continue;
      }
      if (token.minuteContext) {
        parts.push(token.digits === 2 ? pad2(mm) : String(mm));
        continue;
      }
      parts.push(token.digits === 2 ? pad2(m) : String(m));
      continue;
    }
    if (token.kind === "day") {
      parts.push(token.digits === 2 ? pad2(d) : String(d));
      continue;
    }
    if (token.kind === "hour") {
      const hourValue = resolveHourValue();
      const hour12Base = hourValue % 12;
      const hour12 = hour12Base === 0 ? 12 : hour12Base;
      const outputValue = parsed.usesAmPm ? hour12 : hourValue;
      parts.push(token.digits === 2 ? pad2(outputValue) : String(outputValue));
      continue;
    }
    if (token.kind === "second") {
      if (parsed.usesElapsedTime) {
        const value = parsed.hasElapsedSecondsToken ? elapsedTotalSeconds : elapsedSecondsWithinMinute;
        parts.push(token.digits === 2 ? String(value).padStart(2, "0") : String(value));
        continue;
      }
      parts.push(token.digits === 2 ? pad2(ss) : String(ss));
      continue;
    }
  }
  return parts.join("");
}
function formatDateByCode(serial, section, dateSystem) {
  const parsed = parseDateFormatSection(section);
  return renderDateFormatSection({ parsed, serial, dateSystem });
}

// packages/@oxen-office/xlsx/src/domain/style/formatters/number.ts
function countIntegerZeros(integerPattern) {
  return [...integerPattern].filter((ch) => ch === "0").length;
}
function countFractionDigits(fractionPattern) {
  const digits = [...fractionPattern].filter((ch) => ch === "0" || ch === "#");
  const min = digits.filter((ch) => ch === "0").length;
  const max2 = digits.length;
  return { min, max: max2 };
}
function wantsGrouping(integerPattern) {
  return integerPattern.includes(",");
}
function isScientific(section) {
  return /E\+0+/iu.test(removeLiteralsForPattern(section));
}
function findScientificMarker(section) {
  const state = { inQuoted: false };
  for (let i2 = 0;i2 + 1 < section.length; i2 += 1) {
    const ch = section[i2];
    if (ch === "\\" && i2 + 1 < section.length) {
      i2 += 1;
      continue;
    }
    if (ch === '"') {
      if (state.inQuoted && section[i2 + 1] === '"') {
        i2 += 1;
        continue;
      }
      state.inQuoted = !state.inQuoted;
      continue;
    }
    if (state.inQuoted) {
      continue;
    }
    if (ch === "[") {
      const end = section.indexOf("]", i2 + 1);
      if (end !== -1) {
        i2 = end;
        continue;
      }
    }
    if (ch === "e" || ch === "E") {
      const sign = section[i2 + 1];
      if (sign === "+") {
        return { index: i2, letter: ch, signMode: "always" };
      }
      if (sign === "-") {
        return { index: i2, letter: ch, signMode: "negativeOnly" };
      }
    }
  }
  return null;
}
function parseNumericTemplate(template) {
  const integerPlaceholders = [];
  const fractionPlaceholders = [];
  const state = { inQuoted: false, inFraction: false, hasGrouping: false, hasDecimalPoint: false };
  for (let i2 = 0;i2 < template.length; i2 += 1) {
    const ch = template[i2];
    if (ch === "\\" && i2 + 1 < template.length) {
      i2 += 1;
      continue;
    }
    if (ch === '"') {
      if (state.inQuoted && template[i2 + 1] === '"') {
        i2 += 1;
        continue;
      }
      state.inQuoted = !state.inQuoted;
      continue;
    }
    if (state.inQuoted) {
      continue;
    }
    if (ch === "[") {
      const end = template.indexOf("]", i2 + 1);
      if (end !== -1) {
        i2 = end;
        continue;
      }
    }
    if (ch === ".") {
      state.inFraction = true;
      state.hasDecimalPoint = true;
      continue;
    }
    if (ch === ",") {
      if (!state.inFraction) {
        state.hasGrouping = true;
      }
      continue;
    }
    if (ch === "0" || ch === "#" || ch === "?") {
      if (state.inFraction) {
        fractionPlaceholders.push(ch);
      } else {
        integerPlaceholders.push(ch);
      }
    }
  }
  return {
    integerPlaceholders,
    fractionPlaceholders,
    hasGrouping: state.hasGrouping,
    hasDecimalPoint: state.hasDecimalPoint
  };
}
function trimOptionalFractionDigits(digits, placeholders) {
  const minDigits = placeholders.filter((ch) => ch === "0").length;
  const state = { end: digits.length, placeholderEnd: placeholders.length };
  while (state.end > minDigits && state.placeholderEnd > minDigits) {
    const digit = digits[state.end - 1];
    const placeholder = placeholders[state.placeholderEnd - 1];
    if (digit !== "0") {
      break;
    }
    if (placeholder === "0") {
      break;
    }
    state.end -= 1;
    state.placeholderEnd -= 1;
  }
  return { digits: digits.slice(0, state.end), placeholderCount: state.placeholderEnd };
}
function applyGroupingDigits(integerDigits) {
  const negative = integerDigits.startsWith("-");
  const digits = negative ? integerDigits.slice(1) : integerDigits;
  const grouped = digits.replace(/\B(?=(\d{3})+(?!\d))/gu, ",");
  return negative ? `-${grouped}` : grouped;
}
function splitNumericRuns(template) {
  const state = { inQuoted: false, foundStart: false };
  const startState = { start: -1, decimal: -1 };
  for (let i2 = 0;i2 < template.length; i2 += 1) {
    const ch = template[i2];
    if (ch === "\\" && i2 + 1 < template.length) {
      i2 += 1;
      continue;
    }
    if (ch === '"') {
      if (state.inQuoted && template[i2 + 1] === '"') {
        i2 += 1;
        continue;
      }
      state.inQuoted = !state.inQuoted;
      continue;
    }
    if (state.inQuoted) {
      continue;
    }
    if (ch === "[") {
      const end = template.indexOf("]", i2 + 1);
      if (end !== -1) {
        i2 = end;
        continue;
      }
    }
    if (!state.foundStart && (ch === "0" || ch === "#" || ch === "?" || ch === ",")) {
      state.foundStart = true;
      startState.start = i2;
      continue;
    }
    if (state.foundStart && startState.decimal === -1 && ch === ".") {
      startState.decimal = i2;
      continue;
    }
  }
  if (startState.start === -1) {
    return { prefix: template, integerRun: "", fractionRun: "", suffix: "", hasDecimalPoint: false, hasGrouping: false };
  }
  const integerRunStart = startState.start;
  const hasDecimalPoint = startState.decimal !== -1;
  const integerEndState = { end: startState.decimal === -1 ? template.length : startState.decimal };
  if (!hasDecimalPoint) {
    for (let i2 = integerRunStart;i2 < template.length; i2 += 1) {
      const ch = template[i2];
      if (ch === "0" || ch === "#" || ch === "?" || ch === ",") {
        integerEndState.end = i2 + 1;
        continue;
      }
      break;
    }
  }
  const integerRunEnd = integerEndState.end;
  const integerRun = template.slice(integerRunStart, integerRunEnd);
  const hasGrouping = integerRun.includes(",");
  if (startState.decimal === -1) {
    return {
      prefix: template.slice(0, integerRunStart),
      integerRun,
      fractionRun: "",
      suffix: template.slice(integerRunEnd),
      hasDecimalPoint,
      hasGrouping
    };
  }
  const fractionStart = startState.decimal + 1;
  const fractionState = { end: fractionStart };
  for (let i2 = fractionStart;i2 < template.length; i2 += 1) {
    const ch = template[i2];
    if (ch === "\\" && i2 + 1 < template.length) {
      i2 += 1;
      continue;
    }
    if (ch === '"') {
      break;
    }
    if (ch === "[") {
      break;
    }
    if (ch === "0" || ch === "#" || ch === "?" || ch === ",") {
      fractionState.end = i2 + 1;
      continue;
    }
    break;
  }
  const fractionRun = template.slice(fractionStart, fractionState.end);
  return {
    prefix: template.slice(0, integerRunStart),
    integerRun,
    fractionRun,
    suffix: template.slice(fractionState.end),
    hasDecimalPoint,
    hasGrouping
  };
}
function formatNumberByTemplate(value, template) {
  const runs = splitNumericRuns(template);
  const integerPlaceholders = [...runs.integerRun].filter((ch) => ch === "0" || ch === "#" || ch === "?");
  const fractionPlaceholders = [...runs.fractionRun].filter((ch) => ch === "0" || ch === "#" || ch === "?");
  const maxFractionDigits = fractionPlaceholders.length;
  const minFractionDigits = fractionPlaceholders.filter((ch) => ch === "0").length;
  const absolute = Math.abs(value);
  const fixed = maxFractionDigits > 0 ? absolute.toFixed(maxFractionDigits) : `${Math.round(absolute)}`;
  const [integerRaw, fractionRaw = ""] = fixed.split(".");
  const integerDigits = integerRaw ?? "0";
  const fractionDigits = fractionRaw ?? "";
  const integerPlaceholderCount = integerPlaceholders.length;
  const integerOverflow = integerDigits.length > integerPlaceholderCount;
  const extraLeadingDigits = integerOverflow ? integerDigits.slice(0, integerDigits.length - integerPlaceholderCount) : "";
  const digitsToUse = integerOverflow ? integerDigits.slice(integerDigits.length - integerPlaceholderCount) : integerDigits;
  const integerState = { digitIndex: digitsToUse.length - 1, parts: [] };
  for (let i2 = integerPlaceholderCount - 1;i2 >= 0; i2 -= 1) {
    const placeholder = integerPlaceholders[i2];
    const digit = integerState.digitIndex >= 0 ? digitsToUse[integerState.digitIndex] : undefined;
    integerState.digitIndex -= 1;
    if (digit !== undefined) {
      integerState.parts.push(digit);
      continue;
    }
    if (placeholder === "0") {
      integerState.parts.push("0");
      continue;
    }
    if (placeholder === "?") {
      integerState.parts.push(" ");
      continue;
    }
  }
  const integerCoreRaw = `${extraLeadingDigits}${integerState.parts.reverse().join("")}`;
  const integerCore = runs.hasGrouping ? applyGroupingDigits(integerCoreRaw.replace(/^ +/u, "")) : integerCoreRaw;
  const trimmedFraction = trimOptionalFractionDigits(fractionDigits, fractionPlaceholders);
  const fractionPlaceholdersUsed = fractionPlaceholders.slice(0, trimmedFraction.placeholderCount);
  const fractionState = { index: 0, parts: [] };
  for (const placeholder of fractionPlaceholdersUsed) {
    const digit = trimmedFraction.digits[fractionState.index];
    if (digit !== undefined) {
      fractionState.parts.push(digit);
      fractionState.index += 1;
      continue;
    }
    if (placeholder === "0") {
      fractionState.parts.push("0");
      continue;
    }
    if (placeholder === "?") {
      fractionState.parts.push(" ");
      continue;
    }
  }
  const fractionCore = fractionState.parts.join("");
  const includeDecimal = runs.hasDecimalPoint && (fractionCore.length > 0 || minFractionDigits > 0);
  const sign = value < 0 ? "-" : "";
  return `${unescapeAffix(runs.prefix)}${sign}${integerCore}${includeDecimal ? `.${fractionCore}` : ""}${unescapeAffix(runs.suffix)}`;
}
function formatExponentByTemplate(exponent, template, signMode) {
  const signText = exponent < 0 ? "-" : signMode === "always" ? "+" : "";
  const digits = String(Math.abs(exponent));
  const placeholders = [...template].filter((ch) => ch === "0" || ch === "#" || ch === "?");
  const placeholderCount = placeholders.length;
  const minDigits = placeholders.filter((ch) => ch === "0").length;
  const padded = digits.padStart(Math.max(minDigits, placeholderCount), "0");
  const state = { digitIndex: 0, signInserted: false };
  const out = [];
  const templateState = { inQuoted: false };
  for (let i2 = 0;i2 < template.length; i2 += 1) {
    const ch = template[i2];
    if (ch === "\\" && i2 + 1 < template.length) {
      out.push(template[i2 + 1]);
      i2 += 1;
      continue;
    }
    if (ch === '"') {
      templateState.inQuoted = !templateState.inQuoted;
      continue;
    }
    if (templateState.inQuoted) {
      out.push(ch);
      continue;
    }
    if (ch === "[") {
      const end = template.indexOf("]", i2 + 1);
      if (end !== -1) {
        i2 = end;
        continue;
      }
    }
    if (ch === ",") {
      continue;
    }
    if (ch !== "0" && ch !== "#" && ch !== "?") {
      out.push(ch);
      continue;
    }
    if (!state.signInserted) {
      out.push(signText);
      state.signInserted = true;
    }
    const digit = state.digitIndex < padded.length ? padded[state.digitIndex] : undefined;
    state.digitIndex += 1;
    if (digit !== undefined) {
      out.push(digit);
      continue;
    }
    if (ch === "0") {
      out.push("0");
      continue;
    }
    if (ch === "?") {
      out.push(" ");
      continue;
    }
  }
  return out.join("");
}
function resolveApproxScientificDigitsShown(args) {
  if (args.abs >= 1) {
    const digitsBeforeDecimal = args.log10Floor + 1;
    if (digitsBeforeDecimal <= args.maxMantissaIntegerDigits) {
      return digitsBeforeDecimal;
    }
    return args.maxMantissaIntegerDigits >= 4 ? 2 : 1;
  }
  return args.maxMantissaIntegerDigits >= 7 ? 3 : args.maxMantissaIntegerDigits;
}
function trimDecimalString(value) {
  if (!value.includes(".")) {
    return value;
  }
  const trimmed = value.replace(/0+$/u, "").replace(/\.$/u, "");
  return trimmed.length === 0 ? "0" : trimmed;
}
function scientificToDecimal(mantissa, exponent) {
  const negative = mantissa.startsWith("-");
  const mantissaAbs = negative ? mantissa.slice(1) : mantissa;
  const [integerPartRaw, fractionPartRaw = ""] = mantissaAbs.split(".");
  const digits = `${integerPartRaw ?? ""}${fractionPartRaw}`;
  const normalizedDigits = digits.length > 0 ? digits : "0";
  const pointIndex = (integerPartRaw ?? "").length + exponent;
  const signPrefix = negative ? "-" : "";
  if (/^0+$/u.test(normalizedDigits)) {
    return "0";
  }
  if (pointIndex <= 0) {
    const zeros = "0".repeat(Math.max(0, -pointIndex));
    return `${signPrefix}0.${zeros}${normalizedDigits}`;
  }
  if (pointIndex >= normalizedDigits.length) {
    const zeros = "0".repeat(Math.max(0, pointIndex - normalizedDigits.length));
    return `${signPrefix}${normalizedDigits}${zeros}`;
  }
  return `${signPrefix}${normalizedDigits.slice(0, pointIndex)}.${normalizedDigits.slice(pointIndex)}`;
}
function normalizeScientificText(value) {
  const match = /^([-+]?(?:\d+(?:\.\d+)?|\.\d+))[eE]([-+]?\d+)$/u.exec(value);
  if (!match) {
    return value;
  }
  const mantissa = trimDecimalString(match[1] ?? "");
  const exponentNumber = Number.parseInt(match[2] ?? "0", 10);
  const sign = exponentNumber >= 0 ? "+" : "-";
  const abs = Math.abs(exponentNumber);
  return `${mantissa}E${sign}${abs}`;
}
function formatGeneralNumber(value) {
  if (!Number.isFinite(value)) {
    return String(value);
  }
  if (Object.is(value, -0) || value === 0) {
    return "0";
  }
  const sign = value < 0 ? "-" : "";
  const abs = Math.abs(value);
  if (abs >= 100000000000 || abs < 0.000000001) {
    return `${sign}${normalizeScientificText(abs.toExponential(14))}`;
  }
  const raw = abs.toPrecision(15);
  const expMatch = /^(\d+(?:\.\d+)?|\.\d+)[eE]([-+]?\d+)$/u.exec(raw);
  if (!expMatch) {
    return `${sign}${trimDecimalString(raw)}`;
  }
  const mantissa = expMatch[1] ?? "0";
  const exponent = Number.parseInt(expMatch[2] ?? "0", 10);
  if (!Number.isFinite(exponent)) {
    return `${sign}${trimDecimalString(raw)}`;
  }
  const decimal = scientificToDecimal(mantissa, exponent);
  const trimmed = trimDecimalString(decimal);
  if (trimmed.startsWith("-")) {
    return trimmed;
  }
  return `${sign}${trimmed}`;
}
function formatNumberByCode(value, formatCode, options) {
  const { section, hasNegativeSection } = pickFormatSection(formatCode, value);
  const cleaned = removeLiteralsForPattern(section);
  const trimmed = cleaned.trim();
  if (trimmed === "General" || trimmed === "@") {
    return formatGeneralNumber(value);
  }
  const marker = findScientificMarker(section);
  if (marker) {
    const mantissaTemplate = section.slice(0, marker.index);
    const exponentTemplate = section.slice(marker.index + 2);
    const parsed2 = parseNumericTemplate(mantissaTemplate);
    const abs = Math.abs(value);
    if (abs === 0) {
      const mantissa2 = formatNumberByTemplate(0, mantissaTemplate);
      const exponent2 = formatExponentByTemplate(0, exponentTemplate, marker.signMode);
      return `${mantissa2}${marker.letter}${exponent2}`;
    }
    const maxMantissaIntegerDigits = Math.max(1, parsed2.integerPlaceholders.length);
    const log10Floor = Math.floor(Math.log10(abs));
    const digitsShown = resolveApproxScientificDigitsShown({ abs, log10Floor, maxMantissaIntegerDigits });
    const exponent = log10Floor - (digitsShown - 1);
    const mantissaValue = abs / 10 ** exponent;
    const mantissa = formatNumberByTemplate(mantissaValue, mantissaTemplate);
    const exponentText = formatExponentByTemplate(exponent, exponentTemplate, marker.signMode);
    const signPrefix = value < 0 && !hasNegativeSection ? "-" : "";
    return `${signPrefix}${mantissa}${marker.letter}${exponentText}`;
  }
  const datePattern = buildDateTimeDetectionPattern(section);
  if (isDateFormat(datePattern)) {
    return formatDateByCode(value, section, options?.dateSystem ?? "1900");
  }
  const parsed = parseNumberFormatSection(section);
  if (parsed.kind === "literal") {
    return parsed.literal;
  }
  const scaled = value * 100 ** parsed.percentCount / 1000 ** parsed.scaleCommas;
  if (isScientific(section)) {
    const templateNoScale = parsed.fractionPattern.length > 0 ? `${parsed.integerPattern}.${parsed.fractionPattern}` : parsed.integerPattern;
    const expDigitsMatch = /E\+0+/iu.exec(templateNoScale);
    const expDigits = expDigitsMatch ? expDigitsMatch[0].length - 2 : 2;
    const dot = templateNoScale.indexOf(".");
    const fractionPatternForDigits = dot === -1 ? "" : templateNoScale.slice(dot + 1);
    const { min, max: max2 } = countFractionDigits(fractionPatternForDigits);
    const decimals = Math.max(min, max2);
    const exp = scaled.toExponential(decimals);
    const [mantissa, exponentRaw] = exp.split("e");
    const exponent = Number.parseInt(exponentRaw ?? "0", 10);
    const sign = exponent >= 0 ? "+" : "-";
    const abs = Math.abs(exponent);
    return `${mantissa}E${sign}${String(abs).padStart(expDigits, "0")}`;
  }
  const minIntegerDigits = Math.max(1, countIntegerZeros(parsed.integerPattern));
  const { min: minFractionDigits, max: maxFractionDigits } = countFractionDigits(parsed.fractionPattern);
  const grouping = wantsGrouping(parsed.integerPattern);
  const formatter = new Intl.NumberFormat("en-US", {
    useGrouping: grouping,
    minimumIntegerDigits: minIntegerDigits,
    minimumFractionDigits: minFractionDigits,
    maximumFractionDigits: maxFractionDigits
  });
  const isNegative = scaled < 0;
  const formattedCore = formatter.format(Math.abs(scaled));
  const suffixWithoutScale = parsed.suffix.replace(/^,+/u, "");
  const negativePrefix = isNegative && !hasNegativeSection ? "-" : "";
  return `${negativePrefix}${parsed.prefix}${formattedCore}${suffixWithoutScale}`;
}

// packages/@oxen-office/xlsx/src/domain/style/formatters/text.ts
function parseTextSection(section) {
  const tokens = [];
  const buffer = [];
  const state = { skipNextAfterPaddingOrFill: false };
  const flush = () => {
    if (buffer.length === 0) {
      return;
    }
    tokens.push({ kind: "literal", text: buffer.join("") });
    buffer.length = 0;
  };
  scanFormatCodeSection(section, {
    onEscape: (escaped) => {
      buffer.push(escaped);
    },
    onBracketCode: () => {},
    onChar: (ch, index) => {
      if (state.skipNextAfterPaddingOrFill) {
        state.skipNextAfterPaddingOrFill = false;
        return;
      }
      if (ch === "_" || ch === "*") {
        flush();
        state.skipNextAfterPaddingOrFill = true;
        return;
      }
      if (ch === "@") {
        flush();
        tokens.push({ kind: "value" });
        return;
      }
      buffer.push(ch);
    },
    onQuotedChar: (ch) => {
      buffer.push(ch);
    }
  });
  flush();
  return tokens;
}
function renderTextSection(valueText, tokens) {
  const parts = [];
  for (const token of tokens) {
    if (token.kind === "literal") {
      parts.push(token.text);
      continue;
    }
    parts.push(valueText);
  }
  return parts.join("");
}
function formatTextByCode(valueText, formatCode) {
  const sections = splitFormatSections(formatCode);
  if (sections.length >= 4) {
    const section = sections[3] ?? "";
    return renderTextSection(valueText, parseTextSection(section));
  }
  return valueText;
}

// packages/@oxen-office/xlsx/src/domain/style/format-value.ts
function formatNumberByCode2(value, formatCode, options) {
  return formatNumberByCode(value, formatCode, options);
}
function formatTextByCode2(valueText, formatCode) {
  return formatTextByCode(valueText, formatCode);
}

// packages/@oxen-office/xlsx/src/formula/functions/text/text.ts
var textFunction = {
  name: "TEXT",
  category: "text",
  description: {
    en: "Formats a value as text according to a specified number format code.",
    ja: "\u6307\u5B9A\u3057\u305F\u6570\u5024\u66F8\u5F0F\u30B3\u30FC\u30C9\u306B\u5F93\u3063\u3066\u5024\u3092\u6587\u5B57\u5217\u306B\u5909\u63DB\u3057\u307E\u3059\u3002"
  },
  examples: ['TEXT(12.34, "0.00")', 'TEXT(314159, "#,##0.00")', 'TEXT(A1, "000.00")'],
  samples: [
    {
      input: 'TEXT(12.3, "000.00")',
      output: "012.30"
    },
    {
      input: 'TEXT(314159, "#,##0.00")',
      output: "314,159.00"
    }
  ],
  evaluateLazy: (nodes, context) => {
    if (nodes.length !== 2) {
      throw new Error("TEXT expects two arguments");
    }
    const valueResult = context.helpers.coerceScalar(context.evaluate(nodes[0]), "TEXT value");
    const formatText = context.helpers.coerceText(context.evaluate(nodes[1]), "TEXT format_text");
    if (typeof valueResult === "number") {
      return formatNumberByCode2(valueResult, formatText, { dateSystem: context.dateSystem });
    }
    return formatTextByCode2(context.helpers.valueToText(valueResult), formatText);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/engineering/trigonometric.ts
var assertSingleArgument = (argsLength, functionName) => {
  if (argsLength !== 1) {
    throw new Error(`${functionName} expects exactly one argument`);
  }
};
var sinFunction = {
  name: "SIN",
  category: "engineering",
  description: {
    en: "Returns the sine of an angle specified in radians.",
    ja: "\u30E9\u30B8\u30A2\u30F3\u3067\u6307\u5B9A\u3057\u305F\u89D2\u5EA6\u306E\u30B5\u30A4\u30F3\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["SIN(PI()/2)"],
  samples: [
    {
      input: "SIN(0)",
      output: 0,
      description: {
        en: "Sine of 0 radians is 0",
        ja: "0\u30E9\u30B8\u30A2\u30F3\u306E\u30B5\u30A4\u30F3\u306F0"
      }
    },
    {
      input: "SIN(1.5708)",
      output: 1,
      description: {
        en: "Sine of \u03C0/2 (approximately 1.5708) is 1",
        ja: "\u03C0/2\uFF08\u7D041.5708\uFF09\u306E\u30B5\u30A4\u30F3\u306F1"
      }
    },
    {
      input: "SIN(3.14159)",
      output: 0,
      description: {
        en: "Sine of \u03C0 (approximately 3.14159) is approximately 0",
        ja: "\u03C0\uFF08\u7D043.14159\uFF09\u306E\u30B5\u30A4\u30F3\u306F\u7D040"
      }
    }
  ],
  evaluate: (args, helpers) => {
    assertSingleArgument(args.length, "SIN");
    const angle = helpers.requireNumber(args[0], "SIN angle");
    return Math.sin(angle);
  }
};
var cosFunction = {
  name: "COS",
  category: "engineering",
  description: {
    en: "Returns the cosine of an angle specified in radians.",
    ja: "\u30E9\u30B8\u30A2\u30F3\u3067\u6307\u5B9A\u3057\u305F\u89D2\u5EA6\u306E\u30B3\u30B5\u30A4\u30F3\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["COS(0)"],
  samples: [
    {
      input: "COS(0)",
      output: 1,
      description: {
        en: "Cosine of 0 radians is 1",
        ja: "0\u30E9\u30B8\u30A2\u30F3\u306E\u30B3\u30B5\u30A4\u30F3\u306F1"
      }
    },
    {
      input: "COS(1.5708)",
      output: 0,
      description: {
        en: "Cosine of \u03C0/2 (approximately 1.5708) is 0",
        ja: "\u03C0/2\uFF08\u7D041.5708\uFF09\u306E\u30B3\u30B5\u30A4\u30F3\u306F0"
      }
    },
    {
      input: "COS(3.14159)",
      output: -1,
      description: {
        en: "Cosine of \u03C0 (approximately 3.14159) is -1",
        ja: "\u03C0\uFF08\u7D043.14159\uFF09\u306E\u30B3\u30B5\u30A4\u30F3\u306F-1"
      }
    }
  ],
  evaluate: (args, helpers) => {
    assertSingleArgument(args.length, "COS");
    const angle = helpers.requireNumber(args[0], "COS angle");
    return Math.cos(angle);
  }
};
var tanFunction = {
  name: "TAN",
  category: "engineering",
  description: {
    en: "Returns the tangent of an angle specified in radians.",
    ja: "\u30E9\u30B8\u30A2\u30F3\u3067\u6307\u5B9A\u3057\u305F\u89D2\u5EA6\u306E\u30BF\u30F3\u30B8\u30A7\u30F3\u30C8\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["TAN(PI()/4)"],
  samples: [
    {
      input: "TAN(0)",
      output: 0,
      description: {
        en: "Tangent of 0 radians is 0",
        ja: "0\u30E9\u30B8\u30A2\u30F3\u306E\u30BF\u30F3\u30B8\u30A7\u30F3\u30C8\u306F0"
      }
    },
    {
      input: "TAN(0.7854)",
      output: 1,
      description: {
        en: "Tangent of \u03C0/4 (approximately 0.7854) is 1",
        ja: "\u03C0/4\uFF08\u7D040.7854\uFF09\u306E\u30BF\u30F3\u30B8\u30A7\u30F3\u30C8\u306F1"
      }
    },
    {
      input: "TAN(1)",
      output: 1.5574,
      description: {
        en: "Tangent of 1 radian is approximately 1.5574",
        ja: "1\u30E9\u30B8\u30A2\u30F3\u306E\u30BF\u30F3\u30B8\u30A7\u30F3\u30C8\u306F\u7D041.5574"
      }
    }
  ],
  evaluate: (args, helpers) => {
    assertSingleArgument(args.length, "TAN");
    const angle = helpers.requireNumber(args[0], "TAN angle");
    return Math.tan(angle);
  }
};
var asinFunction = {
  name: "ASIN",
  category: "engineering",
  description: {
    en: "Returns the arcsine of a value, in radians.",
    ja: "\u5024\u306E\u9006\u30B5\u30A4\u30F3\u3092\u30E9\u30B8\u30A2\u30F3\u3067\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ASIN(1)"],
  samples: [
    {
      input: "ASIN(0)",
      output: 0,
      description: {
        en: "Arcsine of 0 is 0 radians",
        ja: "0\u306E\u9006\u30B5\u30A4\u30F3\u306F0\u30E9\u30B8\u30A2\u30F3"
      }
    },
    {
      input: "ASIN(0.5)",
      output: 0.5236,
      description: {
        en: "Arcsine of 0.5 is \u03C0/6 (approximately 0.5236)",
        ja: "0.5\u306E\u9006\u30B5\u30A4\u30F3\u306F\u03C0/6\uFF08\u7D040.5236\uFF09"
      }
    },
    {
      input: "ASIN(1)",
      output: 1.5708,
      description: {
        en: "Arcsine of 1 is \u03C0/2 (approximately 1.5708)",
        ja: "1\u306E\u9006\u30B5\u30A4\u30F3\u306F\u03C0/2\uFF08\u7D041.5708\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    assertSingleArgument(args.length, "ASIN");
    const value = helpers.requireNumber(args[0], "ASIN value");
    if (value < -1 || value > 1) {
      throw new Error("ASIN value must be between -1 and 1");
    }
    return Math.asin(value);
  }
};
var acosFunction = {
  name: "ACOS",
  category: "engineering",
  description: {
    en: "Returns the arccosine of a value, in radians.",
    ja: "\u5024\u306E\u9006\u30B3\u30B5\u30A4\u30F3\u3092\u30E9\u30B8\u30A2\u30F3\u3067\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ACOS(0)"],
  samples: [
    {
      input: "ACOS(1)",
      output: 0,
      description: {
        en: "Arccosine of 1 is 0 radians",
        ja: "1\u306E\u9006\u30B3\u30B5\u30A4\u30F3\u306F0\u30E9\u30B8\u30A2\u30F3"
      }
    },
    {
      input: "ACOS(0.5)",
      output: 1.0472,
      description: {
        en: "Arccosine of 0.5 is \u03C0/3 (approximately 1.0472)",
        ja: "0.5\u306E\u9006\u30B3\u30B5\u30A4\u30F3\u306F\u03C0/3\uFF08\u7D041.0472\uFF09"
      }
    },
    {
      input: "ACOS(0)",
      output: 1.5708,
      description: {
        en: "Arccosine of 0 is \u03C0/2 (approximately 1.5708)",
        ja: "0\u306E\u9006\u30B3\u30B5\u30A4\u30F3\u306F\u03C0/2\uFF08\u7D041.5708\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    assertSingleArgument(args.length, "ACOS");
    const value = helpers.requireNumber(args[0], "ACOS value");
    if (value < -1 || value > 1) {
      throw new Error("ACOS value must be between -1 and 1");
    }
    return Math.acos(value);
  }
};
var atanFunction = {
  name: "ATAN",
  category: "engineering",
  description: {
    en: "Returns the arctangent of a value, in radians.",
    ja: "\u5024\u306E\u9006\u30BF\u30F3\u30B8\u30A7\u30F3\u30C8\u3092\u30E9\u30B8\u30A2\u30F3\u3067\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ATAN(1)"],
  samples: [
    {
      input: "ATAN(0)",
      output: 0,
      description: {
        en: "Arctangent of 0 is 0 radians",
        ja: "0\u306E\u9006\u30BF\u30F3\u30B8\u30A7\u30F3\u30C8\u306F0\u30E9\u30B8\u30A2\u30F3"
      }
    },
    {
      input: "ATAN(1)",
      output: 0.7854,
      description: {
        en: "Arctangent of 1 is \u03C0/4 (approximately 0.7854)",
        ja: "1\u306E\u9006\u30BF\u30F3\u30B8\u30A7\u30F3\u30C8\u306F\u03C0/4\uFF08\u7D040.7854\uFF09"
      }
    },
    {
      input: "ATAN(-1)",
      output: -0.7854,
      description: {
        en: "Arctangent of -1 is -\u03C0/4 (approximately -0.7854)",
        ja: "-1\u306E\u9006\u30BF\u30F3\u30B8\u30A7\u30F3\u30C8\u306F-\u03C0/4\uFF08\u7D04-0.7854\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    assertSingleArgument(args.length, "ATAN");
    const value = helpers.requireNumber(args[0], "ATAN value");
    return Math.atan(value);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/engineering/hyperbolic.ts
var assertSingleArgument2 = (argsLength, functionName) => {
  if (argsLength !== 1) {
    throw new Error(`${functionName} expects exactly one argument`);
  }
};
var sinhFunction = {
  name: "SINH",
  category: "engineering",
  description: {
    en: "Returns the hyperbolic sine of a number.",
    ja: "\u6570\u5024\u306E\u53CC\u66F2\u7DDA\u30B5\u30A4\u30F3\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["SINH(0.5)"],
  samples: [
    {
      input: "SINH(0)",
      output: 0,
      description: {
        en: "Hyperbolic sine of 0 is 0",
        ja: "0\u306E\u53CC\u66F2\u7DDA\u30B5\u30A4\u30F3\u306F0"
      }
    },
    {
      input: "SINH(1)",
      output: 1.1752,
      description: {
        en: "Hyperbolic sine of 1 is approximately 1.1752",
        ja: "1\u306E\u53CC\u66F2\u7DDA\u30B5\u30A4\u30F3\u306F\u7D041.1752"
      }
    },
    {
      input: "SINH(-1)",
      output: -1.1752,
      description: {
        en: "Hyperbolic sine of -1 is approximately -1.1752",
        ja: "-1\u306E\u53CC\u66F2\u7DDA\u30B5\u30A4\u30F3\u306F\u7D04-1.1752"
      }
    }
  ],
  evaluate: (args, helpers) => {
    assertSingleArgument2(args.length, "SINH");
    const value = helpers.requireNumber(args[0], "SINH value");
    return Math.sinh(value);
  }
};
var coshFunction = {
  name: "COSH",
  category: "engineering",
  description: {
    en: "Returns the hyperbolic cosine of a number.",
    ja: "\u6570\u5024\u306E\u53CC\u66F2\u7DDA\u30B3\u30B5\u30A4\u30F3\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["COSH(0.5)"],
  samples: [
    {
      input: "COSH(0)",
      output: 1,
      description: {
        en: "Hyperbolic cosine of 0 is 1",
        ja: "0\u306E\u53CC\u66F2\u7DDA\u30B3\u30B5\u30A4\u30F3\u306F1"
      }
    },
    {
      input: "COSH(1)",
      output: 1.5431,
      description: {
        en: "Hyperbolic cosine of 1 is approximately 1.5431",
        ja: "1\u306E\u53CC\u66F2\u7DDA\u30B3\u30B5\u30A4\u30F3\u306F\u7D041.5431"
      }
    },
    {
      input: "COSH(2)",
      output: 3.7622,
      description: {
        en: "Hyperbolic cosine of 2 is approximately 3.7622",
        ja: "2\u306E\u53CC\u66F2\u7DDA\u30B3\u30B5\u30A4\u30F3\u306F\u7D043.7622"
      }
    }
  ],
  evaluate: (args, helpers) => {
    assertSingleArgument2(args.length, "COSH");
    const value = helpers.requireNumber(args[0], "COSH value");
    return Math.cosh(value);
  }
};
var tanhFunction = {
  name: "TANH",
  category: "engineering",
  description: {
    en: "Returns the hyperbolic tangent of a number.",
    ja: "\u6570\u5024\u306E\u53CC\u66F2\u7DDA\u30BF\u30F3\u30B8\u30A7\u30F3\u30C8\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["TANH(0.5)"],
  samples: [
    {
      input: "TANH(0)",
      output: 0,
      description: {
        en: "Hyperbolic tangent of 0 is 0",
        ja: "0\u306E\u53CC\u66F2\u7DDA\u30BF\u30F3\u30B8\u30A7\u30F3\u30C8\u306F0"
      }
    },
    {
      input: "TANH(1)",
      output: 0.7616,
      description: {
        en: "Hyperbolic tangent of 1 is approximately 0.7616",
        ja: "1\u306E\u53CC\u66F2\u7DDA\u30BF\u30F3\u30B8\u30A7\u30F3\u30C8\u306F\u7D040.7616"
      }
    },
    {
      input: "TANH(2)",
      output: 0.964,
      description: {
        en: "Hyperbolic tangent of 2 is approximately 0.9640",
        ja: "2\u306E\u53CC\u66F2\u7DDA\u30BF\u30F3\u30B8\u30A7\u30F3\u30C8\u306F\u7D040.9640"
      }
    }
  ],
  evaluate: (args, helpers) => {
    assertSingleArgument2(args.length, "TANH");
    const value = helpers.requireNumber(args[0], "TANH value");
    return Math.tanh(value);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/engineering/conversion.ts
var assertSingleArgument3 = (argsLength, functionName) => {
  if (argsLength !== 1) {
    throw new Error(`${functionName} expects exactly one argument`);
  }
};
var RADIANS_PER_DEGREE = Math.PI / 180;
var DEGREES_PER_RADIAN = 180 / Math.PI;
var degreesFunction = {
  name: "DEGREES",
  category: "engineering",
  description: {
    en: "Converts radians to degrees.",
    ja: "\u30E9\u30B8\u30A2\u30F3\u5024\u3092\u5EA6\u306B\u5909\u63DB\u3057\u307E\u3059\u3002"
  },
  examples: ["DEGREES(PI())"],
  samples: [
    {
      input: "DEGREES(0)",
      output: 0,
      description: {
        en: "0 radians equals 0 degrees",
        ja: "0\u30E9\u30B8\u30A2\u30F3\u306F0\u5EA6"
      }
    },
    {
      input: "DEGREES(1.5708)",
      output: 90,
      description: {
        en: "\u03C0/2 radians (approximately 1.5708) equals 90 degrees",
        ja: "\u03C0/2\u30E9\u30B8\u30A2\u30F3\uFF08\u7D041.5708\uFF09\u306F90\u5EA6"
      }
    },
    {
      input: "DEGREES(3.14159)",
      output: 180,
      description: {
        en: "\u03C0 radians (approximately 3.14159) equals 180 degrees",
        ja: "\u03C0\u30E9\u30B8\u30A2\u30F3\uFF08\u7D043.14159\uFF09\u306F180\u5EA6"
      }
    }
  ],
  evaluate: (args, helpers) => {
    assertSingleArgument3(args.length, "DEGREES");
    const radians = helpers.requireNumber(args[0], "DEGREES radians");
    return radians * DEGREES_PER_RADIAN;
  }
};
var radiansFunction = {
  name: "RADIANS",
  category: "engineering",
  description: {
    en: "Converts degrees to radians.",
    ja: "\u5EA6\u3092\u30E9\u30B8\u30A2\u30F3\u5024\u306B\u5909\u63DB\u3057\u307E\u3059\u3002"
  },
  examples: ["RADIANS(180)"],
  samples: [
    {
      input: "RADIANS(0)",
      output: 0,
      description: {
        en: "0 degrees equals 0 radians",
        ja: "0\u5EA6\u306F0\u30E9\u30B8\u30A2\u30F3"
      }
    },
    {
      input: "RADIANS(90)",
      output: 1.5708,
      description: {
        en: "90 degrees equals \u03C0/2 radians (approximately 1.5708)",
        ja: "90\u5EA6\u306F\u03C0/2\u30E9\u30B8\u30A2\u30F3\uFF08\u7D041.5708\uFF09"
      }
    },
    {
      input: "RADIANS(180)",
      output: 3.14159,
      description: {
        en: "180 degrees equals \u03C0 radians (approximately 3.14159)",
        ja: "180\u5EA6\u306F\u03C0\u30E9\u30B8\u30A2\u30F3\uFF08\u7D043.14159\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    assertSingleArgument3(args.length, "RADIANS");
    const degrees = helpers.requireNumber(args[0], "RADIANS degrees");
    return degrees * RADIANS_PER_DEGREE;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/engineering/bessel.ts
var BESSEL_MAX_ITERATIONS = 500;
var BESSEL_TOLERANCE = 0.000000000001;
var computeBesselSeries = (order, x2, alternating) => {
  const halfX = x2 / 2;
  const state = { term: 1, sum: 0 };
  if (order > 0) {
    for (let k = 1;k <= order; k += 1) {
      state.term *= halfX / k;
    }
  }
  state.sum = state.term;
  for (let m = 0;m < BESSEL_MAX_ITERATIONS; m += 1) {
    const denominator = (m + 1) * (m + 1 + order);
    if (denominator === 0) {
      throw new Error("Bessel series encountered zero denominator");
    }
    const ratioBase = halfX * halfX / denominator;
    const ratio = alternating ? -ratioBase : ratioBase;
    state.term *= ratio;
    state.sum += state.term;
    if (!Number.isFinite(state.term) || !Number.isFinite(state.sum)) {
      throw new Error("Bessel series failed to converge");
    }
    const magnitude = Math.abs(state.sum);
    const tolerance = magnitude > 1 ? BESSEL_TOLERANCE * magnitude : BESSEL_TOLERANCE;
    if (Math.abs(state.term) < tolerance) {
      break;
    }
  }
  return state.sum;
};
var besseliFunction = {
  name: "BESSELI",
  category: "engineering",
  description: {
    en: "Returns the modified Bessel function of the first kind.",
    ja: "\u7B2C1\u7A2E\u5909\u5F62\u30D9\u30C3\u30BB\u30EB\u95A2\u6570\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["BESSELI(1, 0)", "BESSELI(2, 1.5)"],
  samples: [
    {
      input: "BESSELI(0, 0)",
      output: 1,
      description: {
        en: "Modified Bessel I\u2080(0) equals 1",
        ja: "\u5909\u5F62\u30D9\u30C3\u30BB\u30EBI\u2080(0)\u306F1"
      }
    },
    {
      input: "BESSELI(1, 0)",
      output: 1.2661,
      description: {
        en: "Modified Bessel I\u2080(1) is approximately 1.2661",
        ja: "\u5909\u5F62\u30D9\u30C3\u30BB\u30EBI\u2080(1)\u306F\u7D041.2661"
      }
    },
    {
      input: "BESSELI(1, 1)",
      output: 0.5652,
      description: {
        en: "Modified Bessel I\u2081(1) is approximately 0.5652",
        ja: "\u5909\u5F62\u30D9\u30C3\u30BB\u30EBI\u2081(1)\u306F\u7D040.5652"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2) {
      throw new Error("BESSELI expects exactly two arguments");
    }
    const x2 = helpers.requireNumber(args[0], "BESSELI value");
    const orderCandidate = helpers.requireNumber(args[1], "BESSELI order");
    const order = helpers.requireInteger(orderCandidate, "BESSELI order must be an integer");
    if (order < 0) {
      throw new Error("BESSELI order must be non-negative");
    }
    return computeBesselSeries(order, x2, false);
  }
};
var besseljFunction = {
  name: "BESSELJ",
  category: "engineering",
  description: {
    en: "Returns the Bessel function of the first kind.",
    ja: "\u7B2C1\u7A2E\u30D9\u30C3\u30BB\u30EB\u95A2\u6570\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["BESSELJ(0, 1)", "BESSELJ(1, 2.5)"],
  samples: [
    {
      input: "BESSELJ(0, 0)",
      output: 1,
      description: {
        en: "Bessel J\u2080(0) equals 1",
        ja: "\u30D9\u30C3\u30BB\u30EBJ\u2080(0)\u306F1"
      }
    },
    {
      input: "BESSELJ(1, 0)",
      output: 0.7652,
      description: {
        en: "Bessel J\u2080(1) is approximately 0.7652",
        ja: "\u30D9\u30C3\u30BB\u30EBJ\u2080(1)\u306F\u7D040.7652"
      }
    },
    {
      input: "BESSELJ(1, 1)",
      output: 0.4401,
      description: {
        en: "Bessel J\u2081(1) is approximately 0.4401",
        ja: "\u30D9\u30C3\u30BB\u30EBJ\u2081(1)\u306F\u7D040.4401"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2) {
      throw new Error("BESSELJ expects exactly two arguments");
    }
    const x2 = helpers.requireNumber(args[0], "BESSELJ value");
    const orderCandidate = helpers.requireNumber(args[1], "BESSELJ order");
    const order = helpers.requireInteger(orderCandidate, "BESSELJ order must be an integer");
    if (order < 0) {
      throw new Error("BESSELJ order must be non-negative");
    }
    return computeBesselSeries(order, x2, true);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/engineering/delta.ts
var deltaFunction = {
  name: "DELTA",
  category: "engineering",
  description: {
    en: "Tests whether two numbers are equal.",
    ja: "2\u3064\u306E\u6570\u5024\u304C\u7B49\u3057\u3044\u304B\u3069\u3046\u304B\u3092\u5224\u5B9A\u3057\u307E\u3059\u3002"
  },
  examples: ["DELTA(5, 5)", "DELTA(3)"],
  samples: [
    {
      input: "DELTA(5, 5)",
      output: 1,
      description: {
        en: "Returns 1 when numbers are equal",
        ja: "\u6570\u5024\u304C\u7B49\u3057\u3044\u3068\u304D\u306F1\u3092\u8FD4\u3059"
      }
    },
    {
      input: "DELTA(5, 3)",
      output: 0,
      description: {
        en: "Returns 0 when numbers are different",
        ja: "\u6570\u5024\u304C\u7570\u306A\u308B\u3068\u304D\u306F0\u3092\u8FD4\u3059"
      }
    },
    {
      input: "DELTA(0)",
      output: 1,
      description: {
        en: "Single argument compares with 0 (returns 1 when value is 0)",
        ja: "\u5F15\u65701\u3064\u306E\u5834\u5408\u306F0\u3068\u6BD4\u8F03\uFF08\u5024\u304C0\u306E\u5834\u5408\u306F1\u3092\u8FD4\u3059\uFF09"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length === 0 || args.length > 2) {
      throw new Error("DELTA expects one or two arguments");
    }
    const x2 = helpers.requireNumber(args[0], "DELTA number1");
    const y = args.length === 2 ? helpers.requireNumber(args[1], "DELTA number2") : 0;
    return x2 === y ? 1 : 0;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/engineering/erf.ts
var TWO_OVER_SQRT_PI = 2 / Math.sqrt(Math.PI);
var ERF_SERIES_TOLERANCE = 0.000000000000001;
var ERF_SERIES_MAX_ITERATIONS = 80;
var ERFC_TOLERANCE = 0.000000000000001;
var ERFC_MAX_ITERATIONS = 60;
var computeErfSeries = (x2) => {
  if (x2 === 0) {
    return 0;
  }
  const state = { term: x2, sum: x2 };
  for (let n = 1;n < ERF_SERIES_MAX_ITERATIONS; n += 1) {
    state.term *= -x2 * x2 / n;
    const contribution = state.term / (2 * n + 1);
    state.sum += contribution;
    if (Math.abs(contribution) < ERF_SERIES_TOLERANCE) {
      break;
    }
  }
  return TWO_OVER_SQRT_PI * state.sum;
};
var computeErfcComplement = (x2) => {
  const inverseSquare = 1 / (x2 * x2);
  const state = { term: 1, sum: 1 };
  for (let n = 1;n < ERFC_MAX_ITERATIONS; n += 1) {
    state.term *= -((2 * n - 1) * inverseSquare) / 2;
    state.sum += state.term;
    if (Math.abs(state.term) < ERFC_TOLERANCE) {
      break;
    }
  }
  const prefactor = Math.exp(-x2 * x2) / (x2 * Math.sqrt(Math.PI));
  return prefactor * state.sum;
};
var computeErf = (x2) => {
  if (!Number.isFinite(x2)) {
    return x2 < 0 ? -1 : 1;
  }
  if (x2 === 0) {
    return 0;
  }
  const sign = x2 < 0 ? -1 : 1;
  const absX = Math.abs(x2);
  if (absX <= 2) {
    return sign * computeErfSeries(absX);
  }
  const complement = computeErfcComplement(absX);
  return sign * (1 - complement);
};
var computeErfc = (x2) => {
  if (!Number.isFinite(x2)) {
    return x2 < 0 ? 2 : 0;
  }
  if (x2 <= 0) {
    return 1 - computeErf(x2);
  }
  if (x2 <= 2) {
    return 1 - computeErf(x2);
  }
  return computeErfcComplement(x2);
};
var erfFunction = {
  name: "ERF",
  category: "engineering",
  description: {
    en: "Returns the integral of the Gaussian distribution.",
    ja: "\u30AC\u30A6\u30B9\u5206\u5E03\u306E\u7A4D\u5206\u5024\uFF08\u8AA4\u5DEE\u95A2\u6570\uFF09\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ERF(1)", "ERF(0, 1)"],
  samples: [
    {
      input: "ERF(0)",
      output: 0,
      description: {
        en: "Error function of 0 is 0",
        ja: "0\u306E\u8AA4\u5DEE\u95A2\u6570\u306F0"
      }
    },
    {
      input: "ERF(1)",
      output: 0.8427,
      description: {
        en: "Error function of 1 is approximately 0.8427",
        ja: "1\u306E\u8AA4\u5DEE\u95A2\u6570\u306F\u7D040.8427"
      }
    },
    {
      input: "ERF(0, 1)",
      output: 0.8427,
      description: {
        en: "Error function between 0 and 1",
        ja: "0\u304B\u30891\u307E\u3067\u306E\u8AA4\u5DEE\u95A2\u6570"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length === 0 || args.length > 2) {
      throw new Error("ERF expects one or two arguments");
    }
    const lower = helpers.requireNumber(args[0], "ERF lower limit");
    if (args.length === 1) {
      return computeErf(lower);
    }
    const upper = helpers.requireNumber(args[1], "ERF upper limit");
    return computeErf(upper) - computeErf(lower);
  }
};
var erfcFunction = {
  name: "ERFC",
  category: "engineering",
  description: {
    en: "Returns the complementary error function.",
    ja: "\u76F8\u88DC\u8AA4\u5DEE\u95A2\u6570\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["ERFC(1)"],
  samples: [
    {
      input: "ERFC(0)",
      output: 1,
      description: {
        en: "Complementary error function of 0 is 1",
        ja: "0\u306E\u76F8\u88DC\u8AA4\u5DEE\u95A2\u6570\u306F1"
      }
    },
    {
      input: "ERFC(1)",
      output: 0.1573,
      description: {
        en: "Complementary error function of 1 is approximately 0.1573",
        ja: "1\u306E\u76F8\u88DC\u8AA4\u5DEE\u95A2\u6570\u306F\u7D040.1573"
      }
    },
    {
      input: "ERFC(2)",
      output: 0.0047,
      description: {
        en: "Complementary error function of 2 is approximately 0.0047",
        ja: "2\u306E\u76F8\u88DC\u8AA4\u5DEE\u95A2\u6570\u306F\u7D040.0047"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("ERFC expects exactly one argument");
    }
    const value = helpers.requireNumber(args[0], "ERFC value");
    return computeErfc(value);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/matrix/matrixHelpers.ts
var ensureNumericEntry = (params) => {
  const { value, description, rowIndex, columnIndex } = params;
  if (typeof value !== "number" || Number.isNaN(value)) {
    throw new Error(`${description} requires numeric values (row ${rowIndex + 1}, column ${columnIndex + 1})`);
  }
  return value;
};
var normalizeNumericMatrix = (range2, description) => {
  const table = toLookupTable(range2, description);
  if (table.length === 0 || table[0]?.length === 0) {
    throw new Error(`${description} requires a non-empty matrix`);
  }
  return table.map((row, rowIndex) => {
    return row.map((value, columnIndex) => ensureNumericEntry({ value, description, rowIndex, columnIndex }));
  });
};
var requireSquareMatrix = (matrix, description) => {
  const columnCount = matrix[0]?.length ?? 0;
  if (matrix.length !== columnCount) {
    throw new Error(`${description} requires a square matrix`);
  }
  return matrix;
};
var cloneMatrix = (matrix) => {
  return matrix.map((row) => row.slice());
};
var createIdentityMatrix = (size) => {
  return Array.from({ length: size }, (_, rowIndex) => {
    return Array.from({ length: size }, (_2, columnIndex) => rowIndex === columnIndex ? 1 : 0);
  });
};
var MATRIX_TOLERANCE = 0.000000000001;

// packages/@oxen-office/xlsx/src/formula/functions/matrix/mmult.ts
var multiplyMatrices = (left, right, description) => {
  const sharedDimension = left[0]?.length ?? 0;
  if (sharedDimension === 0) {
    throw new Error(`${description} requires non-empty matrices`);
  }
  if (right.length !== sharedDimension) {
    throw new Error(`${description} requires the number of columns in the first matrix to match the number of rows in the second matrix`);
  }
  const rightColumnCount = right[0]?.length ?? 0;
  if (rightColumnCount === 0) {
    throw new Error(`${description} requires non-empty matrices`);
  }
  return left.map((leftRow) => {
    return Array.from({ length: rightColumnCount }, (_, columnIndex) => {
      return leftRow.reduce((total, leftValue, sharedIndex) => {
        const rightValue = right[sharedIndex]?.[columnIndex];
        if (typeof rightValue !== "number") {
          throw new Error(`${description} requires rectangular matrices`);
        }
        return total + leftValue * rightValue;
      }, 0);
    });
  });
};
var mmultFunction = {
  name: "MMULT",
  category: "matrix",
  description: {
    en: "Returns the matrix product of two arrays.",
    ja: "2\u3064\u306E\u914D\u5217\u306E\u884C\u5217\u7A4D\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["MMULT({1,2;3,4},{5;6})", "MMULT(A1:B2, C1:D2)"],
  samples: [
    {
      input: "MMULT({{1, 2}; {3, 4}}, {{5}; {6}})",
      output: [[17], [39]],
      description: {
        en: "2x2 matrix multiplied by 2x1 column vector",
        ja: "2x2\u884C\u5217\u30682x1\u5217\u30D9\u30AF\u30C8\u30EB\u306E\u4E57\u7B97"
      }
    },
    {
      input: "MMULT({{1, 2}}, {{3, 4}; {5, 6}})",
      output: [[13, 16]],
      description: {
        en: "1x2 row vector multiplied by 2x2 matrix",
        ja: "1x2\u884C\u30D9\u30AF\u30C8\u30EB\u30682x2\u884C\u5217\u306E\u4E57\u7B97"
      }
    },
    {
      input: "MMULT({{1, 0}; {0, 1}}, {{2, 3}; {4, 5}})",
      output: [[2, 3], [4, 5]],
      description: {
        en: "Identity matrix multiplied by 2x2 matrix",
        ja: "\u5358\u4F4D\u884C\u5217\u30682x2\u884C\u5217\u306E\u4E57\u7B97"
      }
    }
  ],
  evaluate: (args) => {
    if (args.length !== 2) {
      throw new Error("MMULT expects exactly two arguments");
    }
    const left = normalizeNumericMatrix(args[0], "MMULT");
    const right = normalizeNumericMatrix(args[1], "MMULT");
    return multiplyMatrices(left, right, "MMULT");
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/matrix/minverse.ts
var findPivotRow = (matrix, pivotIndex) => {
  const size = matrix.length;
  for (let rowIndex = pivotIndex;rowIndex < size; rowIndex += 1) {
    if (Math.abs(matrix[rowIndex]?.[pivotIndex] ?? 0) > MATRIX_TOLERANCE) {
      return rowIndex;
    }
  }
  return;
};
var swapRows = (matrix, rowA, rowB) => {
  const temp = matrix[rowA];
  matrix[rowA] = matrix[rowB];
  matrix[rowB] = temp;
};
var scaleRow = (matrix, rowIndex, factor) => {
  matrix[rowIndex] = matrix[rowIndex]?.map((value) => value / factor) ?? [];
};
var eliminateColumn = (matrix, pivotIndex, rowIndex) => {
  const pivotRow = matrix[pivotIndex];
  const currentRow = matrix[rowIndex];
  if (!pivotRow || !currentRow) {
    return;
  }
  const factor = currentRow[pivotIndex];
  matrix[rowIndex] = currentRow.map((value, columnIndex) => value - factor * (pivotRow[columnIndex] ?? 0));
};
var augmentMatrices = (left, right) => {
  return left.map((row, rowIndex) => {
    return [...row, ...right[rowIndex]];
  });
};
var extractRightHalf = (augmented, size) => {
  return augmented.map((row) => row.slice(size));
};
var invertMatrix = (matrix) => {
  const size = matrix.length;
  const augmented = augmentMatrices(cloneMatrix(matrix), createIdentityMatrix(size));
  for (let pivotIndex = 0;pivotIndex < size; pivotIndex += 1) {
    const pivotRowIndex = findPivotRow(augmented, pivotIndex);
    if (pivotRowIndex === undefined) {
      throw new Error("MINVERSE requires a non-singular matrix");
    }
    if (pivotRowIndex !== pivotIndex) {
      swapRows(augmented, pivotIndex, pivotRowIndex);
    }
    const pivotValue = augmented[pivotIndex]?.[pivotIndex];
    if (pivotValue === undefined || Math.abs(pivotValue) <= MATRIX_TOLERANCE) {
      throw new Error("MINVERSE requires a non-singular matrix");
    }
    scaleRow(augmented, pivotIndex, pivotValue);
    for (let rowIndex = 0;rowIndex < size; rowIndex += 1) {
      if (rowIndex !== pivotIndex) {
        eliminateColumn(augmented, pivotIndex, rowIndex);
      }
    }
  }
  return extractRightHalf(augmented, size);
};
var minverseFunction = {
  name: "MINVERSE",
  category: "matrix",
  description: {
    en: "Returns the inverse matrix for a square array.",
    ja: "\u6B63\u65B9\u884C\u5217\u306E\u9006\u884C\u5217\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["MINVERSE({1,2;3,4})", "MINVERSE(A1:C3)"],
  samples: [
    {
      input: "MINVERSE({{1, 0}; {0, 1}})",
      output: [[1, 0], [0, 1]],
      description: {
        en: "Inverse of identity matrix is itself",
        ja: "\u5358\u4F4D\u884C\u5217\u306E\u9006\u884C\u5217\u306F\u81EA\u5206\u81EA\u8EAB"
      }
    },
    {
      input: "MINVERSE({{1, 2}; {3, 4}})",
      output: [[-2, 1], [1.5, -0.5]],
      description: {
        en: "Inverse of a 2x2 matrix",
        ja: "2x2\u884C\u5217\u306E\u9006\u884C\u5217"
      }
    },
    {
      input: "MINVERSE({{2, 0}; {0, 2}})",
      output: [[0.5, 0], [0, 0.5]],
      description: {
        en: "Inverse of a diagonal matrix",
        ja: "\u5BFE\u89D2\u884C\u5217\u306E\u9006\u884C\u5217"
      }
    }
  ],
  evaluate: (args) => {
    if (args.length !== 1) {
      throw new Error("MINVERSE expects exactly one argument");
    }
    const matrix = requireSquareMatrix(normalizeNumericMatrix(args[0], "MINVERSE"), "MINVERSE");
    return invertMatrix(matrix);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/matrix/mdeterm.ts
var swapRowsImmutable = (matrix, rowA, rowB) => {
  return matrix.map((row, index) => {
    if (index === rowA) {
      return matrix[rowB] ? matrix[rowB].slice() : [];
    }
    if (index === rowB) {
      return matrix[rowA] ? matrix[rowA].slice() : [];
    }
    return row.slice();
  });
};
var eliminateBelowPivot = (matrix, pivotIndex, pivot) => {
  return matrix.map((row, rowIndex) => {
    if (rowIndex <= pivotIndex) {
      return row.slice();
    }
    const factor = (row[pivotIndex] ?? 0) / pivot;
    if (Math.abs(factor) <= MATRIX_TOLERANCE) {
      return row.slice();
    }
    return row.map((value, columnIndex) => {
      if (columnIndex < pivotIndex) {
        return 0;
      }
      const pivotValue = matrix[pivotIndex]?.[columnIndex] ?? 0;
      return (value ?? 0) - factor * pivotValue;
    });
  });
};
var computeDeterminant = (matrix) => {
  const size = matrix.length;
  const initialState = {
    working: cloneMatrix(matrix),
    determinant: 1,
    zeroDetected: false
  };
  const result = Array.from({ length: size }).reduce((state, _, pivotIndex) => {
    if (state.zeroDetected) {
      return state;
    }
    const pivotRowIndex = state.working.findIndex((row, rowIndex) => rowIndex >= pivotIndex && Math.abs(row?.[pivotIndex] ?? 0) > MATRIX_TOLERANCE);
    if (pivotRowIndex === -1) {
      return {
        working: state.working,
        determinant: 0,
        zeroDetected: true
      };
    }
    const swapped = pivotRowIndex === pivotIndex ? state.working : swapRowsImmutable(state.working, pivotIndex, pivotRowIndex);
    const adjustedDeterminant = pivotRowIndex === pivotIndex ? state.determinant : -state.determinant;
    const pivot = swapped[pivotIndex]?.[pivotIndex];
    if (pivot === undefined) {
      return {
        working: swapped,
        determinant: 0,
        zeroDetected: true
      };
    }
    const nextDeterminant = adjustedDeterminant * pivot;
    const nextWorking = eliminateBelowPivot(swapped, pivotIndex, pivot);
    return {
      working: nextWorking,
      determinant: nextDeterminant,
      zeroDetected: Math.abs(nextDeterminant) <= MATRIX_TOLERANCE
    };
  }, initialState);
  return Math.abs(result.determinant) <= MATRIX_TOLERANCE ? 0 : result.determinant;
};
var mdetermFunction = {
  name: "MDETERM",
  category: "matrix",
  description: {
    en: "Returns the determinant of a square matrix.",
    ja: "\u6B63\u65B9\u884C\u5217\u306E\u884C\u5217\u5F0F\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["MDETERM({1,2;3,4})", "MDETERM(A1:C3)"],
  samples: [
    {
      input: "MDETERM({{1, 0}; {0, 1}})",
      output: 1,
      description: {
        en: "Determinant of identity matrix is 1",
        ja: "\u5358\u4F4D\u884C\u5217\u306E\u884C\u5217\u5F0F\u306F1"
      }
    },
    {
      input: "MDETERM({{1, 2}; {3, 4}})",
      output: -2,
      description: {
        en: "Determinant of a 2x2 matrix is (1*4 - 2*3) = -2",
        ja: "2x2\u884C\u5217\u306E\u884C\u5217\u5F0F\u306F(1*4 - 2*3) = -2"
      }
    },
    {
      input: "MDETERM({{2, 0, 0}; {0, 3, 0}; {0, 0, 4}})",
      output: 24,
      description: {
        en: "Determinant of diagonal matrix is product of diagonal (2*3*4 = 24)",
        ja: "\u5BFE\u89D2\u884C\u5217\u306E\u884C\u5217\u5F0F\u306F\u5BFE\u89D2\u8981\u7D20\u306E\u7A4D(2*3*4 = 24)"
      }
    }
  ],
  evaluate: (args) => {
    if (args.length !== 1) {
      throw new Error("MDETERM expects exactly one argument");
    }
    const matrix = requireSquareMatrix(normalizeNumericMatrix(args[0], "MDETERM"), "MDETERM");
    return computeDeterminant(matrix);
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/matrix/transpose.ts
var transposeFunction = {
  name: "TRANSPOSE",
  category: "matrix",
  description: {
    en: "Returns the transpose of an array.",
    ja: "\u914D\u5217\u306E\u8EE2\u7F6E\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["TRANSPOSE({1,2,3})", "TRANSPOSE(A1:C2)"],
  samples: [
    {
      input: "TRANSPOSE({{1, 2, 3}})",
      output: [[1], [2], [3]],
      description: {
        en: "Transpose row vector to column vector",
        ja: "\u884C\u30D9\u30AF\u30C8\u30EB\u3092\u5217\u30D9\u30AF\u30C8\u30EB\u306B\u8EE2\u7F6E"
      }
    },
    {
      input: "TRANSPOSE({{1, 2}; {3, 4}})",
      output: [[1, 3], [2, 4]],
      description: {
        en: "Transpose 2x2 matrix",
        ja: "2x2\u884C\u5217\u306E\u8EE2\u7F6E"
      }
    },
    {
      input: "TRANSPOSE({{1, 2, 3}; {4, 5, 6}})",
      output: [[1, 4], [2, 5], [3, 6]],
      description: {
        en: "Transpose 2x3 to 3x2 matrix",
        ja: "2x3\u884C\u5217\u30923x2\u884C\u5217\u306B\u8EE2\u7F6E"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 1) {
      throw new Error("TRANSPOSE expects exactly one argument");
    }
    const source = args[0];
    if (!isArrayResult2(source)) {
      return helpers.coerceScalar(source, "TRANSPOSE value");
    }
    const table = toLookupTable(source, "TRANSPOSE");
    const rowCount = table.length;
    const columnCount = table[0]?.length ?? 0;
    if (columnCount === 0) {
      throw new Error("TRANSPOSE range cannot be empty");
    }
    return Array.from({ length: columnCount }, (_, columnIndex) => {
      return Array.from({ length: rowCount }, (_2, rowIndex) => {
        const value = table[rowIndex]?.[columnIndex] ?? null;
        return value === null || value === "" ? 0 : value;
      });
    });
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/matrix/frequency.ts
var collectNumericValues = (values) => {
  return values.reduce((collected, value) => {
    if (typeof value === "number" && Number.isFinite(value)) {
      collected.push(value);
    }
    return collected;
  }, []);
};
var validateAscendingBins = (bins, description) => {
  bins.forEach((bin, index) => {
    if (index > 0 && bin < bins[index - 1]) {
      throw new Error(`${description} bins must be sorted in ascending order`);
    }
  });
};
var computeFrequencyCounts = (data, bins) => {
  const sortedData = [...data].sort((left, right) => left - right);
  const binCounts = bins.map((bin, index) => {
    const lowerBound = index === 0 ? Number.NEGATIVE_INFINITY : bins[index - 1];
    return sortedData.filter((value) => value > lowerBound && value <= bin).length;
  });
  const beyondUpperBound = sortedData.filter((value) => value > bins[bins.length - 1]).length;
  return [...binCounts, beyondUpperBound];
};
var frequencyFunction = {
  name: "FREQUENCY",
  category: "matrix",
  description: {
    en: "Returns a frequency distribution as a vertical array.",
    ja: "\u5EA6\u6570\u5206\u5E03\u3092\u7E26\u65B9\u5411\u306E\u914D\u5217\u3068\u3057\u3066\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["FREQUENCY(A1:A10, B1:B3)"],
  samples: [
    {
      input: "FREQUENCY({1, 2, 3, 4, 5, 6}, {2, 4})",
      output: [[2], [2], [2]],
      description: {
        en: "Count values <=2, 2<x<=4, >4 (returns 2, 2, 2)",
        ja: "\u5024\u3092<=2\u30012<x<=4\u3001>4\u3067\u30AB\u30A6\u30F3\u30C8\uFF082\u30012\u30012\u3092\u8FD4\u3059\uFF09"
      }
    },
    {
      input: "FREQUENCY({10, 20, 30, 40}, {15, 25, 35})",
      output: [[1], [1], [1], [1]],
      description: {
        en: "Count data in bins <=15, 15<x<=25, 25<x<=35, >35",
        ja: "<=15\u300115<x<=25\u300125<x<=35\u3001>35\u306E\u7BC4\u56F2\u3067\u30C7\u30FC\u30BF\u3092\u30AB\u30A6\u30F3\u30C8"
      }
    },
    {
      input: "FREQUENCY({5, 5, 5, 15, 25, 25}, {10, 20})",
      output: [[3], [1], [2]],
      description: {
        en: "Count values <=10 (3), 10<x<=20 (1), >20 (2)",
        ja: "<=10 (3)\u300110<x<=20 (1)\u3001>20 (2)\u306E\u5024\u3092\u30AB\u30A6\u30F3\u30C8"
      }
    }
  ],
  evaluate: (args, helpers) => {
    if (args.length !== 2) {
      throw new Error("FREQUENCY expects exactly two arguments");
    }
    const dataValues = collectNumericValues(helpers.flattenResult(args[0]));
    const binValues = helpers.flattenResult(args[1]).map((value, index) => {
      if (typeof value !== "number" || Number.isNaN(value)) {
        throw new Error(`FREQUENCY bins must be numeric (index ${index + 1})`);
      }
      return value;
    });
    if (binValues.length === 0) {
      throw new Error("FREQUENCY bins array cannot be empty");
    }
    validateAscendingBins(binValues, "FREQUENCY");
    const counts = computeFrequencyCounts(dataValues, binValues);
    return counts.map((count) => [count]);
  }
};

// packages/@oxen-office/xlsx/src/formula/functionRegistry.ts
var registry = new Map;
var registeredHelpers = formulaFunctionHelpers;
var registerFormulaFunction = (definition) => {
  const normalizedName = definition.name.toUpperCase();
  if (registry.has(normalizedName)) {
    throw new Error(`Formula function "${definition.name}" is already registered`);
  }
  registry.set(normalizedName, {
    ...definition,
    name: normalizedName
  });
};
var getFormulaFunction = (name) => {
  return registry.get(name.toUpperCase());
};
var builtInFunctions = [
  sumFunction,
  productFunction,
  powerFunction,
  roundFunction,
  roundUpFunction,
  roundDownFunction,
  absFunction,
  isEvenFunction,
  intFunction,
  modFunction,
  quotientFunction,
  signFunction,
  sumIfFunction,
  sumIfsFunction,
  subtotalFunction,
  aggregateFunction,
  dateFunction,
  timeFunction,
  dateValueFunction,
  timeValueFunction,
  todayFunction,
  nowFunction,
  eDateFunction,
  eoMonthFunction,
  dayFunction,
  monthFunction,
  yearFunction,
  weekDayFunction,
  weekNumFunction,
  workdayFunction,
  pmtFunction,
  ipmtFunction,
  ppmtFunction,
  pvFunction,
  fvFunction,
  npvFunction,
  irrFunction,
  xnpvFunction,
  xirrFunction,
  rateFunction,
  isBlankFunction,
  isNumberFunction,
  isTextFunction,
  isLogicalFunction,
  isErrFunction,
  isNaFunction,
  isErrorFunction,
  ifErrorFunction,
  ifNaFunction,
  errorTypeFunction,
  typeFunction,
  averageFunction,
  averageIfFunction,
  averageIfsFunction,
  maxFunction,
  minFunction,
  countFunction,
  countIfFunction,
  countIfsFunction,
  countAFunction,
  countBlankFunction,
  medianFunction,
  modeFunction,
  varianceFunction,
  variancePopulationFunction,
  standardDeviationFunction,
  standardDeviationPopulationFunction,
  dSumFunction,
  dProductFunction,
  dAverageFunction,
  dCountFunction,
  dMaxFunction,
  dMinFunction,
  dStdevFunction,
  dStdevpFunction,
  dVarFunction,
  dVarpFunction,
  vlookupFunction,
  hlookupFunction,
  lookupFunction,
  rowFunction,
  matchFunction,
  indexFunction,
  offsetFunction,
  indirectFunction,
  chooseFunction,
  andFunction,
  orFunction,
  notFunction,
  xorFunction,
  trueFunction,
  falseFunction,
  ifFunction,
  ifsFunction,
  switchFunction,
  concatFunction,
  concatenateFunction,
  textJoinFunction,
  leftFunction,
  rightFunction,
  midFunction,
  lenFunction,
  trimFunction,
  upperFunction,
  lowerFunction,
  properFunction,
  replaceFunction,
  substituteFunction,
  findFunction,
  searchFunction,
  textFunction,
  sinFunction,
  cosFunction,
  tanFunction,
  asinFunction,
  acosFunction,
  atanFunction,
  sinhFunction,
  coshFunction,
  tanhFunction,
  degreesFunction,
  radiansFunction,
  besseliFunction,
  besseljFunction,
  deltaFunction,
  erfFunction,
  erfcFunction,
  mmultFunction,
  minverseFunction,
  mdetermFunction,
  transposeFunction,
  frequencyFunction
];
builtInFunctions.forEach(registerFormulaFunction);

// packages/@oxen-office/xlsx/src/formula/functions/xlfn/xlookup.ts
function toLookupVector(range2, description) {
  const table = toLookupTable(range2, description);
  const rowCount = table.length;
  const colCount = table[0]?.length ?? 0;
  if (rowCount === 0 || colCount === 0) {
    throw new Error(`${description} cannot be empty`);
  }
  if (rowCount === 1) {
    const row = table[0];
    return {
      orientation: "row",
      length: row.length,
      at: (index) => row[index] ?? null
    };
  }
  if (colCount === 1) {
    return {
      orientation: "col",
      length: rowCount,
      at: (index) => table[index]?.[0] ?? null
    };
  }
  throw new Error(`${description} must be a single row or single column`);
}
function resolveReturnValue(params) {
  const table = toLookupTable(params.returnArray, "XLOOKUP return array");
  const rowCount = table.length;
  const colCount = table[0]?.length ?? 0;
  if (rowCount === 0 || colCount === 0) {
    throw new Error("XLOOKUP return array cannot be empty");
  }
  if (params.orientation === "row") {
    const row2 = table[0];
    if (!row2) {
      throw new Error("XLOOKUP return array must contain at least one row");
    }
    const value2 = row2[params.matchIndex];
    if (value2 === undefined) {
      throw new Error("XLOOKUP return array column index is out of range");
    }
    return value2;
  }
  const row = table[params.matchIndex];
  if (!row) {
    throw new Error("XLOOKUP return array row index is out of range");
  }
  const value = row[0];
  if (value === undefined) {
    throw new Error("XLOOKUP return array must contain at least one column");
  }
  return value;
}
function coerceBinaryKey(value, order) {
  if (typeof value === "number") {
    return value;
  }
  if (value === null) {
    return order === "ascending" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  }
  return order === "ascending" ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
}
function binarySearchAscendingLowerBound(vector, lookup) {
  const n = vector.length;
  const state = { lo: 0, hi: n };
  while (state.lo < state.hi) {
    const mid = Math.floor((state.lo + state.hi) / 2);
    const key = coerceBinaryKey(vector.at(mid), "ascending");
    if (key >= lookup) {
      state.hi = mid;
    } else {
      state.lo = mid + 1;
    }
  }
  return state.lo < n ? state.lo : null;
}
function binarySearchAscendingUpperBound(vector, lookup) {
  const n = vector.length;
  const state = { lo: 0, hi: n };
  while (state.lo < state.hi) {
    const mid = Math.floor((state.lo + state.hi) / 2);
    const key = coerceBinaryKey(vector.at(mid), "ascending");
    if (key <= lookup) {
      state.lo = mid + 1;
    } else {
      state.hi = mid;
    }
  }
  const index = state.lo - 1;
  return index >= 0 ? index : null;
}
function binarySearchDescendingLowerBound(vector, lookup) {
  const n = vector.length;
  const state = { lo: 0, hi: n };
  while (state.lo < state.hi) {
    const mid = Math.floor((state.lo + state.hi) / 2);
    const key = coerceBinaryKey(vector.at(mid), "descending");
    if (key >= lookup) {
      state.lo = mid + 1;
    } else {
      state.hi = mid;
    }
  }
  const index = state.lo - 1;
  return index >= 0 ? index : null;
}
function binarySearchDescendingUpperBound(vector, lookup) {
  const n = vector.length;
  const state = { lo: 0, hi: n };
  while (state.lo < state.hi) {
    const mid = Math.floor((state.lo + state.hi) / 2);
    const key = coerceBinaryKey(vector.at(mid), "descending");
    if (key <= lookup) {
      state.hi = mid;
    } else {
      state.lo = mid + 1;
    }
  }
  return state.lo < n ? state.lo : null;
}
function findExactIndex(params) {
  const { vector, lookupValue, fromEnd, compare } = params;
  if (!fromEnd) {
    for (let i2 = 0;i2 < vector.length; i2 += 1) {
      if (compare(vector.at(i2), lookupValue)) {
        return i2;
      }
    }
    return null;
  }
  for (let i2 = vector.length - 1;i2 >= 0; i2 -= 1) {
    if (compare(vector.at(i2), lookupValue)) {
      return i2;
    }
  }
  return null;
}
var xlookupFunction = {
  name: "XLOOKUP",
  category: "lookup",
  description: {
    en: "Searches a range or array and returns an item corresponding to the first match.",
    ja: "\u7BC4\u56F2/\u914D\u5217\u3092\u691C\u7D22\u3057\u3001\u4E00\u81F4\u3059\u308B\u8981\u7D20\u306B\u5BFE\u5FDC\u3059\u308B\u5024\u3092\u8FD4\u3057\u307E\u3059\u3002"
  },
  examples: ["XLOOKUP(E2, C2:C7, B2:B7)", "XLOOKUP(B2, B5:B14, C5:D14)"],
  evaluate: (args, helpers) => {
    if (args.length < 3 || args.length > 6) {
      throw new Error("XLOOKUP expects three to six arguments");
    }
    const lookupValue = helpers.coerceScalar(args[0], "XLOOKUP lookup value");
    const lookupVector = toLookupVector(args[1], "XLOOKUP lookup array");
    const ifNotFound = args.length >= 4 ? helpers.coerceScalar(args[3], "XLOOKUP if_not_found") : undefined;
    const matchMode = args.length >= 5 ? helpers.requireNumber(args[4], "XLOOKUP match_mode") : 0;
    const searchMode = args.length >= 6 ? helpers.requireNumber(args[5], "XLOOKUP search_mode") : 1;
    if (![0, -1, 1, 2].includes(matchMode)) {
      throw new Error("XLOOKUP match_mode must be -1, 0, 1, or 2");
    }
    if (![1, -1, 2, -2].includes(searchMode)) {
      throw new Error("XLOOKUP search_mode must be 1, -1, 2, or -2");
    }
    if (matchMode === 2) {
      throw new Error("XLOOKUP wildcard match is not implemented");
    }
    const fromEnd = searchMode === -1;
    const useBinaryAscending = searchMode === 2;
    const useBinaryDescending = searchMode === -2;
    const findIndex = () => {
      if (matchMode === 0) {
        return findExactIndex({ vector: lookupVector, lookupValue, fromEnd, compare: helpers.comparePrimitiveEquality });
      }
      if (typeof lookupValue !== "number") {
        throw new Error("XLOOKUP approximate match requires numeric lookup value");
      }
      if (useBinaryAscending) {
        if (matchMode === 1) {
          return binarySearchAscendingLowerBound(lookupVector, lookupValue);
        }
        return binarySearchAscendingUpperBound(lookupVector, lookupValue);
      }
      if (useBinaryDescending) {
        if (matchMode === 1) {
          return binarySearchDescendingLowerBound(lookupVector, lookupValue);
        }
        return binarySearchDescendingUpperBound(lookupVector, lookupValue);
      }
      if (matchMode === 1) {
        for (let i2 = 0;i2 < lookupVector.length; i2 += 1) {
          const idx = fromEnd ? lookupVector.length - 1 - i2 : i2;
          const candidate = lookupVector.at(idx);
          if (typeof candidate !== "number") {
            continue;
          }
          if (candidate >= lookupValue) {
            return idx;
          }
        }
        return null;
      }
      for (let i2 = 0;i2 < lookupVector.length; i2 += 1) {
        const idx = fromEnd ? lookupVector.length - 1 - i2 : i2;
        const candidate = lookupVector.at(idx);
        if (typeof candidate !== "number") {
          continue;
        }
        if (candidate <= lookupValue) {
          return idx;
        }
      }
      return null;
    };
    const matchIndex = findIndex();
    if (matchIndex === null) {
      if (ifNotFound !== undefined) {
        return ifNotFound;
      }
      throw helpers.createFormulaError("#N/A", "XLOOKUP could not find a match");
    }
    return resolveReturnValue({ orientation: lookupVector.orientation, matchIndex, returnArray: args[2] });
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/xlfn/xmatch.ts
function toLookupVector2(range2, description) {
  const table = toLookupTable(range2, description);
  const rowCount = table.length;
  const colCount = table[0]?.length ?? 0;
  if (rowCount === 0 || colCount === 0) {
    throw new Error(`${description} cannot be empty`);
  }
  if (rowCount === 1) {
    const row = table[0];
    return { length: row.length, at: (index) => row[index] ?? null };
  }
  if (colCount === 1) {
    return { length: rowCount, at: (index) => table[index]?.[0] ?? null };
  }
  throw new Error(`${description} must be a single row or single column`);
}
function guessVectorOrder(vector) {
  if (vector.length < 2) {
    return "unknown";
  }
  const first = vector.at(0);
  const last = vector.at(vector.length - 1);
  if (typeof first === "number" && typeof last === "number") {
    return first <= last ? "ascending" : "descending";
  }
  return "unknown";
}
function coerceBinaryKey2(value, order) {
  if (typeof value === "number") {
    return value;
  }
  if (value === null) {
    return order === "ascending" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  }
  return order === "ascending" ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
}
function binarySearchExact(vector, lookup, order) {
  const n = vector.length;
  const state = { lo: 0, hi: n };
  while (state.lo < state.hi) {
    const mid = Math.floor((state.lo + state.hi) / 2);
    const key = coerceBinaryKey2(vector.at(mid), order);
    if (key === lookup) {
      return mid;
    }
    if (order === "ascending") {
      if (key < lookup) {
        state.lo = mid + 1;
      } else {
        state.hi = mid;
      }
    } else if (key > lookup) {
      state.lo = mid + 1;
    } else {
      state.hi = mid;
    }
  }
  return null;
}
function binarySearchNextLarger(vector, lookup, order) {
  const n = vector.length;
  const state = { lo: 0, hi: n };
  while (state.lo < state.hi) {
    const mid = Math.floor((state.lo + state.hi) / 2);
    const key = coerceBinaryKey2(vector.at(mid), order);
    if (order === "ascending") {
      if (key >= lookup) {
        state.hi = mid;
      } else {
        state.lo = mid + 1;
      }
    } else if (key >= lookup) {
      state.lo = mid + 1;
    } else {
      state.hi = mid;
    }
  }
  if (order === "ascending") {
    return state.lo < n ? state.lo : null;
  }
  const index = state.lo - 1;
  return index >= 0 ? index : null;
}
function binarySearchNextSmaller(vector, lookup, order) {
  const n = vector.length;
  const state = { lo: 0, hi: n };
  while (state.lo < state.hi) {
    const mid = Math.floor((state.lo + state.hi) / 2);
    const key = coerceBinaryKey2(vector.at(mid), order);
    if (order === "ascending") {
      if (key <= lookup) {
        state.lo = mid + 1;
      } else {
        state.hi = mid;
      }
    } else if (key <= lookup) {
      state.hi = mid;
    } else {
      state.lo = mid + 1;
    }
  }
  if (order === "ascending") {
    const index = state.lo - 1;
    return index >= 0 ? index : null;
  }
  return state.lo < n ? state.lo : null;
}
var xmatchFunction = {
  name: "XMATCH",
  category: "lookup",
  description: {
    en: "Returns the relative position of an item in a range/array (Excel XMATCH).",
    ja: "\u7BC4\u56F2/\u914D\u5217\u5185\u3067\u306E\u9805\u76EE\u306E\u76F8\u5BFE\u4F4D\u7F6E\u3092\u8FD4\u3057\u307E\u3059\uFF08Excel XMATCH\uFF09\u3002"
  },
  examples: ["XMATCH(15000, C3:C9, -1)", 'XMATCH("Key", A1:A10)'],
  evaluate: (args, helpers) => {
    if (args.length < 2 || args.length > 4) {
      throw new Error("XMATCH expects two to four arguments");
    }
    const lookupValue = helpers.coerceScalar(args[0], "XMATCH lookup value");
    const vector = toLookupVector2(args[1], "XMATCH lookup array");
    const matchMode = args.length >= 3 ? helpers.requireNumber(args[2], "XMATCH match_mode") : 0;
    const searchMode = args.length >= 4 ? helpers.requireNumber(args[3], "XMATCH search_mode") : 1;
    if (![0, -1, 1, 2].includes(matchMode)) {
      throw new Error("XMATCH match_mode must be -1, 0, 1, or 2");
    }
    if (![1, -1, 2, -2].includes(searchMode)) {
      throw new Error("XMATCH search_mode must be 1, -1, 2, or -2");
    }
    if (matchMode === 2) {
      throw new Error("XMATCH wildcard match is not implemented");
    }
    const resolveNotFound = () => {
      throw helpers.createFormulaError("#N/A", "XMATCH could not find a match");
    };
    const findExactLinear = (fromEnd) => {
      if (!fromEnd) {
        for (let i2 = 0;i2 < vector.length; i2 += 1) {
          if (helpers.comparePrimitiveEquality(vector.at(i2), lookupValue)) {
            return i2;
          }
        }
        return null;
      }
      for (let i2 = vector.length - 1;i2 >= 0; i2 -= 1) {
        if (helpers.comparePrimitiveEquality(vector.at(i2), lookupValue)) {
          return i2;
        }
      }
      return null;
    };
    const findApproxLinear = (fromEnd, mode) => {
      if (typeof lookupValue !== "number") {
        throw new Error("XMATCH approximate match requires numeric lookup value");
      }
      const order = guessVectorOrder(vector);
      if (order === "unknown") {
        throw new Error("XMATCH approximate match requires an ordered numeric vector");
      }
      const iterateIndex = (i2) => fromEnd ? vector.length - 1 - i2 : i2;
      if (order === "descending") {
        if (mode === -1) {
          for (let i2 = 0;i2 < vector.length; i2 += 1) {
            const idx = iterateIndex(i2);
            const candidate = vector.at(idx);
            if (typeof candidate !== "number") {
              continue;
            }
            if (candidate <= lookupValue) {
              return idx;
            }
          }
          return null;
        }
        const state2 = { best: null };
        for (let i2 = 0;i2 < vector.length; i2 += 1) {
          const idx = iterateIndex(i2);
          const candidate = vector.at(idx);
          if (typeof candidate !== "number") {
            continue;
          }
          if (candidate >= lookupValue) {
            state2.best = idx;
          } else {
            break;
          }
        }
        return state2.best;
      }
      if (mode === 1) {
        for (let i2 = 0;i2 < vector.length; i2 += 1) {
          const idx = iterateIndex(i2);
          const candidate = vector.at(idx);
          if (typeof candidate !== "number") {
            continue;
          }
          if (candidate >= lookupValue) {
            return idx;
          }
        }
        return null;
      }
      const state = { best: null };
      for (let i2 = 0;i2 < vector.length; i2 += 1) {
        const idx = iterateIndex(i2);
        const candidate = vector.at(idx);
        if (typeof candidate !== "number") {
          continue;
        }
        if (candidate <= lookupValue) {
          state.best = idx;
        } else {
          break;
        }
      }
      return state.best;
    };
    const findIndex = () => {
      if (searchMode === 2 || searchMode === -2) {
        if (typeof lookupValue !== "number") {
          throw new Error("XMATCH binary search requires numeric lookup value");
        }
        const order = searchMode === 2 ? "ascending" : "descending";
        if (matchMode === 0) {
          return binarySearchExact(vector, lookupValue, order);
        }
        if (matchMode === 1) {
          return binarySearchNextLarger(vector, lookupValue, order);
        }
        return binarySearchNextSmaller(vector, lookupValue, order);
      }
      const fromEnd = searchMode === -1;
      if (matchMode === 0) {
        return findExactLinear(fromEnd);
      }
      return findApproxLinear(fromEnd, matchMode);
    };
    const index = findIndex();
    if (index === null) {
      return resolveNotFound();
    }
    return index + 1;
  }
};

// packages/@oxen-office/xlsx/src/formula/functions/xlfn/registry.ts
var xlfnRegistry = new Map([
  ["XLOOKUP", xlookupFunction],
  ["XMATCH", xmatchFunction]
]);
function isXlfnQualifiedFunctionName(name) {
  return name.toUpperCase().startsWith("_XLFN.");
}
function extractQualifiedSuffix(name) {
  const upper = name.toUpperCase();
  const parts = upper.split(".");
  return parts[parts.length - 1] ?? upper;
}
function getXlfnFormulaFunction(qualifiedName) {
  if (!isXlfnQualifiedFunctionName(qualifiedName)) {
    return;
  }
  const suffix = extractQualifiedSuffix(qualifiedName);
  return xlfnRegistry.get(suffix);
}

// packages/@oxen-office/xlsx/src/formula/evaluator.ts
function toFormulaErrorScalar(value) {
  return { type: "error", value };
}
function isFormulaErrorScalar(value) {
  return typeof value === "object" && value !== null && "type" in value && value.type === "error";
}
function cellValueToFormulaScalar(value) {
  switch (value.type) {
    case "empty":
      return null;
    case "string":
      return value.value;
    case "number":
      return value.value;
    case "boolean":
      return value.value;
    case "error":
      return toFormulaErrorScalar(value.value);
    case "date":
      return value.value.toISOString();
  }
}
function asPrimitiveOrThrow(value) {
  if (isFormulaError(value)) {
    throw createFormulaError(value.value);
  }
  return value;
}
function normalizeFormulaText(formula) {
  const trimmed = formula.trim();
  if (trimmed.startsWith("=")) {
    return trimmed.slice(1).trim();
  }
  return trimmed;
}
function buildWorkbookMatrix(workbook) {
  const sheetIndexByName = new Map;
  const sheets = workbook.sheets.map((sheet, idx) => {
    sheetIndexByName.set(sheet.name.trim().toUpperCase(), idx);
    const dimensionEndRow = sheet.dimension?.end.row;
    const dimensionEndCol = sheet.dimension?.end.col;
    const bounds = {
      maxRow: Math.max(1, dimensionEndRow ?? 1),
      maxCol: Math.max(1, dimensionEndCol ?? 1)
    };
    const rows = new Map;
    for (const row of sheet.rows) {
      const rowNumber = row.rowNumber;
      bounds.maxRow = Math.max(bounds.maxRow, rowNumber);
      const rowMap = rows.get(rowNumber) ?? new Map;
      for (const cell of row.cells) {
        bounds.maxCol = Math.max(bounds.maxCol, cell.address.col);
        rowMap.set(cell.address.col, { value: cell.value, formula: cell.formula });
      }
      rows.set(rowNumber, rowMap);
    }
    return { sheetName: sheet.name, rows, maxRow: bounds.maxRow, maxCol: bounds.maxCol };
  });
  return { sheets, sheetIndexByName };
}
function resolveSheetIndexByName(matrix, sheetName) {
  return matrix.sheetIndexByName.get(sheetName.trim().toUpperCase());
}
function parseSheetQualifiedCellReference(reference, defaultSheetName) {
  const parsed = parseRange(reference);
  const isSingleCell = parsed.start.col === parsed.end.col && parsed.start.row === parsed.end.row && parsed.start.colAbsolute === parsed.end.colAbsolute && parsed.start.rowAbsolute === parsed.end.rowAbsolute;
  if (!isSingleCell) {
    throw new Error("Expected single cell reference");
  }
  return {
    sheetName: parsed.sheetName ?? defaultSheetName,
    address: parsed.start
  };
}
function resolveScopeSheetIndex(scope, explicitSheetName) {
  if (!explicitSheetName) {
    return scope.defaultSheetIndex;
  }
  return scope.resolveSheetIndexByName(explicitSheetName);
}
function parse3dSheetRange(rawSheetName) {
  const idx = rawSheetName.indexOf(":");
  if (idx === -1) {
    return null;
  }
  const start = rawSheetName.slice(0, idx).trim();
  const end = rawSheetName.slice(idx + 1).trim();
  if (start.length === 0 || end.length === 0) {
    return null;
  }
  return { start, end };
}
function buildDefinedNameFormulaIndex(definedNames) {
  const byKey = new Map;
  for (const def of definedNames ?? []) {
    const nameKey = def.name.trim().toUpperCase();
    const scopeKey = def.localSheetId === undefined ? "*" : String(def.localSheetId);
    const key = `${scopeKey}|${nameKey}`;
    const list = byKey.get(key) ?? [];
    list.push(def.formula);
    byKey.set(key, list);
  }
  return byKey;
}
function buildTablesByName(tables) {
  const map = new Map;
  for (const table of tables ?? []) {
    map.set(table.name.trim().toUpperCase(), table);
  }
  return map;
}
function resolveTableItemRowRange(params) {
  switch (params.item) {
    case "#ALL":
      return { startRow: params.fullStartRow, endRow: params.fullEndRow };
    case "#DATA":
      return { startRow: params.dataStartRow, endRow: params.dataEndRow };
    case "#HEADERS":
      return { startRow: params.fullStartRow, endRow: params.fullStartRow + params.headerRowCount - 1 };
    case "#TOTALS":
      return { startRow: params.fullEndRow - params.totalsRowCount + 1, endRow: params.fullEndRow };
    case "#THIS ROW": {
      const originRow = params.originRow;
      if (!originRow) {
        return null;
      }
      if (originRow < params.dataStartRow || originRow > params.dataEndRow) {
        return null;
      }
      return { startRow: originRow, endRow: originRow };
    }
    default:
      return null;
  }
}
function resolveStructuredTableReferenceRowRange(params) {
  if (!params.item) {
    return { startRow: params.dataStartRow, endRow: params.dataEndRow };
  }
  return resolveTableItemRowRange({
    item: params.item,
    fullStartRow: params.fullStartRow,
    fullEndRow: params.fullEndRow,
    headerRowCount: params.headerRowCount,
    totalsRowCount: params.totalsRowCount,
    dataStartRow: params.dataStartRow,
    dataEndRow: params.dataEndRow,
    originRow: params.originRow
  });
}
function pickFirstInternalDefinedNameFormula(candidates) {
  if (!candidates || candidates.length === 0) {
    return;
  }
  const internal = candidates.find((value) => value.trim().startsWith("[") === false);
  return internal ?? candidates[0];
}
function tryParseRangeReference(text) {
  try {
    return parseRange(text);
  } catch (error2) {
    if (!(error2 instanceof Error)) {
      throw error2;
    }
    return null;
  }
}
function compareOrder(left, right) {
  if (typeof left === "number" && typeof right === "number") {
    return left - right;
  }
  if (typeof left === "string" && typeof right === "string") {
    return left.localeCompare(right);
  }
  return;
}
function compareScalars(left, right, op) {
  if (op === "=") {
    return registeredHelpers.comparePrimitiveEquality(left, right);
  }
  if (op === "<>") {
    return !registeredHelpers.comparePrimitiveEquality(left, right);
  }
  if (left === null || right === null) {
    throw createFormulaError("#VALUE!");
  }
  if (typeof left !== typeof right) {
    throw createFormulaError("#VALUE!");
  }
  if (typeof left === "boolean") {
    throw createFormulaError("#VALUE!");
  }
  const cmp = compareOrder(left, right);
  if (cmp === undefined) {
    throw createFormulaError("#VALUE!");
  }
  if (op === ">") {
    return cmp > 0;
  }
  if (op === "<") {
    return cmp < 0;
  }
  if (op === ">=") {
    return cmp >= 0;
  }
  if (op === "<=") {
    return cmp <= 0;
  }
  throw createFormulaError("#NAME?");
}
function coerceNumberForMath(value, description) {
  const scalar = registeredHelpers.coerceScalar(value, description);
  if (scalar === null || scalar === "") {
    return 0;
  }
  if (typeof scalar === "boolean") {
    return scalar ? 1 : 0;
  }
  if (typeof scalar === "number" && !Number.isNaN(scalar)) {
    return scalar;
  }
  throw createFormulaError("#VALUE!");
}
function applyBinaryNumberOperator(left, right, operator) {
  switch (operator) {
    case "+":
      return left + right;
    case "-":
      return left - right;
    case "*":
      return left * right;
    case "/":
      if (right === 0) {
        throw createFormulaError("#DIV/0!");
      }
      return left / right;
    case "^":
      return left ** right;
    default:
      throw createFormulaError("#NAME?");
  }
}
function normalizeEvalResultToNumberMatrix(result, description) {
  if (!isArrayResult2(result)) {
    return [[coerceNumberForMath(result, description)]];
  }
  if (result.length === 0) {
    throw createFormulaError("#VALUE!");
  }
  const hasNested = result.some((value) => isArrayResult2(value));
  if (!hasNested) {
    return [
      result.map((value) => {
        return coerceNumberForMath(value, description);
      })
    ];
  }
  const matrix = result.map((row) => {
    if (!isArrayResult2(row)) {
      throw createFormulaError("#VALUE!");
    }
    return row.map((value) => {
      return coerceNumberForMath(value, description);
    });
  });
  const columnCount = matrix[0]?.length ?? 0;
  if (columnCount === 0) {
    throw createFormulaError("#VALUE!");
  }
  if (matrix.some((row) => row.length !== columnCount)) {
    throw createFormulaError("#VALUE!");
  }
  return matrix;
}
function isScalarMatrix(matrix) {
  return matrix.length === 1 && (matrix[0]?.length ?? 0) === 1;
}
function evaluateBinaryArithmetic(left, right, operator) {
  if (!isArrayResult2(left) && !isArrayResult2(right)) {
    return applyBinaryNumberOperator(coerceNumberForMath(left, `binary ${operator}`), coerceNumberForMath(right, `binary ${operator}`), operator);
  }
  const leftMatrix = normalizeEvalResultToNumberMatrix(left, `binary ${operator} left`);
  const rightMatrix = normalizeEvalResultToNumberMatrix(right, `binary ${operator} right`);
  const leftScalar = isScalarMatrix(leftMatrix);
  const rightScalar = isScalarMatrix(rightMatrix);
  if (leftScalar && rightScalar) {
    return applyBinaryNumberOperator(leftMatrix[0][0], rightMatrix[0][0], operator);
  }
  const leftRows = leftMatrix.length;
  const leftCols = leftMatrix[0]?.length ?? 0;
  const rightRows = rightMatrix.length;
  const rightCols = rightMatrix[0]?.length ?? 0;
  if (!(leftScalar || rightScalar) && (leftRows !== rightRows || leftCols !== rightCols)) {
    throw createFormulaError("#VALUE!");
  }
  const rows = leftScalar ? rightRows : leftRows;
  const cols = leftScalar ? rightCols : leftCols;
  return Array.from({ length: rows }, (_, rowIndex) => {
    return Array.from({ length: cols }, (_2, colIndex) => {
      const l = leftScalar ? leftMatrix[0][0] : leftMatrix[rowIndex]?.[colIndex] ?? 0;
      const r = rightScalar ? rightMatrix[0][0] : rightMatrix[rowIndex]?.[colIndex] ?? 0;
      return applyBinaryNumberOperator(l, r, operator);
    });
  });
}
function negateEvalResult(value, description) {
  if (!isArrayResult2(value)) {
    return -coerceNumberForMath(value, description);
  }
  const matrix = normalizeEvalResultToNumberMatrix(value, description);
  return matrix.map((row) => row.map((cell) => -cell));
}
function evaluateNode(node, scope) {
  switch (node.type) {
    case "Literal": {
      if (isFormulaError(node.value)) {
        throw createFormulaError(node.value.value);
      }
      return node.value;
    }
    case "Name": {
      return scope.resolveName(node.name);
    }
    case "StructuredTableReference": {
      return scope.resolveStructuredTableReference(node);
    }
    case "Reference": {
      const sheetIndex = resolveScopeSheetIndex(scope, node.sheetName);
      if (sheetIndex === undefined) {
        throw createFormulaError("#REF!");
      }
      return scope.resolveCell(sheetIndex, node.reference);
    }
    case "Range": {
      const rangeSheetName = node.range.sheetName;
      const threeD = rangeSheetName ? parse3dSheetRange(rangeSheetName) : null;
      if (!threeD) {
        const sheetIndex = resolveScopeSheetIndex(scope, rangeSheetName);
        if (sheetIndex === undefined) {
          throw createFormulaError("#REF!");
        }
        return scope.resolveRange(sheetIndex, { start: node.range.start, end: node.range.end });
      }
      const startIndex = resolveScopeSheetIndex(scope, threeD.start);
      const endIndex = resolveScopeSheetIndex(scope, threeD.end);
      if (startIndex === undefined || endIndex === undefined) {
        throw createFormulaError("#REF!");
      }
      const minIndex = Math.min(startIndex, endIndex);
      const maxIndex = Math.max(startIndex, endIndex);
      const perSheet = [];
      for (let si = minIndex;si <= maxIndex; si += 1) {
        perSheet.push(scope.resolveRange(si, { start: node.range.start, end: node.range.end }));
      }
      return perSheet;
    }
    case "Array": {
      const rows = [];
      for (const row of node.elements) {
        const values = [];
        for (const el of row) {
          values.push(registeredHelpers.coerceScalar(evaluateNode(el, scope), "array literal"));
        }
        rows.push(values);
      }
      return rows;
    }
    case "Unary": {
      const value = evaluateNode(node.argument, scope);
      const description = `unary ${node.operator}`;
      if (node.operator === "-") {
        return negateEvalResult(value, description);
      }
      return coerceNumberForMath(value, description);
    }
    case "Binary": {
      const left = evaluateNode(node.left, scope);
      const right = evaluateNode(node.right, scope);
      if (node.operator === "&") {
        const leftScalar = registeredHelpers.coerceScalar(left, "binary & left");
        const rightScalar = registeredHelpers.coerceScalar(right, "binary & right");
        return `${registeredHelpers.valueToText(leftScalar)}${registeredHelpers.valueToText(rightScalar)}`;
      }
      return evaluateBinaryArithmetic(left, right, node.operator);
    }
    case "Compare": {
      const left = registeredHelpers.coerceScalar(evaluateNode(node.left, scope), `comparator ${node.operator}`);
      const right = registeredHelpers.coerceScalar(evaluateNode(node.right, scope), `comparator ${node.operator}`);
      return compareScalars(left, right, node.operator);
    }
    case "Function": {
      const definition = getXlfnFormulaFunction(node.name) ?? getFormulaFunction(node.name);
      if (!definition) {
        throw new Error(`Unknown function "${node.name}"`);
      }
      if (definition.evaluateLazy) {
        return definition.evaluateLazy([...node.args], {
          evaluate: (child) => evaluateNode(child, scope),
          helpers: registeredHelpers,
          parseReference: (reference) => parseSheetQualifiedCellReference(reference, scope.origin.sheetName),
          origin: scope.origin,
          dateSystem: scope.dateSystem
        });
      }
      if (!definition.evaluate) {
        throw new Error(`Formula function "${node.name}" must provide an eager evaluator`);
      }
      const args = node.args.map((arg) => evaluateNode(arg, scope));
      return definition.evaluate(args, registeredHelpers);
    }
  }
}
function createFormulaEvaluator(workbook) {
  const matrix = buildWorkbookMatrix(workbook);
  const astCache = new Map;
  const valueCache = new Map;
  const inProgress = new Set;
  const nameInProgress = new Set;
  const definedNamesByKey = buildDefinedNameFormulaIndex(workbook.definedNames);
  const tablesByName = buildTablesByName(workbook.tables);
  const normalizeArrayFormulaResultToMatrix = (result, description) => {
    if (!isArrayResult2(result)) {
      return [[registeredHelpers.coerceScalar(result, description)]];
    }
    if (result.length === 0) {
      return [];
    }
    const hasNested = result.some((value) => isArrayResult2(value));
    if (!hasNested) {
      return [
        result.map((value) => {
          return registeredHelpers.coerceScalar(value, description);
        })
      ];
    }
    return result.map((row) => {
      if (!isArrayResult2(row)) {
        throw new Error(`Expected 2D array for ${description}`);
      }
      return row.map((value) => {
        return registeredHelpers.coerceScalar(value, description);
      });
    });
  };
  const getOrParseAst = (cacheKey, formula) => {
    const cached = astCache.get(cacheKey);
    if (cached !== undefined) {
      return cached;
    }
    try {
      const parsed = parseFormula2(formula);
      astCache.set(cacheKey, parsed);
      return parsed;
    } catch (error2) {
      if (!(error2 instanceof Error)) {
        throw error2;
      }
      astCache.set(cacheKey, null);
      return null;
    }
  };
  const evaluateFormulaResultInternal = (sheetIndex, origin, formula) => {
    const normalized = normalizeFormulaText(formula);
    const cacheKey = `${sheetIndex}|${normalized}`;
    const ast = getOrParseAst(cacheKey, normalized);
    if (!ast) {
      return toFormulaErrorScalar("#NAME?");
    }
    const defaultSheetName = matrix.sheets[sheetIndex]?.sheetName;
    if (!defaultSheetName) {
      return toFormulaErrorScalar("#REF!");
    }
    const scope = {
      defaultSheetIndex: sheetIndex,
      defaultSheetName,
      resolveSheetIndexByName: (sheetName) => resolveSheetIndexByName(matrix, sheetName),
      resolveCell: (si, addr) => resolveCellPrimitive(si, addr),
      resolveRange: (si, range2) => resolveRangePrimitive(si, range2),
      resolveName: (name) => resolveDefinedNameValue(scope, name),
      resolveStructuredTableReference: (node) => resolveStructuredTableReferenceValue(scope, node),
      origin: { sheetName: defaultSheetName, address: origin },
      dateSystem: workbook.dateSystem
    };
    try {
      return evaluateNode(ast, scope);
    } catch (error2) {
      const code = getErrorCodeFromError(error2);
      return toFormulaErrorScalar(code);
    }
  };
  const resolveDefinedNameValue = (scope, name) => {
    const keyName = name.trim().toUpperCase();
    const localKey = `${scope.defaultSheetIndex}|${keyName}`;
    const globalKey = `*|${keyName}`;
    const formula = pickFirstInternalDefinedNameFormula(definedNamesByKey.get(localKey)) ?? pickFirstInternalDefinedNameFormula(definedNamesByKey.get(globalKey));
    if (!formula) {
      throw createFormulaError("#NAME?");
    }
    const progressKey = `${scope.defaultSheetIndex}|${keyName}`;
    if (nameInProgress.has(progressKey)) {
      throw createFormulaError("#REF!");
    }
    nameInProgress.add(progressKey);
    try {
      const normalized = normalizeFormulaText(formula);
      if (normalized.trim().startsWith("[")) {
        throw createFormulaError("#REF!");
      }
      const range2 = tryParseRangeReference(normalized);
      if (range2) {
        return evaluateNode({ type: "Range", range: range2 }, scope);
      }
      const evaluated = evaluateFormulaResultInternal(scope.defaultSheetIndex, scope.origin.address, normalized);
      if (isFormulaErrorScalar(evaluated)) {
        throw createFormulaError(evaluated.value);
      }
      return evaluated;
    } finally {
      nameInProgress.delete(progressKey);
    }
  };
  const resolveStructuredTableReferenceValue = (scope, node) => {
    const tableKey = node.tableName.trim().toUpperCase();
    const table = tablesByName.get(tableKey);
    if (!table) {
      throw createFormulaError("#NAME?");
    }
    const headerRowCount = Math.max(0, table.headerRowCount);
    const totalsRowCount = Math.max(0, table.totalsRowCount);
    const fullStartRow = table.ref.start.row;
    const fullEndRow = table.ref.end.row;
    const dataStartRow = fullStartRow + headerRowCount;
    const dataEndRow = fullEndRow - totalsRowCount;
    const item = node.item?.trim().toUpperCase();
    const startName = node.startColumnName?.trim().toUpperCase();
    const endName = node.endColumnName?.trim().toUpperCase();
    const rowRange = resolveStructuredTableReferenceRowRange({
      item,
      fullStartRow,
      fullEndRow,
      headerRowCount,
      totalsRowCount,
      dataStartRow,
      dataEndRow,
      originRow: scope.origin.address.row
    });
    if (!rowRange || rowRange.endRow < rowRange.startRow) {
      throw createFormulaError("#REF!");
    }
    if (!startName || !endName) {
      const startCol2 = table.ref.start.col;
      const endCol2 = table.ref.start.col + Math.max(0, table.columns.length - 1);
      return scope.resolveRange(table.sheetIndex, {
        start: { col: colIdx(startCol2), row: rowIdx(rowRange.startRow), colAbsolute: false, rowAbsolute: false },
        end: { col: colIdx(endCol2), row: rowIdx(rowRange.endRow), colAbsolute: false, rowAbsolute: false }
      });
    }
    const startIndex = table.columns.findIndex((col) => col.name.trim().toUpperCase() === startName);
    const endIndex = table.columns.findIndex((col) => col.name.trim().toUpperCase() === endName);
    if (startIndex === -1 || endIndex === -1) {
      throw createFormulaError("#REF!");
    }
    const minColIndex = Math.min(startIndex, endIndex);
    const maxColIndex = Math.max(startIndex, endIndex);
    const startCol = table.ref.start.col + minColIndex;
    const endCol = table.ref.start.col + maxColIndex;
    return scope.resolveRange(table.sheetIndex, {
      start: { col: colIdx(startCol), row: rowIdx(rowRange.startRow), colAbsolute: false, rowAbsolute: false },
      end: { col: colIdx(endCol), row: rowIdx(rowRange.endRow), colAbsolute: false, rowAbsolute: false }
    });
  };
  const evaluateFormulaInternal = (sheetIndex, origin, formula) => {
    const evaluated = evaluateFormulaResultInternal(sheetIndex, origin, formula);
    if (isFormulaErrorScalar(evaluated)) {
      return evaluated;
    }
    try {
      return registeredHelpers.coerceScalar(evaluated, "formula");
    } catch (error2) {
      const code = getErrorCodeFromError(error2);
      return toFormulaErrorScalar(code);
    }
  };
  const evaluateArrayFormulaScalar = (sheetIndex, address, formula) => {
    const ref = formula.ref;
    if (!ref) {
      return evaluateFormulaInternal(sheetIndex, address, formula.expression);
    }
    const rowOffset = address.row - ref.start.row;
    const colOffset = address.col - ref.start.col;
    if (rowOffset < 0 || colOffset < 0) {
      return toFormulaErrorScalar("#REF!");
    }
    const maxRowOffset = ref.end.row - ref.start.row;
    const maxColOffset = ref.end.col - ref.start.col;
    if (rowOffset > maxRowOffset || colOffset > maxColOffset) {
      return toFormulaErrorScalar("#REF!");
    }
    const evaluated = evaluateFormulaResultInternal(sheetIndex, ref.start, formula.expression);
    if (isFormulaErrorScalar(evaluated)) {
      return evaluated;
    }
    try {
      const matrixResult = normalizeArrayFormulaResultToMatrix(evaluated, `array formula "${formula.expression}"`);
      const row = matrixResult[rowOffset];
      if (!row) {
        return toFormulaErrorScalar("#VALUE!");
      }
      const value = row[colOffset];
      if (value === undefined) {
        return toFormulaErrorScalar("#VALUE!");
      }
      return value ?? null;
    } catch (error2) {
      const code = getErrorCodeFromError(error2);
      return toFormulaErrorScalar(code);
    }
  };
  const computeCellScalarValue = (sheetIndex, address, cellData) => {
    if (!cellData) {
      return null;
    }
    if (cellData.formula) {
      if (cellData.formula.type === "array") {
        return evaluateArrayFormulaScalar(sheetIndex, address, cellData.formula);
      }
      return evaluateFormulaInternal(sheetIndex, address, cellData.formula.expression);
    }
    return cellValueToFormulaScalar(cellData.value);
  };
  const resolveCellScalar = (sheetIndex, address) => {
    const key = `${sheetIndex}|${address.col}:${address.row}`;
    const cached = valueCache.get(key);
    if (cached !== undefined) {
      return cached;
    }
    if (inProgress.has(key)) {
      return toFormulaErrorScalar("#REF!");
    }
    inProgress.add(key);
    const sheet = matrix.sheets[sheetIndex];
    const cellData = sheet?.rows.get(address.row)?.get(address.col);
    const result = computeCellScalarValue(sheetIndex, address, cellData);
    valueCache.set(key, result);
    inProgress.delete(key);
    return result;
  };
  const resolveCellPrimitive = (sheetIndex, address) => {
    return asPrimitiveOrThrow(resolveCellScalar(sheetIndex, address));
  };
  const resolveRangePrimitive = (sheetIndex, range2) => {
    const minRow = Math.min(range2.start.row, range2.end.row);
    const requestedMaxRow = Math.max(range2.start.row, range2.end.row);
    const minCol = Math.min(range2.start.col, range2.end.col);
    const requestedMaxCol = Math.max(range2.start.col, range2.end.col);
    const sheet = matrix.sheets[sheetIndex];
    const sheetMaxRow = sheet?.maxRow ?? EXCEL_MAX_ROWS;
    const sheetMaxCol = sheet?.maxCol ?? EXCEL_MAX_COLS;
    const maxRow = requestedMaxRow === EXCEL_MAX_ROWS ? sheetMaxRow : requestedMaxRow;
    const maxCol = requestedMaxCol === EXCEL_MAX_COLS ? sheetMaxCol : requestedMaxCol;
    const rows = [];
    for (let r = minRow;r <= maxRow; r += 1) {
      const rowValues = [];
      for (let c = minCol;c <= maxCol; c += 1) {
        rowValues.push(resolveCellPrimitive(sheetIndex, { col: colIdx(c), row: rowIdx(r), colAbsolute: false, rowAbsolute: false }));
      }
      rows.push(rowValues);
    }
    return rows;
  };
  return {
    evaluateCell: (sheetIndex, address) => resolveCellScalar(sheetIndex, address),
    evaluateFormula: (sheetIndex, formula) => evaluateFormulaInternal(sheetIndex, { col: colIdx(1), row: rowIdx(1), colAbsolute: false, rowAbsolute: false }, formula),
    evaluateFormulaResult: (sheetIndex, origin, formula) => evaluateFormulaResultInternal(sheetIndex, origin, formula)
  };
}

// packages/@oxen-cli/xlsx-cli/src/commands/formulas.ts
function formatScalarValue(value) {
  if (value === null) {
    return null;
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    return value;
  }
  if (typeof value === "object" && "type" in value && value.type === "error") {
    return value.value;
  }
  return String(value);
}
function formatCellValue2(value) {
  switch (value.type) {
    case "string":
      return value.value;
    case "number":
      return value.value;
    case "boolean":
      return value.value;
    case "error":
      return value.value;
    case "date":
      return value.value.toISOString();
    case "empty":
      return null;
    default:
      return null;
  }
}
function evaluateFormula(evaluator, sheetIndex, address) {
  if (!evaluator) {
    return;
  }
  try {
    const result = evaluator.evaluateCell(sheetIndex, address);
    return formatScalarValue(result);
  } catch {
    return "#ERROR!";
  }
}
async function runFormulas(filePath, options = {}) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    const evaluator = options.evaluate ? createFormulaEvaluator(workbook) : undefined;
    const sheets = workbook.sheets.map((sheet, sheetIndex) => ({ sheet, sheetIndex })).filter(({ sheet }) => !options.sheet || sheet.name === options.sheet).map(({ sheet, sheetIndex }) => {
      const formulas = sheet.rows.flatMap((row) => row.cells.filter((cell) => cell.formula).map((cell) => {
        const calculatedValue = evaluateFormula(evaluator, sheetIndex, cell.address);
        return {
          ref: formatCellRef(cell.address),
          formula: cell.formula.expression,
          storedValue: formatCellValue2(cell.value),
          ...calculatedValue !== undefined && { calculatedValue }
        };
      }));
      return { sheetName: sheet.name, formulas };
    }).filter(({ formulas }) => formulas.length > 0);
    const totalCount = sheets.reduce((sum, s) => sum + s.formulas.length, 0);
    return success({
      totalCount,
      sheets
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/commands/names.ts
async function runNames(filePath) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    if (!workbook.definedNames || workbook.definedNames.length === 0) {
      return success({
        count: 0,
        names: []
      });
    }
    const getScope = (localSheetId) => {
      if (localSheetId === undefined) {
        return;
      }
      return workbook.sheets[localSheetId]?.name ?? `Sheet ${localSheetId + 1}`;
    };
    const names = workbook.definedNames.map((dn) => {
      const scope = getScope(dn.localSheetId);
      return {
        name: dn.name,
        formula: dn.formula,
        ...scope && { scope },
        ...dn.hidden && { hidden: true }
      };
    });
    return success({
      count: names.length,
      names
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/serializers/sheet-serializer.ts
function formatRange2(range2) {
  const startCol = indexToColumnLetter(colIdx(range2.start.col));
  const endCol = indexToColumnLetter(colIdx(range2.end.col));
  return `${startCol}${range2.start.row}:${endCol}${range2.end.row}`;
}

// packages/@oxen-cli/xlsx-cli/src/commands/tables.ts
async function runTables3(filePath) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    if (!workbook.tables || workbook.tables.length === 0) {
      return success({
        count: 0,
        tables: []
      });
    }
    const tables = workbook.tables.map((table) => {
      const sheet = workbook.sheets[table.sheetIndex];
      const sheetName = sheet ? sheet.name : `Sheet ${table.sheetIndex + 1}`;
      return {
        id: table.id,
        name: table.name,
        ...table.displayName && { displayName: table.displayName },
        ref: formatRange2(table.ref),
        sheetName,
        headerRowCount: table.headerRowCount,
        totalsRowCount: table.totalsRowCount,
        columns: table.columns.map((col) => ({
          id: col.id,
          name: col.name
        })),
        ...table.styleInfo && {
          styleInfo: {
            name: table.styleInfo.name,
            ...table.styleInfo.showFirstColumn && { showFirstColumn: true },
            ...table.styleInfo.showLastColumn && { showLastColumn: true },
            ...table.styleInfo.showRowStripes && { showRowStripes: true },
            ...table.styleInfo.showColumnStripes && { showColumnStripes: true }
          }
        }
      };
    });
    return success({
      count: tables.length,
      tables
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/commands/comments.ts
async function runComments2(filePath, options = {}) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    const sheets = workbook.sheets.filter((sheet) => !options.sheet || sheet.name === options.sheet).filter((sheet) => sheet.comments && sheet.comments.length > 0).map((sheet) => ({
      sheetName: sheet.name,
      comments: sheet.comments.map((comment) => {
        const col = indexToColumnLetter(comment.address.col);
        const ref = `${col}${comment.address.row}`;
        return {
          ref,
          ...comment.author && { author: comment.author },
          text: comment.text
        };
      })
    }));
    const totalCount = sheets.reduce((sum, s) => sum + s.comments.length, 0);
    return success({
      totalCount,
      sheets
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/commands/autofilter.ts
function serializeFilter(filter) {
  switch (filter.type) {
    case "filters":
      return {
        filterType: "filters",
        values: filter.values?.map((v) => v.val)
      };
    case "customFilters":
      return {
        filterType: "customFilters",
        operator: filter.and ? "and" : "or",
        conditions: filter.conditions.map((c) => ({
          operator: c.operator,
          val: c.val
        }))
      };
    case "top10":
      return {
        filterType: "top10",
        top10: {
          top: filter.top,
          percent: filter.percent,
          val: filter.val
        }
      };
    case "dynamicFilter":
      return {
        filterType: "dynamicFilter",
        dynamicType: filter.filterType
      };
    case "colorFilter":
      return {
        filterType: "colorFilter"
      };
    case "iconFilter":
      return {
        filterType: "iconFilter"
      };
    default:
      return { filterType: "unknown" };
  }
}
function serializeFilterColumn(col) {
  const base = {
    colId: col.colId,
    filterType: col.filter?.type ?? "none",
    ...col.hiddenButton !== undefined && { hiddenButton: col.hiddenButton },
    ...col.showButton !== undefined && { showButton: col.showButton }
  };
  if (col.filter) {
    return { ...base, ...serializeFilter(col.filter) };
  }
  return base;
}
function serializeSortState(sortState) {
  return {
    ref: sortState.ref,
    ...sortState.caseSensitive !== undefined && { caseSensitive: sortState.caseSensitive },
    ...sortState.sortConditions && {
      conditions: sortState.sortConditions.map((c) => ({
        ref: c.ref,
        ...c.descending !== undefined && { descending: c.descending }
      }))
    }
  };
}
async function runAutofilter(filePath, options = {}) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    const sheets = workbook.sheets.filter((sheet) => !options.sheet || sheet.name === options.sheet).filter((sheet) => sheet.autoFilter).map((sheet) => {
      const af = sheet.autoFilter;
      return {
        sheetName: sheet.name,
        ref: formatRange(af.ref),
        filterColumns: af.filterColumns?.map(serializeFilterColumn) ?? [],
        ...af.sortState && { sortState: serializeSortState(af.sortState) }
      };
    });
    return success({
      totalCount: sheets.length,
      sheets
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/commands/validation.ts
function serializeValidation(v) {
  return {
    sqref: v.sqref,
    ...v.type && { type: v.type },
    ...v.operator && { operator: v.operator },
    ...v.formula1 && { formula1: v.formula1 },
    ...v.formula2 && { formula2: v.formula2 },
    ...v.allowBlank !== undefined && { allowBlank: v.allowBlank },
    ...v.showDropDown !== undefined && { showDropDown: v.showDropDown },
    ...v.errorStyle && { errorStyle: v.errorStyle },
    ...v.promptTitle && { promptTitle: v.promptTitle },
    ...v.prompt && { prompt: v.prompt },
    ...v.errorTitle && { errorTitle: v.errorTitle },
    ...v.error && { error: v.error }
  };
}
async function runValidation(filePath, options = {}) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    const sheets = workbook.sheets.filter((sheet) => !options.sheet || sheet.name === options.sheet).filter((sheet) => sheet.dataValidations && sheet.dataValidations.length > 0).map((sheet) => ({
      sheetName: sheet.name,
      validations: sheet.dataValidations.map(serializeValidation)
    }));
    const totalCount = sheets.reduce((sum, s) => sum + s.validations.length, 0);
    return success({
      totalCount,
      sheets
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/commands/conditional.ts
function serializeRule(rule) {
  return {
    type: rule.type,
    ...rule.priority !== undefined && { priority: rule.priority },
    ...rule.dxfId !== undefined && { dxfId: rule.dxfId },
    ...rule.operator && { operator: rule.operator },
    ...rule.stopIfTrue !== undefined && { stopIfTrue: rule.stopIfTrue },
    formulas: rule.formulas
  };
}
function serializeConditionalFormatting(cf) {
  return {
    sqref: cf.sqref,
    rules: cf.rules.map(serializeRule)
  };
}
async function runConditional(filePath, options = {}) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    const sheets = workbook.sheets.filter((sheet) => !options.sheet || sheet.name === options.sheet).filter((sheet) => sheet.conditionalFormattings && sheet.conditionalFormattings.length > 0).map((sheet) => ({
      sheetName: sheet.name,
      formattings: sheet.conditionalFormattings.map(serializeConditionalFormatting)
    }));
    const totalCount = sheets.reduce((sum, s) => sum + s.formattings.length, 0);
    return success({
      totalCount,
      sheets
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/commands/hyperlinks.ts
function serializeHyperlink2(h) {
  return {
    ref: formatRange(h.ref),
    ...h.target && { target: h.target },
    ...h.targetMode && { targetMode: h.targetMode },
    ...h.display && { display: h.display },
    ...h.location && { location: h.location },
    ...h.tooltip && { tooltip: h.tooltip }
  };
}
async function runHyperlinks(filePath, options = {}) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    const sheets = workbook.sheets.filter((sheet) => !options.sheet || sheet.name === options.sheet).filter((sheet) => sheet.hyperlinks && sheet.hyperlinks.length > 0).map((sheet) => ({
      sheetName: sheet.name,
      hyperlinks: sheet.hyperlinks.map(serializeHyperlink2)
    }));
    const totalCount = sheets.reduce((sum, s) => sum + s.hyperlinks.length, 0);
    return success({
      totalCount,
      sheets
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/commands/styles.ts
function serializeColor2(color) {
  if (!color) {
    return;
  }
  switch (color.type) {
    case "rgb":
      return { type: "rgb", value: color.value };
    case "theme":
      return { type: "theme", theme: color.theme, ...color.tint !== undefined && { tint: color.tint } };
    case "indexed":
      return { type: "indexed", index: color.index };
    case "auto":
      return { type: "auto" };
    default:
      return;
  }
}
function serializeFont(font, id) {
  return {
    id,
    name: font.name,
    size: font.size,
    ...font.bold && { bold: font.bold },
    ...font.italic && { italic: font.italic },
    ...font.underline && { underline: font.underline },
    ...font.strikethrough && { strikethrough: font.strikethrough },
    ...font.color && { color: serializeColor2(font.color) },
    ...font.scheme && { scheme: font.scheme }
  };
}
function serializeFill3(fill, id) {
  switch (fill.type) {
    case "none":
      return { id, type: "none" };
    case "pattern":
      return {
        id,
        type: "pattern",
        patternType: fill.pattern.patternType,
        ...fill.pattern.fgColor && { fgColor: serializeColor2(fill.pattern.fgColor) },
        ...fill.pattern.bgColor && { bgColor: serializeColor2(fill.pattern.bgColor) }
      };
    case "gradient":
      return {
        id,
        type: "gradient",
        gradientType: fill.gradient.gradientType,
        ...fill.gradient.degree !== undefined && { degree: fill.gradient.degree }
      };
    default:
      return { id, type: "unknown" };
  }
}
function serializeBorderSide(side) {
  if (!side) {
    return;
  }
  return {
    ...side.style && { style: side.style },
    ...side.color && { color: serializeColor2(side.color) }
  };
}
function serializeBorder(border, id) {
  return {
    id,
    ...border.left && { left: serializeBorderSide(border.left) },
    ...border.right && { right: serializeBorderSide(border.right) },
    ...border.top && { top: serializeBorderSide(border.top) },
    ...border.bottom && { bottom: serializeBorderSide(border.bottom) },
    ...border.diagonal && { diagonal: serializeBorderSide(border.diagonal) }
  };
}
function serializeNumberFormat(fmt, id) {
  return {
    id,
    formatCode: fmt.formatCode
  };
}
function serializeCellXf(xf, id) {
  return {
    id,
    numFmtId: xf.numFmtId,
    fontId: xf.fontId,
    fillId: xf.fillId,
    borderId: xf.borderId,
    ...xf.xfId !== undefined && { xfId: xf.xfId },
    ...xf.applyNumberFormat !== undefined && { applyNumberFormat: xf.applyNumberFormat },
    ...xf.applyFont !== undefined && { applyFont: xf.applyFont },
    ...xf.applyFill !== undefined && { applyFill: xf.applyFill },
    ...xf.applyBorder !== undefined && { applyBorder: xf.applyBorder },
    ...xf.applyAlignment !== undefined && { applyAlignment: xf.applyAlignment },
    ...xf.applyProtection !== undefined && { applyProtection: xf.applyProtection },
    ...xf.alignment && {
      alignment: {
        ...xf.alignment.horizontal && { horizontal: xf.alignment.horizontal },
        ...xf.alignment.vertical && { vertical: xf.alignment.vertical },
        ...xf.alignment.wrapText !== undefined && { wrapText: xf.alignment.wrapText },
        ...xf.alignment.shrinkToFit !== undefined && { shrinkToFit: xf.alignment.shrinkToFit },
        ...xf.alignment.textRotation !== undefined && { textRotation: xf.alignment.textRotation },
        ...xf.alignment.indent !== undefined && { indent: xf.alignment.indent }
      }
    },
    ...xf.protection && {
      protection: {
        ...xf.protection.locked !== undefined && { locked: xf.protection.locked },
        ...xf.protection.hidden !== undefined && { hidden: xf.protection.hidden }
      }
    }
  };
}
function serializeCellStyle(style) {
  return {
    name: style.name,
    xfId: style.xfId,
    ...style.builtinId !== undefined && { builtinId: style.builtinId }
  };
}
async function runStyles2(filePath, options = {}) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    const styles = workbook.styles;
    const fonts = styles.fonts.map((f, i2) => serializeFont(f, i2));
    const fills = styles.fills.map((f, i2) => serializeFill3(f, i2));
    const borders = styles.borders.map((b, i2) => serializeBorder(b, i2));
    const numberFormats = styles.numberFormats.map((f, i2) => serializeNumberFormat(f, i2));
    const cellXfs = styles.cellXfs.map((x2, i2) => serializeCellXf(x2, i2));
    const cellStyles = styles.cellStyles.map(serializeCellStyle);
    const section = options.section?.toLowerCase();
    const filterBySection = (items, sectionName) => {
      return section && section !== sectionName ? [] : items;
    };
    return success({
      fonts: filterBySection(fonts, "fonts"),
      fills: filterBySection(fills, "fills"),
      borders: filterBySection(borders, "borders"),
      numberFormats: filterBySection(numberFormats, "numberformats"),
      cellXfs: filterBySection(cellXfs, "cellxfs"),
      cellStyles: filterBySection(cellStyles, "cellstyles"),
      summary: {
        fontCount: styles.fonts.length,
        fillCount: styles.fills.length,
        borderCount: styles.borders.length,
        numberFormatCount: styles.numberFormats.length,
        cellXfCount: styles.cellXfs.length,
        cellStyleCount: styles.cellStyles.length,
        dxfCount: styles.dxfs?.length ?? 0
      }
    });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-renderer/xlsx/src/ascii/sheet-renderer.ts
function indexToColumnLetter2(index) {
  let result = "";
  let n = index;
  while (n >= 0) {
    result = String.fromCharCode(n % 26 + 65) + result;
    n = Math.floor(n / 26) - 1;
  }
  return result;
}
function formatCellValue3(cell) {
  if (cell.value === null || cell.value === undefined) {
    return "";
  }
  if (cell.type === "number" && typeof cell.value === "number") {
    return cell.value.toLocaleString("en-US");
  }
  return String(cell.value);
}
function cellAlignment(cell) {
  return cell.type === "number" ? "right" : "left";
}
function renderSheetAscii(params) {
  const { rows, columnCount, width, showRowNumbers = true, showColumnHeaders = true } = params;
  if (rows.length === 0 || columnCount === 0) {
    return `(empty sheet: ${params.name})`;
  }
  const headers = [];
  if (showRowNumbers) {
    headers.push("");
  }
  if (showColumnHeaders) {
    for (let c = 0;c < columnCount; c++) {
      headers.push(indexToColumnLetter2(c));
    }
  }
  const dataRows = [];
  const alignments = [];
  if (showRowNumbers) {
    alignments.push("right");
  }
  for (let c = 0;c < columnCount; c++) {
    let align = "left";
    for (const row of rows) {
      if (c < row.cells.length && row.cells[c].type !== "empty") {
        align = cellAlignment(row.cells[c]);
        break;
      }
    }
    alignments.push(align);
  }
  for (const row of rows) {
    const rowData = [];
    if (showRowNumbers) {
      rowData.push(String(row.rowNumber));
    }
    for (let c = 0;c < columnCount; c++) {
      const cell = c < row.cells.length ? row.cells[c] : { value: null, type: "empty" };
      rowData.push(formatCellValue3(cell));
    }
    dataRows.push(rowData);
  }
  return renderAsciiTable({
    headers: showColumnHeaders ? headers : undefined,
    rows: dataRows,
    maxWidth: width,
    alignments
  });
}
// packages/@oxen-cli/xlsx-cli/src/commands/preview.ts
function parseRange3(range2) {
  const match = range2.match(/^([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?$/i);
  if (!match) {
    return;
  }
  const startCol = columnLetterToIndex(match[1].toUpperCase());
  const startRow = parseInt(match[2], 10);
  const endCol = match[3] ? columnLetterToIndex(match[3].toUpperCase()) : startCol;
  const endRow = match[4] ? parseInt(match[4], 10) : startRow;
  return { startCol, startRow, endCol, endRow };
}
async function runPreview3(filePath, sheetName, options) {
  try {
    const workbook = await loadXlsxWorkbook(filePath);
    const sheetsToRender = sheetName ? workbook.sheets.filter((s) => s.name === sheetName) : workbook.sheets;
    if (sheetName && sheetsToRender.length === 0) {
      const available = workbook.sheets.map((s) => s.name).join(", ");
      return error("SHEET_NOT_FOUND", `Sheet "${sheetName}" not found. Available sheets: ${available}`);
    }
    const results = [];
    for (const sheet of sheetsToRender) {
      const sheetRange = getSheetRange(sheet);
      const targetRange = options.range ? parseRange3(options.range) : sheetRange ? {
        startCol: columnLetterToIndex(sheetRange.startCol),
        startRow: sheetRange.startRow,
        endCol: columnLetterToIndex(sheetRange.endCol),
        endRow: sheetRange.endRow
      } : undefined;
      if (!targetRange) {
        results.push({
          name: sheet.name,
          ascii: `(empty sheet: ${sheet.name})`,
          rows: [],
          rowCount: 0,
          colCount: 0
        });
        continue;
      }
      const colCount = targetRange.endCol - targetRange.startCol + 1;
      const cellMap = new Map;
      for (const row of sheet.rows) {
        for (const cell of row.cells) {
          const serialized = serializeCell(cell);
          cellMap.set(serialized.ref, serialized);
        }
      }
      const asciiRows = [];
      for (let rowNum = targetRange.startRow;rowNum <= targetRange.endRow; rowNum++) {
        const cells = [];
        for (let colNum = targetRange.startCol;colNum <= targetRange.endCol; colNum++) {
          let letter = "";
          let n = colNum;
          while (n >= 0) {
            letter = String.fromCharCode(n % 26 + 65) + letter;
            n = Math.floor(n / 26) - 1;
          }
          const ref = `${letter}${rowNum}`;
          const cell = cellMap.get(ref);
          if (cell && cell.type !== "empty") {
            cells.push({
              value: cell.value,
              type: cell.type
            });
          } else {
            cells.push({ value: null, type: "empty" });
          }
        }
        asciiRows.push({ rowNumber: rowNum, cells });
      }
      const ascii = renderSheetAscii({
        name: sheet.name,
        rows: asciiRows,
        columnCount: colCount,
        width: options.width
      });
      results.push({
        name: sheet.name,
        ascii,
        rows: asciiRows,
        rowCount: asciiRows.length,
        colCount
      });
    }
    return success({ sheets: results });
  } catch (err2) {
    if (err2.code === "ENOENT") {
      return error("FILE_NOT_FOUND", `File not found: ${filePath}`);
    }
    return error("PARSE_ERROR", `Failed to parse XLSX: ${err2.message}`);
  }
}

// packages/@oxen-cli/xlsx-cli/src/output/pretty-output.ts
function formatInfoPretty3(data) {
  const lines = [
    `Sheets: ${data.sheetCount}`,
    `Sheet Names: ${data.sheetNames.join(", ")}`,
    `Shared Strings: ${data.sharedStringCount}`,
    `Total Rows: ${data.totalRows}`,
    `Total Cells: ${data.totalCells}`
  ];
  return lines.join(`
`);
}
function formatListPretty3(data) {
  if (data.sheets.length === 0) {
    return "No sheets found";
  }
  return data.sheets.map((sheet) => {
    const parts = [
      `${sheet.name}:`,
      `  Rows: ${sheet.rowCount}`,
      `  Cells: ${sheet.cellCount}`
    ];
    if (sheet.range) {
      parts.push(`  Range: ${sheet.range}`);
    }
    if (sheet.mergedCellCount) {
      parts.push(`  Merged Cells: ${sheet.mergedCellCount}`);
    }
    if (sheet.formulaCount) {
      parts.push(`  Formulas: ${sheet.formulaCount}`);
    }
    if (sheet.hasAutoFilter) {
      parts.push(`  Auto Filter: yes`);
    }
    return parts.join(`
`);
  }).join(`

`);
}
function formatShowPretty3(data) {
  const lines = [`Sheet: ${data.sheetName}`];
  if (data.range) {
    lines.push(`Range: ${data.range}`);
  }
  lines.push("");
  if (data.rows.length === 0) {
    lines.push("(empty)");
  } else {
    for (const row of data.rows) {
      const cellValues = row.cells.map((c) => `${c.ref}=${c.value ?? ""}`).join(", ");
      lines.push(`Row ${row.rowNumber}: ${cellValues}`);
    }
  }
  return lines.join(`
`);
}
function formatExtractPretty3(data) {
  const header = `Sheet: ${data.sheetName} (${data.format.toUpperCase()})`;
  return `${header}
${"=".repeat(header.length)}
${data.content}`;
}
function formatBuildPretty3(data) {
  return `Built: ${data.outputPath}`;
}
function formatRunProps(run) {
  const props = [];
  if (run.bold) {
    props.push("bold");
  }
  if (run.italic) {
    props.push("italic");
  }
  if (run.underline) {
    props.push("underline");
  }
  if (run.strike) {
    props.push("strike");
  }
  if (run.fontSize) {
    props.push(`size:${run.fontSize}`);
  }
  if (run.fontName) {
    props.push(`font:${run.fontName}`);
  }
  if (run.color) {
    props.push(`color:${run.color}`);
  }
  return props.length > 0 ? ` [${props.join(", ")}]` : "";
}
function formatStringsPretty(data) {
  const lines = [`Shared Strings: ${data.count}`];
  lines.push("");
  for (const item of data.strings) {
    if (item.type === "plain") {
      lines.push(`[${item.index}] "${item.text}"`);
    } else {
      lines.push(`[${item.index}] (rich) "${item.text}"`);
      if (item.runs) {
        for (const run of item.runs) {
          const props = formatRunProps(run);
          lines.push(`    "${run.text}"${props}`);
        }
      }
    }
  }
  return lines.join(`
`);
}
function formatFormulasPretty(data) {
  const lines = [`Total Formulas: ${data.totalCount}`];
  lines.push("");
  for (const sheet of data.sheets) {
    lines.push(`Sheet: ${sheet.sheetName}`);
    for (const f of sheet.formulas) {
      const stored = f.storedValue === null ? "(empty)" : String(f.storedValue);
      if (f.calculatedValue !== undefined) {
        const calc = f.calculatedValue === null ? "(empty)" : String(f.calculatedValue);
        lines.push(`  ${f.ref}: =${f.formula} -> ${calc} (stored: ${stored})`);
      } else {
        lines.push(`  ${f.ref}: =${f.formula} = ${stored}`);
      }
    }
    lines.push("");
  }
  return lines.join(`
`);
}
function formatVerifyPretty3(data) {
  const lines = [`Results: ${data.passed} passed, ${data.failed} failed`];
  lines.push("");
  for (const result of data.results) {
    const status = result.passed ? "\u2713" : "\u2717";
    lines.push(`${status} ${result.name}`);
    if (!result.passed) {
      for (const assertion of result.assertions.filter((a) => !a.passed)) {
        lines.push(`    ${assertion.path}: expected ${JSON.stringify(assertion.expected)}, got ${JSON.stringify(assertion.actual)}`);
      }
    }
  }
  return lines.join(`
`);
}
function formatNamesPretty(data) {
  if (data.count === 0) {
    return "No defined names found";
  }
  const lines = [`Defined Names: ${data.count}`];
  lines.push("");
  for (const name of data.names) {
    const parts = [`${name.name}`];
    if (name.scope) {
      parts.push(`(scope: ${name.scope})`);
    }
    if (name.hidden) {
      parts.push("[hidden]");
    }
    lines.push(parts.join(" "));
    lines.push(`  = ${name.formula}`);
  }
  return lines.join(`
`);
}
function formatTablesPretty3(data) {
  if (data.count === 0) {
    return "No tables found";
  }
  const lines = [`Tables: ${data.count}`];
  lines.push("");
  for (const table of data.tables) {
    lines.push(`${table.name} (${table.ref})`);
    lines.push(`  Sheet: ${table.sheetName}`);
    if (table.displayName && table.displayName !== table.name) {
      lines.push(`  Display Name: ${table.displayName}`);
    }
    lines.push(`  Columns: ${table.columns.map((c) => c.name).join(", ")}`);
    if (table.headerRowCount !== 1) {
      lines.push(`  Header Rows: ${table.headerRowCount}`);
    }
    if (table.totalsRowCount > 0) {
      lines.push(`  Totals Rows: ${table.totalsRowCount}`);
    }
    if (table.styleInfo) {
      lines.push(`  Style: ${table.styleInfo.name}`);
    }
    lines.push("");
  }
  return lines.join(`
`).trim();
}
function formatCommentsPretty2(data) {
  if (data.totalCount === 0) {
    return "No comments found";
  }
  const lines = [`Total Comments: ${data.totalCount}`];
  lines.push("");
  for (const sheet of data.sheets) {
    lines.push(`Sheet: ${sheet.sheetName}`);
    for (const comment of sheet.comments) {
      const author = comment.author ? ` (${comment.author})` : "";
      lines.push(`  ${comment.ref}${author}: ${comment.text}`);
    }
    lines.push("");
  }
  return lines.join(`
`).trim();
}
function formatAutofilterPretty(data) {
  if (data.totalCount === 0) {
    return "No auto filters found";
  }
  const lines = [`Auto Filters: ${data.totalCount}`];
  lines.push("");
  for (const sheet of data.sheets) {
    lines.push(`Sheet: ${sheet.sheetName}`);
    lines.push(`  Range: ${sheet.ref}`);
    if (sheet.filterColumns.length > 0) {
      lines.push(`  Filter Columns:`);
      for (const col of sheet.filterColumns) {
        const parts = [`    Column ${col.colId}: ${col.filterType}`];
        if (col.values && col.values.length > 0) {
          const valuesStr = col.values.slice(0, 5).join(", ");
          const suffix = col.values.length > 5 ? ` ... (${col.values.length} total)` : "";
          parts.push(`      Values: ${valuesStr}${suffix}`);
        }
        if (col.conditions) {
          for (const cond of col.conditions) {
            parts.push(`      ${cond.operator ?? "equal"} "${cond.val ?? ""}"`);
          }
        }
        if (col.dynamicType) {
          parts.push(`      Type: ${col.dynamicType}`);
        }
        if (col.top10) {
          const dir = col.top10.top ? "top" : "bottom";
          const unit = col.top10.percent ? "%" : "";
          parts.push(`      ${dir} ${col.top10.val}${unit}`);
        }
        lines.push(parts.join(`
`));
      }
    }
    if (sheet.sortState) {
      lines.push(`  Sort State: ${sheet.sortState.ref}`);
      if (sheet.sortState.conditions) {
        for (const cond of sheet.sortState.conditions) {
          const dir = cond.descending ? "descending" : "ascending";
          lines.push(`    ${cond.ref}: ${dir}`);
        }
      }
    }
    lines.push("");
  }
  return lines.join(`
`).trim();
}
function formatValidationPretty(data) {
  if (data.totalCount === 0) {
    return "No data validations found";
  }
  const lines = [`Data Validations: ${data.totalCount}`];
  lines.push("");
  for (const sheet of data.sheets) {
    lines.push(`Sheet: ${sheet.sheetName}`);
    for (const v of sheet.validations) {
      lines.push(`  ${v.sqref}: ${v.type ?? "any"}`);
      if (v.operator) {
        lines.push(`    Operator: ${v.operator}`);
      }
      if (v.formula1) {
        lines.push(`    Formula1: ${v.formula1}`);
      }
      if (v.formula2) {
        lines.push(`    Formula2: ${v.formula2}`);
      }
      if (v.errorStyle) {
        lines.push(`    Error Style: ${v.errorStyle}`);
      }
      if (v.promptTitle || v.prompt) {
        lines.push(`    Prompt: ${v.promptTitle ?? ""} - ${v.prompt ?? ""}`);
      }
      if (v.errorTitle || v.error) {
        lines.push(`    Error: ${v.errorTitle ?? ""} - ${v.error ?? ""}`);
      }
    }
    lines.push("");
  }
  return lines.join(`
`).trim();
}
function formatConditionalPretty(data) {
  if (data.totalCount === 0) {
    return "No conditional formatting found";
  }
  const lines = [`Conditional Formatting: ${data.totalCount}`];
  lines.push("");
  for (const sheet of data.sheets) {
    lines.push(`Sheet: ${sheet.sheetName}`);
    for (const cf of sheet.formattings) {
      lines.push(`  Range: ${cf.sqref}`);
      for (const rule of cf.rules) {
        const parts = [`    [${rule.priority ?? "-"}] ${rule.type}`];
        if (rule.operator) {
          parts[0] += ` (${rule.operator})`;
        }
        if (rule.dxfId !== undefined) {
          parts.push(`      DXF ID: ${rule.dxfId}`);
        }
        if (rule.stopIfTrue) {
          parts.push(`      Stop If True: yes`);
        }
        if (rule.formulas.length > 0) {
          parts.push(`      Formulas: ${rule.formulas.join(", ")}`);
        }
        lines.push(parts.join(`
`));
      }
    }
    lines.push("");
  }
  return lines.join(`
`).trim();
}
function formatHyperlinksPretty(data) {
  if (data.totalCount === 0) {
    return "No hyperlinks found";
  }
  const lines = [`Hyperlinks: ${data.totalCount}`];
  lines.push("");
  for (const sheet of data.sheets) {
    lines.push(`Sheet: ${sheet.sheetName}`);
    for (const h of sheet.hyperlinks) {
      const target = h.target ?? h.location ?? "(no target)";
      lines.push(`  ${h.ref}: ${target}`);
      if (h.display && h.display !== h.target) {
        lines.push(`    Display: ${h.display}`);
      }
      if (h.tooltip) {
        lines.push(`    Tooltip: ${h.tooltip}`);
      }
      if (h.targetMode) {
        lines.push(`    Mode: ${h.targetMode}`);
      }
    }
    lines.push("");
  }
  return lines.join(`
`).trim();
}
function formatPreviewPretty3(data) {
  const lines = [];
  for (let i2 = 0;i2 < data.sheets.length; i2++) {
    const sheet = data.sheets[i2];
    if (i2 > 0) {
      lines.push("");
    }
    lines.push(`Sheet: ${sheet.name} (${sheet.rowCount} rows, ${sheet.colCount} columns)`);
    lines.push("");
    lines.push(sheet.ascii);
  }
  return lines.join(`
`);
}
function formatColorValue(color) {
  if (!color) {
    return "none";
  }
  switch (color.type) {
    case "rgb":
      return `#${color.value}`;
    case "theme":
      return color.tint !== undefined ? `theme:${color.theme} (tint:${color.tint})` : `theme:${color.theme}`;
    case "indexed":
      return `indexed:${color.index}`;
    case "auto":
      return "auto";
    default:
      return "unknown";
  }
}
function formatStylesPretty2(data) {
  const lines = [
    "Stylesheet Summary",
    "=".repeat(18),
    `  Fonts: ${data.summary.fontCount}`,
    `  Fills: ${data.summary.fillCount}`,
    `  Borders: ${data.summary.borderCount}`,
    `  Number Formats: ${data.summary.numberFormatCount}`,
    `  Cell XFs: ${data.summary.cellXfCount}`,
    `  Cell Styles: ${data.summary.cellStyleCount}`,
    `  DXFs: ${data.summary.dxfCount}`
  ];
  if (data.fonts.length > 0) {
    lines.push("", "Fonts", "-".repeat(5));
    for (const f of data.fonts) {
      const props = [];
      if (f.bold)
        props.push("bold");
      if (f.italic)
        props.push("italic");
      if (f.underline)
        props.push(`underline:${f.underline}`);
      if (f.strikethrough)
        props.push("strike");
      if (f.color)
        props.push(`color:${formatColorValue(f.color)}`);
      if (f.scheme)
        props.push(`scheme:${f.scheme}`);
      const propsStr = props.length > 0 ? ` [${props.join(", ")}]` : "";
      lines.push(`  [${f.id}] ${f.name} ${f.size}pt${propsStr}`);
    }
  }
  if (data.fills.length > 0) {
    lines.push("", "Fills", "-".repeat(5));
    for (const f of data.fills) {
      if (f.type === "none") {
        lines.push(`  [${f.id}] none`);
      } else if (f.type === "pattern") {
        const fg = f.fgColor ? ` fg:${formatColorValue(f.fgColor)}` : "";
        const bg = f.bgColor ? ` bg:${formatColorValue(f.bgColor)}` : "";
        lines.push(`  [${f.id}] pattern:${f.patternType}${fg}${bg}`);
      } else if (f.type === "gradient") {
        const deg2 = f.degree !== undefined ? ` ${f.degree}deg` : "";
        lines.push(`  [${f.id}] gradient:${f.gradientType}${deg2}`);
      }
    }
  }
  if (data.borders.length > 0) {
    lines.push("", "Borders", "-".repeat(7));
    for (const b of data.borders) {
      const sides = [];
      if (b.left?.style)
        sides.push(`L:${b.left.style}`);
      if (b.right?.style)
        sides.push(`R:${b.right.style}`);
      if (b.top?.style)
        sides.push(`T:${b.top.style}`);
      if (b.bottom?.style)
        sides.push(`B:${b.bottom.style}`);
      if (b.diagonal?.style)
        sides.push(`D:${b.diagonal.style}`);
      const borderStr = sides.length > 0 ? sides.join(" ") : "none";
      lines.push(`  [${b.id}] ${borderStr}`);
    }
  }
  if (data.numberFormats.length > 0) {
    lines.push("", "Number Formats (Custom)", "-".repeat(23));
    for (const nf of data.numberFormats) {
      lines.push(`  [${nf.id}] ${nf.formatCode}`);
    }
  }
  if (data.cellXfs.length > 0) {
    lines.push("", "Cell Formats (XFs)", "-".repeat(18));
    for (const xf of data.cellXfs) {
      const refs = `font:${xf.fontId} fill:${xf.fillId} border:${xf.borderId} numFmt:${xf.numFmtId}`;
      lines.push(`  [${xf.id}] ${refs}`);
      if (xf.alignment) {
        const align = [];
        if (xf.alignment.horizontal)
          align.push(`h:${xf.alignment.horizontal}`);
        if (xf.alignment.vertical)
          align.push(`v:${xf.alignment.vertical}`);
        if (xf.alignment.wrapText)
          align.push("wrap");
        if (xf.alignment.shrinkToFit)
          align.push("shrink");
        if (xf.alignment.textRotation !== undefined)
          align.push(`rot:${xf.alignment.textRotation}`);
        if (align.length > 0) {
          lines.push(`    alignment: ${align.join(" ")}`);
        }
      }
    }
  }
  if (data.cellStyles.length > 0) {
    lines.push("", "Cell Styles", "-".repeat(11));
    for (const s of data.cellStyles) {
      const builtin = s.builtinId !== undefined ? ` (builtin:${s.builtinId})` : "";
      lines.push(`  ${s.name} -> xfId:${s.xfId}${builtin}`);
    }
  }
  return lines.join(`
`);
}

// packages/@oxen-renderer/xlsx/src/mermaid/sheet-renderer.ts
function indexToColumnLetter3(index) {
  let result = "";
  let n = index;
  while (n >= 0) {
    result = String.fromCharCode(n % 26 + 65) + result;
    n = Math.floor(n / 26) - 1;
  }
  return result;
}
function formatCellValue4(cell) {
  if (cell.value === null || cell.value === undefined) {
    return "";
  }
  if (cell.type === "number" && typeof cell.value === "number") {
    return cell.value.toLocaleString("en-US");
  }
  return String(cell.value);
}
function renderSheetMermaid(params) {
  const { rows, columnCount, showRowNumbers = true, showColumnHeaders = true } = params;
  if (rows.length === 0 || columnCount === 0) {
    return `(empty sheet: ${params.name})`;
  }
  const headers = [];
  if (showRowNumbers) {
    headers.push("");
  }
  if (showColumnHeaders) {
    for (let c = 0;c < columnCount; c++) {
      headers.push(indexToColumnLetter3(c));
    }
  }
  const alignments = [];
  if (showRowNumbers) {
    alignments.push("right");
  }
  for (let c = 0;c < columnCount; c++) {
    let align = "left";
    for (const row of rows) {
      if (c < row.cells.length && row.cells[c].type !== "empty") {
        align = row.cells[c].type === "number" ? "right" : "left";
        break;
      }
    }
    alignments.push(align);
  }
  const dataRows = [];
  for (const row of rows) {
    const rowData = [];
    if (showRowNumbers) {
      rowData.push(String(row.rowNumber));
    }
    for (let c = 0;c < columnCount; c++) {
      const cell = c < row.cells.length ? row.cells[c] : { value: null, type: "empty" };
      rowData.push(formatCellValue4(cell));
    }
    dataRows.push(rowData);
  }
  return renderMarkdownTable({
    headers: showColumnHeaders ? headers : headers.slice(0, showRowNumbers ? 1 : 0),
    rows: dataRows,
    alignments
  });
}
// packages/@oxen-cli/xlsx-cli/src/output/mermaid-output.ts
function formatPreviewMermaid3(data) {
  const sections = [];
  for (const sheet of data.sheets) {
    const header = `## ${sheet.name}`;
    const mermaid = renderSheetMermaid({
      name: sheet.name,
      rows: sheet.rows,
      columnCount: sheet.colCount
    });
    sections.push(mermaid ? `${header}

${mermaid}` : header);
  }
  return sections.join(`

`);
}

// packages/@oxen-cli/xlsx-cli/src/program.ts
function createProgram3() {
  const program2 = new Command;
  program2.name("xlsx").description("CLI tool for inspecting XLSX files").version("0.1.0").option("-o, --output <mode>", "Output mode (json|pretty|mermaid)", "pretty");
  program2.command("info").description("Display workbook metadata").argument("<file>", "XLSX file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runInfo3(file);
    output(result, mode, formatInfoPretty3);
  });
  program2.command("list").description("List sheets with summary").argument("<file>", "XLSX file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runList3(file);
    output(result, mode, formatListPretty3);
  });
  program2.command("show").description("Display sheet content").argument("<file>", "XLSX file path").argument("<sheet>", "Sheet name").option("--range <range>", 'Cell range (e.g., "A1:C10")').action(async (file, sheet, options) => {
    const mode = program2.opts().output;
    const result = await runShow3(file, sheet, options);
    output(result, mode, formatShowPretty3);
  });
  program2.command("extract").description("Extract data from sheet (CSV or JSON)").argument("<file>", "XLSX file path").option("--sheet <name>", "Sheet name (default: first sheet)").option("--format <format>", "Output format (csv|json)", "csv").action(async (file, options) => {
    const mode = program2.opts().output;
    const format = options.format === "json" ? "json" : "csv";
    const result = await runExtract3(file, { sheet: options.sheet, format });
    output(result, mode, formatExtractPretty3);
  });
  program2.command("build").description("Build XLSX from JSON specification").argument("<spec>", "JSON spec file path").action(async (spec) => {
    const mode = program2.opts().output;
    const result = await runBuild3(spec);
    output(result, mode, formatBuildPretty3);
  });
  program2.command("verify").description("Verify XLSX build results against expected values").argument("<path>", "Test case file or directory path").option("--tag <tag>", "Filter test cases by tag").action(async (specPath, options) => {
    const mode = program2.opts().output;
    const result = await runVerify3(specPath, options);
    output(result, mode, formatVerifyPretty3);
  });
  program2.command("strings").description("Display shared strings with optional rich text formatting").argument("<file>", "XLSX file path").option("--rich-text", "Include rich text formatting details").action(async (file, options) => {
    const mode = program2.opts().output;
    const result = await runStrings(file, { richText: options.richText });
    output(result, mode, formatStringsPretty);
  });
  program2.command("formulas").description("Display formulas with optional evaluation").argument("<file>", "XLSX file path").option("--sheet <name>", "Filter by sheet name").option("--evaluate", "Evaluate formulas and show calculated values").action(async (file, options) => {
    const mode = program2.opts().output;
    const result = await runFormulas(file, { sheet: options.sheet, evaluate: options.evaluate });
    output(result, mode, formatFormulasPretty);
  });
  program2.command("names").description("Display defined names (named ranges)").argument("<file>", "XLSX file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runNames(file);
    output(result, mode, formatNamesPretty);
  });
  program2.command("tables").description("Display table definitions (ListObjects)").argument("<file>", "XLSX file path").action(async (file) => {
    const mode = program2.opts().output;
    const result = await runTables3(file);
    output(result, mode, formatTablesPretty3);
  });
  program2.command("comments").description("Display cell comments").argument("<file>", "XLSX file path").option("--sheet <name>", "Filter by sheet name").action(async (file, options) => {
    const mode = program2.opts().output;
    const result = await runComments2(file, options);
    output(result, mode, formatCommentsPretty2);
  });
  program2.command("autofilter").description("Display auto filter configurations").argument("<file>", "XLSX file path").option("--sheet <name>", "Filter by sheet name").action(async (file, options) => {
    const mode = program2.opts().output;
    const result = await runAutofilter(file, options);
    output(result, mode, formatAutofilterPretty);
  });
  program2.command("validation").description("Display data validation rules").argument("<file>", "XLSX file path").option("--sheet <name>", "Filter by sheet name").action(async (file, options) => {
    const mode = program2.opts().output;
    const result = await runValidation(file, options);
    output(result, mode, formatValidationPretty);
  });
  program2.command("conditional").description("Display conditional formatting rules").argument("<file>", "XLSX file path").option("--sheet <name>", "Filter by sheet name").action(async (file, options) => {
    const mode = program2.opts().output;
    const result = await runConditional(file, options);
    output(result, mode, formatConditionalPretty);
  });
  program2.command("hyperlinks").description("Display hyperlinks").argument("<file>", "XLSX file path").option("--sheet <name>", "Filter by sheet name").action(async (file, options) => {
    const mode = program2.opts().output;
    const result = await runHyperlinks(file, options);
    output(result, mode, formatHyperlinksPretty);
  });
  program2.command("styles").description("Display stylesheet definitions (fonts, fills, borders, formats)").argument("<file>", "XLSX file path").option("--section <section>", "Filter by section (fonts, fills, borders, numberformats, cellxfs, cellstyles)").action(async (file, options) => {
    const mode = program2.opts().output;
    const result = await runStyles2(file, options);
    output(result, mode, formatStylesPretty2);
  });
  program2.command("preview").description("Render ASCII grid preview of sheet data").argument("<file>", "XLSX file path").argument("[sheet]", "Sheet name (omit for all sheets)").option("--width <columns>", "Terminal width in columns", "80").option("--range <range>", 'Cell range (e.g., "A1:C10")').action(async (file, sheet, options) => {
    const mode = program2.opts().output;
    const width = parseInt(options.width, 10);
    if (Number.isNaN(width) || width < 20) {
      console.error("Error: Width must be an integer >= 20");
      process.exitCode = 1;
      return;
    }
    const result = await runPreview3(file, sheet, { width, range: options.range });
    output(result, mode, formatPreviewPretty3, formatPreviewMermaid3);
  });
  return program2;
}
// packages/@oxen-cli/cli/src/cli.ts
var program2 = new Command;
program2.name("oxen").description("Unified CLI for Office document inspection").version("0.1.0");
program2.addCommand(createProgram());
program2.addCommand(createProgram2());
program2.addCommand(createProgram3());
program2.parse();
